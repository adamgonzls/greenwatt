(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
//     Backbone.js 1.2.3

//     (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(factory) {

  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
  // We use `self` instead of `window` for `WebWorker` support.
  var root = (typeof self == 'object' && self.self == self && self) ||
            (typeof global == 'object' && global.global == global && global);

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore'), $;
    try { $ = require('jquery'); } catch(e) {}
    factory(root, exports, _, $);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create a local reference to a common array method we'll want to use later.
  var slice = Array.prototype.slice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.2.3';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... this will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Proxy Backbone class methods to Underscore functions, wrapping the model's
  // `attributes` object or collection's `models` array behind the scenes.
  //
  // collection.filter(function(model) { return model.get('age') > 10 });
  // collection.each(this.addView);
  //
  // `Function#apply` can be slow so we use the method's arg count, if we know it.
  var addMethod = function(length, method, attribute) {
    switch (length) {
      case 1: return function() {
        return _[method](this[attribute]);
      };
      case 2: return function(value) {
        return _[method](this[attribute], value);
      };
      case 3: return function(iteratee, context) {
        return _[method](this[attribute], cb(iteratee, this), context);
      };
      case 4: return function(iteratee, defaultVal, context) {
        return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
      };
      default: return function() {
        var args = slice.call(arguments);
        args.unshift(this[attribute]);
        return _[method].apply(_, args);
      };
    }
  };
  var addUnderscoreMethods = function(Class, methods, attribute) {
    _.each(methods, function(length, method) {
      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
    });
  };

  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
  var cb = function(iteratee, instance) {
    if (_.isFunction(iteratee)) return iteratee;
    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };
    return iteratee;
  };
  var modelMatcher = function(attrs) {
    var matcher = _.matches(attrs);
    return function(model) {
      return matcher(model.attributes);
    };
  };

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // a custom event channel. You may bind a callback to an event with `on` or
  // remove with `off`; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {};

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Iterates over the standard `event, callback` (as well as the fancy multiple
  // space-separated events `"change blur", callback` and jQuery-style event
  // maps `{event: callback}`).
  var eventsApi = function(iteratee, events, name, callback, opts) {
    var i = 0, names;
    if (name && typeof name === 'object') {
      // Handle event maps.
      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
      for (names = _.keys(name); i < names.length ; i++) {
        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
      }
    } else if (name && eventSplitter.test(name)) {
      // Handle space separated event names by delegating them individually.
      for (names = name.split(eventSplitter); i < names.length; i++) {
        events = iteratee(events, names[i], callback, opts);
      }
    } else {
      // Finally, standard events.
      events = iteratee(events, name, callback, opts);
    }
    return events;
  };

  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  Events.on = function(name, callback, context) {
    return internalOn(this, name, callback, context);
  };

  // Guard the `listening` argument from the public API.
  var internalOn = function(obj, name, callback, context, listening) {
    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
        context: context,
        ctx: obj,
        listening: listening
    });

    if (listening) {
      var listeners = obj._listeners || (obj._listeners = {});
      listeners[listening.id] = listening;
    }

    return obj;
  };

  // Inversion-of-control versions of `on`. Tell *this* object to listen to
  // an event in another object... keeping track of what it's listening to
  // for easier unbinding later.
  Events.listenTo =  function(obj, name, callback) {
    if (!obj) return this;
    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
    var listeningTo = this._listeningTo || (this._listeningTo = {});
    var listening = listeningTo[id];

    // This object is not listening to any other events on `obj` yet.
    // Setup the necessary references to track the listening callbacks.
    if (!listening) {
      var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
      listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};
    }

    // Bind callbacks on obj, and keep track of them on listening.
    internalOn(obj, name, callback, this, listening);
    return this;
  };

  // The reducing API that adds a callback to the `events` object.
  var onApi = function(events, name, callback, options) {
    if (callback) {
      var handlers = events[name] || (events[name] = []);
      var context = options.context, ctx = options.ctx, listening = options.listening;
      if (listening) listening.count++;

      handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });
    }
    return events;
  };

  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  Events.off =  function(name, callback, context) {
    if (!this._events) return this;
    this._events = eventsApi(offApi, this._events, name, callback, {
        context: context,
        listeners: this._listeners
    });
    return this;
  };

  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  Events.stopListening =  function(obj, name, callback) {
    var listeningTo = this._listeningTo;
    if (!listeningTo) return this;

    var ids = obj ? [obj._listenId] : _.keys(listeningTo);

    for (var i = 0; i < ids.length; i++) {
      var listening = listeningTo[ids[i]];

      // If listening doesn't exist, this object is not currently
      // listening to obj. Break out early.
      if (!listening) break;

      listening.obj.off(name, callback, this);
    }
    if (_.isEmpty(listeningTo)) this._listeningTo = void 0;

    return this;
  };

  // The reducing API that removes a callback from the `events` object.
  var offApi = function(events, name, callback, options) {
    if (!events) return;

    var i = 0, listening;
    var context = options.context, listeners = options.listeners;

    // Delete all events listeners and "drop" events.
    if (!name && !callback && !context) {
      var ids = _.keys(listeners);
      for (; i < ids.length; i++) {
        listening = listeners[ids[i]];
        delete listeners[listening.id];
        delete listening.listeningTo[listening.objId];
      }
      return;
    }

    var names = name ? [name] : _.keys(events);
    for (; i < names.length; i++) {
      name = names[i];
      var handlers = events[name];

      // Bail out if there are no events stored.
      if (!handlers) break;

      // Replace events if there are any remaining.  Otherwise, clean up.
      var remaining = [];
      for (var j = 0; j < handlers.length; j++) {
        var handler = handlers[j];
        if (
          callback && callback !== handler.callback &&
            callback !== handler.callback._callback ||
              context && context !== handler.context
        ) {
          remaining.push(handler);
        } else {
          listening = handler.listening;
          if (listening && --listening.count === 0) {
            delete listeners[listening.id];
            delete listening.listeningTo[listening.objId];
          }
        }
      }

      // Update tail event if the list has any events.  Otherwise, clean up.
      if (remaining.length) {
        events[name] = remaining;
      } else {
        delete events[name];
      }
    }
    if (_.size(events)) return events;
  };

  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, its listener will be removed. If multiple events
  // are passed in using the space-separated syntax, the handler will fire
  // once for each event, not once for a combination of all events.
  Events.once =  function(name, callback, context) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
    return this.on(events, void 0, context);
  };

  // Inversion-of-control versions of `once`.
  Events.listenToOnce =  function(obj, name, callback) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
    return this.listenTo(obj, events);
  };

  // Reduces the event callbacks into a map of `{event: onceWrapper}`.
  // `offer` unbinds the `onceWrapper` after it has been called.
  var onceMap = function(map, name, callback, offer) {
    if (callback) {
      var once = map[name] = _.once(function() {
        offer(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
    }
    return map;
  };

  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  Events.trigger =  function(name) {
    if (!this._events) return this;

    var length = Math.max(0, arguments.length - 1);
    var args = Array(length);
    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];

    eventsApi(triggerApi, this._events, name, void 0, args);
    return this;
  };

  // Handles triggering the appropriate event callbacks.
  var triggerApi = function(objEvents, name, cb, args) {
    if (objEvents) {
      var events = objEvents[name];
      var allEvents = objEvents.all;
      if (events && allEvents) allEvents = allEvents.slice();
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, [name].concat(args));
    }
    return objEvents;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId(this.cidPrefix);
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // The prefix is used to create the client id which is used to identify models locally.
    // You may want to override this if you're experiencing name clashes with model ids.
    cidPrefix: 'c',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Special-cased proxy to underscore's `_.matches` method.
    matches: function(attrs) {
      return !!_.iteratee(attrs, this)(this.attributes);
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      var unset      = options.unset;
      var silent     = options.silent;
      var changes    = [];
      var changing   = this._changing;
      this._changing = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }

      var current = this.attributes;
      var changed = this.changed;
      var prev    = this._previousAttributes;

      // For each `set` attribute, update or delete the current value.
      for (var attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          changed[attr] = val;
        } else {
          delete changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Update the `id`.
      this.id = this.get(this.idAttribute);

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0; i < changes.length; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      var changed = {};
      for (var attr in diff) {
        var val = diff[attr];
        if (_.isEqual(old[attr], val)) continue;
        changed[attr] = val;
      }
      return _.size(changed) ? changed : false;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server, merging the response with the model's
    // local attributes. Any changed attributes will trigger a "change" event.
    fetch: function(options) {
      options = _.extend({parse: true}, options);
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (!model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true, parse: true}, options);
      var wait = options.wait;

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var model = this;
      var success = options.success;
      var attributes = this.attributes;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
        if (serverAttrs && !model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      // Set temporary attributes if `{wait: true}` to properly find new ids.
      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch' && !options.attrs) options.attrs = attrs;
      var xhr = this.sync(method, this, options);

      // Restore attributes.
      this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;
      var wait = options.wait;

      var destroy = function() {
        model.stopListening();
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (wait) destroy();
        if (success) success.call(options.context, model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      var xhr = false;
      if (this.isNew()) {
        _.defer(options.success);
      } else {
        wrapError(this, options);
        xhr = this.sync('delete', this, options);
      }
      if (!wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      var id = this.get(this.idAttribute);
      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.defaults({validate: true}, options));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model, mapped to the
  // number of arguments they take.
  var modelMethods = { keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
      omit: 0, chain: 1, isEmpty: 1 };

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  addUnderscoreMethods(Model, modelMethods, 'attributes');

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analogous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Splices `insert` into `array` at index `at`.
  var splice = function(array, insert, at) {
    at = Math.min(Math.max(at, 0), array.length);
    var tail = Array(array.length - at);
    var length = insert.length;
    for (var i = 0; i < tail.length; i++) tail[i] = array[i + at];
    for (i = 0; i < length; i++) array[i + at] = insert[i];
    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
  };

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model) { return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set. `models` may be Backbone
    // Models or raw JavaScript objects to be converted to Models, or any
    // combination of the two.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      options = _.extend({}, options);
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      var removed = this._removeModels(models, options);
      if (!options.silent && removed) this.trigger('update', this, options);
      return singular ? removed[0] : removed;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      if (models == null) return;

      options = _.defaults({}, options, setOptions);
      if (options.parse && !this._isModel(models)) models = this.parse(models, options);

      var singular = !_.isArray(models);
      models = singular ? [models] : models.slice();

      var at = options.at;
      if (at != null) at = +at;
      if (at < 0) at += this.length + 1;

      var set = [];
      var toAdd = [];
      var toRemove = [];
      var modelMap = {};

      var add = options.add;
      var merge = options.merge;
      var remove = options.remove;

      var sort = false;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      var model;
      for (var i = 0; i < models.length; i++) {
        model = models[i];

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        var existing = this.get(model);
        if (existing) {
          if (merge && model !== existing) {
            var attrs = this._isModel(model) ? model.attributes : model;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort) sort = existing.hasChanged(sortAttr);
          }
          if (!modelMap[existing.cid]) {
            modelMap[existing.cid] = true;
            set.push(existing);
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(model, options);
          if (model) {
            toAdd.push(model);
            this._addReference(model, options);
            modelMap[model.cid] = true;
            set.push(model);
          }
        }
      }

      // Remove stale models.
      if (remove) {
        for (i = 0; i < this.length; i++) {
          model = this.models[i];
          if (!modelMap[model.cid]) toRemove.push(model);
        }
        if (toRemove.length) this._removeModels(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      var orderChanged = false;
      var replace = !sortable && add && remove;
      if (set.length && replace) {
        orderChanged = this.length != set.length || _.some(this.models, function(model, index) {
          return model !== set[index];
        });
        this.models.length = 0;
        splice(this.models, set, 0);
        this.length = this.models.length;
      } else if (toAdd.length) {
        if (sortable) sort = true;
        splice(this.models, toAdd, at == null ? this.length : at);
        this.length = this.models.length;
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0; i < toAdd.length; i++) {
          if (at != null) options.index = at + i;
          model = toAdd[i];
          model.trigger('add', model, this, options);
        }
        if (sort || orderChanged) this.trigger('sort', this, options);
        if (toAdd.length || toRemove.length) this.trigger('update', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options = options ? _.clone(options) : {};
      for (var i = 0; i < this.models.length; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      return this.remove(model, options);
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      return this.remove(model, options);
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      var id = this.modelId(this._isModel(obj) ? obj.attributes : obj);
      return this._byId[obj] || this._byId[id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      if (index < 0) index += this.length;
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      return this[first ? 'find' : 'filter'](attrs);
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      var comparator = this.comparator;
      if (!comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      var length = comparator.length;
      if (_.isFunction(comparator)) comparator = _.bind(comparator, this);

      // Run sort based on type of `comparator`.
      if (length === 1 || _.isString(comparator)) {
        this.models = this.sortBy(comparator);
      } else {
        this.models.sort(comparator);
      }
      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = _.extend({parse: true}, options);
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success.call(options.context, collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      var wait = options.wait;
      model = this._prepareModel(model, options);
      if (!model) return false;
      if (!wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp, callbackOpts) {
        if (wait) collection.add(model, callbackOpts);
        if (success) success.call(callbackOpts.context, model, resp, callbackOpts);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models, {
        model: this.model,
        comparator: this.comparator
      });
    },

    // Define how to uniquely identify models in the collection.
    modelId: function (attrs) {
      return attrs[this.model.prototype.idAttribute || 'id'];
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (this._isModel(attrs)) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method called by both remove and set.
    _removeModels: function(models, options) {
      var removed = [];
      for (var i = 0; i < models.length; i++) {
        var model = this.get(models[i]);
        if (!model) continue;

        var index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;

        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }

        removed.push(model);
        this._removeReference(model, options);
      }
      return removed.length ? removed : false;
    },

    // Method for checking whether an object should be considered a model for
    // the purposes of adding to the collection.
    _isModel: function (model) {
      return model instanceof Model;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      var id = this.modelId(model.attributes);
      if (id != null) this._byId[id] = model;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      delete this._byId[model.cid];
      var id = this.modelId(model.attributes);
      if (id != null) delete this._byId[id];
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (event === 'change') {
        var prevId = this.modelId(model.previousAttributes());
        var id = this.modelId(model.attributes);
        if (prevId !== id) {
          if (prevId != null) delete this._byId[prevId];
          if (id != null) this._byId[id] = model;
        }
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var collectionMethods = { forEach: 3, each: 3, map: 3, collect: 3, reduce: 4,
      foldl: 4, inject: 4, reduceRight: 4, foldr: 4, find: 3, detect: 3, filter: 3,
      select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,
      contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
      head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
      without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
      isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,
      sortBy: 3, indexBy: 3};

  // Mix in each Underscore method as a proxy to `Collection#models`.
  addUnderscoreMethods(Collection, collectionMethods, 'models');

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be set as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this._removeElement();
      this.stopListening();
      return this;
    },

    // Remove this view's element from the document and all event listeners
    // attached to it. Exposed for subclasses using an alternative DOM
    // manipulation API.
    _removeElement: function() {
      this.$el.remove();
    },

    // Change the view's element (`this.el` property) and re-delegate the
    // view's events on the new element.
    setElement: function(element) {
      this.undelegateEvents();
      this._setElement(element);
      this.delegateEvents();
      return this;
    },

    // Creates the `this.el` and `this.$el` references for this view using the
    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
    // context or an element. Subclasses can override this to utilize an
    // alternative DOM manipulation API and are only required to set the
    // `this.el` property.
    _setElement: function(el) {
      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
      this.el = this.$el[0];
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    delegateEvents: function(events) {
      events || (events = _.result(this, 'events'));
      if (!events) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[method];
        if (!method) continue;
        var match = key.match(delegateEventSplitter);
        this.delegate(match[1], match[2], _.bind(method, this));
      }
      return this;
    },

    // Add a single event listener to the view's element (or a child element
    // using `selector`). This only works for delegate-able events: not `focus`,
    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
    delegate: function(eventName, selector, listener) {
      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Clears all callbacks previously bound to the view by `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      if (this.$el) this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // A finer-grained `undelegateEvents` for removing a single delegated event.
    // `selector` and `listener` are both optional.
    undelegate: function(eventName, selector, listener) {
      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Produces a DOM element to be assigned to your view. Exposed for
    // subclasses using an alternative DOM manipulation API.
    _createElement: function(tagName) {
      return document.createElement(tagName);
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        this.setElement(this._createElement(_.result(this, 'tagName')));
        this._setAttributes(attrs);
      } else {
        this.setElement(_.result(this, 'el'));
      }
    },

    // Set attributes from a hash on this view's element.  Exposed for
    // subclasses using an alternative DOM manipulation API.
    _setAttributes: function(attributes) {
      this.$el.attr(attributes);
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // Pass along `textStatus` and `errorThrown` from jQuery.
    var error = options.error;
    options.error = function(xhr, textStatus, errorThrown) {
      options.textStatus = textStatus;
      options.errorThrown = errorThrown;
      if (error) error.call(options.context, xhr, textStatus, errorThrown);
    };

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        if (router.execute(callback, args, name) !== false) {
          router.trigger.apply(router, ['route:' + name].concat(args));
          router.trigger('route', name, args);
          Backbone.history.trigger('route', router, name, args);
        }
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args, name) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    this.checkUrl = _.bind(this.checkUrl, this);

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      var path = this.location.pathname.replace(/[^\/]$/, '$&/');
      return path === this.root && !this.getSearch();
    },

    // Does the pathname match the root?
    matchRoot: function() {
      var path = this.decodeFragment(this.location.pathname);
      var root = path.slice(0, this.root.length - 1) + '/';
      return root === this.root;
    },

    // Unicode characters in `location.pathname` are percent encoded so they're
    // decoded for comparison. `%25` should not be decoded since it may be part
    // of an encoded parameter.
    decodeFragment: function(fragment) {
      return decodeURI(fragment.replace(/%25/g, '%2525'));
    },

    // In IE6, the hash fragment and search params are incorrect if the
    // fragment contains `?`.
    getSearch: function() {
      var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
      return match ? match[0] : '';
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the pathname and search params, without the root.
    getPath: function() {
      var path = this.decodeFragment(
        this.location.pathname + this.getSearch()
      ).slice(this.root.length - 1);
      return path.charAt(0) === '/' ? path.slice(1) : path;
    },

    // Get the cross-browser normalized URL fragment from the path or hash.
    getFragment: function(fragment) {
      if (fragment == null) {
        if (this._usePushState || !this._wantsHashChange) {
          fragment = this.getPath();
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error('Backbone.history has already been started');
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
      this._useHashChange   = this._wantsHashChange && this._hasHashChange;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.history && this.history.pushState);
      this._usePushState    = this._wantsPushState && this._hasPushState;
      this.fragment         = this.getFragment();

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          var root = this.root.slice(0, -1) || '/';
          this.location.replace(root + '#' + this.getPath());
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot()) {
          this.navigate(this.getHash(), {replace: true});
        }

      }

      // Proxy an iframe to handle location events if the browser doesn't
      // support the `hashchange` event, HTML5 history, or the user wants
      // `hashChange` but not `pushState`.
      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
        this.iframe = document.createElement('iframe');
        this.iframe.src = 'javascript:0';
        this.iframe.style.display = 'none';
        this.iframe.tabIndex = -1;
        var body = document.body;
        // Using `appendChild` will throw on IE < 9 if the document is not ready.
        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
        iWindow.document.open();
        iWindow.document.close();
        iWindow.location.hash = '#' + this.fragment;
      }

      // Add a cross-platform `addEventListener` shim for older browsers.
      var addEventListener = window.addEventListener || function (eventName, listener) {
        return attachEvent('on' + eventName, listener);
      };

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._usePushState) {
        addEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        addEventListener('hashchange', this.checkUrl, false);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      // Add a cross-platform `removeEventListener` shim for older browsers.
      var removeEventListener = window.removeEventListener || function (eventName, listener) {
        return detachEvent('on' + eventName, listener);
      };

      // Remove window listeners.
      if (this._usePushState) {
        removeEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        removeEventListener('hashchange', this.checkUrl, false);
      }

      // Clean up the iframe if necessary.
      if (this.iframe) {
        document.body.removeChild(this.iframe);
        this.iframe = null;
      }

      // Some environments will throw when clearing an undefined interval.
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();

      // If the user pressed the back button, the iframe's hash will have
      // changed and we should use that for comparison.
      if (current === this.fragment && this.iframe) {
        current = this.getHash(this.iframe.contentWindow);
      }

      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      // If the root doesn't match, no routes can match either.
      if (!this.matchRoot()) return false;
      fragment = this.fragment = this.getFragment(fragment);
      return _.some(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      // Normalize the fragment.
      fragment = this.getFragment(fragment || '');

      // Don't include a trailing slash on the root.
      var root = this.root;
      if (fragment === '' || fragment.charAt(0) === '?') {
        root = root.slice(0, -1) || '/';
      }
      var url = root + fragment;

      // Strip the hash and decode for matching.
      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._usePushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getHash(this.iframe.contentWindow))) {
          var iWindow = this.iframe.contentWindow;

          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if (!options.replace) {
            iWindow.document.open();
            iWindow.document.close();
          }

          this._updateHash(iWindow.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent` constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"jquery":25,"underscore":2}],2:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],3:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _handlebarsBase = require('./handlebars/base');

var base = _interopRequireWildcard(_handlebarsBase);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var _handlebarsSafeString = require('./handlebars/safe-string');

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = require('./handlebars/exception');

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = require('./handlebars/utils');

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = require('./handlebars/runtime');

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars/base":4,"./handlebars/exception":7,"./handlebars/no-conflict":17,"./handlebars/runtime":18,"./handlebars/safe-string":19,"./handlebars/utils":20}],4:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _helpers = require('./helpers');

var _decorators = require('./decorators');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var VERSION = '4.0.5';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];


},{"./decorators":5,"./exception":7,"./helpers":8,"./logger":16,"./utils":20}],5:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _decoratorsInline = require('./decorators/inline');

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}


},{"./decorators/inline":6}],6:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function (context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];


},{"../utils":20}],7:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  if (loc) {
    this.lineNumber = line;
    this.column = column;
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];


},{}],8:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = require('./helpers/each');

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = require('./helpers/helper-missing');

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = require('./helpers/if');

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = require('./helpers/log');

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = require('./helpers/lookup');

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = require('./helpers/with');

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}


},{"./helpers/block-helper-missing":9,"./helpers/each":10,"./helpers/helper-missing":11,"./helpers/if":12,"./helpers/log":13,"./helpers/lookup":14,"./helpers/with":15}],9:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];


},{"../utils":20}],10:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('../utils');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey !== undefined) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];


},{"../exception":7,"../utils":20}],11:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];


},{"../exception":7}],12:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });
};

module.exports = exports['default'];


},{"../utils":20}],13:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];


},{}],14:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field) {
    return obj && obj[field];
  });
};

module.exports = exports['default'];


},{}],15:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];


},{"../utils":20}],16:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('./utils');

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      if (!console[method]) {
        // eslint-disable-line no-console
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];


},{"./utils":20}],17:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
    return Handlebars;
  };
};

module.exports = exports['default'];


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],18:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _base = require('./base');

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = container.merge(options.decorators, env.decorators);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths && context !== depths[0]) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    options.data = _base.createFrame(options.data);
    partialBlock = options.data['partial-block'] = options.fn;

    if (partialBlock.partials) {
      options.partials = Utils.extend({}, options.partials, partialBlock.partials);
    }
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}


},{"./base":4,"./exception":7,"./utils":20}],19:[function(require,module,exports){
// Build out our basic SafeString type
'use strict';

exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];


},{}],20:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

var badChars = /[&<>"'`=]/g,
    possible = /[&<>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};

exports.isArray = isArray;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}


},{}],21:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime')['default'];

},{"./dist/cjs/handlebars.runtime":3}],22:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":21}],23:[function(require,module,exports){

/**
 * @license Highcharts JS v4.1.9 (2015-10-07)
 *
 * Standalone Highcharts Framework
 *
 * License: MIT License
 */


/*global Highcharts */
var HighchartsAdapter = (function () {

var UNDEFINED,
	doc = document,
	emptyArray = [],
	timers = [],
	animSetters = {},
	Fx;

Math.easeInOutSine = function (t, b, c, d) {
	return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
};



/**
 * Extend given object with custom events
 */
function augment(obj) {
	function removeOneEvent(el, type, fn) {
		el.removeEventListener(type, fn, false);
	}

	function IERemoveOneEvent(el, type, fn) {
		fn = el.HCProxiedMethods[fn.toString()];
		el.detachEvent('on' + type, fn);
	}

	function removeAllEvents(el, type) {
		var events = el.HCEvents,
			remove,
			types,
			len,
			n;

		if (el.removeEventListener) {
			remove = removeOneEvent;
		} else if (el.attachEvent) {
			remove = IERemoveOneEvent;
		} else {
			return; // break on non-DOM events
		}


		if (type) {
			types = {};
			types[type] = true;
		} else {
			types = events;
		}

		for (n in types) {
			if (events[n]) {
				len = events[n].length;
				while (len--) {
					remove(el, n, events[n][len]);
				}
			}
		}
	}

	if (!obj.HCExtended) {
		Highcharts.extend(obj, {
			HCExtended: true,

			HCEvents: {},

			bind: function (name, fn) {
				var el = this,
					events = this.HCEvents,
					wrappedFn;

				// handle DOM events in modern browsers
				if (el.addEventListener) {
					el.addEventListener(name, fn, false);

				// handle old IE implementation
				} else if (el.attachEvent) {
					
					wrappedFn = function (e) {
						e.target = e.srcElement || window; // #2820
						fn.call(el, e);
					};

					if (!el.HCProxiedMethods) {
						el.HCProxiedMethods = {};
					}

					// link wrapped fn with original fn, so we can get this in removeEvent
					el.HCProxiedMethods[fn.toString()] = wrappedFn;

					el.attachEvent('on' + name, wrappedFn);
				}


				if (events[name] === UNDEFINED) {
					events[name] = [];
				}

				events[name].push(fn);
			},

			unbind: function (name, fn) {
				var events,
					index;

				if (name) {
					events = this.HCEvents[name] || [];
					if (fn) {
						index = HighchartsAdapter.inArray(fn, events);
						if (index > -1) {
							events.splice(index, 1);
							this.HCEvents[name] = events;
						}
						if (this.removeEventListener) {
							removeOneEvent(this, name, fn);
						} else if (this.attachEvent) {
							IERemoveOneEvent(this, name, fn);
						}
					} else {
						removeAllEvents(this, name);
						this.HCEvents[name] = [];
					}
				} else {
					removeAllEvents(this);
					this.HCEvents = {};
				}
			},

			trigger: function (name, args) {
				var events = this.HCEvents[name] || [],
					target = this,
					len = events.length,
					i,
					preventDefault,
					fn;

				// Attach a simple preventDefault function to skip default handler if called
				preventDefault = function () {
					args.defaultPrevented = true;
				};
				
				for (i = 0; i < len; i++) {
					fn = events[i];

					// args is never null here
					if (args.stopped) {
						return;
					}

					args.preventDefault = preventDefault;
					args.target = target;

					// If the type is not set, we're running a custom event (#2297). If it is set,
					// we're running a browser event, and setting it will cause en error in
					// IE8 (#2465).
					if (!args.type) {
						args.type = name;
					}
					

					
					// If the event handler return false, prevent the default handler from executing
					if (fn.call(this, args) === false) {
						args.preventDefault();
					}
				}
			}
		});
	}

	return obj;
}


return {

	/**
	 * Initialize the adapter. This is run once as Highcharts is first run.
	 */
	init: function (pathAnim) {

		/**
		 * Compatibility section to add support for legacy IE. This can be removed if old IE 
		 * support is not needed.
		 */
		if (!doc.defaultView) {
			this._getStyle = function (el, prop) {
				var val;
				if (el.style[prop]) {
					return el.style[prop];
				} else {
					if (prop === 'opacity') {
						prop = 'filter';
					}
					/*jslint unparam: true*/
					val = el.currentStyle[prop.replace(/\-(\w)/g, function (a, b) { return b.toUpperCase(); })];
					if (prop === 'filter') {
						val = val.replace(
							/alpha\(opacity=([0-9]+)\)/, 
							function (a, b) { 
								return b / 100; 
							}
						);
					}
					/*jslint unparam: false*/
					return val === '' ? 1 : val;
				} 
			};
			this.adapterRun = function (elem, method) {
				var alias = { width: 'clientWidth', height: 'clientHeight' }[method];

				if (alias) {
					elem.style.zoom = 1;
					return elem[alias] - 2 * parseInt(HighchartsAdapter._getStyle(elem, 'padding'), 10);
				}
			};
		}

		if (!Array.prototype.forEach) {
			this.each = function (arr, fn) { // legacy
				var i = 0, 
					len = arr.length;
				for (; i < len; i++) {
					if (fn.call(arr[i], arr[i], i, arr) === false) {
						return i;
					}
				}
			};
		}

		if (!Array.prototype.indexOf) {
			this.inArray = function (item, arr) {
				var len, 
					i = 0;

				if (arr) {
					len = arr.length;
					
					for (; i < len; i++) {
						if (arr[i] === item) {
							return i;
						}
					}
				}

				return -1;
			};
		}

		if (!Array.prototype.filter) {
			this.grep = function (elements, callback) {
				var ret = [],
					i = 0,
					length = elements.length;

				for (; i < length; i++) {
					if (!!callback(elements[i], i)) {
						ret.push(elements[i]);
					}
				}

				return ret;
			};
		}

		//--- End compatibility section ---


		/**
		 * Start of animation specific code
		 */
		Fx = function (elem, options, prop) {
			this.options = options;
			this.elem = elem;
			this.prop = prop;
		};
		Fx.prototype = {
			
			update: function () {
				var styles,
					paths = this.paths,
					elem = this.elem,
					elemelem = elem.element; // if destroyed, it is null

				// Animation setter defined from outside
				if (animSetters[this.prop]) {
					animSetters[this.prop](this);

				// Animating a path definition on SVGElement
				} else if (paths && elemelem) {
					elem.attr('d', pathAnim.step(paths[0], paths[1], this.now, this.toD));

				// Other animations on SVGElement
				} else if (elem.attr) {
					if (elemelem) {
						elem.attr(this.prop, this.now);
					}

				// HTML styles
				} else {
					styles = {};
					styles[this.prop] = this.now + this.unit;
					Highcharts.css(elem, styles);
				}
				
				if (this.options.step) {
					this.options.step.call(this.elem, this.now, this);
				}

			},
			custom: function (from, to, unit) {
				var self = this,
					t = function (gotoEnd) {
						return self.step(gotoEnd);
					},
					i;

				this.startTime = +new Date();
				this.start = from;
				this.end = to;
				this.unit = unit;
				this.now = this.start;
				this.pos = this.state = 0;

				t.elem = this.elem;

				if (t() && timers.push(t) === 1) {
					t.timerId = setInterval(function () {
						
						for (i = 0; i < timers.length; i++) {
							if (!timers[i]()) {
								timers.splice(i--, 1);
							}
						}

						if (!timers.length) {
							clearInterval(t.timerId);
						}
					}, 13);
				}
			},
			
			step: function (gotoEnd) {
				var t = +new Date(),
					ret,
					done,
					options = this.options,
					elem = this.elem,
					i;
				
				if (elem.attr && !elem.element) { // #2616, element including flag is destroyed
					ret = false;

				} else if (gotoEnd || t >= options.duration + this.startTime) {
					this.now = this.end;
					this.pos = this.state = 1;
					this.update();

					this.options.curAnim[this.prop] = true;

					done = true;
					for (i in options.curAnim) {
						if (options.curAnim[i] !== true) {
							done = false;
						}
					}

					if (done) {
						if (options.complete) {
							options.complete.call(elem);
						}
					}
					ret = false;

				} else {
					var n = t - this.startTime;
					this.state = n / options.duration;
					this.pos = options.easing(n, 0, 1, options.duration);
					this.now = this.start + ((this.end - this.start) * this.pos);
					this.update();
					ret = true;
				}
				return ret;
			}
		};

		/**
		 * The adapter animate method
		 */
		this.animate = function (el, prop, opt) {
			var start,
				unit = '',
				end,
				fx,
				args,
				name,
				PX = 'px';

			if (typeof opt !== 'object' || opt === null) {
				args = arguments;
				opt = {
					duration: args[2],
					easing: args[3],
					complete: args[4]
				};
			}
			if (typeof opt.duration !== 'number') {
				opt.duration = 400;
			}
			opt.easing = Math[opt.easing] || Math.easeInOutSine;
			opt.curAnim = Highcharts.extend({}, prop);
			
			for (name in prop) {
				fx = new Fx(el, opt, name);
				end = null;
				
				if (name === 'd') {
					fx.paths = pathAnim.init(
						el,
						el.d,
						prop.d
					);
					fx.toD = prop.d;
					start = 0;
					end = 1;
				} else if (el.attr) {
					start = el.attr(name);
				} else {
					start = parseFloat(HighchartsAdapter._getStyle(el, name)) || 0;
					if (name !== 'opacity') {
						unit = PX;
					}
				}
	
				if (!end) {
					end = prop[name];
				}
				if (end.match && end.match(PX)) {
					end = end.replace(/px/g, ''); // #4351
				}
				fx.custom(start, end, unit);
			}	
		};
	},

	/**
	 * Internal method to return CSS value for given element and property
	 */
	_getStyle: function (el, prop) {
		return window.getComputedStyle(el, undefined).getPropertyValue(prop);
	},

	/**
	 * Add an animation setter for a specific property
	 */
	addAnimSetter: function (prop, fn) {
		animSetters[prop] = fn;
	},

	/**
	 * Downloads a script and executes a callback when done.
	 * @param {String} scriptLocation
	 * @param {Function} callback
	 */
	getScript: function (scriptLocation, callback) {
		// We cannot assume that Assets class from mootools-more is available so instead insert a script tag to download script.
		var head = doc.getElementsByTagName('head')[0],
			script = doc.createElement('script');

		script.type = 'text/javascript';
		script.src = scriptLocation;
		script.onload = callback;

		head.appendChild(script);
	},

	/**
	 * Return the index of an item in an array, or -1 if not found
	 */
	inArray: function (item, arr) {
		return arr.indexOf ? arr.indexOf(item) : emptyArray.indexOf.call(arr, item);
	},


	/**
	 * A direct link to adapter methods
	 */
	adapterRun: function (elem, method) {
		return parseInt(HighchartsAdapter._getStyle(elem, method), 10);
	},

	/**
	 * Filter an array
	 */
	grep: function (elements, callback) {
		return emptyArray.filter.call(elements, callback);
	},

	/**
	 * Map an array
	 */
	map: function (arr, fn) {
		var results = [], i = 0, len = arr.length;

		for (; i < len; i++) {
			results[i] = fn.call(arr[i], arr[i], i, arr);
		}

		return results;
	},

	/**
	 * Get the element's offset position, corrected by overflow:auto. Loosely based on jQuery's offset method.
	 */
	offset: function (el) {
		var docElem = document.documentElement,
			box = el.getBoundingClientRect();

		return {
			top: box.top  + (window.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0),
			left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
		};
	},

	/**
	 * Add an event listener
	 */
	addEvent: function (el, type, fn) {
		augment(el).bind(type, fn);
	},

	/**
	 * Remove event added with addEvent
	 */
	removeEvent: function (el, type, fn) {
		augment(el).unbind(type, fn);
	},

	/**
	 * Fire an event on a custom object
	 */
	fireEvent: function (el, type, eventArguments, defaultFunction) {
		var e;

		if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {
			e = doc.createEvent('Events');
			e.initEvent(type, true, true);
			e.target = el;

			Highcharts.extend(e, eventArguments);

			if (el.dispatchEvent) {
				el.dispatchEvent(e);
			} else {
				el.fireEvent(type, e);
			}

		} else if (el.HCExtended === true) {
			eventArguments = eventArguments || {};
			el.trigger(type, eventArguments);
		}

		if (eventArguments && eventArguments.defaultPrevented) {
			defaultFunction = null;
		}

		if (defaultFunction) {
			defaultFunction(eventArguments);
		}
	},

	washMouseEvent: function (e) {
		return e;
	},


	/**
	 * Stop running animation
	 */
	stop: function (el) {

		var i = timers.length,
			timer;

		// Remove timers related to this element (#4519)
		while (i--) {
			timer = timers[i];
			if (timer.elem === el) {
				timers.splice(i, 1);
			}
		}
	},

	/**
	 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
	 * @param {Array} arr
	 * @param {Function} fn
	 */
	each: function (arr, fn) { // modern browsers
		return Array.prototype.forEach.call(arr, fn);
	}
};
}());
;

module.exports = HighchartsAdapter;
},{}],24:[function(require,module,exports){

var HighchartsAdapter = window.HighchartsAdapter = require('./adapters/standalone-framework');

// ==ClosureCompiler==
// @compilation_level SIMPLE_OPTIMIZATIONS

/**
 * @license Highcharts JS v4.1.9 (2015-10-07)
 *
 * (c) 2009-2014 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

// JSLint options:
/*global Highcharts, HighchartsAdapter, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console, each, grep */
/*jslint ass: true, sloppy: true, forin: true, plusplus: true, nomen: true, vars: true, regexp: true, newcap: true, browser: true, continue: true, white: true */
(function () {
// encapsulated variables
var UNDEFINED,
	doc = document,
	win = window,
	math = Math,
	mathRound = math.round,
	mathFloor = math.floor,
	mathCeil = math.ceil,
	mathMax = math.max,
	mathMin = math.min,
	mathAbs = math.abs,
	mathCos = math.cos,
	mathSin = math.sin,
	mathPI = math.PI,
	deg2rad = mathPI * 2 / 360,


	// some variables
	userAgent = navigator.userAgent,
	isOpera = win.opera,
	isMS = /(msie|trident|edge)/i.test(userAgent) && !isOpera,
	docMode8 = doc.documentMode === 8,
	isWebKit = !isMS && /AppleWebKit/.test(userAgent),
	isFirefox = /Firefox/.test(userAgent),
	isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),
	SVG_NS = 'http://www.w3.org/2000/svg',
	hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
	hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38
	useCanVG = !hasSVG && !isMS && !!doc.createElement('canvas').getContext,
	Renderer,
	hasTouch,
	symbolSizes = {},
	idCounter = 0,
	garbageBin,
	defaultOptions,
	dateFormat, // function
	pathAnim,
	timeUnits,
	noop = function () { return UNDEFINED; },
	charts = [],
	chartCount = 0,
	PRODUCT = 'Highcharts',
	VERSION = '4.1.9',

	// some constants for frequently used strings
	DIV = 'div',
	ABSOLUTE = 'absolute',
	RELATIVE = 'relative',
	HIDDEN = 'hidden',
	PREFIX = 'highcharts-',
	VISIBLE = 'visible',
	PX = 'px',
	NONE = 'none',
	M = 'M',
	L = 'L',
	numRegex = /^[0-9]+$/,
	NORMAL_STATE = '',
	HOVER_STATE = 'hover',
	SELECT_STATE = 'select',
	marginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],
	
	// Object for extending Axis
	AxisPlotLineOrBandExtension,

	// constants for attributes
	STROKE_WIDTH = 'stroke-width',

	// time methods, changed based on whether or not UTC is used
	Date,  // Allow using a different Date class
	makeTime,
	timezoneOffset,
	getTimezoneOffset,
	getMinutes,
	getHours,
	getDay,
	getDate,
	getMonth,
	getFullYear,
	setMilliseconds,
	setSeconds,
	setMinutes,
	setHours,
	setDate,
	setMonth,
	setFullYear,


	// lookup over the types and the associated classes
	seriesTypes = {},
	Highcharts;

// The Highcharts namespace
Highcharts = win.Highcharts = win.Highcharts ? error(16, true) : {};

Highcharts.seriesTypes = seriesTypes;

/**
 * Extend an object with the members of another
 * @param {Object} a The object to be extended
 * @param {Object} b The object to add to the first one
 */
var extend = Highcharts.extend = function (a, b) {
	var n;
	if (!a) {
		a = {};
	}
	for (n in b) {
		a[n] = b[n];
	}
	return a;
};
	
/**
 * Deep merge two or more objects and return a third object. If the first argument is
 * true, the contents of the second object is copied into the first object.
 * Previously this function redirected to jQuery.extend(true), but this had two limitations.
 * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,
 * it copied properties from extended prototypes. 
 */
function merge() {
	var i,
		args = arguments,
		len,
		ret = {},
		doCopy = function (copy, original) {
			var value, key;

			// An object is replacing a primitive
			if (typeof copy !== 'object') {
				copy = {};
			}

			for (key in original) {
				if (original.hasOwnProperty(key)) {
					value = original[key];

					// Copy the contents of objects, but not arrays or DOM nodes
					if (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]' &&
							key !== 'renderTo' && typeof value.nodeType !== 'number') {
						copy[key] = doCopy(copy[key] || {}, value);
				
					// Primitives and arrays are copied over directly
					} else {
						copy[key] = original[key];
					}
				}
			}
			return copy;
		};

	// If first argument is true, copy into the existing object. Used in setOptions.
	if (args[0] === true) {
		ret = args[1];
		args = Array.prototype.slice.call(args, 2);
	}

	// For each argument, extend the return
	len = args.length;
	for (i = 0; i < len; i++) {
		ret = doCopy(ret, args[i]);
	}

	return ret;
}

/**
 * Shortcut for parseInt
 * @param {Object} s
 * @param {Number} mag Magnitude
 */
function pInt(s, mag) {
	return parseInt(s, mag || 10);
}

/**
 * Check for string
 * @param {Object} s
 */
function isString(s) {
	return typeof s === 'string';
}

/**
 * Check for object
 * @param {Object} obj
 */
function isObject(obj) {
	return obj && typeof obj === 'object';
}

/**
 * Check for array
 * @param {Object} obj
 */
function isArray(obj) {
	return Object.prototype.toString.call(obj) === '[object Array]';
}

/**
 * Check for number
 * @param {Object} n
 */
function isNumber(n) {
	return typeof n === 'number';
}

function log2lin(num) {
	return math.log(num) / math.LN10;
}
function lin2log(num) {
	return math.pow(10, num);
}

/**
 * Remove last occurence of an item from an array
 * @param {Array} arr
 * @param {Mixed} item
 */
function erase(arr, item) {
	var i = arr.length;
	while (i--) {
		if (arr[i] === item) {
			arr.splice(i, 1);
			break;
		}
	}
	//return arr;
}

/**
 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
 * @param {Object} obj
 */
function defined(obj) {
	return obj !== UNDEFINED && obj !== null;
}

/**
 * Set or get an attribute or an object of attributes. Can't use jQuery attr because
 * it attempts to set expando properties on the SVG element, which is not allowed.
 *
 * @param {Object} elem The DOM element to receive the attribute(s)
 * @param {String|Object} prop The property or an abject of key-value pairs
 * @param {String} value The value if a single property is set
 */
function attr(elem, prop, value) {
	var key,
		ret;

	// if the prop is a string
	if (isString(prop)) {
		// set the value
		if (defined(value)) {
			elem.setAttribute(prop, value);

		// get the value
		} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
			ret = elem.getAttribute(prop);
		}

	// else if prop is defined, it is a hash of key/value pairs
	} else if (defined(prop) && isObject(prop)) {
		for (key in prop) {
			elem.setAttribute(key, prop[key]);
		}
	}
	return ret;
}
/**
 * Check if an element is an array, and if not, make it into an array. Like
 * MooTools' $.splat.
 */
function splat(obj) {
	return isArray(obj) ? obj : [obj];
}


/**
 * Return the first value that is defined. Like MooTools' $.pick.
 */
var pick = Highcharts.pick = function () {
	var args = arguments,
		i,
		arg,
		length = args.length;
	for (i = 0; i < length; i++) {
		arg = args[i];
		if (arg !== UNDEFINED && arg !== null) {
			return arg;
		}
	}
};

/**
 * Set CSS on a given element
 * @param {Object} el
 * @param {Object} styles Style object with camel case property names
 */
function css(el, styles) {
	if (isMS && !hasSVG) { // #2686
		if (styles && styles.opacity !== UNDEFINED) {
			styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
		}
	}
	extend(el.style, styles);
}

/**
 * Utility function to create element with attributes and styles
 * @param {Object} tag
 * @param {Object} attribs
 * @param {Object} styles
 * @param {Object} parent
 * @param {Object} nopad
 */
function createElement(tag, attribs, styles, parent, nopad) {
	var el = doc.createElement(tag);
	if (attribs) {
		extend(el, attribs);
	}
	if (nopad) {
		css(el, {padding: 0, border: NONE, margin: 0});
	}
	if (styles) {
		css(el, styles);
	}
	if (parent) {
		parent.appendChild(el);
	}
	return el;
}

/**
 * Extend a prototyped class by new members
 * @param {Object} parent
 * @param {Object} members
 */
function extendClass(parent, members) {
	var object = function () { return UNDEFINED; };
	object.prototype = new parent();
	extend(object.prototype, members);
	return object;
}

/**
 * Pad a string to a given length by adding 0 to the beginning
 * @param {Number} number
 * @param {Number} length
 */
function pad(number, length) {
	// Create an array of the remaining length +1 and join it with 0's
	return new Array((length || 2) + 1 - String(number).length).join(0) + number;
}

/**
 * Return a length based on either the integer value, or a percentage of a base.
 */
function relativeLength (value, base) {
	return (/%$/).test(value) ? base * parseFloat(value) / 100 : parseFloat(value);
}

/**
 * Wrap a method with extended functionality, preserving the original function
 * @param {Object} obj The context object that the method belongs to 
 * @param {String} method The name of the method to extend
 * @param {Function} func A wrapper function callback. This function is called with the same arguments
 * as the original function, except that the original function is unshifted and passed as the first 
 * argument. 
 */
var wrap = Highcharts.wrap = function (obj, method, func) {
	var proceed = obj[method];
	obj[method] = function () {
		var args = Array.prototype.slice.call(arguments);
		args.unshift(proceed);
		return func.apply(this, args);
	};
};


function getTZOffset(timestamp) {
	return ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;
}

/**
 * Based on http://www.php.net/manual/en/function.strftime.php
 * @param {String} format
 * @param {Number} timestamp
 * @param {Boolean} capitalize
 */
dateFormat = function (format, timestamp, capitalize) {
	if (!defined(timestamp) || isNaN(timestamp)) {
		return defaultOptions.lang.invalidDate || '';
	}
	format = pick(format, '%Y-%m-%d %H:%M:%S');

	var date = new Date(timestamp - getTZOffset(timestamp)),
		key, // used in for constuct below
		// get the basic time values
		hours = date[getHours](),
		day = date[getDay](),
		dayOfMonth = date[getDate](),
		month = date[getMonth](),
		fullYear = date[getFullYear](),
		lang = defaultOptions.lang,
		langWeekdays = lang.weekdays,

		// List all format keys. Custom formats can be added from the outside. 
		replacements = extend({

			// Day
			'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
			'A': langWeekdays[day], // Long weekday, like 'Monday'
			'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
			'e': dayOfMonth, // Day of the month, 1 through 31
			'w': day,

			// Week (none implemented)
			//'W': weekNumber(),

			// Month
			'b': lang.shortMonths[month], // Short month, like 'Jan'
			'B': lang.months[month], // Long month, like 'January'
			'm': pad(month + 1), // Two digit month number, 01 through 12

			// Year
			'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
			'Y': fullYear, // Four digits year, like 2009

			// Time
			'H': pad(hours), // Two digits hours in 24h format, 00 through 23
			'k': hours, // Hours in 24h format, 0 through 23
			'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
			'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
			'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
			'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
			'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
			'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59
			'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)
		}, Highcharts.dateFormats);


	// do the replaces
	for (key in replacements) {
		while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster
			format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);
		}
	}

	// Optionally capitalize the string and return
	return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
};

/** 
 * Format a single variable. Similar to sprintf, without the % prefix.
 */
function formatSingle(format, val) {
	var floatRegex = /f$/,
		decRegex = /\.([0-9])/,
		lang = defaultOptions.lang,
		decimals;

	if (floatRegex.test(format)) { // float
		decimals = format.match(decRegex);
		decimals = decimals ? decimals[1] : -1;
		if (val !== null) {
			val = Highcharts.numberFormat(
				val,
				decimals,
				lang.decimalPoint,
				format.indexOf(',') > -1 ? lang.thousandsSep : ''
			);
		}
	} else {
		val = dateFormat(format, val);
	}
	return val;
}

/**
 * Format a string according to a subset of the rules of Python's String.format method.
 */
function format(str, ctx) {
	var splitter = '{',
		isInside = false,
		segment,
		valueAndFormat,
		path,
		i,
		len,
		ret = [],
		val,
		index;
	
	while ((index = str.indexOf(splitter)) !== -1) {
		
		segment = str.slice(0, index);
		if (isInside) { // we're on the closing bracket looking back
			
			valueAndFormat = segment.split(':');
			path = valueAndFormat.shift().split('.'); // get first and leave format
			len = path.length;
			val = ctx;

			// Assign deeper paths
			for (i = 0; i < len; i++) {
				val = val[path[i]];
			}

			// Format the replacement
			if (valueAndFormat.length) {
				val = formatSingle(valueAndFormat.join(':'), val);
			}

			// Push the result and advance the cursor
			ret.push(val);
			
		} else {
			ret.push(segment);
			
		}
		str = str.slice(index + 1); // the rest
		isInside = !isInside; // toggle
		splitter = isInside ? '}' : '{'; // now look for next matching bracket
	}
	ret.push(str);
	return ret.join('');
}

/**
 * Get the magnitude of a number
 */
function getMagnitude(num) {
	return math.pow(10, mathFloor(math.log(num) / math.LN10));
}

/**
 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
 * @param {Number} interval
 * @param {Array} multiples
 * @param {Number} magnitude
 * @param {Object} options
 */
function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {
	var normalized, 
		i,
		retInterval = interval;

	// round to a tenfold of 1, 2, 2.5 or 5
	magnitude = pick(magnitude, 1);
	normalized = interval / magnitude;

	// multiples for a linear scale
	if (!multiples) {
		multiples = [1, 2, 2.5, 5, 10];

		// the allowDecimals option
		if (allowDecimals === false) {
			if (magnitude === 1) {
				multiples = [1, 2, 5, 10];
			} else if (magnitude <= 0.1) {
				multiples = [1 / magnitude];
			}
		}
	}

	// normalize the interval to the nearest multiple
	for (i = 0; i < multiples.length; i++) {
		retInterval = multiples[i];
		if ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural
			(!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {
			break;
		}
	}

	// multiply back to the correct magnitude
	retInterval *= magnitude;
	
	return retInterval;
}


/**
 * Utility method that sorts an object array and keeping the order of equal items.
 * ECMA script standard does not specify the behaviour when items are equal.
 */
function stableSort(arr, sortFunction) {
	var length = arr.length,
		sortValue,
		i;

	// Add index to each item
	for (i = 0; i < length; i++) {
		arr[i].ss_i = i; // stable sort index
	}

	arr.sort(function (a, b) {
		sortValue = sortFunction(a, b);
		return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
	});

	// Remove index from items
	for (i = 0; i < length; i++) {
		delete arr[i].ss_i; // stable sort index
	}
}

/**
 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
 * method is slightly slower, but safe.
 */
function arrayMin(data) {
	var i = data.length,
		min = data[0];

	while (i--) {
		if (data[i] < min) {
			min = data[i];
		}
	}
	return min;
}

/**
 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
 * method is slightly slower, but safe.
 */
function arrayMax(data) {
	var i = data.length,
		max = data[0];

	while (i--) {
		if (data[i] > max) {
			max = data[i];
		}
	}
	return max;
}

/**
 * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.
 * It loops all properties and invokes destroy if there is a destroy method. The property is
 * then delete'ed.
 * @param {Object} The object to destroy properties on
 * @param {Object} Exception, do not destroy this property, only delete it.
 */
function destroyObjectProperties(obj, except) {
	var n;
	for (n in obj) {
		// If the object is non-null and destroy is defined
		if (obj[n] && obj[n] !== except && obj[n].destroy) {
			// Invoke the destroy
			obj[n].destroy();
		}

		// Delete the property from the object.
		delete obj[n];
	}
}


/**
 * Discard an element by moving it to the bin and delete
 * @param {Object} The HTML node to discard
 */
function discardElement(element) {
	// create a garbage bin element, not part of the DOM
	if (!garbageBin) {
		garbageBin = createElement(DIV);
	}

	// move the node and empty bin
	if (element) {
		garbageBin.appendChild(element);
	}
	garbageBin.innerHTML = '';
}

/**
 * Provide error messages for debugging, with links to online explanation 
 */
function error (code, stop) {
	var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;
	if (stop) {
		throw msg;
	}
	// else ...
	if (win.console) {
		console.log(msg);
	}
}

/**
 * Fix JS round off float errors
 * @param {Number} num
 */
function correctFloat(num, prec) {
	return parseFloat(
		num.toPrecision(prec || 14)
	);
}

/**
 * Set the global animation to either a given value, or fall back to the
 * given chart's animation option
 * @param {Object} animation
 * @param {Object} chart
 */
function setAnimation(animation, chart) {
	chart.renderer.globalAnimation = pick(animation, chart.animation);
}

/**
 * The time unit lookup
 */
timeUnits = {
	millisecond: 1,
	second: 1000,
	minute: 60000,
	hour: 3600000,
	day: 24 * 3600000,
	week: 7 * 24 * 3600000,
	month: 28 * 24 * 3600000,
	year: 364 * 24 * 3600000
};


/**
 * Format a number and return a string based on input settings
 * @param {Number} number The input number to format
 * @param {Number} decimals The amount of decimals
 * @param {String} decPoint The decimal point, defaults to the one given in the lang options
 * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
 */
Highcharts.numberFormat = function (number, decimals, decPoint, thousandsSep) {
	var lang = defaultOptions.lang,
		// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
		n = +number || 0,
		c = decimals === -1 ?
			mathMin((n.toString().split('.')[1] || '').length, 20) : // Preserve decimals. Not huge numbers (#3793).
			(isNaN(decimals = mathAbs(decimals)) ? 2 : decimals),
		d = decPoint === undefined ? lang.decimalPoint : decPoint,
		t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,
		s = n < 0 ? "-" : "",
		i = String(pInt(n = mathAbs(n).toFixed(c))),
		j = i.length > 3 ? i.length % 3 : 0;

	return (s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
			(c ? d + mathAbs(n - i).toFixed(c).slice(2) : ""));
};
/**
 * Path interpolation algorithm used across adapters
 */
pathAnim = {
	/**
	 * Prepare start and end values so that the path can be animated one to one
	 */
	init: function (elem, fromD, toD) {
		fromD = fromD || '';
		var shift = elem.shift,
			bezier = fromD.indexOf('C') > -1,
			numParams = bezier ? 7 : 3,
			endLength,
			slice,
			i,
			start = fromD.split(' '),
			end = [].concat(toD), // copy
			startBaseLine,
			endBaseLine,
			sixify = function (arr) { // in splines make move points have six parameters like bezier curves
				i = arr.length;
				while (i--) {
					if (arr[i] === M) {
						arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
					}
				}
			};

		if (bezier) {
			sixify(start);
			sixify(end);
		}

		// pull out the base lines before padding
		if (elem.isArea) {
			startBaseLine = start.splice(start.length - 6, 6);
			endBaseLine = end.splice(end.length - 6, 6);
		}

		// if shifting points, prepend a dummy point to the end path
		if (shift <= end.length / numParams && start.length === end.length) {
			while (shift--) {
				end = [].concat(end).splice(0, numParams).concat(end);
			}
		}
		elem.shift = 0; // reset for following animations

		// copy and append last point until the length matches the end length
		if (start.length) {
			endLength = end.length;
			while (start.length < endLength) {

				//bezier && sixify(start);
				slice = [].concat(start).splice(start.length - numParams, numParams);
				if (bezier) { // disable first control point
					slice[numParams - 6] = slice[numParams - 2];
					slice[numParams - 5] = slice[numParams - 1];
				}
				start = start.concat(slice);
			}
		}

		if (startBaseLine) { // append the base lines for areas
			start = start.concat(startBaseLine);
			end = end.concat(endBaseLine);
		}
		return [start, end];
	},

	/**
	 * Interpolate each value of the path and return the array
	 */
	step: function (start, end, pos, complete) {
		var ret = [],
			i = start.length,
			startVal;

		if (pos === 1) { // land on the final path without adjustment points appended in the ends
			ret = complete;

		} else if (i === end.length && pos < 1) {
			while (i--) {
				startVal = parseFloat(start[i]);
				ret[i] =
					isNaN(startVal) ? // a letter instruction like M or L
						start[i] :
						pos * (parseFloat(end[i] - startVal)) + startVal;

			}
		} else { // if animation is finished or length not matching, land on right value
			ret = end;
		}
		return ret;
	}
};

(function ($) {
	/**
	 * The default HighchartsAdapter for jQuery
	 */
	win.HighchartsAdapter = win.HighchartsAdapter || ($ && {
		
		/**
		 * Initialize the adapter by applying some extensions to jQuery
		 */
		init: function (pathAnim) {
			
			// extend the animate function to allow SVG animations
			var Fx = $.fx;
			
			/*jslint unparam: true*//* allow unused param x in this function */
			$.extend($.easing, {
				easeOutQuad: function (x, t, b, c, d) {
					return -c * (t /= d) * (t - 2) + b;
				}
			});
			/*jslint unparam: false*/
		
			// extend some methods to check for elem.attr, which means it is a Highcharts SVG object
			$.each(['cur', '_default', 'width', 'height', 'opacity'], function (i, fn) {
				var obj = Fx.step,
					base;
					
				// Handle different parent objects
				if (fn === 'cur') {
					obj = Fx.prototype; // 'cur', the getter, relates to Fx.prototype
				
				} else if (fn === '_default' && $.Tween) { // jQuery 1.8 model
					obj = $.Tween.propHooks[fn];
					fn = 'set';
				}
		
				// Overwrite the method
				base = obj[fn];
				if (base) { // step.width and step.height don't exist in jQuery < 1.7
		
					// create the extended function replacement
					obj[fn] = function (fx) {

						var elem;
						
						// Fx.prototype.cur does not use fx argument
						fx = i ? fx : this;

						// Don't run animations on textual properties like align (#1821)
						if (fx.prop === 'align') {
							return;
						}
		
						// shortcut
						elem = fx.elem;
		
						// Fx.prototype.cur returns the current value. The other ones are setters
						// and returning a value has no effect.
						return elem.attr ? // is SVG element wrapper
							elem.attr(fx.prop, fn === 'cur' ? UNDEFINED : fx.now) : // apply the SVG wrapper's method
							base.apply(this, arguments); // use jQuery's built-in method
					};
				}
			});

			// Extend the opacity getter, needed for fading opacity with IE9 and jQuery 1.10+
			wrap($.cssHooks.opacity, 'get', function (proceed, elem, computed) {
				return elem.attr ? (elem.opacity || 0) : proceed.call(this, elem, computed);
			});
			
			// Define the setter function for d (path definitions)
			this.addAnimSetter('d', function (fx) {
				var elem = fx.elem,
					ends;
		
				// Normally start and end should be set in state == 0, but sometimes,
				// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
				// in these cases
				if (!fx.started) {
					ends = pathAnim.init(elem, elem.d, elem.toD);
					fx.start = ends[0];
					fx.end = ends[1];
					fx.started = true;
				}
		
				// Interpolate each value of the path
				elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
			});
			
			/**
			 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
			 * @param {Array} arr
			 * @param {Function} fn
			 */
			this.each = Array.prototype.forEach ?
				function (arr, fn) { // modern browsers
					return Array.prototype.forEach.call(arr, fn);
					
				} : 
				function (arr, fn) { // legacy
					var i, 
						len = arr.length;
					for (i = 0; i < len; i++) {
						if (fn.call(arr[i], arr[i], i, arr) === false) {
							return i;
						}
					}
				};
			
			/**
			 * Register Highcharts as a plugin in the respective framework
			 */
			$.fn.highcharts = function () {
				var constr = 'Chart', // default constructor
					args = arguments,
					options,
					ret,
					chart;

				if (this[0]) {

					if (isString(args[0])) {
						constr = args[0];
						args = Array.prototype.slice.call(args, 1); 
					}
					options = args[0];

					// Create the chart
					if (options !== UNDEFINED) {
						/*jslint unused:false*/
						options.chart = options.chart || {};
						options.chart.renderTo = this[0];
						chart = new Highcharts[constr](options, args[1]);
						ret = this;
						/*jslint unused:true*/
					}

					// When called without parameters or with the return argument, get a predefined chart
					if (options === UNDEFINED) {
						ret = charts[attr(this[0], 'data-highcharts-chart')];
					}
				}
				
				return ret;
			};

		},

		/**
		 * Add an animation setter for a specific property
		 */
		addAnimSetter: function (prop, setter) {
			// jQuery 1.8 style
			if ($.Tween) {
				$.Tween.propHooks[prop] = {
					set: setter
				};
			// pre 1.8
			} else {
				$.fx.step[prop] = setter;
			}
		},
		
		/**
		 * Downloads a script and executes a callback when done.
		 * @param {String} scriptLocation
		 * @param {Function} callback
		 */
		getScript: $.getScript,
		
		/**
		 * Return the index of an item in an array, or -1 if not found
		 */
		inArray: $.inArray,
		
		/**
		 * A direct link to jQuery methods. MooTools and Prototype adapters must be implemented for each case of method.
		 * @param {Object} elem The HTML element
		 * @param {String} method Which method to run on the wrapped element
		 */
		adapterRun: function (elem, method) {
			return $(elem)[method]();
		},
	
		/**
		 * Filter an array
		 */
		grep: $.grep,
	
		/**
		 * Map an array
		 * @param {Array} arr
		 * @param {Function} fn
		 */
		map: function (arr, fn) {
			//return jQuery.map(arr, fn);
			var results = [],
				i = 0,
				len = arr.length;
			for (; i < len; i++) {
				results[i] = fn.call(arr[i], arr[i], i, arr);
			}
			return results;
	
		},
	
		/**
		 * Get the position of an element relative to the top left of the page
		 */
		offset: function (el) {
			return $(el).offset();
		},
	
		/**
		 * Add an event listener
		 * @param {Object} el A HTML element or custom object
		 * @param {String} event The event type
		 * @param {Function} fn The event handler
		 */
		addEvent: function (el, event, fn) {
			$(el).bind(event, fn);
		},
	
		/**
		 * Remove event added with addEvent
		 * @param {Object} el The object
		 * @param {String} eventType The event type. Leave blank to remove all events.
		 * @param {Function} handler The function to remove
		 */
		removeEvent: function (el, eventType, handler) {
			// workaround for jQuery issue with unbinding custom events:
			// http://forum.jQuery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jQuery-1-4-2
			var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
			if (doc[func] && el && !el[func]) {
				el[func] = function () {};
			}
	
			$(el).unbind(eventType, handler);
		},
	
		/**
		 * Fire an event on a custom object
		 * @param {Object} el
		 * @param {String} type
		 * @param {Object} eventArguments
		 * @param {Function} defaultFunction
		 */
		fireEvent: function (el, type, eventArguments, defaultFunction) {
			var event = $.Event(type),
				detachedType = 'detached' + type,
				defaultPrevented;
	
			// Remove warnings in Chrome when accessing returnValue (#2790), layerX and layerY. Although Highcharts
			// never uses these properties, Chrome includes them in the default click event and
			// raises the warning when they are copied over in the extend statement below.
			//
			// To avoid problems in IE (see #1010) where we cannot delete the properties and avoid
			// testing if they are there (warning in chrome) the only option is to test if running IE.
			if (!isMS && eventArguments) {
				delete eventArguments.layerX;
				delete eventArguments.layerY;
				delete eventArguments.returnValue;
			}
	
			extend(event, eventArguments);
	
			// Prevent jQuery from triggering the object method that is named the
			// same as the event. For example, if the event is 'select', jQuery
			// attempts calling el.select and it goes into a loop.
			if (el[type]) {
				el[detachedType] = el[type];
				el[type] = null;
			}
	
			// Wrap preventDefault and stopPropagation in try/catch blocks in
			// order to prevent JS errors when cancelling events on non-DOM
			// objects. #615.
			/*jslint unparam: true*/
			$.each(['preventDefault', 'stopPropagation'], function (i, fn) {
				var base = event[fn];
				event[fn] = function () {
					try {
						base.call(event);
					} catch (e) {
						if (fn === 'preventDefault') {
							defaultPrevented = true;
						}
					}
				};
			});
			/*jslint unparam: false*/
	
			// trigger it
			$(el).trigger(event);
	
			// attach the method
			if (el[detachedType]) {
				el[type] = el[detachedType];
				el[detachedType] = null;
			}
	
			if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {
				defaultFunction(event);
			}
		},
		
		/**
		 * Extension method needed for MooTools
		 */
		washMouseEvent: function (e) {
			var ret = e.originalEvent || e;
			
			// computed by jQuery, needed by IE8
			if (ret.pageX === UNDEFINED) { // #1236
				ret.pageX = e.pageX;
				ret.pageY = e.pageY;
			}
			
			return ret;
		},
	
		/**
		 * Animate a HTML element or SVG element wrapper
		 * @param {Object} el
		 * @param {Object} params
		 * @param {Object} options jQuery-like animation options: duration, easing, callback
		 */
		animate: function (el, params, options) {
			var $el = $(el);
			if (!el.style) {
				el.style = {}; // #1881
			}
			if (params.d) {
				el.toD = params.d; // keep the array form for paths, used in $.fx.step.d
				params.d = 1; // because in jQuery, animating to an array has a different meaning
			}
	
			$el.stop();
			if (params.opacity !== UNDEFINED && el.attr) {
				params.opacity += 'px'; // force jQuery to use same logic as width and height (#2161)
			}
			el.hasAnim = 1; // #3342
			$el.animate(params, options);
	
		},
		/**
		 * Stop running animation
		 */
		stop: function (el) {
			if (el.hasAnim) { // #3342, memory leak on calling $(el) from destroy
				$(el).stop();
			}
		}
	});
}(win.jQuery));


// check for a custom HighchartsAdapter defined prior to this file
var globalAdapter = win.HighchartsAdapter,
	adapter = globalAdapter || {};
	
// Initialize the adapter
if (globalAdapter) {
	globalAdapter.init.call(globalAdapter, pathAnim);
}


// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
// and all the utility functions will be null. In that case they are populated by the
// default adapters below.
var adapterRun = adapter.adapterRun,
	getScript = adapter.getScript,
	inArray = adapter.inArray,
	each = Highcharts.each = adapter.each,
	grep = adapter.grep,
	offset = adapter.offset,
	map = adapter.map,
	addEvent = adapter.addEvent,
	removeEvent = adapter.removeEvent,
	fireEvent = adapter.fireEvent,
	washMouseEvent = adapter.washMouseEvent,
	animate = adapter.animate,
	stop = adapter.stop;



/* ****************************************************************************
 * Handle the options                                                         *
 *****************************************************************************/
defaultOptions = {
	colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c', 
		    '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],
	symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
	lang: {
		loading: 'Loading...',
		months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
				'August', 'September', 'October', 'November', 'December'],
		shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		// invalidDate: '',
		decimalPoint: '.',
		numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels
		resetZoom: 'Reset zoom',
		resetZoomTitle: 'Reset zoom level 1:1',
		thousandsSep: ' '
	},
	global: {
		useUTC: true,
		//timezoneOffset: 0,
		canvasToolsURL: 'http://code.highcharts.com/4.1.9/modules/canvas-tools.js',
		VMLRadialGradientURL: 'http://code.highcharts.com/4.1.9/gfx/vml-radial-gradient.png'
	},
	chart: {
		//animation: true,
		//alignTicks: false,
		//reflow: true,
		//className: null,
		//events: { load, selection },
		//margin: [null],
		//marginTop: null,
		//marginRight: null,
		//marginBottom: null,
		//marginLeft: null,
		borderColor: '#4572A7',
		//borderWidth: 0,
		borderRadius: 0,
		defaultSeriesType: 'line',
		ignoreHiddenSeries: true,
		//inverted: false,
		//shadow: false,
		spacing: [10, 10, 15, 10],
		//spacingTop: 10,
		//spacingRight: 10,
		//spacingBottom: 15,
		//spacingLeft: 10,
		//style: {
		//	fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
		//	fontSize: '12px'
		//},
		backgroundColor: '#FFFFFF',
		//plotBackgroundColor: null,
		plotBorderColor: '#C0C0C0',
		//plotBorderWidth: 0,
		//plotShadow: false,
		//zoomType: ''
		resetZoomButton: {
			theme: {
				zIndex: 20
			},
			position: {
				align: 'right',
				x: -10,
				//verticalAlign: 'top',
				y: 10
			}
			// relativeTo: 'plot'
		}
	},
	title: {
		text: 'Chart title',
		align: 'center',
		// floating: false,
		margin: 15,
		// x: 0,
		// verticalAlign: 'top',
		// y: null,
		style: {
			color: '#333333',
			fontSize: '18px'
		}

	},
	subtitle: {
		text: '',
		align: 'center',
		// floating: false
		// x: 0,
		// verticalAlign: 'top',
		// y: null,
		style: {
			color: '#555555'
		}
	},

	plotOptions: {
		line: { // base series options
			allowPointSelect: false,
			showCheckbox: false,
			animation: {
				duration: 1000
			},
			//connectNulls: false,
			//cursor: 'default',
			//clip: true,
			//dashStyle: null,
			//enableMouseTracking: true,
			events: {},
			//legendIndex: 0,
			//linecap: 'round',
			lineWidth: 2,
			//shadow: false,
			// stacking: null,
			marker: {
				//enabled: true,
				//symbol: null,
				lineWidth: 0,
				radius: 4,
				lineColor: '#FFFFFF',
				//fillColor: null,
				states: { // states for a single point
					hover: {
						enabled: true,
						lineWidthPlus: 1,
						radiusPlus: 2
					},
					select: {
						fillColor: '#FFFFFF',
						lineColor: '#000000',
						lineWidth: 2
					}
				}
			},
			point: {
				events: {}
			},
			dataLabels: {
				align: 'center',
				// defer: true,
				// enabled: false,
				formatter: function () {
					return this.y === null ? '' : Highcharts.numberFormat(this.y, -1);
				},
				style: {
					color: 'contrast',
					fontSize: '11px',
					fontWeight: 'bold',
					textShadow: '0 0 6px contrast, 0 0 3px contrast'
				},
				verticalAlign: 'bottom', // above singular point
				x: 0,
				y: 0,
				// backgroundColor: undefined,
				// borderColor: undefined,
				// borderRadius: undefined,
				// borderWidth: undefined,
				padding: 5
				// shadow: false
			},
			cropThreshold: 300, // draw points outside the plot area when the number of points is less than this
			pointRange: 0,
			//pointStart: 0,
			//pointInterval: 1,
			//showInLegend: null, // auto: true for standalone series, false for linked series
			softThreshold: true,
			states: { // states for the entire series
				hover: {
					//enabled: false,
					lineWidthPlus: 1,
					marker: {
						// lineWidth: base + 1,
						// radius: base + 1
					},
					halo: {
						size: 10,
						opacity: 0.25
					}
				},
				select: {
					marker: {}
				}
			},
			stickyTracking: true,
			//tooltip: {
				//pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b>'
				//valueDecimals: null,
				//xDateFormat: '%A, %b %e, %Y',
				//valuePrefix: '',
				//ySuffix: ''				
			//}
			turboThreshold: 1000
			// zIndex: null
		}
	},
	labels: {
		//items: [],
		style: {
			//font: defaultFont,
			position: ABSOLUTE,
			color: '#3E576F'
		}
	},
	legend: {
		enabled: true,
		align: 'center',
		//floating: false,
		layout: 'horizontal',
		labelFormatter: function () {
			return this.name;
		},
		//borderWidth: 0,
		borderColor: '#909090',
		borderRadius: 0,
		navigation: {
			// animation: true,
			activeColor: '#274b6d',
			// arrowSize: 12
			inactiveColor: '#CCC'
			// style: {} // text styles
		},
		// margin: 20,
		// reversed: false,
		shadow: false,
		// backgroundColor: null,
		/*style: {
			padding: '5px'
		},*/
		itemStyle: {			
			color: '#333333',
			fontSize: '12px',
			fontWeight: 'bold'
		},
		itemHoverStyle: {
			//cursor: 'pointer', removed as of #601
			color: '#000'
		},
		itemHiddenStyle: {
			color: '#CCC'
		},
		itemCheckboxStyle: {
			position: ABSOLUTE,
			width: '13px', // for IE precision
			height: '13px'
		},
		// itemWidth: undefined,
		// symbolRadius: 0,
		// symbolWidth: 16,
		symbolPadding: 5,
		verticalAlign: 'bottom',
		// width: undefined,
		x: 0,
		y: 0,
		title: {
			//text: null,
			style: {
				fontWeight: 'bold'
			}
		}			
	},

	loading: {
		// hideDuration: 100,
		labelStyle: {
			fontWeight: 'bold',
			position: RELATIVE,
			top: '45%'
		},
		// showDuration: 0,
		style: {
			position: ABSOLUTE,
			backgroundColor: 'white',
			opacity: 0.5,
			textAlign: 'center'
		}
	},

	tooltip: {
		enabled: true,
		animation: hasSVG,
		//crosshairs: null,
		backgroundColor: 'rgba(249, 249, 249, .85)',
		borderWidth: 1,
		borderRadius: 3,
		dateTimeLabelFormats: { 
			millisecond: '%A, %b %e, %H:%M:%S.%L',
			second: '%A, %b %e, %H:%M:%S',
			minute: '%A, %b %e, %H:%M',
			hour: '%A, %b %e, %H:%M',
			day: '%A, %b %e, %Y',
			week: 'Week from %A, %b %e, %Y',
			month: '%B %Y',
			year: '%Y'
		},
		footerFormat: '',
		//formatter: defaultFormatter,
		headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
		pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
		shadow: true,
		//shape: 'callout',
		//shared: false,
		snap: isTouchDevice ? 25 : 10,
		style: {
			color: '#333333',
			cursor: 'default',
			fontSize: '12px',
			padding: '8px',
			pointerEvents: 'none', // #1686 http://caniuse.com/#feat=pointer-events
			whiteSpace: 'nowrap'
		}
		//xDateFormat: '%A, %b %e, %Y',
		//valueDecimals: null,
		//valuePrefix: '',
		//valueSuffix: ''
	},

	credits: {
		enabled: true,
		text: 'Highcharts.com',
		href: 'http://www.highcharts.com',
		position: {
			align: 'right',
			x: -10,
			verticalAlign: 'bottom',
			y: -5
		},
		style: {
			cursor: 'pointer',
			color: '#909090',
			fontSize: '9px'
		}
	}
};




// Series defaults
var defaultPlotOptions = defaultOptions.plotOptions,
	defaultSeriesOptions = defaultPlotOptions.line;

// set the default time methods
setTimeMethods();



/**
 * Set the time methods globally based on the useUTC option. Time method can be either
 * local time or UTC (default).
 */
function setTimeMethods() {
	var globalOptions = defaultOptions.global,
		useUTC = globalOptions.useUTC,
		GET = useUTC ? 'getUTC' : 'get',
		SET = useUTC ? 'setUTC' : 'set';


	Date = globalOptions.Date || window.Date;
	timezoneOffset = useUTC && globalOptions.timezoneOffset;
	getTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;
	makeTime = function (year, month, date, hours, minutes, seconds) {
		var d;
		if (useUTC) {
			d = Date.UTC.apply(0, arguments);
			d += getTZOffset(d);
		} else {
			d = new Date(
				year,
				month,
				pick(date, 1),
				pick(hours, 0),
				pick(minutes, 0),
				pick(seconds, 0)
			).getTime();
		}
		return d;
	};
	getMinutes =      GET + 'Minutes';
	getHours =        GET + 'Hours';
	getDay =          GET + 'Day';
	getDate =         GET + 'Date';
	getMonth =        GET + 'Month';
	getFullYear =     GET + 'FullYear';
	setMilliseconds = SET + 'Milliseconds';
	setSeconds =      SET + 'Seconds';
	setMinutes =      SET + 'Minutes';
	setHours =        SET + 'Hours';
	setDate =         SET + 'Date';
	setMonth =        SET + 'Month';
	setFullYear =     SET + 'FullYear';

}

/**
 * Merge the default options with custom options and return the new options structure
 * @param {Object} options The new custom options
 */
function setOptions(options) {
	
	// Copy in the default options
	defaultOptions = merge(true, defaultOptions, options);
	
	// Apply UTC
	setTimeMethods();

	return defaultOptions;
}

/**
 * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules
 * wasn't enough because the setOptions method created a new object.
 */
function getOptions() {
	return defaultOptions;
}


/**
 * Handle color operations. The object methods are chainable.
 * @param {String} input The input color in either rbga or hex format
 */
var rgbaRegEx = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
	hexRegEx = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
	rgbRegEx = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/;

var Color = function (input) {
	// declare variables
	var rgba = [], result, stops;

	/**
	 * Parse the input color to rgba array
	 * @param {String} input
	 */
	function init(input) {

		// Gradients
		if (input && input.stops) {
			stops = map(input.stops, function (stop) {
				return Color(stop[1]);
			});

		// Solid colors
		} else {
			// rgba
			result = rgbaRegEx.exec(input);
			if (result) {
				rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
			} else { 
				// hex
				result = hexRegEx.exec(input);
				if (result) {
					rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
				} else {
					// rgb
					result = rgbRegEx.exec(input);
					if (result) {
						rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
					}
				}
			}
		}		

	}
	/**
	 * Return the color a specified format
	 * @param {String} format
	 */
	function get(format) {
		var ret;

		if (stops) {
			ret = merge(input);
			ret.stops = [].concat(ret.stops);
			each(stops, function (stop, i) {
				ret.stops[i] = [ret.stops[i][0], stop.get(format)];
			});

		// it's NaN if gradient colors on a column chart
		} else if (rgba && !isNaN(rgba[0])) {
			if (format === 'rgb') {
				ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
			} else if (format === 'a') {
				ret = rgba[3];
			} else {
				ret = 'rgba(' + rgba.join(',') + ')';
			}
		} else {
			ret = input;
		}
		return ret;
	}

	/**
	 * Brighten the color
	 * @param {Number} alpha
	 */
	function brighten(alpha) {
		if (stops) {
			each(stops, function (stop) {
				stop.brighten(alpha);
			});
		
		} else if (isNumber(alpha) && alpha !== 0) {
			var i;
			for (i = 0; i < 3; i++) {
				rgba[i] += pInt(alpha * 255);

				if (rgba[i] < 0) {
					rgba[i] = 0;
				}
				if (rgba[i] > 255) {
					rgba[i] = 255;
				}
			}
		}
		return this;
	}
	/**
	 * Set the color's opacity to a given alpha value
	 * @param {Number} alpha
	 */
	function setOpacity(alpha) {
		rgba[3] = alpha;
		return this;
	}

	// initialize: parse the input
	init(input);

	// public methods
	return {
		get: get,
		brighten: brighten,
		rgba: rgba,
		setOpacity: setOpacity,
		raw: input
	};
};


/**
 * A wrapper object for SVG elements
 */
function SVGElement() {}

SVGElement.prototype = {
	
	// Default base for animation
	opacity: 1,
	// For labels, these CSS properties are applied to the <text> node directly
	textProps: ['fontSize', 'fontWeight', 'fontFamily', 'fontStyle', 'color', 
		'lineHeight', 'width', 'textDecoration', 'textOverflow', 'textShadow'],
	
	/**
	 * Initialize the SVG renderer
	 * @param {Object} renderer
	 * @param {String} nodeName
	 */
	init: function (renderer, nodeName) {
		var wrapper = this;
		wrapper.element = nodeName === 'span' ?
			createElement(nodeName) :
			doc.createElementNS(SVG_NS, nodeName);
		wrapper.renderer = renderer;
	},
	
	/**
	 * Animate a given attribute
	 * @param {Object} params
	 * @param {Number} options The same options as in jQuery animation
	 * @param {Function} complete Function to perform at the end of animation
	 */
	animate: function (params, options, complete) {
		var animOptions = pick(options, this.renderer.globalAnimation, true);
		stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)
		if (animOptions) {
			animOptions = merge(animOptions, {}); //#2625
			if (complete) { // allows using a callback with the global animation without overwriting it
				animOptions.complete = complete;
			}
			animate(this, params, animOptions);
		} else {
			this.attr(params, null, complete);
		}
		return this;
	},

	/**
	 * Build an SVG gradient out of a common JavaScript configuration object
	 */
	colorGradient: function (color, prop, elem) {
		var renderer = this.renderer,
			colorObject,
			gradName,
			gradAttr,
			radAttr,
			gradients,
			gradientObject,
			stops,
			stopColor,
			stopOpacity,
			radialReference,
			n,
			id,
			key = [];

		// Apply linear or radial gradients
		if (color.linearGradient) {
			gradName = 'linearGradient';
		} else if (color.radialGradient) {
			gradName = 'radialGradient';
		}

		if (gradName) {
			gradAttr = color[gradName];
			gradients = renderer.gradients;
			stops = color.stops;
			radialReference = elem.radialReference;

			// Keep < 2.2 kompatibility
			if (isArray(gradAttr)) {
				color[gradName] = gradAttr = {
					x1: gradAttr[0],
					y1: gradAttr[1],
					x2: gradAttr[2],
					y2: gradAttr[3],
					gradientUnits: 'userSpaceOnUse'
				};
			}

			// Correct the radial gradient for the radial reference system
			if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {
				radAttr = gradAttr; // Save the radial attributes for updating
				gradAttr = merge(gradAttr, 
					renderer.getRadialAttr(radialReference, radAttr),
					{ gradientUnits: 'userSpaceOnUse' }
				);
			}

			// Build the unique key to detect whether we need to create a new element (#1282)
			for (n in gradAttr) {
				if (n !== 'id') {
					key.push(n, gradAttr[n]);
				}
			}
			for (n in stops) {
				key.push(stops[n]);
			}
			key = key.join(',');

			// Check if a gradient object with the same config object is created within this renderer
			if (gradients[key]) {
				id = gradients[key].attr('id');

			} else {

				// Set the id and create the element
				gradAttr.id = id = PREFIX + idCounter++;
				gradients[key] = gradientObject = renderer.createElement(gradName)
					.attr(gradAttr)
					.add(renderer.defs);

				gradientObject.radAttr = radAttr;

				// The gradient needs to keep a list of stops to be able to destroy them
				gradientObject.stops = [];
				each(stops, function (stop) {
					var stopObject;
					if (stop[1].indexOf('rgba') === 0) {
						colorObject = Color(stop[1]);
						stopColor = colorObject.get('rgb');
						stopOpacity = colorObject.get('a');
					} else {
						stopColor = stop[1];
						stopOpacity = 1;
					}
					stopObject = renderer.createElement('stop').attr({
						offset: stop[0],
						'stop-color': stopColor,
						'stop-opacity': stopOpacity
					}).add(gradientObject);

					// Add the stop element to the gradient
					gradientObject.stops.push(stopObject);
				});
			}

			// Set the reference to the gradient object
			elem.setAttribute(prop, 'url(' + renderer.url + '#' + id + ')');
			elem.gradient = key;
		} 
	},

	/**
	 * Apply a polyfill to the text-stroke CSS property, by copying the text element
	 * and apply strokes to the copy.
	 *
	 * Contrast checks at http://jsfiddle.net/highcharts/43soe9m1/2/
	 *
	 * docs: update default, document the polyfill and the limitations on hex colors and pixel values, document contrast pseudo-color
	 */
	applyTextShadow: function (textShadow) {
		var elem = this.element,
			tspans,
			hasContrast = textShadow.indexOf('contrast') !== -1,
			styles = {},
			forExport = this.renderer.forExport,
			// IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check
			// this again with new IE release. In exports, the rendering is passed to PhantomJS. 
			supports = forExport || (elem.style.textShadow !== UNDEFINED && !isMS);

		// When the text shadow is set to contrast, use dark stroke for light text and vice versa
		if (hasContrast) {
			styles.textShadow = textShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
		}

		// Safari with retina displays as well as PhantomJS bug (#3974). Firefox does not tolerate this,
		// it removes the text shadows.
		if (isWebKit || forExport) {
			styles.textRendering = 'geometricPrecision';
		}

		/* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)
		if (elem.textContent.indexOf('2.') === 0) {
			elem.style['text-shadow'] = 'none';
			supports = false;
		}
		// */

		// No reason to polyfill, we've got native support
		if (supports) {
			this.css(styles); // Apply altered textShadow or textRendering workaround
		} else {

			this.fakeTS = true; // Fake text shadow

			// In order to get the right y position of the clones, 
			// copy over the y setter
			this.ySetter = this.xSetter;

			tspans = [].slice.call(elem.getElementsByTagName('tspan'));
			each(textShadow.split(/\s?,\s?/g), function (textShadow) {
				var firstChild = elem.firstChild,
					color,
					strokeWidth;
				
				textShadow = textShadow.split(' ');
				color = textShadow[textShadow.length - 1];

				// Approximately tune the settings to the text-shadow behaviour
				strokeWidth = textShadow[textShadow.length - 2];

				if (strokeWidth) {
					each(tspans, function (tspan, y) {
						var clone;

						// Let the first line start at the correct X position
						if (y === 0) {
							tspan.setAttribute('x', elem.getAttribute('x'));
							y = elem.getAttribute('y');
							tspan.setAttribute('y', y || 0);
							if (y === null) {
								elem.setAttribute('y', 0);
							}
						}

						// Create the clone and apply shadow properties
						clone = tspan.cloneNode(1);
						attr(clone, {
							'class': PREFIX + 'text-shadow',
							'fill': color,
							'stroke': color,
							'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),
							'stroke-width': strokeWidth,
							'stroke-linejoin': 'round'
						});
						elem.insertBefore(clone, firstChild);
					});
				}
			});
		}
	},

	/**
	 * Set or get a given attribute
	 * @param {Object|String} hash
	 * @param {Mixed|Undefined} val
	 */
	attr: function (hash, val, complete) {
		var key,
			value,
			element = this.element,
			hasSetSymbolSize,
			ret = this,
			skipAttr;

		// single key-value pair
		if (typeof hash === 'string' && val !== UNDEFINED) {
			key = hash;
			hash = {};
			hash[key] = val;
		}

		// used as a getter: first argument is a string, second is undefined
		if (typeof hash === 'string') {
			ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);
		
		// setter
		} else {

			for (key in hash) {
				value = hash[key];
				skipAttr = false;



				if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {
					if (!hasSetSymbolSize) {
						this.symbolAttr(hash);
						hasSetSymbolSize = true;
					}
					skipAttr = true;
				}

				if (this.rotation && (key === 'x' || key === 'y')) {
					this.doTransform = true;
				}
				
				if (!skipAttr) {
					(this[key + 'Setter'] || this._defaultSetter).call(this, value, key, element);
				}

				// Let the shadow follow the main element
				if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
					this.updateShadows(key, value);
				}
			}

			// Update transform. Do this outside the loop to prevent redundant updating for batch setting
			// of attributes.
			if (this.doTransform) {
				this.updateTransform();
				this.doTransform = false;
			}

		}

		// In accordance with animate, run a complete callback
		if (complete) {
			complete();
		}

		return ret;
	},

	updateShadows: function (key, value) {
		var shadows = this.shadows,
			i = shadows.length;
		while (i--) {
			shadows[i].setAttribute(
				key,
				key === 'height' ?
					mathMax(value - (shadows[i].cutHeight || 0), 0) :
					key === 'd' ? this.d : value
			);
		}
	},

	/**
	 * Add a class name to an element
	 */
	addClass: function (className) {
		var element = this.element,
			currentClassName = attr(element, 'class') || '';

		if (currentClassName.indexOf(className) === -1) {
			attr(element, 'class', currentClassName + ' ' + className);
		}
		return this;
	},
	/* hasClass and removeClass are not (yet) needed
	hasClass: function (className) {
		return attr(this.element, 'class').indexOf(className) !== -1;
	},
	removeClass: function (className) {
		attr(this.element, 'class', attr(this.element, 'class').replace(className, ''));
		return this;
	},
	*/

	/**
	 * If one of the symbol size affecting parameters are changed,
	 * check all the others only once for each call to an element's
	 * .attr() method
	 * @param {Object} hash
	 */
	symbolAttr: function (hash) {
		var wrapper = this;

		each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {
			wrapper[key] = pick(hash[key], wrapper[key]);
		});

		wrapper.attr({
			d: wrapper.renderer.symbols[wrapper.symbolName](
				wrapper.x,
				wrapper.y,
				wrapper.width,
				wrapper.height,
				wrapper
			)
		});
	},

	/**
	 * Apply a clipping path to this object
	 * @param {String} id
	 */
	clip: function (clipRect) {
		return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);
	},

	/**
	 * Calculate the coordinates needed for drawing a rectangle crisply and return the
	 * calculated attributes
	 * @param {Number} strokeWidth
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	crisp: function (rect) {

		var wrapper = this,
			key,
			attribs = {},
			normalizer,
			strokeWidth = rect.strokeWidth || wrapper.strokeWidth || 0;

		normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors

		// normalize for crisp edges
		rect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;
		rect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;
		rect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);
		rect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);
		rect.strokeWidth = strokeWidth;

		for (key in rect) {
			if (wrapper[key] !== rect[key]) { // only set attribute if changed
				wrapper[key] = attribs[key] = rect[key];
			}
		}

		return attribs;
	},

	/**
	 * Set styles for the element
	 * @param {Object} styles
	 */
	css: function (styles) {
		var elemWrapper = this,
			oldStyles = elemWrapper.styles,
			newStyles = {},
			elem = elemWrapper.element,
			textWidth,
			n,
			serializedCss = '',
			hyphenate,
			hasNew = !oldStyles;

		// convert legacy
		if (styles && styles.color) {
			styles.fill = styles.color;
		}

		// Filter out existing styles to increase performance (#2640)
		if (oldStyles) {
			for (n in styles) {
				if (styles[n] !== oldStyles[n]) {
					newStyles[n] = styles[n];
					hasNew = true;
				}
			}
		}
		if (hasNew) {
			textWidth = elemWrapper.textWidth = 
				(styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) || 
				elemWrapper.textWidth; // #3501

			// Merge the new styles with the old ones
			if (oldStyles) {
				styles = extend(
					oldStyles,
					newStyles
				);
			}		

			// store object
			elemWrapper.styles = styles;

			if (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {
				delete styles.width;
			}

			// serialize and set style attribute
			if (isMS && !hasSVG) {
				css(elemWrapper.element, styles);
			} else {
				/*jslint unparam: true*/
				hyphenate = function (a, b) { return '-' + b.toLowerCase(); };
				/*jslint unparam: false*/
				for (n in styles) {
					serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';
				}
				attr(elem, 'style', serializedCss); // #1881
			}


			// re-build text
			if (textWidth && elemWrapper.added) {
				elemWrapper.renderer.buildText(elemWrapper);
			}
		}

		return elemWrapper;
	},

	/**
	 * Add an event listener
	 * @param {String} eventType
	 * @param {Function} handler
	 */
	on: function (eventType, handler) {
		var svgElement = this,
			element = svgElement.element;
		
		// touch
		if (hasTouch && eventType === 'click') {
			element.ontouchstart = function (e) {			
				svgElement.touchEventFired = Date.now();				
				e.preventDefault();
				handler.call(element, e);
			};
			element.onclick = function (e) {												
				if (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269
					handler.call(element, e);
				}
			};			
		} else {
			// simplest possible event model for internal use
			element['on' + eventType] = handler;
		}
		return this;
	},

	/**
	 * Set the coordinates needed to draw a consistent radial gradient across
	 * pie slices regardless of positioning inside the chart. The format is
	 * [centerX, centerY, diameter] in pixels.
	 */
	setRadialReference: function (coordinates) {
		var existingGradient = this.renderer.gradients[this.element.gradient];

		this.element.radialReference = coordinates;
		
		// On redrawing objects with an existing gradient, the gradient needs
		// to be repositioned (#3801)
		if (existingGradient && existingGradient.radAttr) {
			existingGradient.animate(
				this.renderer.getRadialAttr(
					coordinates, 
					existingGradient.radAttr
				)
			);
		}

		return this;
	},

	/**
	 * Move an object and its children by x and y values
	 * @param {Number} x
	 * @param {Number} y
	 */
	translate: function (x, y) {
		return this.attr({
			translateX: x,
			translateY: y
		});
	},

	/**
	 * Invert a group, rotate and flip
	 */
	invert: function () {
		var wrapper = this;
		wrapper.inverted = true;
		wrapper.updateTransform();
		return wrapper;
	},

	/**
	 * Private method to update the transform attribute based on internal
	 * properties
	 */
	updateTransform: function () {
		var wrapper = this,
			translateX = wrapper.translateX || 0,
			translateY = wrapper.translateY || 0,
			scaleX = wrapper.scaleX,
			scaleY = wrapper.scaleY,
			inverted = wrapper.inverted,
			rotation = wrapper.rotation,
			element = wrapper.element,
			transform;

		// flipping affects translate as adjustment for flipping around the group's axis
		if (inverted) {
			translateX += wrapper.attr('width');
			translateY += wrapper.attr('height');
		}

		// Apply translate. Nearly all transformed elements have translation, so instead
		// of checking for translate = 0, do it always (#1767, #1846).
		transform = ['translate(' + translateX + ',' + translateY + ')'];

		// apply rotation
		if (inverted) {
			transform.push('rotate(90) scale(-1,1)');
		} else if (rotation) { // text rotation
			transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');
			
			// Delete bBox memo when the rotation changes
			//delete wrapper.bBox;
		}

		// apply scale
		if (defined(scaleX) || defined(scaleY)) {
			transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');
		}

		if (transform.length) {
			element.setAttribute('transform', transform.join(' '));
		}
	},
	/**
	 * Bring the element to the front
	 */
	toFront: function () {
		var element = this.element;
		element.parentNode.appendChild(element);
		return this;
	},


	/**
	 * Break down alignment options like align, verticalAlign, x and y
	 * to x and y relative to the chart.
	 *
	 * @param {Object} alignOptions
	 * @param {Boolean} alignByTranslate
	 * @param {String[Object} box The box to align to, needs a width and height. When the
	 *		box is a string, it refers to an object in the Renderer. For example, when
	 *		box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height
	 *		x and y properties.
	 *
	 */
	align: function (alignOptions, alignByTranslate, box) {
		var align,
			vAlign,
			x,
			y,
			attribs = {},
			alignTo,
			renderer = this.renderer,
			alignedObjects = renderer.alignedObjects;

		// First call on instanciate
		if (alignOptions) {
			this.alignOptions = alignOptions;
			this.alignByTranslate = alignByTranslate;
			if (!box || isString(box)) { // boxes other than renderer handle this internally
				this.alignTo = alignTo = box || 'renderer';
				erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize
				alignedObjects.push(this);
				box = null; // reassign it below
			}

		// When called on resize, no arguments are supplied
		} else {
			alignOptions = this.alignOptions;
			alignByTranslate = this.alignByTranslate;
			alignTo = this.alignTo;
		}

		box = pick(box, renderer[alignTo], renderer);

		// Assign variables
		align = alignOptions.align;
		vAlign = alignOptions.verticalAlign;
		x = (box.x || 0) + (alignOptions.x || 0); // default: left align
		y = (box.y || 0) + (alignOptions.y || 0); // default: top align

		// Align
		if (align === 'right' || align === 'center') {
			x += (box.width - (alignOptions.width || 0)) /
					{ right: 1, center: 2 }[align];
		}
		attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);


		// Vertical align
		if (vAlign === 'bottom' || vAlign === 'middle') {
			y += (box.height - (alignOptions.height || 0)) /
					({ bottom: 1, middle: 2 }[vAlign] || 1);

		}
		attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);

		// Animate only if already placed
		this[this.placed ? 'animate' : 'attr'](attribs);
		this.placed = true;
		this.alignAttr = attribs;

		return this;
	},

	/**
	 * Get the bounding box (width, height, x and y) for the element
	 */
	getBBox: function (reload) {
		var wrapper = this,
			bBox,// = wrapper.bBox,
			renderer = wrapper.renderer,
			width,
			height,
			rotation = wrapper.rotation,
			element = wrapper.element,
			styles = wrapper.styles,
			rad = rotation * deg2rad,
			textStr = wrapper.textStr,
			textShadow,
			elemStyle = element.style,
			toggleTextShadowShim,
			cacheKey;

		if (textStr !== UNDEFINED) {

			// Properties that affect bounding box
			cacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');

			// Since numbers are monospaced, and numerical labels appear a lot in a chart,
			// we assume that a label of n characters has the same bounding box as others 
			// of the same length.
			if (textStr === '' || numRegex.test(textStr)) {
				cacheKey = 'num:' + textStr.toString().length + cacheKey;

			// Caching all strings reduces rendering time by 4-5%.
			} else {
				cacheKey = textStr + cacheKey;
			}
		}

		if (cacheKey && !reload) {
			bBox = renderer.cache[cacheKey];
		}

		// No cache found
		if (!bBox) {

			// SVG elements
			if (element.namespaceURI === SVG_NS || renderer.forExport) {
				try { // Fails in Firefox if the container has display: none.

					// When the text shadow shim is used, we need to hide the fake shadows
					// to get the correct bounding box (#3872)
					toggleTextShadowShim = this.fakeTS && function (display) {
						each(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {
							tspan.style.display = display;
						});
					};

					// Workaround for #3842, Firefox reporting wrong bounding box for shadows
					if (isFirefox && elemStyle.textShadow) {
						textShadow = elemStyle.textShadow;
						elemStyle.textShadow = '';
					} else if (toggleTextShadowShim) {
						toggleTextShadowShim(NONE);
					}

					bBox = element.getBBox ?
						// SVG: use extend because IE9 is not allowed to change width and height in case
						// of rotation (below)
						extend({}, element.getBBox()) :
						// Canvas renderer and legacy IE in export mode
						{
							width: element.offsetWidth,
							height: element.offsetHeight
						};

					// #3842
					if (textShadow) {
						elemStyle.textShadow = textShadow;
					} else if (toggleTextShadowShim) {
						toggleTextShadowShim('');
					}
				} catch (e) {}

				// If the bBox is not set, the try-catch block above failed. The other condition
				// is for Opera that returns a width of -Infinity on hidden elements.
				if (!bBox || bBox.width < 0) {
					bBox = { width: 0, height: 0 };
				}


			// VML Renderer or useHTML within SVG
			} else {

				bBox = wrapper.htmlGetBBox();

			}

			// True SVG elements as well as HTML elements in modern browsers using the .useHTML option
			// need to compensated for rotation
			if (renderer.isSVG) {
				width = bBox.width;
				height = bBox.height;

				// Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)
				if (isMS && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {
					bBox.height = height = 14;
				}

				// Adjust for rotated text
				if (rotation) {
					bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
					bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
				}
			}

			// Cache it
			if (cacheKey) {
				renderer.cache[cacheKey] = bBox;
			}
		}
		return bBox;
	},

	/**
	 * Show the element
	 */
	show: function (inherit) {
		return this.attr({ visibility: inherit ? 'inherit' : VISIBLE });
	},

	/**
	 * Hide the element
	 */
	hide: function () {
		return this.attr({ visibility: HIDDEN });
	},

	fadeOut: function (duration) {
		var elemWrapper = this;
		elemWrapper.animate({
			opacity: 0
		}, {
			duration: duration || 150,
			complete: function () {
				elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips
			}
		});
	},

	/**
	 * Add the element
	 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
	 *	to append the element to the renderer.box.
	 */
	add: function (parent) {

		var renderer = this.renderer,
			element = this.element,
			inserted;

		if (parent) {
			this.parentGroup = parent;
		}

		// mark as inverted
		this.parentInverted = parent && parent.inverted;

		// build formatted text
		if (this.textStr !== undefined) {
			renderer.buildText(this);
		}

		// Mark as added
		this.added = true;

		// If we're adding to renderer root, or other elements in the group 
		// have a z index, we need to handle it
		if (!parent || parent.handleZ || this.zIndex) {
			inserted = this.zIndexSetter();
		}

		// If zIndex is not handled, append at the end
		if (!inserted) {
			(parent ? parent.element : renderer.box).appendChild(element);
		}

		// fire an event for internal hooks
		if (this.onAdd) {
			this.onAdd();
		}

		return this;
	},

	/**
	 * Removes a child either by removeChild or move to garbageBin.
	 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	 */
	safeRemoveChild: function (element) {
		var parentNode = element.parentNode;
		if (parentNode) {
			parentNode.removeChild(element);
		}
	},

	/**
	 * Destroy the element and element wrapper
	 */
	destroy: function () {
		var wrapper = this,
			element = wrapper.element || {},
			shadows = wrapper.shadows,
			parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,
			grandParent,
			key,
			i;

		// remove events
		element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
		stop(wrapper); // stop running animations

		if (wrapper.clipPath) {
			wrapper.clipPath = wrapper.clipPath.destroy();
		}

		// Destroy stops in case this is a gradient object
		if (wrapper.stops) {
			for (i = 0; i < wrapper.stops.length; i++) {
				wrapper.stops[i] = wrapper.stops[i].destroy();
			}
			wrapper.stops = null;
		}

		// remove element
		wrapper.safeRemoveChild(element);

		// destroy shadows
		if (shadows) {
			each(shadows, function (shadow) {
				wrapper.safeRemoveChild(shadow);
			});
		}

		// In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).
		while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
			grandParent = parentToClean.parentGroup;
			wrapper.safeRemoveChild(parentToClean.div);
			delete parentToClean.div;
			parentToClean = grandParent;
		}

		// remove from alignObjects
		if (wrapper.alignTo) {
			erase(wrapper.renderer.alignedObjects, wrapper);
		}

		for (key in wrapper) {
			delete wrapper[key];
		}

		return null;
	},

	/**
	 * Add a shadow to the element. Must be done after the element is added to the DOM
	 * @param {Boolean|Object} shadowOptions
	 */
	shadow: function (shadowOptions, group, cutOff) {
		var shadows = [],
			i,
			shadow,
			element = this.element,
			strokeWidth,
			shadowWidth,
			shadowElementOpacity,

			// compensate for inverted plot area
			transform;


		if (shadowOptions) {
			shadowWidth = pick(shadowOptions.width, 3);
			shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
			transform = this.parentInverted ?
				'(-1,-1)' :
				'(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';
			for (i = 1; i <= shadowWidth; i++) {
				shadow = element.cloneNode(0);
				strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
				attr(shadow, {
					'isShadow': 'true',
					'stroke': shadowOptions.color || 'black',
					'stroke-opacity': shadowElementOpacity * i,
					'stroke-width': strokeWidth,
					'transform': 'translate' + transform,
					'fill': NONE
				});
				if (cutOff) {
					attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));
					shadow.cutHeight = strokeWidth;
				}

				if (group) {
					group.element.appendChild(shadow);
				} else {
					element.parentNode.insertBefore(shadow, element);
				}

				shadows.push(shadow);
			}

			this.shadows = shadows;
		}
		return this;

	},

	xGetter: function (key) {
		if (this.element.nodeName === 'circle') {
			key = { x: 'cx', y: 'cy' }[key] || key;
		}
		return this._defaultGetter(key);
	},

	/** 
	 * Get the current value of an attribute or pseudo attribute, used mainly
	 * for animation.
	 */
	_defaultGetter: function (key) {
		var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);

		if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
			ret = parseFloat(ret);
		}
		return ret;
	},


	dSetter: function (value, key, element) {
		if (value && value.join) { // join path
			value = value.join(' ');
		}
		if (/(NaN| {2}|^$)/.test(value)) {
			value = 'M 0 0';
		}
		element.setAttribute(key, value);

		this[key] = value;
	},
	dashstyleSetter: function (value) {
		var i;
		value = value && value.toLowerCase();
		if (value) {
			value = value
				.replace('shortdashdotdot', '3,1,1,1,1,1,')
				.replace('shortdashdot', '3,1,1,1')
				.replace('shortdot', '1,1,')
				.replace('shortdash', '3,1,')
				.replace('longdash', '8,3,')
				.replace(/dot/g, '1,3,')
				.replace('dash', '4,3,')
				.replace(/,$/, '')
				.split(','); // ending comma

			i = value.length;
			while (i--) {
				value[i] = pInt(value[i]) * this['stroke-width'];
			}
			value = value.join(',')
				.replace('NaN', 'none'); // #3226
			this.element.setAttribute('stroke-dasharray', value);
		}
	},
	alignSetter: function (value) {
		this.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);
	},
	opacitySetter: function (value, key, element) {
		this[key] = value;
		element.setAttribute(key, value);
	},
	titleSetter: function (value) {
		var titleNode = this.element.getElementsByTagName('title')[0];
		if (!titleNode) {
			titleNode = doc.createElementNS(SVG_NS, 'title');
			this.element.appendChild(titleNode);
		}
		titleNode.appendChild(
			doc.createTextNode(
				(String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895
			)
		);
	},
	textSetter: function (value) {
		if (value !== this.textStr) {
			// Delete bBox memo when the text changes
			delete this.bBox;
		
			this.textStr = value;
			if (this.added) {
				this.renderer.buildText(this);
			}
		}
	},
	fillSetter: function (value, key, element) {
		if (typeof value === 'string') {
			element.setAttribute(key, value);
		} else if (value) {
			this.colorGradient(value, key, element);
		}
	},
	visibilitySetter: function (value, key, element) {
		// IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881, #3909)
		if (value === 'inherit') {
			element.removeAttribute(key);
		} else {
			element.setAttribute(key, value);
		}
	},
	zIndexSetter: function (value, key) {
		var renderer = this.renderer,
			parentGroup = this.parentGroup,
			parentWrapper = parentGroup || renderer,
			parentNode = parentWrapper.element || renderer.box,
			childNodes,
			otherElement,
			otherZIndex,
			element = this.element,
			inserted,
			run = this.added,
			i;
		
		if (defined(value)) {
			element.setAttribute(key, value); // So we can read it for other elements in the group
			value = +value;
			if (this[key] === value) { // Only update when needed (#3865)
				run = false;
			}
			this[key] = value;
		}

		// Insert according to this and other elements' zIndex. Before .add() is called,
		// nothing is done. Then on add, or by later calls to zIndexSetter, the node
		// is placed on the right place in the DOM.
		if (run) {
			value = this.zIndex;

			if (value && parentGroup) {
				parentGroup.handleZ = true;
			}
		
			childNodes = parentNode.childNodes;
			for (i = 0; i < childNodes.length && !inserted; i++) {
				otherElement = childNodes[i];
				otherZIndex = attr(otherElement, 'zIndex');
				if (otherElement !== element && (
						// Insert before the first element with a higher zIndex
						pInt(otherZIndex) > value ||
						// If no zIndex given, insert before the first element with a zIndex
						(!defined(value) && defined(otherZIndex))

						)) {
					parentNode.insertBefore(element, otherElement);
					inserted = true;
				}
			}
			if (!inserted) {
				parentNode.appendChild(element);
			}
		}
		return inserted;
	},
	_defaultSetter: function (value, key, element) {
		element.setAttribute(key, value);
	}
};

// Some shared setters and getters
SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = 
		SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = 
		SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {
	this[key] = value;
	this.doTransform = true;
};

// WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the 
// stroke attribute altogether. #1270, #1369, #3065, #3072.
SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {
	this[key] = value;
	// Only apply the stroke attribute if the stroke width is defined and larger than 0
	if (this.stroke && this['stroke-width']) {
		this.strokeWidth = this['stroke-width'];
		SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden
		element.setAttribute('stroke-width', this['stroke-width']);
		this.hasStroke = true;
	} else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
		element.removeAttribute('stroke');
		this.hasStroke = false;
	}
};


/**
 * The default SVG renderer
 */
var SVGRenderer = function () {
	this.init.apply(this, arguments);
};
SVGRenderer.prototype = {
	Element: SVGElement,

	/**
	 * Initialize the SVGRenderer
	 * @param {Object} container
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Boolean} forExport
	 */
	init: function (container, width, height, style, forExport, allowHTML) {
		var renderer = this,
			loc = location,
			boxWrapper,
			element,
			desc;

		boxWrapper = renderer.createElement('svg')
			.attr({
				version: '1.1'
			})
			.css(this.getStyle(style));
		element = boxWrapper.element;
		container.appendChild(element);

		// For browsers other than IE, add the namespace attribute (#1978)
		if (container.innerHTML.indexOf('xmlns') === -1) {
			attr(element, 'xmlns', SVG_NS);
		}

		// object properties
		renderer.isSVG = true;
		renderer.box = element;
		renderer.boxWrapper = boxWrapper;
		renderer.alignedObjects = [];

		// Page url used for internal references. #24, #672, #1070
		renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?
			loc.href
				.replace(/#.*?$/, '') // remove the hash
				.replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
				.replace(/ /g, '%20') : // replace spaces (needed for Safari only)
			'';

		// Add description
		desc = this.createElement('desc').add();
		desc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));


		renderer.defs = this.createElement('defs').add();
		renderer.allowHTML = allowHTML;
		renderer.forExport = forExport;
		renderer.gradients = {}; // Object where gradient SvgElements are stored
		renderer.cache = {}; // Cache for numerical bounding boxes

		renderer.setSize(width, height, false);



		// Issue 110 workaround:
		// In Firefox, if a div is positioned by percentage, its pixel position may land
		// between pixels. The container itself doesn't display this, but an SVG element
		// inside this container will be drawn at subpixel precision. In order to draw
		// sharp lines, this must be compensated for. This doesn't seem to work inside
		// iframes though (like in jsFiddle).
		var subPixelFix, rect;
		if (isFirefox && container.getBoundingClientRect) {
			renderer.subPixelFix = subPixelFix = function () {
				css(container, { left: 0, top: 0 });
				rect = container.getBoundingClientRect();
				css(container, {
					left: (mathCeil(rect.left) - rect.left) + PX,
					top: (mathCeil(rect.top) - rect.top) + PX
				});
			};

			// run the fix now
			subPixelFix();

			// run it on resize
			addEvent(win, 'resize', subPixelFix);
		}
	},

	getStyle: function (style) {
		return (this.style = extend({
			fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', // default font
			fontSize: '12px'
		}, style));
	},

	/**
	 * Detect whether the renderer is hidden. This happens when one of the parent elements
	 * has display: none. #608.
	 */
	isHidden: function () {
		return !this.boxWrapper.getBBox().width;
	},

	/**
	 * Destroys the renderer and its allocated members.
	 */
	destroy: function () {
		var renderer = this,
			rendererDefs = renderer.defs;
		renderer.box = null;
		renderer.boxWrapper = renderer.boxWrapper.destroy();

		// Call destroy on all gradient elements
		destroyObjectProperties(renderer.gradients || {});
		renderer.gradients = null;

		// Defs are null in VMLRenderer
		// Otherwise, destroy them here.
		if (rendererDefs) {
			renderer.defs = rendererDefs.destroy();
		}

		// Remove sub pixel fix handler
		// We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed
		// See issue #982
		if (renderer.subPixelFix) {
			removeEvent(win, 'resize', renderer.subPixelFix);
		}

		renderer.alignedObjects = null;

		return null;
	},

	/**
	 * Create a wrapper for an SVG element
	 * @param {Object} nodeName
	 */
	createElement: function (nodeName) {
		var wrapper = new this.Element();
		wrapper.init(this, nodeName);
		return wrapper;
	},

	/**
	 * Dummy function for use in canvas renderer
	 */
	draw: function () {},

	/**
	 * Get converted radial gradient attributes
	 */
	getRadialAttr: function (radialReference, gradAttr) {
		return {
			cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
			cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
			r: gradAttr.r * radialReference[2]
		};
	},

	/**
	 * Parse a simple HTML string into SVG tspans
	 *
	 * @param {Object} textNode The parent text SVG node
	 */
	buildText: function (wrapper) {
		var textNode = wrapper.element,
			renderer = this,
			forExport = renderer.forExport,
			textStr = pick(wrapper.textStr, '').toString(),
			hasMarkup = textStr.indexOf('<') !== -1,
			lines,
			childNodes = textNode.childNodes,
			styleRegex,
			hrefRegex,
			parentX = attr(textNode, 'x'),
			textStyles = wrapper.styles,
			width = wrapper.textWidth,
			textLineHeight = textStyles && textStyles.lineHeight,
			textShadow = textStyles && textStyles.textShadow,
			ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
			i = childNodes.length,
			tempParent = width && !wrapper.added && this.box,
			getLineHeight = function (tspan) {
				return textLineHeight ? 
					pInt(textLineHeight) :
					renderer.fontMetrics(
						/(px|em)$/.test(tspan && tspan.style.fontSize) ?
							tspan.style.fontSize :
							((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),
						tspan
					).h;
			},
			unescapeAngleBrackets = function (inputStr) {
				return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
			};

		/// remove old text
		while (i--) {
			textNode.removeChild(childNodes[i]);
		}

		// Skip tspans, add text directly to text node. The forceTSpan is a hook 
		// used in text outline hack.
		if (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {
			textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));
			return;

		// Complex strings, add more logic
		} else {

			styleRegex = /<.*style="([^"]+)".*>/;
			hrefRegex = /<.*href="(http[^"]+)".*>/;

			if (tempParent) {
				tempParent.appendChild(textNode); // attach it to the DOM to read offset width
			}

			if (hasMarkup) {
				lines = textStr
					.replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
					.replace(/<(i|em)>/g, '<span style="font-style:italic">')
					.replace(/<a/g, '<span')
					.replace(/<\/(b|strong|i|em|a)>/g, '</span>')
					.split(/<br.*?>/g);

			} else {
				lines = [textStr];
			}


			// remove empty line at end
			if (lines[lines.length - 1] === '') {
				lines.pop();
			}

			
			// build the lines
			each(lines, function (line, lineNo) {
				var spans, spanNo = 0;

				line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
				spans = line.split('|||');

				each(spans, function (span) {
					if (span !== '' || spans.length === 1) {
						var attributes = {},
							tspan = doc.createElementNS(SVG_NS, 'tspan'),
							spanStyle; // #390
						if (styleRegex.test(span)) {
							spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');
							attr(tspan, 'style', spanStyle);
						}
						if (hrefRegex.test(span) && !forExport) { // Not for export - #1529
							attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
							css(tspan, { cursor: 'pointer' });
						}

						span = unescapeAngleBrackets(span.replace(/<(.|\n)*?>/g, '') || ' ');

						// Nested tags aren't supported, and cause crash in Safari (#1596)
						if (span !== ' ') {

							// add the text node
							tspan.appendChild(doc.createTextNode(span));

							if (!spanNo) { // first span in a line, align it to the left
								if (lineNo && parentX !== null) {
									attributes.x = parentX;
								}
							} else {
								attributes.dx = 0; // #16
							}

							// add attributes
							attr(tspan, attributes);

							// Append it
							textNode.appendChild(tspan);

							// first span on subsequent line, add the line height
							if (!spanNo && lineNo) {

								// allow getting the right offset height in exporting in IE
								if (!hasSVG && forExport) {
									css(tspan, { display: 'block' });
								}

								// Set the line height based on the font size of either
								// the text element or the tspan element
								attr(
									tspan,
									'dy',
									getLineHeight(tspan)
								);
							}

							/*if (width) {
								renderer.breakText(wrapper, width);
							}*/

							// Check width and apply soft breaks or ellipsis
							if (width) {
								var words = span.replace(/([^\^])-/g, '$1- ').split(' '), // #1273
									hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),
									tooLong,
									wasTooLong,
									actualWidth,
									rest = [],
									dy = getLineHeight(tspan),
									softLineNo = 1,
									rotation = wrapper.rotation,
									wordStr = span, // for ellipsis
									cursor = wordStr.length, // binary search cursor
									bBox;

								while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {
									wrapper.rotation = 0; // discard rotation when computing box
									bBox = wrapper.getBBox(true);
									actualWidth = bBox.width;

									// Old IE cannot measure the actualWidth for SVG elements (#2314)
									if (!hasSVG && renderer.forExport) {
										actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
									}

									tooLong = actualWidth > width;

									// For ellipsis, do a binary search for the correct string length
									if (wasTooLong === undefined) {
										wasTooLong = tooLong; // First time
									}
									if (ellipsis && wasTooLong) {
										cursor /= 2;

										if (wordStr === '' || (!tooLong && cursor < 0.5)) {
											words = []; // All ok, break out
										} else {
											if (tooLong) {
												wasTooLong = true;
											}
											wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));
											words = [wordStr + (width > 3 ? '\u2026' : '')];
											tspan.removeChild(tspan.firstChild);
										}

									// Looping down, this is the first word sequence that is not too long,
									// so we can move on to build the next line.
									} else if (!tooLong || words.length === 1) {
										words = rest;
										rest = [];
												
										if (words.length) {
											softLineNo++;
											
											tspan = doc.createElementNS(SVG_NS, 'tspan');
											attr(tspan, {
												dy: dy,
												x: parentX
											});
											if (spanStyle) { // #390
												attr(tspan, 'style', spanStyle);
											}
											textNode.appendChild(tspan);
										}
										if (actualWidth > width) { // a single word is pressing it out
											width = actualWidth;
										}
									} else { // append to existing line tspan
										tspan.removeChild(tspan.firstChild);
										rest.unshift(words.pop());
									}
									if (words.length) {
										tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
									}
								}
								if (wasTooLong) {
									wrapper.attr('title', wrapper.textStr);
								}
								wrapper.rotation = rotation;
							}

							spanNo++;
						}
					}
				});
			});
			if (tempParent) {
				tempParent.removeChild(textNode); // attach it to the DOM to read offset width
			}

			// Apply the text shadow
			if (textShadow && wrapper.applyTextShadow) {
				wrapper.applyTextShadow(textShadow);
			}
		}
	},

	

	/*
	breakText: function (wrapper, width) {
		var bBox = wrapper.getBBox(),
			node = wrapper.element,
			textLength = node.textContent.length,
			pos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width
			increment = 0,
			finalPos;

		if (bBox.width > width) {
			while (finalPos === undefined) {
				textLength = node.getSubStringLength(0, pos);

				if (textLength <= width) {
					if (increment === -1) {
						finalPos = pos;
					} else {
						increment = 1;
					}
				} else {
					if (increment === 1) {
						finalPos = pos - 1;
					} else {
						increment = -1;
					}
				}
				pos += increment;
			}
		}
		console.log(finalPos, node.getSubStringLength(0, finalPos))
	},
	*/

	/** 
	 * Returns white for dark colors and black for bright colors
	 */
	getContrast: function (color) {
		color = Color(color).rgba;
		return color[0] + color[1] + color[2] > 384 ? '#000000' : '#FFFFFF';
	},

	/**
	 * Create a button with preset states
	 * @param {String} text
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Function} callback
	 * @param {Object} normalState
	 * @param {Object} hoverState
	 * @param {Object} pressedState
	 */
	button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
		var label = this.label(text, x, y, shape, null, null, null, null, 'button'),
			curState = 0,
			stateOptions,
			stateStyle,
			normalStyle,
			hoverStyle,
			pressedStyle,
			disabledStyle,
			verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };

		// Normal state - prepare the attributes
		normalState = merge({
			'stroke-width': 1,
			stroke: '#CCCCCC',
			fill: {
				linearGradient: verticalGradient,
				stops: [
					[0, '#FEFEFE'],
					[1, '#F6F6F6']
				]
			},
			r: 2,
			padding: 5,
			style: {
				color: 'black'
			}
		}, normalState);
		normalStyle = normalState.style;
		delete normalState.style;

		// Hover state
		hoverState = merge(normalState, {
			stroke: '#68A',
			fill: {
				linearGradient: verticalGradient,
				stops: [
					[0, '#FFF'],
					[1, '#ACF']
				]
			}
		}, hoverState);
		hoverStyle = hoverState.style;
		delete hoverState.style;

		// Pressed state
		pressedState = merge(normalState, {
			stroke: '#68A',
			fill: {
				linearGradient: verticalGradient,
				stops: [
					[0, '#9BD'],
					[1, '#CDF']
				]
			}
		}, pressedState);
		pressedStyle = pressedState.style;
		delete pressedState.style;

		// Disabled state
		disabledState = merge(normalState, {
			style: {
				color: '#CCC'
			}
		}, disabledState);
		disabledStyle = disabledState.style;
		delete disabledState.style;

		// Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).
		addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {
			if (curState !== 3) {
				label.attr(hoverState)
					.css(hoverStyle);
			}
		});
		addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {
			if (curState !== 3) {
				stateOptions = [normalState, hoverState, pressedState][curState];
				stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];
				label.attr(stateOptions)
					.css(stateStyle);
			}
		});

		label.setState = function (state) {
			label.state = curState = state;
			if (!state) {
				label.attr(normalState)
					.css(normalStyle);
			} else if (state === 2) {
				label.attr(pressedState)
					.css(pressedStyle);
			} else if (state === 3) {
				label.attr(disabledState)
					.css(disabledStyle);
			}
		};

		return label
			.on('click', function (e) {
				if (curState !== 3) {
					callback.call(label, e);
				}
			})
			.attr(normalState)
			.css(extend({ cursor: 'default' }, normalStyle));
	},

	/**
	 * Make a straight line crisper by not spilling out to neighbour pixels
	 * @param {Array} points
	 * @param {Number} width
	 */
	crispLine: function (points, width) {
		// points format: [M, 0, 0, L, 100, 0]
		// normalize to a crisp line
		if (points[1] === points[4]) {
			// Substract due to #1129. Now bottom and left axis gridlines behave the same.
			points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);
		}
		if (points[2] === points[5]) {
			points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
		}
		return points;
	},


	/**
	 * Draw a path
	 * @param {Array} path An SVG path in array form
	 */
	path: function (path) {
		var attr = {
			fill: NONE
		};
		if (isArray(path)) {
			attr.d = path;
		} else if (isObject(path)) { // attributes
			extend(attr, path);
		}
		return this.createElement('path').attr(attr);
	},

	/**
	 * Draw and return an SVG circle
	 * @param {Number} x The x position
	 * @param {Number} y The y position
	 * @param {Number} r The radius
	 */
	circle: function (x, y, r) {
		var attr = isObject(x) ?
			x :
			{
				x: x,
				y: y,
				r: r
			},
			wrapper = this.createElement('circle');

		wrapper.xSetter = function (value) {
			this.element.setAttribute('cx', value);
		};
		wrapper.ySetter = function (value) {
			this.element.setAttribute('cy', value);
		};
		return wrapper.attr(attr);
	},

	/**
	 * Draw and return an arc
	 * @param {Number} x X position
	 * @param {Number} y Y position
	 * @param {Number} r Radius
	 * @param {Number} innerR Inner radius like used in donut charts
	 * @param {Number} start Starting angle
	 * @param {Number} end Ending angle
	 */
	arc: function (x, y, r, innerR, start, end) {
		var arc;

		if (isObject(x)) {
			y = x.y;
			r = x.r;
			innerR = x.innerR;
			start = x.start;
			end = x.end;
			x = x.x;
		}

		// Arcs are defined as symbols for the ability to set
		// attributes in attr and animate
		arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {
			innerR: innerR || 0,
			start: start || 0,
			end: end || 0
		});
		arc.r = r; // #959
		return arc;
	},

	/**
	 * Draw and return a rectangle
	 * @param {Number} x Left position
	 * @param {Number} y Top position
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Number} r Border corner radius
	 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
	 */
	rect: function (x, y, width, height, r, strokeWidth) {

		r = isObject(x) ? x.r : r;

		var wrapper = this.createElement('rect'),
			attribs = isObject(x) ? x : x === UNDEFINED ? {} : {
				x: x,
				y: y,
				width: mathMax(width, 0),
				height: mathMax(height, 0)
			};

		if (strokeWidth !== UNDEFINED) {
			attribs.strokeWidth = strokeWidth;
			attribs = wrapper.crisp(attribs);
		}

		if (r) {
			attribs.r = r;
		}

		wrapper.rSetter = function (value) {
			attr(this.element, {
				rx: value,
				ry: value
			});
		};
		
		return wrapper.attr(attribs);
	},

	/**
	 * Resize the box and re-align all aligned elements
	 * @param {Object} width
	 * @param {Object} height
	 * @param {Boolean} animate
	 *
	 */
	setSize: function (width, height, animate) {
		var renderer = this,
			alignedObjects = renderer.alignedObjects,
			i = alignedObjects.length;

		renderer.width = width;
		renderer.height = height;

		renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
			width: width,
			height: height
		});

		while (i--) {
			alignedObjects[i].align();
		}
	},

	/**
	 * Create a group
	 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
	 *	 This can be used for styling and scripting.
	 */
	g: function (name) {
		var elem = this.createElement('g');
		return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;
	},

	/**
	 * Display an image
	 * @param {String} src
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	image: function (src, x, y, width, height) {
		var attribs = {
				preserveAspectRatio: NONE
			},
			elemWrapper;

		// optional properties
		if (arguments.length > 1) {
			extend(attribs, {
				x: x,
				y: y,
				width: width,
				height: height
			});
		}

		elemWrapper = this.createElement('image').attr(attribs);

		// set the href in the xlink namespace
		if (elemWrapper.element.setAttributeNS) {
			elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
				'href', src);
		} else {
			// could be exporting in IE
			// using href throws "not supported" in ie7 and under, requries regex shim to fix later
			elemWrapper.element.setAttribute('hc-svg-href', src);
		}
		return elemWrapper;
	},

	/**
	 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
	 *
	 * @param {Object} symbol
	 * @param {Object} x
	 * @param {Object} y
	 * @param {Object} radius
	 * @param {Object} options
	 */
	symbol: function (symbol, x, y, width, height, options) {

		var obj,

			// get the symbol definition function
			symbolFn = this.symbols[symbol],

			// check if there's a path defined for this symbol
			path = symbolFn && symbolFn(
				mathRound(x),
				mathRound(y),
				width,
				height,
				options
			),

			imageElement,
			imageRegex = /^url\((.*?)\)$/,
			imageSrc,
			imageSize,
			centerImage;

		if (path) {

			obj = this.path(path);
			// expando properties for use in animate and attr
			extend(obj, {
				symbolName: symbol,
				x: x,
				y: y,
				width: width,
				height: height
			});
			if (options) {
				extend(obj, options);
			}


		// image symbols
		} else if (imageRegex.test(symbol)) {

			// On image load, set the size and position
			centerImage = function (img, size) {
				if (img.element) { // it may be destroyed in the meantime (#1390)
					img.attr({
						width: size[0],
						height: size[1]
					});

					if (!img.alignByTranslate) { // #185
						img.translate(
							mathRound((width - size[0]) / 2), // #1378
							mathRound((height - size[1]) / 2)
						);
					}
				}
			};

			imageSrc = symbol.match(imageRegex)[1];
			imageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);

			// Ireate the image synchronously, add attribs async
			obj = this.image(imageSrc)
				.attr({
					x: x,
					y: y
				});
			obj.isImg = true;

			if (imageSize) {
				centerImage(obj, imageSize);
			} else {
				// Initialize image to be 0 size so export will still function if there's no cached sizes.
				obj.attr({ width: 0, height: 0 });

				// Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,
				// the created element must be assigned to a variable in order to load (#292).
				imageElement = createElement('img', {
					onload: function () {

						// Special case for SVGs on IE11, the width is not accessible until the image is 
						// part of the DOM (#2854).
						if (this.width === 0) { 
							css(this, {
								position: ABSOLUTE,
								top: '-999em'
							});
							document.body.appendChild(this);
						}

						// Center the image
						centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);

						// Clean up after #2854 workaround.
						if (this.parentNode) {
							this.parentNode.removeChild(this);
						}
					},
					src: imageSrc
				});
			}
		}

		return obj;
	},

	/**
	 * An extendable collection of functions for defining symbol paths.
	 */
	symbols: {
		'circle': function (x, y, w, h) {
			var cpw = 0.166 * w;
			return [
				M, x + w / 2, y,
				'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,
				'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,
				'Z'
			];
		},

		'square': function (x, y, w, h) {
			return [
				M, x, y,
				L, x + w, y,
				x + w, y + h,
				x, y + h,
				'Z'
			];
		},

		'triangle': function (x, y, w, h) {
			return [
				M, x + w / 2, y,
				L, x + w, y + h,
				x, y + h,
				'Z'
			];
		},

		'triangle-down': function (x, y, w, h) {
			return [
				M, x, y,
				L, x + w, y,
				x + w / 2, y + h,
				'Z'
			];
		},
		'diamond': function (x, y, w, h) {
			return [
				M, x + w / 2, y,
				L, x + w, y + h / 2,
				x + w / 2, y + h,
				x, y + h / 2,
				'Z'
			];
		},
		'arc': function (x, y, w, h, options) {
			var start = options.start,
				radius = options.r || w || h,
				end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)
				innerRadius = options.innerR,
				open = options.open,
				cosStart = mathCos(start),
				sinStart = mathSin(start),
				cosEnd = mathCos(end),
				sinEnd = mathSin(end),
				longArc = options.end - start < mathPI ? 0 : 1;

			return [
				M,
				x + radius * cosStart,
				y + radius * sinStart,
				'A', // arcTo
				radius, // x radius
				radius, // y radius
				0, // slanting
				longArc, // long or short arc
				1, // clockwise
				x + radius * cosEnd,
				y + radius * sinEnd,
				open ? M : L,
				x + innerRadius * cosEnd,
				y + innerRadius * sinEnd,
				'A', // arcTo
				innerRadius, // x radius
				innerRadius, // y radius
				0, // slanting
				longArc, // long or short arc
				0, // clockwise
				x + innerRadius * cosStart,
				y + innerRadius * sinStart,

				open ? '' : 'Z' // close
			];
		},

		/**
		 * Callout shape used for default tooltips, also used for rounded rectangles in VML
		 */
		callout: function (x, y, w, h, options) {
			var arrowLength = 6,
				halfDistance = 6,
				r = mathMin((options && options.r) || 0, w, h),
				safeDistance = r + halfDistance,
				anchorX = options && options.anchorX,
				anchorY = options && options.anchorY,
				path;

			path = [
				'M', x + r, y, 
				'L', x + w - r, y, // top side
				'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
				'L', x + w, y + h - r, // right side
				'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner
				'L', x + r, y + h, // bottom side
				'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
				'L', x, y + r, // left side
				'C', x, y, x, y, x + r, y // top-right corner
			];
			
			if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side
				path.splice(13, 3,
					'L', x + w, anchorY - halfDistance, 
					x + w + arrowLength, anchorY,
					x + w, anchorY + halfDistance,
					x + w, y + h - r
				);
			} else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side
				path.splice(33, 3, 
					'L', x, anchorY + halfDistance, 
					x - arrowLength, anchorY,
					x, anchorY - halfDistance,
					x, y + r
				);
			} else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom
				path.splice(23, 3,
					'L', anchorX + halfDistance, y + h,
					anchorX, y + h + arrowLength,
					anchorX - halfDistance, y + h,
					x + r, y + h
				);
			} else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top
				path.splice(3, 3,
					'L', anchorX - halfDistance, y,
					anchorX, y - arrowLength,
					anchorX + halfDistance, y,
					w - r, y
				);
			}
			return path;
		}
	},

	/**
	 * Define a clipping rectangle
	 * @param {String} id
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	clipRect: function (x, y, width, height) {
		var wrapper,
			id = PREFIX + idCounter++,

			clipPath = this.createElement('clipPath').attr({
				id: id
			}).add(this.defs);

		wrapper = this.rect(x, y, width, height, 0).add(clipPath);
		wrapper.id = id;
		wrapper.clipPath = clipPath;
		wrapper.count = 0;

		return wrapper;
	},


	


	/**
	 * Add text to the SVG object
	 * @param {String} str
	 * @param {Number} x Left position
	 * @param {Number} y Top position
	 * @param {Boolean} useHTML Use HTML to render the text
	 */
	text: function (str, x, y, useHTML) {

		// declare variables
		var renderer = this,
			fakeSVG = useCanVG || (!hasSVG && renderer.forExport),
			wrapper,
			attr = {};

		if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
			return renderer.html(str, x, y);
		}

		attr.x = Math.round(x || 0); // X is always needed for line-wrap logic
		if (y) {
			attr.y = Math.round(y);
		}
		if (str || str === 0) {
			attr.text = str;
		}

		wrapper = renderer.createElement('text')
			.attr(attr);

		// Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)
		if (fakeSVG) {
			wrapper.css({
				position: ABSOLUTE
			});
		}

		if (!useHTML) {
			wrapper.xSetter = function (value, key, element) {
				var tspans = element.getElementsByTagName('tspan'),
					tspan,
					parentVal = element.getAttribute(key),
					i;
				for (i = 0; i < tspans.length; i++) {
					tspan = tspans[i];
					// If the x values are equal, the tspan represents a linebreak
					if (tspan.getAttribute(key) === parentVal) {
						tspan.setAttribute(key, value);
					}
				}
				element.setAttribute(key, value);
			};
		}
		
		return wrapper;
	},

	/**
	 * Utility to return the baseline offset and total line height from the font size
	 */
	fontMetrics: function (fontSize, elem) {
		var lineHeight,
			baseline,
			style;

		fontSize = fontSize || this.style.fontSize;
		if (!fontSize && elem && win.getComputedStyle) {
			elem = elem.element || elem; // SVGElement
			style = win.getComputedStyle(elem, "");
			fontSize = style && style.fontSize; // #4309, the style doesn't exist inside a hidden iframe in Firefox
		}
		fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;

		// Empirical values found by comparing font size and bounding box height.
		// Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
		lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2);
		baseline = mathRound(lineHeight * 0.8);

		return {
			h: lineHeight,
			b: baseline,
			f: fontSize
		};
	},

	/**
	 * Correct X and Y positioning of a label for rotation (#1764)
	 */
	rotCorr: function (baseline, rotation, alterY) {
		var y = baseline;
		if (rotation && alterY) {
			y = mathMax(y * mathCos(rotation * deg2rad), 4);
		}
		return {
			x: (-baseline / 3) * mathSin(rotation * deg2rad),
			y: y
		};
	},

	/**
	 * Add a label, a text item that can hold a colored or gradient background
	 * as well as a border and shadow.
	 * @param {string} str
	 * @param {Number} x
	 * @param {Number} y
	 * @param {String} shape
	 * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the
	 *	coordinates it should be pinned to
	 * @param {Number} anchorY
	 * @param {Boolean} baseline Whether to position the label relative to the text baseline,
	 *	like renderer.text, or to the upper border of the rectangle.
	 * @param {String} className Class name for the group
	 */
	label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {

		var renderer = this,
			wrapper = renderer.g(className),
			text = renderer.text('', 0, 0, useHTML)
				.attr({
					zIndex: 1
				}),
				//.add(wrapper),
			box,
			bBox,
			alignFactor = 0,
			padding = 3,
			paddingLeft = 0,
			width,
			height,
			wrapperX,
			wrapperY,
			crispAdjust = 0,
			deferredAttr = {},
			baselineOffset,
			needsBox;

		/**
		 * This function runs after the label is added to the DOM (when the bounding box is
		 * available), and after the text of the label is updated to detect the new bounding
		 * box and reflect it in the border box.
		 */
		function updateBoxSize() {
			var boxX,
				boxY,
				style = text.element.style;

			bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) && 
				text.getBBox(); //#3295 && 3514 box failure when string equals 0
			wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
			wrapper.height = (height || bBox.height || 0) + 2 * padding;

			// update the label-scoped y offset
			baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;

			
			if (needsBox) {

				// create the border box if it is not already present
				if (!box) {
					boxX = mathRound(-alignFactor * padding) + crispAdjust;
					boxY = (baseline ? -baselineOffset : 0) + crispAdjust;

					wrapper.box = box = shape ?
						renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :
						renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);

					if (!box.isImg) { // #4324, fill "none" causes it to be ignored by mouse events in IE
						box.attr('fill', NONE);
					}
					box.add(wrapper);
				}

				// apply the box attributes
				if (!box.isImg) { // #1630
					box.attr(extend({
						width: mathRound(wrapper.width),
						height: mathRound(wrapper.height)
					}, deferredAttr));
				}
				deferredAttr = null;
			}
		}

		/**
		 * This function runs after setting text or padding, but only if padding is changed
		 */
		function updateTextPadding() {
			var styles = wrapper.styles,
				textAlign = styles && styles.textAlign,
				x = paddingLeft + padding * (1 - alignFactor),
				y;

			// determin y based on the baseline
			y = baseline ? 0 : baselineOffset;

			// compensate for alignment
			if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {
				x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);
			}

			// update if anything changed
			if (x !== text.x || y !== text.y) {
				text.attr('x', x);
				if (y !== UNDEFINED) {
					text.attr('y', y);
				}
			}

			// record current values
			text.x = x;
			text.y = y;
		}

		/**
		 * Set a box attribute, or defer it if the box is not yet created
		 * @param {Object} key
		 * @param {Object} value
		 */
		function boxAttr(key, value) {
			if (box) {
				box.attr(key, value);
			} else {
				deferredAttr[key] = value;
			}
		}

		/**
		 * After the text element is added, get the desired size of the border box
		 * and add it before the text in the DOM.
		 */
		wrapper.onAdd = function () {
			text.add(wrapper);
			wrapper.attr({
				text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value
				x: x,
				y: y
			});

			if (box && defined(anchorX)) {
				wrapper.attr({
					anchorX: anchorX,
					anchorY: anchorY
				});
			}
		};

		/*
		 * Add specific attribute setters.
		 */

		// only change local variables
		wrapper.widthSetter = function (value) {
			width = value;
		};
		wrapper.heightSetter = function (value) {
			height = value;
		};
		wrapper.paddingSetter =  function (value) {
			if (defined(value) && value !== padding) {
				padding = wrapper.padding = value;
				updateTextPadding();
			}
		};
		wrapper.paddingLeftSetter =  function (value) {
			if (defined(value) && value !== paddingLeft) {
				paddingLeft = value;
				updateTextPadding();
			}
		};


		// change local variable and prevent setting attribute on the group
		wrapper.alignSetter = function (value) {
			alignFactor = { left: 0, center: 0.5, right: 1 }[value];
		};

		// apply these to the box and the text alike
		wrapper.textSetter = function (value) {
			if (value !== UNDEFINED) {
				text.textSetter(value);
			}
			updateBoxSize();
			updateTextPadding();
		};

		// apply these to the box but not to the text
		wrapper['stroke-widthSetter'] = function (value, key) {
			if (value) {
				needsBox = true;
			}
			crispAdjust = value % 2 / 2;
			boxAttr(key, value);
		};
		wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {
			if (key === 'fill' && value) {
				needsBox = true;
			}
			boxAttr(key, value);
		};
		wrapper.anchorXSetter = function (value, key) {
			anchorX = value;
			boxAttr(key, mathRound(value) - crispAdjust - wrapperX);
		};
		wrapper.anchorYSetter = function (value, key) {
			anchorY = value;
			boxAttr(key, value - wrapperY);
		};

		// rename attributes
		wrapper.xSetter = function (value) {
			wrapper.x = value; // for animation getter
			if (alignFactor) {
				value -= alignFactor * ((width || bBox.width) + padding);
			}
			wrapperX = mathRound(value);
			wrapper.attr('translateX', wrapperX);
		};
		wrapper.ySetter = function (value) {
			wrapperY = wrapper.y = mathRound(value);
			wrapper.attr('translateY', wrapperY);
		};

		// Redirect certain methods to either the box or the text
		var baseCss = wrapper.css;
		return extend(wrapper, {
			/**
			 * Pick up some properties and apply them to the text instead of the wrapper
			 */
			css: function (styles) {
				if (styles) {
					var textStyles = {};
					styles = merge(styles); // create a copy to avoid altering the original object (#537)
					each(wrapper.textProps, function (prop) {
						if (styles[prop] !== UNDEFINED) {
							textStyles[prop] = styles[prop];
							delete styles[prop];
						}
					});
					text.css(textStyles);
				}
				return baseCss.call(wrapper, styles);
			},
			/**
			 * Return the bounding box of the box, not the group
			 */
			getBBox: function () {
				return {
					width: bBox.width + 2 * padding,
					height: bBox.height + 2 * padding,
					x: bBox.x - padding,
					y: bBox.y - padding
				};
			},
			/**
			 * Apply the shadow to the box
			 */
			shadow: function (b) {
				if (box) {
					box.shadow(b);
				}
				return wrapper;
			},
			/**
			 * Destroy and release memory.
			 */
			destroy: function () {

				// Added by button implementation
				removeEvent(wrapper.element, 'mouseenter');
				removeEvent(wrapper.element, 'mouseleave');

				if (text) {
					text = text.destroy();
				}
				if (box) {
					box = box.destroy();
				}
				// Call base implementation to destroy the rest
				SVGElement.prototype.destroy.call(wrapper);

				// Release local pointers (#1298)
				wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
			}
		});
	}
}; // end SVGRenderer


// general renderer
Renderer = SVGRenderer;
// extend SvgElement for useHTML option
extend(SVGElement.prototype, {
	/**
	 * Apply CSS to HTML elements. This is used in text within SVG rendering and
	 * by the VML renderer
	 */
	htmlCss: function (styles) {
		var wrapper = this,
			element = wrapper.element,
			textWidth = styles && element.tagName === 'SPAN' && styles.width;

		if (textWidth) {
			delete styles.width;
			wrapper.textWidth = textWidth;
			wrapper.updateTransform();
		}
		if (styles && styles.textOverflow === 'ellipsis') {
			styles.whiteSpace = 'nowrap';
			styles.overflow = 'hidden';
		}
		wrapper.styles = extend(wrapper.styles, styles);
		css(wrapper.element, styles);

		return wrapper;
	},

	/**
	 * VML and useHTML method for calculating the bounding box based on offsets
	 * @param {Boolean} refresh Whether to force a fresh value from the DOM or to
	 * use the cached value
	 *
	 * @return {Object} A hash containing values for x, y, width and height
	 */

	htmlGetBBox: function () {
		var wrapper = this,
			element = wrapper.element;

		// faking getBBox in exported SVG in legacy IE
		// faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)
		if (element.nodeName === 'text') {
			element.style.position = ABSOLUTE;
		}

		return {
			x: element.offsetLeft,
			y: element.offsetTop,
			width: element.offsetWidth,
			height: element.offsetHeight
		};
	},

	/**
	 * VML override private method to update elements based on internal
	 * properties based on SVG transform
	 */
	htmlUpdateTransform: function () {
		// aligning non added elements is expensive
		if (!this.added) {
			this.alignOnAdd = true;
			return;
		}

		var wrapper = this,
			renderer = wrapper.renderer,
			elem = wrapper.element,
			translateX = wrapper.translateX || 0,
			translateY = wrapper.translateY || 0,
			x = wrapper.x || 0,
			y = wrapper.y || 0,
			align = wrapper.textAlign || 'left',
			alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
			shadows = wrapper.shadows,
			styles = wrapper.styles;

		// apply translate
		css(elem, {
			marginLeft: translateX,
			marginTop: translateY
		});
		if (shadows) { // used in labels/tooltip
			each(shadows, function (shadow) {
				css(shadow, {
					marginLeft: translateX + 1,
					marginTop: translateY + 1
				});
			});
		}

		// apply inversion
		if (wrapper.inverted) { // wrapper is a group
			each(elem.childNodes, function (child) {
				renderer.invertChild(child, elem);
			});
		}

		if (elem.tagName === 'SPAN') {

			var width,
				rotation = wrapper.rotation,
				baseline,
				textWidth = pInt(wrapper.textWidth),
				currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(',');

			if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed


				baseline = renderer.fontMetrics(elem.style.fontSize).b;

				// Renderer specific handling of span rotation
				if (defined(rotation)) {
					wrapper.setSpanRotation(rotation, alignCorrection, baseline);
				}

				width = pick(wrapper.elemWidth, elem.offsetWidth);

				// Update textWidth
				if (width > textWidth && /[ \-]/.test(elem.textContent || elem.innerText)) { // #983, #1254
					css(elem, {
						width: textWidth + PX,
						display: 'block',
						whiteSpace: (styles && styles.whiteSpace) || 'normal' // #3331
					});
					width = textWidth;
				}

				wrapper.getSpanCorrection(width, baseline, alignCorrection, rotation, align);
			}

			// apply position with correction
			css(elem, {
				left: (x + (wrapper.xCorr || 0)) + PX,
				top: (y + (wrapper.yCorr || 0)) + PX
			});

			// force reflow in webkit to apply the left and top on useHTML element (#1249)
			if (isWebKit) {
				baseline = elem.offsetHeight; // assigned to baseline for JSLint purpose
			}

			// record current text transform
			wrapper.cTT = currentTextTransform;
		}
	},

	/**
	 * Set the rotation of an individual HTML span
	 */
	setSpanRotation: function (rotation, alignCorrection, baseline) {
		var rotationStyle = {},
			cssTransformKey = isMS ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';

		rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';
		rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';
		css(this.element, rotationStyle);
	},

	/**
	 * Get the correction in X and Y positioning as the element is rotated.
	 */
	getSpanCorrection: function (width, baseline, alignCorrection) {
		this.xCorr = -width * alignCorrection;
		this.yCorr = -baseline;
	}
});

// Extend SvgRenderer for useHTML option.
extend(SVGRenderer.prototype, {
	/**
	 * Create HTML text node. This is used by the VML renderer as well as the SVG
	 * renderer through the useHTML option.
	 *
	 * @param {String} str
	 * @param {Number} x
	 * @param {Number} y
	 */
	html: function (str, x, y) {
		var wrapper = this.createElement('span'),
			element = wrapper.element,
			renderer = wrapper.renderer;

		// Text setter
		wrapper.textSetter = function (value) {
			if (value !== element.innerHTML) {
				delete this.bBox;
			}
			element.innerHTML = this.textStr = value;
			wrapper.htmlUpdateTransform();
		};

		// Various setters which rely on update transform
		wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {
			if (key === 'align') {
				key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.
			}
			wrapper[key] = value;
			wrapper.htmlUpdateTransform();
		};

		// Set the default attributes
		wrapper.attr({
				text: str,
				x: mathRound(x),
				y: mathRound(y)
			})
			.css({
				position: ABSOLUTE,
				fontFamily: this.style.fontFamily,
				fontSize: this.style.fontSize
			});

		// Keep the whiteSpace style outside the wrapper.styles collection
		element.style.whiteSpace = 'nowrap';

		// Use the HTML specific .css method
		wrapper.css = wrapper.htmlCss;

		// This is specific for HTML within SVG
		if (renderer.isSVG) {
			wrapper.add = function (svgGroupWrapper) {

				var htmlGroup,
					container = renderer.box.parentNode,
					parentGroup,
					parents = [];

				this.parentGroup = svgGroupWrapper;

				// Create a mock group to hold the HTML elements
				if (svgGroupWrapper) {
					htmlGroup = svgGroupWrapper.div;
					if (!htmlGroup) {

						// Read the parent chain into an array and read from top down
						parentGroup = svgGroupWrapper;
						while (parentGroup) {

							parents.push(parentGroup);

							// Move up to the next parent group
							parentGroup = parentGroup.parentGroup;
						}

						// Ensure dynamically updating position when any parent is translated
						each(parents.reverse(), function (parentGroup) {
							var htmlGroupStyle,
								cls = attr(parentGroup.element, 'class');

							if (cls) {
								cls = { className: cls };
							} // else null

							// Create a HTML div and append it to the parent div to emulate
							// the SVG group structure
							htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, cls, {
								position: ABSOLUTE,
								left: (parentGroup.translateX || 0) + PX,
								top: (parentGroup.translateY || 0) + PX
							}, htmlGroup || container); // the top group is appended to container

							// Shortcut
							htmlGroupStyle = htmlGroup.style;

							// Set listeners to update the HTML div's position whenever the SVG group
							// position is changed
							extend(parentGroup, {
								translateXSetter: function (value, key) {
									htmlGroupStyle.left = value + PX;
									parentGroup[key] = value;
									parentGroup.doTransform = true;
								},
								translateYSetter: function (value, key) {
									htmlGroupStyle.top = value + PX;
									parentGroup[key] = value;
									parentGroup.doTransform = true;
								}
							});

							// These properties are set as attributes on the SVG group, and as
							// identical CSS properties on the div. (#3542)
							each(['opacity', 'visibility'], function (prop) {
								wrap(parentGroup, prop + 'Setter', function (proceed, value, key, elem) {
									proceed.call(this, value, key, elem);
									htmlGroupStyle[key] = value;
								});
							});
						});

					}
				} else {
					htmlGroup = container;
				}

				htmlGroup.appendChild(element);

				// Shared with VML:
				wrapper.added = true;
				if (wrapper.alignOnAdd) {
					wrapper.htmlUpdateTransform();
				}

				return wrapper;
			};
		}
		return wrapper;
	}
});

/* ****************************************************************************
 *                                                                            *
 * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
 *                                                                            *
 * For applications and websites that don't need IE support, like platform    *
 * targeted mobile apps and web apps, this code can be removed.               *
 *                                                                            *
 *****************************************************************************/

/**
 * @constructor
 */
var VMLRenderer, VMLElement;
if (!hasSVG && !useCanVG) {

/**
 * The VML element wrapper.
 */
VMLElement = {

	/**
	 * Initialize a new VML element wrapper. It builds the markup as a string
	 * to minimize DOM traffic.
	 * @param {Object} renderer
	 * @param {Object} nodeName
	 */
	init: function (renderer, nodeName) {
		var wrapper = this,
			markup =  ['<', nodeName, ' filled="f" stroked="f"'],
			style = ['position: ', ABSOLUTE, ';'],
			isDiv = nodeName === DIV;

		// divs and shapes need size
		if (nodeName === 'shape' || isDiv) {
			style.push('left:0;top:0;width:1px;height:1px;');
		}
		style.push('visibility: ', isDiv ? HIDDEN : VISIBLE);

		markup.push(' style="', style.join(''), '"/>');

		// create element with default attributes and style
		if (nodeName) {
			markup = isDiv || nodeName === 'span' || nodeName === 'img' ?
				markup.join('')
				: renderer.prepVML(markup);
			wrapper.element = createElement(markup);
		}

		wrapper.renderer = renderer;
	},

	/**
	 * Add the node to the given parent
	 * @param {Object} parent
	 */
	add: function (parent) {
		var wrapper = this,
			renderer = wrapper.renderer,
			element = wrapper.element,
			box = renderer.box,
			inverted = parent && parent.inverted,

			// get the parent node
			parentNode = parent ?
				parent.element || parent :
				box;


		// if the parent group is inverted, apply inversion on all children
		if (inverted) { // only on groups
			renderer.invertChild(element, parentNode);
		}

		// append it
		parentNode.appendChild(element);

		// align text after adding to be able to read offset
		wrapper.added = true;
		if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
			wrapper.updateTransform();
		}

		// fire an event for internal hooks
		if (wrapper.onAdd) {
			wrapper.onAdd();
		}

		return wrapper;
	},

	/**
	 * VML always uses htmlUpdateTransform
	 */
	updateTransform: SVGElement.prototype.htmlUpdateTransform,

	/**
	 * Set the rotation of a span with oldIE's filter
	 */
	setSpanRotation: function () {
		// Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
		// but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
		// has support for CSS3 transform. The getBBox method also needs to be updated
		// to compensate for the rotation, like it currently does for SVG.
		// Test case: http://jsfiddle.net/highcharts/Ybt44/

		var rotation = this.rotation,
			costheta = mathCos(rotation * deg2rad),
			sintheta = mathSin(rotation * deg2rad);
					
		css(this.element, {
			filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
				', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
				', sizingMethod=\'auto expand\')'].join('') : NONE
		});
	},

	/**
	 * Get the positioning correction for the span after rotating. 
	 */
	getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {

		var costheta = rotation ? mathCos(rotation * deg2rad) : 1,
			sintheta = rotation ? mathSin(rotation * deg2rad) : 0,
			height = pick(this.elemHeight, this.element.offsetHeight),
			quad,
			nonLeft = align && align !== 'left';

		// correct x and y
		this.xCorr = costheta < 0 && -width;
		this.yCorr = sintheta < 0 && -height;

		// correct for baseline and corners spilling out after rotation
		quad = costheta * sintheta < 0;
		this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
		this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
		// correct for the length/height of the text
		if (nonLeft) {
			this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
			if (rotation) {
				this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
			}
			css(this.element, {
				textAlign: align
			});
		}
	},

	/**
	 * Converts a subset of an SVG path definition to its VML counterpart. Takes an array
	 * as the parameter and returns a string.
	 */
	pathToVML: function (value) {
		// convert paths
		var i = value.length,
			path = [];

		while (i--) {

			// Multiply by 10 to allow subpixel precision.
			// Substracting half a pixel seems to make the coordinates
			// align with SVG, but this hasn't been tested thoroughly
			if (isNumber(value[i])) {
				path[i] = mathRound(value[i] * 10) - 5;
			} else if (value[i] === 'Z') { // close the path
				path[i] = 'x';
			} else {
				path[i] = value[i];

				// When the start X and end X coordinates of an arc are too close,
				// they are rounded to the same value above. In this case, substract or 
				// add 1 from the end X and Y positions. #186, #760, #1371, #1410.
				if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {
					// Start and end X
					if (path[i + 5] === path[i + 7]) {
						path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;
					}
					// Start and end Y
					if (path[i + 6] === path[i + 8]) {
						path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;
					}
				}
			}
		}

		
		// Loop up again to handle path shortcuts (#2132)
		/*while (i++ < path.length) {
			if (path[i] === 'H') { // horizontal line to
				path[i] = 'L';
				path.splice(i + 2, 0, path[i - 1]);
			} else if (path[i] === 'V') { // vertical line to
				path[i] = 'L';
				path.splice(i + 1, 0, path[i - 2]);
			}
		}*/
		return path.join(' ') || 'x';
	},

	/**
	 * Set the element's clipping to a predefined rectangle
	 *
	 * @param {String} id The id of the clip rectangle
	 */
	clip: function (clipRect) {
		var wrapper = this,
			clipMembers,
			cssRet;

		if (clipRect) {
			clipMembers = clipRect.members;
			erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)
			clipMembers.push(wrapper);
			wrapper.destroyClip = function () {
				erase(clipMembers, wrapper);
			};
			cssRet = clipRect.getCSS(wrapper);

		} else {
			if (wrapper.destroyClip) {
				wrapper.destroyClip();
			}
			cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214
		}

		return wrapper.css(cssRet);

	},

	/**
	 * Set styles for the element
	 * @param {Object} styles
	 */
	css: SVGElement.prototype.htmlCss,

	/**
	 * Removes a child either by removeChild or move to garbageBin.
	 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	 */
	safeRemoveChild: function (element) {
		// discardElement will detach the node from its parent before attaching it
		// to the garbage bin. Therefore it is important that the node is attached and have parent.
		if (element.parentNode) {
			discardElement(element);
		}
	},

	/**
	 * Extend element.destroy by removing it from the clip members array
	 */
	destroy: function () {
		if (this.destroyClip) {
			this.destroyClip();
		}

		return SVGElement.prototype.destroy.apply(this);
	},

	/**
	 * Add an event listener. VML override for normalizing event parameters.
	 * @param {String} eventType
	 * @param {Function} handler
	 */
	on: function (eventType, handler) {
		// simplest possible event model for internal use
		this.element['on' + eventType] = function () {
			var evt = win.event;
			evt.target = evt.srcElement;
			handler(evt);
		};
		return this;
	},

	/**
	 * In stacked columns, cut off the shadows so that they don't overlap
	 */
	cutOffPath: function (path, length) {

		var len;

		path = path.split(/[ ,]/);
		len = path.length;

		if (len === 9 || len === 11) {
			path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
		}
		return path.join(' ');
	},

	/**
	 * Apply a drop shadow by copying elements and giving them different strokes
	 * @param {Boolean|Object} shadowOptions
	 */
	shadow: function (shadowOptions, group, cutOff) {
		var shadows = [],
			i,
			element = this.element,
			renderer = this.renderer,
			shadow,
			elemStyle = element.style,
			markup,
			path = element.path,
			strokeWidth,
			modifiedPath,
			shadowWidth,
			shadowElementOpacity;

		// some times empty paths are not strings
		if (path && typeof path.value !== 'string') {
			path = 'x';
		}
		modifiedPath = path;

		if (shadowOptions) {
			shadowWidth = pick(shadowOptions.width, 3);
			shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
			for (i = 1; i <= 3; i++) {

				strokeWidth = (shadowWidth * 2) + 1 - (2 * i);

				// Cut off shadows for stacked column items
				if (cutOff) {
					modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
				}

				markup = ['<shape isShadow="true" strokeweight="', strokeWidth,
					'" filled="false" path="', modifiedPath,
					'" coordsize="10 10" style="', element.style.cssText, '" />'];

				shadow = createElement(renderer.prepVML(markup),
					null, {
						left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
						top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
					}
				);
				if (cutOff) {
					shadow.cutOff = strokeWidth + 1;
				}

				// apply the opacity
				markup = ['<stroke color="', shadowOptions.color || 'black', '" opacity="', shadowElementOpacity * i, '"/>'];
				createElement(renderer.prepVML(markup), null, null, shadow);


				// insert it
				if (group) {
					group.element.appendChild(shadow);
				} else {
					element.parentNode.insertBefore(shadow, element);
				}

				// record it
				shadows.push(shadow);

			}

			this.shadows = shadows;
		}
		return this;
	},
	updateShadows: noop, // Used in SVG only

	setAttr: function (key, value) {
		if (docMode8) { // IE8 setAttribute bug
			this.element[key] = value;
		} else {
			this.element.setAttribute(key, value);
		}
	},
	classSetter: function (value) {
		// IE8 Standards mode has problems retrieving the className unless set like this
		this.element.className = value;
	},
	dashstyleSetter: function (value, key, element) {
		var strokeElem = element.getElementsByTagName('stroke')[0] ||
			createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);
		strokeElem[key] = value || 'solid';
		this[key] = value; /* because changing stroke-width will change the dash length
			and cause an epileptic effect */
	},
	dSetter: function (value, key, element) {
		var i,
			shadows = this.shadows;
		value = value || [];
		this.d = value.join && value.join(' '); // used in getter for animation

		element.path = value = this.pathToVML(value);

		// update shadows
		if (shadows) {
			i = shadows.length;
			while (i--) {
				shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
			}
		}
		this.setAttr(key, value);
	},
	fillSetter: function (value, key, element) {
		var nodeName = element.nodeName;
		if (nodeName === 'SPAN') { // text color
			element.style.color = value;
		} else if (nodeName !== 'IMG') { // #1336
			element.filled = value !== NONE;
			this.setAttr('fillcolor', this.renderer.color(value, element, key, this));
		}
	},
	opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts
	rotationSetter: function (value, key, element) {
		var style = element.style;
		this[key] = style[key] = value; // style is for #1873

		// Correction for the 1x1 size of the shape container. Used in gauge needles.
		style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;
		style.top = mathRound(mathCos(value * deg2rad)) + PX;
	},
	strokeSetter: function (value, key, element) {
		this.setAttr('strokecolor', this.renderer.color(value, element, key));
	},
	'stroke-widthSetter': function (value, key, element) {
		element.stroked = !!value; // VML "stroked" attribute
		this[key] = value; // used in getter, issue #113
		if (isNumber(value)) {
			value += PX;
		}
		this.setAttr('strokeweight', value);
	},
	titleSetter: function (value, key) {
		this.setAttr(key, value);
	},
	visibilitySetter: function (value, key, element) {

		// Handle inherited visibility
		if (value === 'inherit') {
			value = VISIBLE;
		}
		
		// Let the shadow follow the main element
		if (this.shadows) {
			each(this.shadows, function (shadow) {
				shadow.style[key] = value;
			});
		}

		// Instead of toggling the visibility CSS property, move the div out of the viewport.
		// This works around #61 and #586
		if (element.nodeName === 'DIV') {
			value = value === HIDDEN ? '-999em' : 0;

			// In order to redraw, IE7 needs the div to be visible when tucked away
			// outside the viewport. So the visibility is actually opposite of
			// the expected value. This applies to the tooltip only.
			if (!docMode8) {
				element.style[key] = value ? VISIBLE : HIDDEN;
			}
			key = 'top';
		}
		element.style[key] = value;
	},
	xSetter: function (value, key, element) {
		this[key] = value; // used in getter

		if (key === 'x') {
			key = 'left';
		} else if (key === 'y') {
			key = 'top';
		}/* else {
			value = mathMax(0, value); // don't set width or height below zero (#311)
		}*/

		// clipping rectangle special
		if (this.updateClipping) {
			this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'
			this.updateClipping();
		} else {
			// normal
			element.style[key] = value;
		}
	},
	zIndexSetter: function (value, key, element) {
		element.style[key] = value;
	}
};
Highcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);

// Some shared setters
VMLElement.prototype.ySetter =
	VMLElement.prototype.widthSetter = 
	VMLElement.prototype.heightSetter = 
	VMLElement.prototype.xSetter;


/**
 * The VML renderer
 */
var VMLRendererExtension = { // inherit SVGRenderer

	Element: VMLElement,
	isIE8: userAgent.indexOf('MSIE 8.0') > -1,


	/**
	 * Initialize the VMLRenderer
	 * @param {Object} container
	 * @param {Number} width
	 * @param {Number} height
	 */
	init: function (container, width, height, style) {
		var renderer = this,
			boxWrapper,
			box,
			css;

		renderer.alignedObjects = [];

		boxWrapper = renderer.createElement(DIV)
			.css(extend(this.getStyle(style), { position: RELATIVE}));
		box = boxWrapper.element;
		container.appendChild(boxWrapper.element);


		// generate the containing box
		renderer.isVML = true;
		renderer.box = box;
		renderer.boxWrapper = boxWrapper;
		renderer.cache = {};


		renderer.setSize(width, height, false);

		// The only way to make IE6 and IE7 print is to use a global namespace. However,
		// with IE8 the only way to make the dynamic shapes visible in screen and print mode
		// seems to be to add the xmlns attribute and the behaviour style inline.
		if (!doc.namespaces.hcv) {

			doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

			// Setup default CSS (#2153, #2368, #2384)
			css = 'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
				'{ behavior:url(#default#VML); display: inline-block; } ';
			try {
				doc.createStyleSheet().cssText = css;
			} catch (e) {
				doc.styleSheets[0].cssText += css;
			}

		}
	},


	/**
	 * Detect whether the renderer is hidden. This happens when one of the parent elements
	 * has display: none
	 */
	isHidden: function () {
		return !this.box.offsetWidth;
	},

	/**
	 * Define a clipping rectangle. In VML it is accomplished by storing the values
	 * for setting the CSS style to all associated members.
	 *
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	clipRect: function (x, y, width, height) {

		// create a dummy element
		var clipRect = this.createElement(),
			isObj = isObject(x);

		// mimic a rectangle with its style object for automatic updating in attr
		return extend(clipRect, {
			members: [],
			count: 0,
			left: (isObj ? x.x : x) + 1,
			top: (isObj ? x.y : y) + 1,
			width: (isObj ? x.width : width) - 1,
			height: (isObj ? x.height : height) - 1,
			getCSS: function (wrapper) {
				var element = wrapper.element,
					nodeName = element.nodeName,
					isShape = nodeName === 'shape',
					inverted = wrapper.inverted,
					rect = this,
					top = rect.top - (isShape ? element.offsetTop : 0),
					left = rect.left,
					right = left + rect.width,
					bottom = top + rect.height,
					ret = {
						clip: 'rect(' +
							mathRound(inverted ? left : top) + 'px,' +
							mathRound(inverted ? bottom : right) + 'px,' +
							mathRound(inverted ? right : bottom) + 'px,' +
							mathRound(inverted ? top : left) + 'px)'
					};

				// issue 74 workaround
				if (!inverted && docMode8 && nodeName === 'DIV') {
					extend(ret, {
						width: right + PX,
						height: bottom + PX
					});
				}
				return ret;
			},

			// used in attr and animation to update the clipping of all members
			updateClipping: function () {
				each(clipRect.members, function (member) {
					if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.
						member.css(clipRect.getCSS(member));
					}
				});
			}
		});

	},


	/**
	 * Take a color and return it if it's a string, make it a gradient if it's a
	 * gradient configuration object, and apply opacity.
	 *
	 * @param {Object} color The color or config object
	 */
	color: function (color, elem, prop, wrapper) {
		var renderer = this,
			colorObject,
			regexRgba = /^rgba/,
			markup,
			fillType,
			ret = NONE;

		// Check for linear or radial gradient
		if (color && color.linearGradient) {
			fillType = 'gradient';
		} else if (color && color.radialGradient) {
			fillType = 'pattern';
		}


		if (fillType) {

			var stopColor,
				stopOpacity,
				gradient = color.linearGradient || color.radialGradient,
				x1,
				y1,
				x2,
				y2,
				opacity1,
				opacity2,
				color1,
				color2,
				fillAttr = '',
				stops = color.stops,
				firstStop,
				lastStop,
				colors = [],
				addFillNode = function () {
					// Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2
					// are reversed.
					markup = ['<fill colors="' + colors.join(',') + '" opacity="', opacity2, '" o:opacity2="', opacity1,
						'" type="', fillType, '" ', fillAttr, 'focus="100%" method="any" />'];
					createElement(renderer.prepVML(markup), null, null, elem);
				};

			// Extend from 0 to 1
			firstStop = stops[0];
			lastStop = stops[stops.length - 1];
			if (firstStop[0] > 0) {
				stops.unshift([
					0,
					firstStop[1]
				]);
			}
			if (lastStop[0] < 1) {
				stops.push([
					1,
					lastStop[1]
				]);
			}

			// Compute the stops
			each(stops, function (stop, i) {
				if (regexRgba.test(stop[1])) {
					colorObject = Color(stop[1]);
					stopColor = colorObject.get('rgb');
					stopOpacity = colorObject.get('a');
				} else {
					stopColor = stop[1];
					stopOpacity = 1;
				}

				// Build the color attribute
				colors.push((stop[0] * 100) + '% ' + stopColor);

				// Only start and end opacities are allowed, so we use the first and the last
				if (!i) {
					opacity1 = stopOpacity;
					color2 = stopColor;
				} else {
					opacity2 = stopOpacity;
					color1 = stopColor;
				}
			});

			// Apply the gradient to fills only.
			if (prop === 'fill') {

				// Handle linear gradient angle
				if (fillType === 'gradient') {
					x1 = gradient.x1 || gradient[0] || 0;
					y1 = gradient.y1 || gradient[1] || 0;
					x2 = gradient.x2 || gradient[2] || 0;
					y2 = gradient.y2 || gradient[3] || 0;
					fillAttr = 'angle="' + (90  - math.atan(
						(y2 - y1) / // y vector
						(x2 - x1) // x vector
						) * 180 / mathPI) + '"';

					addFillNode();

				// Radial (circular) gradient
				} else {

					var r = gradient.r,
						sizex = r * 2,
						sizey = r * 2,
						cx = gradient.cx,
						cy = gradient.cy,
						radialReference = elem.radialReference,
						bBox,
						applyRadialGradient = function () {
							if (radialReference) {
								bBox = wrapper.getBBox();
								cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
								cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
								sizex *= radialReference[2] / bBox.width;
								sizey *= radialReference[2] / bBox.height;
							}
							fillAttr = 'src="' + defaultOptions.global.VMLRadialGradientURL + '" ' +
								'size="' + sizex + ',' + sizey + '" ' +
								'origin="0.5,0.5" ' +
								'position="' + cx + ',' + cy + '" ' +
								'color2="' + color2 + '" ';

							addFillNode();
						};

					// Apply radial gradient
					if (wrapper.added) {
						applyRadialGradient();
					} else {
						// We need to know the bounding box to get the size and position right
						wrapper.onAdd = applyRadialGradient;
					}

					// The fill element's color attribute is broken in IE8 standards mode, so we
					// need to set the parent shape's fillcolor attribute instead.
					ret = color1;
				}

			// Gradients are not supported for VML stroke, return the first color. #722.
			} else {
				ret = stopColor;
			}

		// if the color is an rgba color, split it and add a fill node
		// to hold the opacity component
		} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

			colorObject = Color(color);

			markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
			createElement(this.prepVML(markup), null, null, elem);

			ret = colorObject.get('rgb');


		} else {
			var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node
			if (propNodes.length) {
				propNodes[0].opacity = 1;
				propNodes[0].type = 'solid';
			}
			ret = color;
		}

		return ret;
	},

	/**
	 * Take a VML string and prepare it for either IE8 or IE6/IE7.
	 * @param {Array} markup A string array of the VML markup to prepare
	 */
	prepVML: function (markup) {
		var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
			isIE8 = this.isIE8;

		markup = markup.join('');

		if (isIE8) { // add xmlns and style inline
			markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
			if (markup.indexOf('style="') === -1) {
				markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
			} else {
				markup = markup.replace('style="', 'style="' + vmlStyle);
			}

		} else { // add namespace
			markup = markup.replace('<', '<hcv:');
		}

		return markup;
	},

	/**
	 * Create rotated and aligned text
	 * @param {String} str
	 * @param {Number} x
	 * @param {Number} y
	 */
	text: SVGRenderer.prototype.html,

	/**
	 * Create and return a path element
	 * @param {Array} path
	 */
	path: function (path) {
		var attr = {
			// subpixel precision down to 0.1 (width and height = 1px)
			coordsize: '10 10'
		};
		if (isArray(path)) {
			attr.d = path;
		} else if (isObject(path)) { // attributes
			extend(attr, path);
		}
		// create the shape
		return this.createElement('shape').attr(attr);
	},

	/**
	 * Create and return a circle element. In VML circles are implemented as
	 * shapes, which is faster than v:oval
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} r
	 */
	circle: function (x, y, r) {
		var circle = this.symbol('circle');
		if (isObject(x)) {
			r = x.r;
			y = x.y;
			x = x.x;
		}
		circle.isCircle = true; // Causes x and y to mean center (#1682)
		circle.r = r;
		return circle.attr({ x: x, y: y });
	},

	/**
	 * Create a group using an outer div and an inner v:group to allow rotating
	 * and flipping. A simple v:group would have problems with positioning
	 * child HTML elements and CSS clip.
	 *
	 * @param {String} name The name of the group
	 */
	g: function (name) {
		var wrapper,
			attribs;

		// set the class name
		if (name) {
			attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
		}

		// the div to hold HTML and clipping
		wrapper = this.createElement(DIV).attr(attribs);

		return wrapper;
	},

	/**
	 * VML override to create a regular HTML image
	 * @param {String} src
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	image: function (src, x, y, width, height) {
		var obj = this.createElement('img')
			.attr({ src: src });

		if (arguments.length > 1) {
			obj.attr({
				x: x,
				y: y,
				width: width,
				height: height
			});
		}
		return obj;
	},

	/**
	 * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems
	 */
	createElement: function (nodeName) {
		return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);	
	},

	/**
	 * In the VML renderer, each child of an inverted div (group) is inverted
	 * @param {Object} element
	 * @param {Object} parentNode
	 */
	invertChild: function (element, parentNode) {
		var ren = this,
			parentStyle = parentNode.style,
			imgStyle = element.tagName === 'IMG' && element.style; // #1111

		css(element, {
			flip: 'x',
			left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),
			top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),
			rotation: -90
		});

		// Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.
		each(element.childNodes, function (child) {
			ren.invertChild(child, element);
		});
	},

	/**
	 * Symbol definitions that override the parent SVG renderer's symbols
	 *
	 */
	symbols: {
		// VML specific arc function
		arc: function (x, y, w, h, options) {
			var start = options.start,
				end = options.end,
				radius = options.r || w || h,
				innerRadius = options.innerR,
				cosStart = mathCos(start),
				sinStart = mathSin(start),
				cosEnd = mathCos(end),
				sinEnd = mathSin(end),
				ret;

			if (end - start === 0) { // no angle, don't show it.
				return ['x'];
			}

			ret = [
				'wa', // clockwise arc to
				x - radius, // left
				y - radius, // top
				x + radius, // right
				y + radius, // bottom
				x + radius * cosStart, // start x
				y + radius * sinStart, // start y
				x + radius * cosEnd, // end x
				y + radius * sinEnd  // end y
			];

			if (options.open && !innerRadius) {
				ret.push(
					'e',
					M,
					x,// - innerRadius,
					y// - innerRadius
				);
			}

			ret.push(
				'at', // anti clockwise arc to
				x - innerRadius, // left
				y - innerRadius, // top
				x + innerRadius, // right
				y + innerRadius, // bottom
				x + innerRadius * cosEnd, // start x
				y + innerRadius * sinEnd, // start y
				x + innerRadius * cosStart, // end x
				y + innerRadius * sinStart, // end y
				'x', // finish path
				'e' // close
			);

			ret.isArc = true;
			return ret;

		},
		// Add circle symbol path. This performs significantly faster than v:oval.
		circle: function (x, y, w, h, wrapper) {

			if (wrapper) {
				w = h = 2 * wrapper.r;
			}

			// Center correction, #1682
			if (wrapper && wrapper.isCircle) {
				x -= w / 2;
				y -= h / 2;
			}

			// Return the path
			return [
				'wa', // clockwisearcto
				x, // left
				y, // top
				x + w, // right
				y + h, // bottom
				x + w, // start x
				y + h / 2,     // start y
				x + w, // end x
				y + h / 2,     // end y
				//'x', // finish path
				'e' // close
			];
		},
		/**
		 * Add rectangle symbol path which eases rotation and omits arcsize problems
		 * compared to the built-in VML roundrect shape. When borders are not rounded,
		 * use the simpler square path, else use the callout path without the arrow.
		 */
		rect: function (x, y, w, h, options) {
			return SVGRenderer.prototype.symbols[
				!defined(options) || !options.r ? 'square' : 'callout'
			].call(0, x, y, w, h, options);
		}
	}
};
Highcharts.VMLRenderer = VMLRenderer = function () {
	this.init.apply(this, arguments);
};
VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);

	// general renderer
	Renderer = VMLRenderer;
}

// This method is used with exporting in old IE, when emulating SVG (see #2314)
SVGRenderer.prototype.measureSpanWidth = function (text, styles) {
	var measuringSpan = doc.createElement('span'),
		offsetWidth,
	textNode = doc.createTextNode(text);

	measuringSpan.appendChild(textNode);
	css(measuringSpan, styles);
	this.box.appendChild(measuringSpan);
	offsetWidth = measuringSpan.offsetWidth;
	discardElement(measuringSpan); // #2463
	return offsetWidth;
};


/* ****************************************************************************
 *                                                                            *
 * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
 *                                                                            *
 *****************************************************************************/
/* ****************************************************************************
 *                                                                            *
 * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *
 * TARGETING THAT SYSTEM.                                                     *
 *                                                                            *
 *****************************************************************************/
var CanVGRenderer,
	CanVGController;

if (useCanVG) {
	/**
	 * The CanVGRenderer is empty from start to keep the source footprint small.
	 * When requested, the CanVGController downloads the rest of the source packaged
	 * together with the canvg library.
	 */
	Highcharts.CanVGRenderer = CanVGRenderer = function () {
		// Override the global SVG namespace to fake SVG/HTML that accepts CSS
		SVG_NS = 'http://www.w3.org/1999/xhtml';
	};

	/**
	 * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but 
	 * the implementation from SvgRenderer will not be merged in until first render.
	 */
	CanVGRenderer.prototype.symbols = {};

	/**
	 * Handles on demand download of canvg rendering support.
	 */
	CanVGController = (function () {
		// List of renderering calls
		var deferredRenderCalls = [];

		/**
		 * When downloaded, we are ready to draw deferred charts.
		 */
		function drawDeferred() {
			var callLength = deferredRenderCalls.length,
				callIndex;

			// Draw all pending render calls
			for (callIndex = 0; callIndex < callLength; callIndex++) {
				deferredRenderCalls[callIndex]();
			}
			// Clear the list
			deferredRenderCalls = [];
		}

		return {
			push: function (func, scriptLocation) {
				// Only get the script once
				if (deferredRenderCalls.length === 0) {
					getScript(scriptLocation, drawDeferred);
				}
				// Register render call
				deferredRenderCalls.push(func);
			}
		};
	}());

	Renderer = CanVGRenderer;
} // end CanVGRenderer

/* ****************************************************************************
 *                                                                            *
 * END OF ANDROID < 3 SPECIFIC CODE                                           *
 *                                                                            *
 *****************************************************************************/

/**
 * The Tick class
 */
function Tick(axis, pos, type, noLabel) {
	this.axis = axis;
	this.pos = pos;
	this.type = type || '';
	this.isNew = true;

	if (!type && !noLabel) {
		this.addLabel();
	}
}

Tick.prototype = {
	/**
	 * Write the tick label
	 */
	addLabel: function () {
		var tick = this,
			axis = tick.axis,
			options = axis.options,
			chart = axis.chart,
			categories = axis.categories,
			names = axis.names,
			pos = tick.pos,
			labelOptions = options.labels,
			str,
			tickPositions = axis.tickPositions,
			isFirst = pos === tickPositions[0],
			isLast = pos === tickPositions[tickPositions.length - 1],
			value = categories ?
				pick(categories[pos], names[pos], pos) :
				pos,
			label = tick.label,
			tickPositionInfo = tickPositions.info,
			dateTimeLabelFormat;

		// Set the datetime label format. If a higher rank is set for this position, use that. If not,
		// use the general format.
		if (axis.isDatetimeAxis && tickPositionInfo) {
			dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
		}
		// set properties for access in render method
		tick.isFirst = isFirst;
		tick.isLast = isLast;

		// get the string
		str = axis.labelFormatter.call({
			axis: axis,
			chart: chart,
			isFirst: isFirst,
			isLast: isLast,
			dateTimeLabelFormat: dateTimeLabelFormat,
			value: axis.isLog ? correctFloat(lin2log(value)) : value
		});

		// prepare CSS
		//css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };
		
		// first call
		if (!defined(label)) {

			tick.label = label =
				defined(str) && labelOptions.enabled ?
					chart.renderer.text(
							str,
							0,
							0,
							labelOptions.useHTML
						)
						//.attr(attr)
						// without position absolute, IE export sometimes is wrong
						.css(merge(labelOptions.style))
						.add(axis.labelGroup) :
					null;
			tick.labelLength = label && label.getBBox().width; // Un-rotated length
			tick.rotation = 0; // Base value to detect change for new calls to getBBox

		// update
		} else if (label) {
			label.attr({ text: str });
		}
	},

	/**
	 * Get the offset height or width of the label
	 */
	getLabelSize: function () {
		return this.label ?
			this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
			0;
	},

	/**
	 * Handle the label overflow by adjusting the labels to the left and right edge, or
	 * hide them if they collide into the neighbour label.
	 */
	handleOverflow: function (xy) {
		var axis = this.axis,
			pxPos = xy.x,
			chartWidth = axis.chart.chartWidth,
			spacing = axis.chart.spacing,
			leftBound = pick(axis.labelLeft, mathMin(axis.pos, spacing[3])),
			rightBound = pick(axis.labelRight, mathMax(axis.pos + axis.len, chartWidth - spacing[1])),
			label = this.label,
			rotation = this.rotation,
			factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],
			labelWidth = label.getBBox().width,
			slotWidth = axis.slotWidth,
			xCorrection = factor,
			goRight = 1,
			leftPos,
			rightPos,
			textWidth,
			css = {};

		// Check if the label overshoots the chart spacing box. If it does, move it.
		// If it now overshoots the slotWidth, add ellipsis.
		if (!rotation) {
			leftPos = pxPos - factor * labelWidth;
			rightPos = pxPos + (1 - factor) * labelWidth;

			if (leftPos < leftBound) {
				slotWidth = xy.x + slotWidth * (1 - factor) - leftBound;
			} else if (rightPos > rightBound) {
				slotWidth = rightBound - xy.x + slotWidth * factor;
				goRight = -1;
			}

			slotWidth = mathMin(axis.slotWidth, slotWidth); // #4177
			if (slotWidth < axis.slotWidth && axis.labelAlign === 'center') {
				xy.x += goRight * (axis.slotWidth - slotWidth - xCorrection * (axis.slotWidth - mathMin(labelWidth, slotWidth)));				
			}
			// If the label width exceeds the available space, set a text width to be 
			// picked up below. Also, if a width has been set before, we need to set a new
			// one because the reported labelWidth will be limited by the box (#3938).
			if (labelWidth > slotWidth || (axis.autoRotation && label.styles.width)) {
				textWidth = slotWidth;
			}

		// Add ellipsis to prevent rotated labels to be clipped against the edge of the chart
		} else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
			textWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);
		} else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
			textWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));
		}

		if (textWidth) {
			css.width = textWidth;
			if (!axis.options.labels.style.textOverflow) {
				css.textOverflow = 'ellipsis';
			}
			label.css(css);
		}
	},

	/**
	 * Get the x and y position for ticks and labels
	 */
	getPosition: function (horiz, pos, tickmarkOffset, old) {
		var axis = this.axis,
			chart = axis.chart,
			cHeight = (old && chart.oldChartHeight) || chart.chartHeight;

		return {
			x: horiz ?
				axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :
				axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),

			y: horiz ?
				cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :
				cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
		};

	},

	/**
	 * Get the x, y position of the tick label
	 */
	getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
		var axis = this.axis,
			transA = axis.transA,
			reversed = axis.reversed,
			staggerLines = axis.staggerLines,
			rotCorr = axis.tickRotCorr || { x: 0, y: 0 },
			yOffset = pick(labelOptions.y, rotCorr.y + (axis.side === 2 ? 8 : -(label.getBBox().height / 2))),
			line;

		x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?
			tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
		y = y + yOffset - (tickmarkOffset && !horiz ?
			tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

		// Correct for staggered labels
		if (staggerLines) {
			line = (index / (step || 1) % staggerLines);
			y += line * (axis.labelOffset / staggerLines);
		}

		return {
			x: x,
			y: mathRound(y)
		};
	},

	/**
	 * Extendible method to return the path of the marker
	 */
	getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
		return renderer.crispLine([
				M,
				x,
				y,
				L,
				x + (horiz ? 0 : -tickLength),
				y + (horiz ? tickLength : 0)
			], tickWidth);
	},

	/**
	 * Put everything in place
	 *
	 * @param index {Number}
	 * @param old {Boolean} Use old coordinates to prepare an animation into new position
	 */
	render: function (index, old, opacity) {
		var tick = this,
			axis = tick.axis,
			options = axis.options,
			chart = axis.chart,
			renderer = chart.renderer,
			horiz = axis.horiz,
			type = tick.type,
			label = tick.label,
			pos = tick.pos,
			labelOptions = options.labels,
			gridLine = tick.gridLine,
			gridPrefix = type ? type + 'Grid' : 'grid',
			tickPrefix = type ? type + 'Tick' : 'tick',
			gridLineWidth = options[gridPrefix + 'LineWidth'],
			gridLineColor = options[gridPrefix + 'LineColor'],
			dashStyle = options[gridPrefix + 'LineDashStyle'],
			tickLength = options[tickPrefix + 'Length'],
			tickWidth = pick(options[tickPrefix + 'Width'], !type && axis.isXAxis ? 1 : 0), // X axis defaults to 1
			tickColor = options[tickPrefix + 'Color'],
			tickPosition = options[tickPrefix + 'Position'],
			gridLinePath,
			mark = tick.mark,
			markPath,
			step = /*axis.labelStep || */labelOptions.step,
			attribs,
			show = true,
			tickmarkOffset = axis.tickmarkOffset,
			xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
			x = xy.x,
			y = xy.y,
			reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687

		opacity = pick(opacity, 1);
		this.isActive = true;

		// create the grid line
		if (gridLineWidth) {
			gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);

			if (gridLine === UNDEFINED) {
				attribs = {
					stroke: gridLineColor,
					'stroke-width': gridLineWidth
				};
				if (dashStyle) {
					attribs.dashstyle = dashStyle;
				}
				if (!type) {
					attribs.zIndex = 1;
				}
				if (old) {
					attribs.opacity = 0;
				}
				tick.gridLine = gridLine =
					gridLineWidth ?
						renderer.path(gridLinePath)
							.attr(attribs).add(axis.gridGroup) :
						null;
			}

			// If the parameter 'old' is set, the current call will be followed
			// by another call, therefore do not do any animations this time
			if (!old && gridLine && gridLinePath) {
				gridLine[tick.isNew ? 'attr' : 'animate']({
					d: gridLinePath,
					opacity: opacity
				});
			}
		}

		// create the tick mark
		if (tickWidth && tickLength) {

			// negate the length
			if (tickPosition === 'inside') {
				tickLength = -tickLength;
			}
			if (axis.opposite) {
				tickLength = -tickLength;
			}

			markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);
			if (mark) { // updating
				mark.animate({
					d: markPath,
					opacity: opacity
				});
			} else { // first time
				tick.mark = renderer.path(
					markPath
				).attr({
					stroke: tickColor,
					'stroke-width': tickWidth,
					opacity: opacity
				}).add(axis.axisGroup);
			}
		}

		// the label is created on init - now move it into place
		if (label && !isNaN(x)) {
			label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);

			// Apply show first and show last. If the tick is both first and last, it is
			// a single centered tick, in which case we show the label anyway (#2100).
			if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||
					(tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {
				show = false;

			// Handle label overflow and show or hide accordingly
			} else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
				tick.handleOverflow(xy);
			}

			// apply step
			if (step && index % step) {
				// show those indices dividable by step
				show = false;
			}

			// Set the new position, and show or hide
			if (show && !isNaN(xy.y)) {
				xy.opacity = opacity;
				label[tick.isNew ? 'attr' : 'animate'](xy);
				tick.isNew = false;
			} else {
				label.attr('y', -9999); // #1338
			}
		}
	},

	/**
	 * Destructor for the tick prototype
	 */
	destroy: function () {
		destroyObjectProperties(this, this.axis);
	}
};

/**
 * The object wrapper for plot lines and plot bands
 * @param {Object} options
 */
Highcharts.PlotLineOrBand = function (axis, options) {
	this.axis = axis;

	if (options) {
		this.options = options;
		this.id = options.id;
	}
};

Highcharts.PlotLineOrBand.prototype = {
	
	/**
	 * Render the plot line or plot band. If it is already existing,
	 * move it.
	 */
	render: function () {
		var plotLine = this,
			axis = plotLine.axis,
			horiz = axis.horiz,
			options = plotLine.options,
			optionsLabel = options.label,
			label = plotLine.label,
			width = options.width,
			to = options.to,
			from = options.from,
			isBand = defined(from) && defined(to),
			value = options.value,
			dashStyle = options.dashStyle,
			svgElem = plotLine.svgElem,
			path = [],
			addEvent,
			eventType,
			xs,
			ys,
			x,
			y,
			color = options.color,
			zIndex = options.zIndex,
			events = options.events,
			attribs = {},
			renderer = axis.chart.renderer;

		// logarithmic conversion
		if (axis.isLog) {
			from = log2lin(from);
			to = log2lin(to);
			value = log2lin(value);
		}

		// plot line
		if (width) {
			path = axis.getPlotLinePath(value, width);
			attribs = {
				stroke: color,
				'stroke-width': width
			};
			if (dashStyle) {
				attribs.dashstyle = dashStyle;
			}
		} else if (isBand) { // plot band

			path = axis.getPlotBandPath(from, to, options);
			if (color) {
				attribs.fill = color;
			}
			if (options.borderWidth) {
				attribs.stroke = options.borderColor;
				attribs['stroke-width'] = options.borderWidth;
			}
		} else {
			return;
		}
		// zIndex
		if (defined(zIndex)) {
			attribs.zIndex = zIndex;
		}

		// common for lines and bands
		if (svgElem) {
			if (path) {
				svgElem.animate({
					d: path
				}, null, svgElem.onGetPath);
			} else {
				svgElem.hide();
				svgElem.onGetPath = function () {
					svgElem.show();
				};
				if (label) {
					plotLine.label = label = label.destroy();
				}
			}
		} else if (path && path.length) {
			plotLine.svgElem = svgElem = renderer.path(path)
				.attr(attribs).add();

			// events
			if (events) {
				addEvent = function (eventType) {
					svgElem.on(eventType, function (e) {
						events[eventType].apply(plotLine, [e]);
					});
				};
				for (eventType in events) {
					addEvent(eventType);
				}
			}
		}

		// the plot band/line label
		if (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {
			// apply defaults
			optionsLabel = merge({
				align: horiz && isBand && 'center',
				x: horiz ? !isBand && 4 : 10,
				verticalAlign : !horiz && isBand && 'middle',
				y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
				rotation: horiz && !isBand && 90
			}, optionsLabel);

			// add the SVG element
			if (!label) {
				attribs = {
					align: optionsLabel.textAlign || optionsLabel.align,
					rotation: optionsLabel.rotation
				};
				if (defined(zIndex)) {
					attribs.zIndex = zIndex;
				}
				plotLine.label = label = renderer.text(
						optionsLabel.text,
						0,
						0,
						optionsLabel.useHTML
					)
					.attr(attribs)
					.css(optionsLabel.style)
					.add();
			}

			// get the bounding box and align the label
			// #3000 changed to better handle choice between plotband or plotline
			xs = [path[1], path[4], (isBand ? path[6] : path[1])];
			ys = [path[2], path[5], (isBand ? path[7] : path[2])];
			x = arrayMin(xs);
			y = arrayMin(ys);

			label.align(optionsLabel, false, {
				x: x,
				y: y,
				width: arrayMax(xs) - x,
				height: arrayMax(ys) - y
			});
			label.show();

		} else if (label) { // move out of sight
			label.hide();
		}

		// chainable
		return plotLine;
	},

	/**
	 * Remove the plot line or band
	 */
	destroy: function () {
		// remove it from the lookup
		erase(this.axis.plotLinesAndBands, this);
		
		delete this.axis;
		destroyObjectProperties(this);
	}
};

/**
 * Object with members for extending the Axis prototype
 */

AxisPlotLineOrBandExtension = {

	/**
	 * Create the path for a plot band
	 */ 
	getPlotBandPath: function (from, to) {
		var toPath = this.getPlotLinePath(to, null, null, true),
			path = this.getPlotLinePath(from, null, null, true);

		if (path && toPath && path.toString() !== toPath.toString()) { // #3836
			path.push(
				toPath[4],
				toPath[5],
				toPath[1],
				toPath[2]
			);
		} else { // outside the axis area
			path = null;
		}
		
		return path;
	},

	addPlotBand: function (options) {
		return this.addPlotBandOrLine(options, 'plotBands');
	},
	
	addPlotLine: function (options) {
		return this.addPlotBandOrLine(options, 'plotLines');
	},

	/**
	 * Add a plot band or plot line after render time
	 *
	 * @param options {Object} The plotBand or plotLine configuration object
	 */
	addPlotBandOrLine: function (options, coll) {
		var obj = new Highcharts.PlotLineOrBand(this, options).render(),
			userOptions = this.userOptions;

		if (obj) { // #2189
			// Add it to the user options for exporting and Axis.update
			if (coll) {
				userOptions[coll] = userOptions[coll] || [];
				userOptions[coll].push(options); 
			}
			this.plotLinesAndBands.push(obj); 
		}
		
		return obj;
	},

	/**
	 * Remove a plot band or plot line from the chart by id
	 * @param {Object} id
	 */
	removePlotBandOrLine: function (id) {
		var plotLinesAndBands = this.plotLinesAndBands,
			options = this.options,
			userOptions = this.userOptions,
			i = plotLinesAndBands.length;
		while (i--) {
			if (plotLinesAndBands[i].id === id) {
				plotLinesAndBands[i].destroy();
			}
		}
		each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {
			i = arr.length;
			while (i--) {
				if (arr[i].id === id) {
					erase(arr, arr[i]);
				}
			}
		});
	}
};

/**
 * Create a new axis object
 * @param {Object} chart
 * @param {Object} options
 */
var Axis = Highcharts.Axis = function () {
	this.init.apply(this, arguments);
};

Axis.prototype = {

	/**
	 * Default options for the X axis - the Y axis has extended defaults
	 */
	defaultOptions: {
		// allowDecimals: null,
		// alternateGridColor: null,
		// categories: [],
		dateTimeLabelFormats: {
			millisecond: '%H:%M:%S.%L',
			second: '%H:%M:%S',
			minute: '%H:%M',
			hour: '%H:%M',
			day: '%e. %b',
			week: '%e. %b',
			month: '%b \'%y',
			year: '%Y'
		},
		endOnTick: false,
		gridLineColor: '#D8D8D8',
		// gridLineDashStyle: 'solid',
		// gridLineWidth: 0,
		// reversed: false,

		labels: {
			enabled: true,
			// rotation: 0,
			// align: 'center',
			// step: null,
			style: {
				color: '#606060',
				cursor: 'default',
				fontSize: '11px'
			},
			x: 0,
			y: 15
			/*formatter: function () {
				return this.value;
			},*/
		},
		lineColor: '#C0D0E0',
		lineWidth: 1,
		//linkedTo: null,
		//max: undefined,
		//min: undefined,
		minPadding: 0.01,
		maxPadding: 0.01,
		//minRange: null,
		minorGridLineColor: '#E0E0E0',
		// minorGridLineDashStyle: null,
		minorGridLineWidth: 1,
		minorTickColor: '#A0A0A0',
		//minorTickInterval: null,
		minorTickLength: 2,
		minorTickPosition: 'outside', // inside or outside
		//minorTickWidth: 0,
		//opposite: false,
		//offset: 0,
		//plotBands: [{
		//	events: {},
		//	zIndex: 1,
		//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
		//}],
		//plotLines: [{
		//	events: {}
		//  dashStyle: {}
		//	zIndex:
		//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
		//}],
		//reversed: false,
		// showFirstLabel: true,
		// showLastLabel: true,
		startOfWeek: 1,
		startOnTick: false,
		tickColor: '#C0D0E0',
		//tickInterval: null,
		tickLength: 10,
		tickmarkPlacement: 'between', // on or between
		tickPixelInterval: 100,
		tickPosition: 'outside',
		//tickWidth: 1,
		title: {
			//text: null,
			align: 'middle', // low, middle or high
			//margin: 0 for horizontal, 10 for vertical axes,
			//rotation: 0,
			//side: 'outside',
			style: {
				color: '#707070'
			}
			//x: 0,
			//y: 0
		},
		type: 'linear' // linear, logarithmic or datetime
		//visible: true
	},

	/**
	 * This options set extends the defaultOptions for Y axes
	 */
	defaultYAxisOptions: {
		endOnTick: true,
		gridLineWidth: 1,
		tickPixelInterval: 72,
		showLastLabel: true,
		labels: {
			x: -8,
			y: 3
		},
		lineWidth: 0,
		maxPadding: 0.05,
		minPadding: 0.05,
		startOnTick: true,
		//tickWidth: 0,
		title: {
			rotation: 270,
			text: 'Values'
		},
		stackLabels: {
			enabled: false,
			//align: dynamic,
			//y: dynamic,
			//x: dynamic,
			//verticalAlign: dynamic,
			//textAlign: dynamic,
			//rotation: 0,
			formatter: function () {
				return Highcharts.numberFormat(this.total, -1);
			},
			style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })
		}
	},

	/**
	 * These options extend the defaultOptions for left axes
	 */
	defaultLeftAxisOptions: {
		labels: {
			x: -15,
			y: null
		},
		title: {
			rotation: 270
		}
	},

	/**
	 * These options extend the defaultOptions for right axes
	 */
	defaultRightAxisOptions: {
		labels: {
			x: 15,
			y: null
		},
		title: {
			rotation: 90
		}
	},

	/**
	 * These options extend the defaultOptions for bottom axes
	 */
	defaultBottomAxisOptions: {
		labels: {
			autoRotation: [-45],
			x: 0,
			y: null // based on font size
			// overflow: undefined,
			// staggerLines: null
		},
		title: {
			rotation: 0
		}
	},
	/**
	 * These options extend the defaultOptions for top axes
	 */
	defaultTopAxisOptions: {
		labels: {
			autoRotation: [-45],
			x: 0,
			y: -15
			// overflow: undefined
			// staggerLines: null
		},
		title: {
			rotation: 0
		}
	},

	/**
	 * Initialize the axis
	 */
	init: function (chart, userOptions) {


		var isXAxis = userOptions.isX,
			axis = this;

		axis.chart = chart;

		// Flag, is the axis horizontal
		axis.horiz = chart.inverted ? !isXAxis : isXAxis;

		// Flag, isXAxis
		axis.isXAxis = isXAxis;
		axis.coll = isXAxis ? 'xAxis' : 'yAxis';

		axis.opposite = userOptions.opposite; // needed in setOptions
		axis.side = userOptions.side || (axis.horiz ?
				(axis.opposite ? 0 : 2) : // top : bottom
				(axis.opposite ? 1 : 3));  // right : left

		axis.setOptions(userOptions);


		var options = this.options,
			type = options.type,
			isDatetimeAxis = type === 'datetime';

		axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format


		// Flag, stagger lines or not
		axis.userOptions = userOptions;

		//axis.axisTitleMargin = UNDEFINED,// = options.title.margin,
		axis.minPixelPadding = 0;

		axis.reversed = options.reversed;
		axis.visible = options.visible !== false;
		axis.zoomEnabled = options.zoomEnabled !== false;

		// Initial categories
		axis.categories = options.categories || type === 'category';
		axis.names = axis.names || []; // Preserve on update (#3830)

		// Elements
		//axis.axisGroup = UNDEFINED;
		//axis.gridGroup = UNDEFINED;
		//axis.axisTitle = UNDEFINED;
		//axis.axisLine = UNDEFINED;

		// Shorthand types
		axis.isLog = type === 'logarithmic';
		axis.isDatetimeAxis = isDatetimeAxis;

		// Flag, if axis is linked to another axis
		axis.isLinked = defined(options.linkedTo);
		// Linked axis.
		//axis.linkedParent = UNDEFINED;

		// Tick positions
		//axis.tickPositions = UNDEFINED; // array containing predefined positions
		// Tick intervals
		//axis.tickInterval = UNDEFINED;
		//axis.minorTickInterval = UNDEFINED;

		
		// Major ticks
		axis.ticks = {};
		axis.labelEdge = [];
		// Minor ticks
		axis.minorTicks = {};

		// List of plotLines/Bands
		axis.plotLinesAndBands = [];

		// Alternate bands
		axis.alternateBands = {};

		// Axis metrics
		//axis.left = UNDEFINED;
		//axis.top = UNDEFINED;
		//axis.width = UNDEFINED;
		//axis.height = UNDEFINED;
		//axis.bottom = UNDEFINED;
		//axis.right = UNDEFINED;
		//axis.transA = UNDEFINED;
		//axis.transB = UNDEFINED;
		//axis.oldTransA = UNDEFINED;
		axis.len = 0;
		//axis.oldMin = UNDEFINED;
		//axis.oldMax = UNDEFINED;
		//axis.oldUserMin = UNDEFINED;
		//axis.oldUserMax = UNDEFINED;
		//axis.oldAxisLength = UNDEFINED;
		axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
		axis.range = options.range;
		axis.offset = options.offset || 0;


		// Dictionary for stacks
		axis.stacks = {};
		axis.oldStacks = {};
		axis.stacksTouched = 0;

		// Min and max in the data
		//axis.dataMin = UNDEFINED,
		//axis.dataMax = UNDEFINED,

		// The axis range
		axis.max = null;
		axis.min = null;

		// User set min and max
		//axis.userMin = UNDEFINED,
		//axis.userMax = UNDEFINED,

		// Crosshair options
		axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);
		// Run Axis

		var eventType,
			events = axis.options.events;

		// Register
		if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()
			if (isXAxis && !this.isColorAxis) { // #2713
				chart.axes.splice(chart.xAxis.length, 0, axis);
			} else {
				chart.axes.push(axis);
			}

			chart[axis.coll].push(axis);
		}

		axis.series = axis.series || []; // populated by Series

		// inverted charts have reversed xAxes as default
		if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {
			axis.reversed = true;
		}

		axis.removePlotBand = axis.removePlotBandOrLine;
		axis.removePlotLine = axis.removePlotBandOrLine;


		// register event listeners
		for (eventType in events) {
			addEvent(axis, eventType, events[eventType]);
		}

		// extend logarithmic axis
		if (axis.isLog) {
			axis.val2lin = log2lin;
			axis.lin2val = lin2log;
		}
	},

	/**
	 * Merge and set options
	 */
	setOptions: function (userOptions) {
		this.options = merge(
			this.defaultOptions,
			this.isXAxis ? {} : this.defaultYAxisOptions,
			[this.defaultTopAxisOptions, this.defaultRightAxisOptions,
				this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],
			merge(
				defaultOptions[this.coll], // if set in setOptions (#1053)
				userOptions
			)
		);
	},

	/**
	 * The default label formatter. The context is a special config object for the label.
	 */
	defaultLabelFormatter: function () {
		var axis = this.axis,
			value = this.value,
			categories = axis.categories,
			dateTimeLabelFormat = this.dateTimeLabelFormat,
			numericSymbols = defaultOptions.lang.numericSymbols,
			i = numericSymbols && numericSymbols.length,
			multi,
			ret,
			formatOption = axis.options.labels.format,

			// make sure the same symbol is added for all labels on a linear axis
			numericSymbolDetector = axis.isLog ? value : axis.tickInterval;

		if (formatOption) {
			ret = format(formatOption, this);

		} else if (categories) {
			ret = value;

		} else if (dateTimeLabelFormat) { // datetime axis
			ret = dateFormat(dateTimeLabelFormat, value);

		} else if (i && numericSymbolDetector >= 1000) {
			// Decide whether we should add a numeric symbol like k (thousands) or M (millions).
			// If we are to enable this in tooltip or other places as well, we can move this
			// logic to the numberFormatter and enable it by a parameter.
			while (i-- && ret === UNDEFINED) {
				multi = Math.pow(1000, i + 1);
				if (numericSymbolDetector >= multi && (value * 10) % multi === 0 && numericSymbols[i] !== null) {
					ret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];
				}
			}
		}

		if (ret === UNDEFINED) {
			if (mathAbs(value) >= 10000) { // add thousands separators
				ret = Highcharts.numberFormat(value, -1);

			} else { // small numbers
				ret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466
			}
		}

		return ret;
	},

	/**
	 * Get the minimum and maximum for the series of each axis
	 */
	getSeriesExtremes: function () {
		var axis = this,
			chart = axis.chart;

		axis.hasVisibleSeries = false;

		// Reset properties in case we're redrawing (#3353)
		axis.dataMin = axis.dataMax = axis.threshold = null;
		axis.softThreshold = !axis.isXAxis;
		
		if (axis.buildStacks) {
			axis.buildStacks();
		}

		// loop through this axis' series
		each(axis.series, function (series) {

			if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

				var seriesOptions = series.options,
					xData,
					threshold = seriesOptions.threshold,
					seriesDataMin,
					seriesDataMax;

				axis.hasVisibleSeries = true;

				// Validate threshold in logarithmic axes
				if (axis.isLog && threshold <= 0) {
					threshold = null;
				}

				// Get dataMin and dataMax for X axes
				if (axis.isXAxis) {
					xData = series.xData;
					if (xData.length) {
						axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));
						axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));
					}

				// Get dataMin and dataMax for Y axes, as well as handle stacking and processed data
				} else {

					// Get this particular series extremes
					series.getExtremes();
					seriesDataMax = series.dataMax;
					seriesDataMin = series.dataMin;

					// Get the dataMin and dataMax so far. If percentage is used, the min and max are
					// always 0 and 100. If seriesDataMin and seriesDataMax is null, then series
					// doesn't have active y data, we continue with nulls
					if (defined(seriesDataMin) && defined(seriesDataMax)) {
						axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);
						axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);
					}

					// Adjust to threshold
					if (defined(threshold)) {
						axis.threshold = threshold;
					}
					// If any series has a hard threshold, it takes precedence
					if (!seriesOptions.softThreshold || axis.isLog) {
						axis.softThreshold = false;
					}
				}
			}
		});
	},

	/**
	 * Translate from axis value to pixel position on the chart, or back
	 *
	 */
	translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {
		var axis = this.linkedParent || this, // #1417
			sign = 1,
			cvsOffset = 0,
			localA = old ? axis.oldTransA : axis.transA,
			localMin = old ? axis.oldMin : axis.min,
			returnValue,
			minPixelPadding = axis.minPixelPadding,
			doPostTranslate = (axis.doPostTranslate || (axis.isLog && handleLog)) && axis.lin2val;

		if (!localA) {
			localA = axis.transA;
		}

		// In vertical axes, the canvas coordinates start from 0 at the top like in
		// SVG.
		if (cvsCoord) {
			sign *= -1; // canvas coordinates inverts the value
			cvsOffset = axis.len;
		}

		// Handle reversed axis
		if (axis.reversed) {
			sign *= -1;
			cvsOffset -= sign * (axis.sector || axis.len);
		}

		// From pixels to value
		if (backwards) { // reverse translation

			val = val * sign + cvsOffset;
			val -= minPixelPadding;
			returnValue = val / localA + localMin; // from chart pixel to value
			if (doPostTranslate) { // log and ordinal axes
				returnValue = axis.lin2val(returnValue);
			}

		// From value to pixels
		} else {
			if (doPostTranslate) { // log and ordinal axes
				val = axis.val2lin(val);
			}
			if (pointPlacement === 'between') {
				pointPlacement = 0.5;
			}
			returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +
				(isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);
		}

		return returnValue;
	},

	/**
	 * Utility method to translate an axis value to pixel position.
	 * @param {Number} value A value in terms of axis units
	 * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart
	 *        or just the axis/pane itself.
	 */
	toPixels: function (value, paneCoordinates) {
		return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
	},

	/*
	 * Utility method to translate a pixel position in to an axis value
	 * @param {Number} pixel The pixel value coordinate
	 * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the
	 *        axis/pane itself.
	 */
	toValue: function (pixel, paneCoordinates) {
		return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
	},

	/**
	 * Create the path for a plot line that goes from the given value on
	 * this axis, across the plot to the opposite side
	 * @param {Number} value
	 * @param {Number} lineWidth Used for calculation crisp line
	 * @param {Number] old Use old coordinates (for resizing and rescaling)
	 */
	getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {
		var axis = this,
			chart = axis.chart,
			axisLeft = axis.left,
			axisTop = axis.top,
			x1,
			y1,
			x2,
			y2,
			cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
			cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
			skip,
			transB = axis.transB,
			/**
			 * Check if x is between a and b. If not, either move to a/b or skip, 
			 * depending on the force parameter.
			 */
			between = function (x, a, b) {
				if (x < a || x > b) {
					if (force) {
						x = mathMin(mathMax(a, x), b);
					} else {
						skip = true;
					}
				}
				return x;
			};

		translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
		x1 = x2 = mathRound(translatedValue + transB);
		y1 = y2 = mathRound(cHeight - translatedValue - transB);

		if (isNaN(translatedValue)) { // no min or max
			skip = true;

		} else if (axis.horiz) {
			y1 = axisTop;
			y2 = cHeight - axis.bottom;
			x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
		} else {
			x1 = axisLeft;
			x2 = cWidth - axis.right;
			y1 = y2 = between(y1, axisTop, axisTop + axis.height);
		}
		return skip && !force ?
			null :
			chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);
	},

	/**
	 * Set the tick positions of a linear axis to round values like whole tens or every five.
	 */
	getLinearTickPositions: function (tickInterval, min, max) {
		var pos,
			lastPos,
			roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
			roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),
			tickPositions = [];

		// For single points, add a tick regardless of the relative position (#2662)
		if (min === max && isNumber(min)) {
			return [min];
		}

		// Populate the intermediate values
		pos = roundedMin;
		while (pos <= roundedMax) {

			// Place the tick on the rounded value
			tickPositions.push(pos);

			// Always add the raw tickInterval, not the corrected one.
			pos = correctFloat(pos + tickInterval);

			// If the interval is not big enough in the current min - max range to actually increase
			// the loop variable, we need to break out to prevent endless loop. Issue #619
			if (pos === lastPos) {
				break;
			}

			// Record the last value
			lastPos = pos;
		}
		return tickPositions;
	},

	/**
	 * Return the minor tick positions. For logarithmic axes, reuse the same logic
	 * as for major ticks.
	 */
	getMinorTickPositions: function () {
		var axis = this,
			options = axis.options,
			tickPositions = axis.tickPositions,
			minorTickInterval = axis.minorTickInterval,
			minorTickPositions = [],
			pos,
			i,
			pointRangePadding = axis.pointRangePadding || 0, 
			min = axis.min - pointRangePadding, // #1498
			max = axis.max + pointRangePadding, // #1498
			range = max - min,
			len;

		// If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.
		if (range && range / minorTickInterval < axis.len / 3) { // #3875

			if (axis.isLog) {
				len = tickPositions.length;
				for (i = 1; i < len; i++) {
					minorTickPositions = minorTickPositions.concat(
						axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
					);
				}
			} else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314
				minorTickPositions = minorTickPositions.concat(
					axis.getTimeTicks(
						axis.normalizeTimeTickInterval(minorTickInterval),
						min,
						max,
						options.startOfWeek
					)
				);
			} else {
				for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
					minorTickPositions.push(pos);
				}
			}
		}

		if(minorTickPositions.length !== 0) { // don't change the extremes, when there is no minor ticks
			axis.trimTicks(minorTickPositions, options.startOnTick, options.endOnTick); // #3652 #3743 #1498
		}
		return minorTickPositions;
	},

	/**
	 * Adjust the min and max for the minimum range. Keep in mind that the series data is
	 * not yet processed, so we don't have information on data cropping and grouping, or
	 * updated axis.pointRange or series.pointRange. The data can't be processed until
	 * we have finally established min and max.
	 */
	adjustForMinRange: function () {
		var axis = this,
			options = axis.options,
			min = axis.min,
			max = axis.max,
			zoomOffset,
			spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,
			closestDataRange,
			i,
			distance,
			xData,
			loopLength,
			minArgs,
			maxArgs,
			minRange;

		// Set the automatic minimum range based on the closest point distance
		if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {

			if (defined(options.min) || defined(options.max)) {
				axis.minRange = null; // don't do this again

			} else {

				// Find the closest distance between raw data points, as opposed to
				// closestPointRange that applies to processed points (cropped and grouped)
				each(axis.series, function (series) {
					xData = series.xData;
					loopLength = series.xIncrement ? 1 : xData.length - 1;
					for (i = loopLength; i > 0; i--) {
						distance = xData[i] - xData[i - 1];
						if (closestDataRange === UNDEFINED || distance < closestDataRange) {
							closestDataRange = distance;
						}
					}
				});
				axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);
			}
		}

		// if minRange is exceeded, adjust
		if (max - min < axis.minRange) {
			minRange = axis.minRange;
			zoomOffset = (minRange - max + min) / 2;

			// if min and max options have been set, don't go beyond it
			minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
			if (spaceAvailable) { // if space is available, stay within the data range
				minArgs[2] = axis.dataMin;
			}
			min = arrayMax(minArgs);

			maxArgs = [min + minRange, pick(options.max, min + minRange)];
			if (spaceAvailable) { // if space is availabe, stay within the data range
				maxArgs[2] = axis.dataMax;
			}

			max = arrayMin(maxArgs);

			// now if the max is adjusted, adjust the min back
			if (max - min < minRange) {
				minArgs[0] = max - minRange;
				minArgs[1] = pick(options.min, max - minRange);
				min = arrayMax(minArgs);
			}
		}

		// Record modified extremes
		axis.min = min;
		axis.max = max;
	},

	/**
	 * Update translation information
	 */
	setAxisTranslation: function (saveOld) {
		var axis = this,
			range = axis.max - axis.min,
			pointRange = axis.axisPointRange || 0,
			closestPointRange,
			minPointOffset = 0,
			pointRangePadding = 0,
			linkedParent = axis.linkedParent,
			ordinalCorrection,
			hasCategories = !!axis.categories,
			transA = axis.transA,
			isXAxis = axis.isXAxis;

		// Adjust translation for padding. Y axis with categories need to go through the same (#1784).
		if (isXAxis || hasCategories || pointRange) {
			if (linkedParent) {
				minPointOffset = linkedParent.minPointOffset;
				pointRangePadding = linkedParent.pointRangePadding;

			} else {
				each(axis.series, function (series) {
					var seriesPointRange = hasCategories ? 1 : (isXAxis ? series.pointRange : (axis.axisPointRange || 0)), // #2806
						pointPlacement = series.options.pointPlacement,
						seriesClosestPointRange = series.closestPointRange;

					pointRange = mathMax(pointRange, seriesPointRange);

					if (!axis.single) {
						// minPointOffset is the value padding to the left of the axis in order to make
						// room for points with a pointRange, typically columns. When the pointPlacement option
						// is 'between' or 'on', this padding does not apply.
						minPointOffset = mathMax(
							minPointOffset,
							isString(pointPlacement) ? 0 : seriesPointRange / 2
						);

						// Determine the total padding needed to the length of the axis to make room for the
						// pointRange. If the series' pointPlacement is 'on', no padding is added.
						pointRangePadding = mathMax(
							pointRangePadding,
							pointPlacement === 'on' ? 0 : seriesPointRange
						);
					}

					// Set the closestPointRange
					if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {
						closestPointRange = defined(closestPointRange) ?
							mathMin(closestPointRange, seriesClosestPointRange) :
							seriesClosestPointRange;
					}
				});
			}

			// Record minPointOffset and pointRangePadding
			ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853
			axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
			axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;

			// pointRange means the width reserved for each point, like in a column chart
			axis.pointRange = mathMin(pointRange, range);

			// closestPointRange means the closest distance between points. In columns
			// it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
			// is some other value
			if (isXAxis) {
				axis.closestPointRange = closestPointRange;
			}
		}

		// Secondary values
		if (saveOld) {
			axis.oldTransA = transA;
		}
		axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);
		axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend
		axis.minPixelPadding = transA * minPointOffset;
	},

	minFromRange: function () {
		return this.max - this.range;
	},

	/**
	 * Set the tick positions to round values and optionally extend the extremes
	 * to the nearest tick
	 */
	setTickInterval: function (secondPass) {
		var axis = this,
			chart = axis.chart,
			options = axis.options,
			isLog = axis.isLog,
			isDatetimeAxis = axis.isDatetimeAxis,
			isXAxis = axis.isXAxis,
			isLinked = axis.isLinked,
			maxPadding = options.maxPadding,
			minPadding = options.minPadding,
			length,
			linkedParentExtremes,
			tickIntervalOption = options.tickInterval,
			minTickInterval,
			tickPixelIntervalOption = options.tickPixelInterval,
			categories = axis.categories,
			threshold = axis.threshold,
			softThreshold = axis.softThreshold,
			thresholdMin,
			thresholdMax,
			hardMin,
			hardMax;

		if (!isDatetimeAxis && !categories && !isLinked) {
			this.getTickAmount();
		}

		// Min or max set either by zooming/setExtremes or initial options
		hardMin = pick(axis.userMin, options.min);
		hardMax = pick(axis.userMax, options.max);

		// Linked axis gets the extremes from the parent axis
		if (isLinked) {
			axis.linkedParent = chart[axis.coll][options.linkedTo];
			linkedParentExtremes = axis.linkedParent.getExtremes();
			axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
			axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
			if (options.type !== axis.linkedParent.options.type) {
				error(11, 1); // Can't link axes of different type
			}

		// Initial min and max from the extreme data values
		} else {

			// Adjust to hard threshold
			if (!softThreshold && defined(threshold)) {
				if (axis.dataMin >= threshold) {
					thresholdMin = threshold;
					minPadding = 0;
				} else if (axis.dataMax <= threshold) {
					thresholdMax = threshold;
					maxPadding = 0;
				}
			}

			axis.min = pick(hardMin, thresholdMin, axis.dataMin);
			axis.max = pick(hardMax, thresholdMax, axis.dataMax);

		}

		if (isLog) {
			if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978
				error(10, 1); // Can't plot negative values on log axis
			}
			// The correctFloat cures #934, float errors on full tens. But it
			// was too aggressive for #4360 because of conversion back to lin,
			// therefore use precision 15.
			axis.min = correctFloat(log2lin(axis.min), 15);
			axis.max = correctFloat(log2lin(axis.max), 15);
		}

		// handle zoomed range
		if (axis.range && defined(axis.max)) {
			axis.userMin = axis.min = hardMin = mathMax(axis.min, axis.minFromRange()); // #618
			axis.userMax = hardMax = axis.max;

			axis.range = null;  // don't use it when running setExtremes
		}

		// Hook for adjusting this.min and this.max. Used by bubble series.
		if (axis.beforePadding) {
			axis.beforePadding();
		}

		// adjust min and max for the minimum range
		axis.adjustForMinRange();

		// Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding
		// into account, we do this after computing tick interval (#1337).
		if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
			length = axis.max - axis.min;
			if (length) {
				if (!defined(hardMin) && minPadding) {
					axis.min -= length * minPadding;
				}
				if (!defined(hardMax)  && maxPadding) {
					axis.max += length * maxPadding;
				}
			}
		}

		// Stay within floor and ceiling
		if (isNumber(options.floor)) {
			axis.min = mathMax(axis.min, options.floor);
		}
		if (isNumber(options.ceiling)) {
			axis.max = mathMin(axis.max, options.ceiling);
		}

		// When the threshold is soft, adjust the extreme value only if 
		// the data extreme and the padded extreme land on either side of the threshold. For example,
		// a series of [0, 1, 2, 3] would make the yAxis add a tick for -1 because of the
		// default minPadding and startOnTick options. This is prevented by the softThreshold
		// option.
		if (softThreshold && defined(axis.dataMin)) {
			threshold = threshold || 0;
			if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {
				axis.min = threshold;
			} else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {
				axis.max = threshold;
			}
		}


		// get tickInterval
		if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
			axis.tickInterval = 1;
		} else if (isLinked && !tickIntervalOption &&
				tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
			axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
		} else {
			axis.tickInterval = pick(
				tickIntervalOption,
				this.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,
				categories ? // for categoried axis, 1 is default, for linear axis use tickPix
					1 :
					// don't let it be more than the data range
					(axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)
			);
		}

		// Now we're finished detecting min and max, crop and group series data. This
		// is in turn needed in order to find tick positions in ordinal axes.
		if (isXAxis && !secondPass) {
			each(axis.series, function (series) {
				series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
			});
		}

		// set the translation factor used in translate function
		axis.setAxisTranslation(true);

		// hook for ordinal axes and radial axes
		if (axis.beforeSetTickPositions) {
			axis.beforeSetTickPositions();
		}

		// hook for extensions, used in Highstock ordinal axes
		if (axis.postProcessTickInterval) {
			axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
		}

		// In column-like charts, don't cramp in more ticks than there are points (#1943)
		if (axis.pointRange) {
			axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);
		}

		// Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.
		minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);
		if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
			axis.tickInterval = minTickInterval;
		}

		// for linear axes, get magnitude and normalize the interval
		if (!isDatetimeAxis && !isLog && !tickIntervalOption) {
			axis.tickInterval = normalizeTickInterval(
				axis.tickInterval, 
				null, 
				getMagnitude(axis.tickInterval), 
				// If the tick interval is between 0.5 and 5 and the axis max is in the order of
				// thousands, chances are we are dealing with years. Don't allow decimals. #3363.
				pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),
				!!this.tickAmount
			);
		}
		
		// Prevent ticks from getting so close that we can't draw the labels
		if (!this.tickAmount && this.len) { // Color axis with disabled legend has no length
			axis.tickInterval = axis.unsquish();
		}

		this.setTickPositions();
	},

	/**
	 * Now we have computed the normalized tickInterval, get the tick positions
	 */
	setTickPositions: function () {

		var options = this.options,
			tickPositions,
			tickPositionsOption = options.tickPositions,
			tickPositioner = options.tickPositioner,
			startOnTick = options.startOnTick,
			endOnTick = options.endOnTick,
			single;

		// Set the tickmarkOffset
		this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' && 
			this.tickInterval === 1) ? 0.5 : 0; // #3202


		// get minorTickInterval
		this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?
			this.tickInterval / 5 : options.minorTickInterval;

		// Find the tick positions
		this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)
		if (!tickPositions) {

			if (this.isDatetimeAxis) {
				tickPositions = this.getTimeTicks(
					this.normalizeTimeTickInterval(this.tickInterval, options.units),
					this.min,
					this.max,
					options.startOfWeek,
					this.ordinalPositions,
					this.closestPointRange,
					true
				);
			} else if (this.isLog) {
				tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);
			} else {
				tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
			}

			// Too dense ticks, keep only the first and last (#4477)
			if (tickPositions.length > this.len) {
				tickPositions = [tickPositions[0], tickPositions.pop()];
			}

			this.tickPositions = tickPositions;

			// Run the tick positioner callback, that allows modifying auto tick positions.
			if (tickPositioner) {
				tickPositioner = tickPositioner.apply(this, [this.min, this.max]);
				if (tickPositioner) {
					this.tickPositions = tickPositions = tickPositioner;
				}
			}

		}

		if (!this.isLinked) {

			// reset min/max or remove extremes based on start/end on tick
			this.trimTicks(tickPositions, startOnTick, endOnTick);

			// When there is only one point, or all points have the same value on this axis, then min
			// and max are equal and tickPositions.length is 0 or 1. In this case, add some padding
			// in order to center the point, but leave it with one tick. #1337.
			if (this.min === this.max && defined(this.min) && !this.tickAmount) {
				// Substract half a unit (#2619, #2846, #2515, #3390)
				single = true;
				this.min -= 0.5;
				this.max += 0.5;
			}
			this.single = single;

			if (!tickPositionsOption && !tickPositioner) {
				this.adjustTickAmount();
			}
		}
	},

	/**
	 * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max
	 */
	trimTicks: function (tickPositions, startOnTick, endOnTick) {
		var roundedMin = tickPositions[0],
			roundedMax = tickPositions[tickPositions.length - 1],
			minPointOffset = this.minPointOffset || 0;
			
		if (startOnTick) {
			this.min = roundedMin;
		} else if (this.min - minPointOffset > roundedMin) {
			tickPositions.shift();
		}

		if (endOnTick) {
			this.max = roundedMax;
		} else if (this.max + minPointOffset < roundedMax) {
			tickPositions.pop();
		}

		// If no tick are left, set one tick in the middle (#3195) 
		if (tickPositions.length === 0 && defined(roundedMin)) {
			tickPositions.push((roundedMax + roundedMin) / 2);
		}		
	},

	/**
	 * Set the max ticks of either the x and y axis collection
	 */
	getTickAmount: function () {
		var others = {}, // Whether there is another axis to pair with this one
			hasOther,
			options = this.options,
			tickAmount = options.tickAmount,
			tickPixelInterval = options.tickPixelInterval;

		if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&
				!this.isLog && options.startOnTick && options.endOnTick) {
			tickAmount = 2;
		}

		if (!tickAmount && this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {
			// Check if there are multiple axes in the same pane
			each(this.chart[this.coll], function (axis) {
				var options = axis.options,
					horiz = axis.horiz,
					key = [horiz ? options.left : options.top, horiz ? options.width : options.height, options.pane].join(',');
				
				if (axis.series.length) { // #4442
					if (others[key]) {
						hasOther = true; // #4201
					} else {
						others[key] = 1;
					}
				}
			});

			if (hasOther) {
				// Add 1 because 4 tick intervals require 5 ticks (including first and last)
				tickAmount = mathCeil(this.len / tickPixelInterval) + 1;
			}
		}

		// For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This
		// prevents the axis from adding ticks that are too far away from the data extremes.
		if (tickAmount < 4) {
			this.finalTickAmt = tickAmount;
			tickAmount = 5;
		}
		
		this.tickAmount = tickAmount;
	},

	/**
	 * When using multiple axes, adjust the number of ticks to match the highest
	 * number of ticks in that group
	 */
	adjustTickAmount: function () {
		var tickInterval = this.tickInterval,
			tickPositions = this.tickPositions,
			tickAmount = this.tickAmount,
			finalTickAmt = this.finalTickAmt,
			currentTickAmount = tickPositions && tickPositions.length,
			i,
			len;

		if (currentTickAmount < tickAmount) { // TODO: Check #3411
			while (tickPositions.length < tickAmount) {
				tickPositions.push(correctFloat(
					tickPositions[tickPositions.length - 1] + tickInterval
				));
			}
			this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
			this.max = tickPositions[tickPositions.length - 1];

		// We have too many ticks, run second pass to try to reduce ticks
		} else if (currentTickAmount > tickAmount) {
			this.tickInterval *= 2;
			this.setTickPositions();
		}

		// The finalTickAmt property is set in getTickAmount
		if (defined(finalTickAmt)) {
			i = len = tickPositions.length;
			while (i--) {
				if (
					(finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick
					(finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last
				) {
					tickPositions.splice(i, 1);
				}	
			}
			this.finalTickAmt = UNDEFINED;
		}
	},

	/**
	 * Set the scale based on data min and max, user set min and max or options
	 *
	 */
	setScale: function () {
		var axis = this,
			isDirtyData,
			isDirtyAxisLength;

		axis.oldMin = axis.min;
		axis.oldMax = axis.max;
		axis.oldAxisLength = axis.len;

		// set the new axisLength
		axis.setAxisSize();
		//axisLength = horiz ? axisWidth : axisHeight;
		isDirtyAxisLength = axis.len !== axis.oldAxisLength;

		// is there new data?
		each(axis.series, function (series) {
			if (series.isDirtyData || series.isDirty ||
					series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
				isDirtyData = true;
			}
		});

		// do we really need to go through all this?
		if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
			axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {

			if (axis.resetStacks) {
				axis.resetStacks();
			}

			axis.forceRedraw = false;

			// get data extremes if needed
			axis.getSeriesExtremes();

			// get fixed positions based on tickInterval
			axis.setTickInterval();

			// record old values to decide whether a rescale is necessary later on (#540)
			axis.oldUserMin = axis.userMin;
			axis.oldUserMax = axis.userMax;

			// Mark as dirty if it is not already set to dirty and extremes have changed. #595.
			if (!axis.isDirty) {
				axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
			}
		} else if (axis.cleanStacks) {
			axis.cleanStacks();
		}
	},

	/**
	 * Set the extremes and optionally redraw
	 * @param {Number} newMin
	 * @param {Number} newMax
	 * @param {Boolean} redraw
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 * @param {Object} eventArguments
	 *
	 */
	setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
		var axis = this,
			chart = axis.chart;

		redraw = pick(redraw, true); // defaults to true

		each(axis.series, function (serie) {
			delete serie.kdTree;
		});

		// Extend the arguments with min and max
		eventArguments = extend(eventArguments, {
			min: newMin,
			max: newMax
		});

		// Fire the event
		fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler

			axis.userMin = newMin;
			axis.userMax = newMax;
			axis.eventArgs = eventArguments;

			if (redraw) {
				chart.redraw(animation);
			}
		});
	},

	/**
	 * Overridable method for zooming chart. Pulled out in a separate method to allow overriding
	 * in stock charts.
	 */
	zoom: function (newMin, newMax) {
		var dataMin = this.dataMin,
			dataMax = this.dataMax,
			options = this.options,
			min = mathMin(dataMin, pick(options.min, dataMin)),
			max = mathMax(dataMax, pick(options.max, dataMax));

		// Prevent pinch zooming out of range. Check for defined is for #1946. #1734.
		if (!this.allowZoomOutside) {
			if (defined(dataMin) && newMin <= min) {
				newMin = min;
			}
			if (defined(dataMax) && newMax >= max) {
				newMax = max;
			}
		}

		// In full view, displaying the reset zoom button is not required
		this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;

		// Do it
		this.setExtremes(
			newMin,
			newMax,
			false,
			UNDEFINED,
			{ trigger: 'zoom' }
		);
		return true;
	},

	/**
	 * Update the axis metrics
	 */
	setAxisSize: function () {
		var chart = this.chart,
			options = this.options,
			offsetLeft = options.offsetLeft || 0,
			offsetRight = options.offsetRight || 0,
			horiz = this.horiz,
			width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),
			height = pick(options.height, chart.plotHeight),
			top = pick(options.top, chart.plotTop),
			left = pick(options.left, chart.plotLeft + offsetLeft),
			percentRegex = /%$/;

		// Check for percentage based input values
		if (percentRegex.test(height)) {
			height = parseFloat(height) / 100 * chart.plotHeight;
		}
		if (percentRegex.test(top)) {
			top = parseFloat(top) / 100 * chart.plotHeight + chart.plotTop;
		}

		// Expose basic values to use in Series object and navigator
		this.left = left;
		this.top = top;
		this.width = width;
		this.height = height;
		this.bottom = chart.chartHeight - height - top;
		this.right = chart.chartWidth - width - left;

		// Direction agnostic properties
		this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905
		this.pos = horiz ? left : top; // distance from SVG origin
	},

	/**
	 * Get the actual axis extremes
	 */
	getExtremes: function () {
		var axis = this,
			isLog = axis.isLog;

		return {
			min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
			max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
			dataMin: axis.dataMin,
			dataMax: axis.dataMax,
			userMin: axis.userMin,
			userMax: axis.userMax
		};
	},

	/**
	 * Get the zero plane either based on zero or on the min or max value.
	 * Used in bar and area plots
	 */
	getThreshold: function (threshold) {
		var axis = this,
			isLog = axis.isLog,
			realMin = isLog ? lin2log(axis.min) : axis.min,
			realMax = isLog ? lin2log(axis.max) : axis.max;

		// With a threshold of null, make the columns/areas rise from the top or bottom 
		// depending on the value, assuming an actual threshold of 0 (#4233).
		if (threshold === null) {
			threshold = realMax < 0 ? realMax : realMin;
		} else if (realMin > threshold) {
			threshold = realMin;
		} else if (realMax < threshold) {
			threshold = realMax;
		}

		return axis.translate(threshold, 0, 1, 0, 1);
	},

	/**
	 * Compute auto alignment for the axis label based on which side the axis is on
	 * and the given rotation for the label
	 */
	autoLabelAlign: function (rotation) {
		var ret,
			angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

		if (angle > 15 && angle < 165) {
			ret = 'right';
		} else if (angle > 195 && angle < 345) {
			ret = 'left';
		} else {
			ret = 'center';
		}
		return ret;
	},

	/**
	 * Prevent the ticks from getting so close we can't draw the labels. On a horizontal
	 * axis, this is handled by rotating the labels, removing ticks and adding ellipsis. 
	 * On a vertical axis remove ticks and add ellipsis.
	 */
	unsquish: function () {
		var chart = this.chart,
			ticks = this.ticks,
			labelOptions = this.options.labels,
			horiz = this.horiz,
			tickInterval = this.tickInterval,
			newTickInterval = tickInterval,
			slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),
			rotation,
			rotationOption = labelOptions.rotation,
			labelMetrics = chart.renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
			step,
			bestScore = Number.MAX_VALUE,
			autoRotation,
			// Return the multiple of tickInterval that is needed to avoid collision
			getStep = function (spaceNeeded) {
				var step = spaceNeeded / (slotSize || 1);
				step = step > 1 ? mathCeil(step) : 1;
				return step * tickInterval;
			};
		
		if (horiz) {
			autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971
				defined(rotationOption) ? 
					[rotationOption] :
					slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation
			);

			if (autoRotation) {

				// Loop over the given autoRotation options, and determine which gives the best score. The 
				// best score is that with the lowest number of steps and a rotation closest to horizontal.
				each(autoRotation, function (rot) {
					var score;

					if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891
					
						step = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));

						score = step + mathAbs(rot / 360);

						if (score < bestScore) {
							bestScore = score;
							rotation = rot;
							newTickInterval = step;
						}
					}
				});
			}

		} else if (!labelOptions.step) { // #4411
			newTickInterval = getStep(labelMetrics.h);
		}

		this.autoRotation = autoRotation;
		this.labelRotation = pick(rotation, rotationOption);

		return newTickInterval;
	},

	renderUnsquish: function () {
		var chart = this.chart,
			renderer = chart.renderer,
			tickPositions = this.tickPositions,
			ticks = this.ticks,
			labelOptions = this.options.labels,
			horiz = this.horiz,
			margin = chart.margin,
			slotCount = this.categories ? tickPositions.length : tickPositions.length - 1,
			slotWidth = this.slotWidth = (horiz && !labelOptions.step && !labelOptions.rotation &&
				((this.staggerLines || 1) * chart.plotWidth) / slotCount) ||
				(!horiz && ((margin[3] && (margin[3] - chart.spacing[3])) || chart.chartWidth * 0.33)), // #1580, #1931,
			innerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),
			attr = {},
			labelMetrics = renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
			textOverflowOption = labelOptions.style.textOverflow,
			css,
			labelLength = 0,
			label,
			i,
			pos;

		// Set rotation option unless it is "auto", like in gauges
		if (!isString(labelOptions.rotation)) {
			attr.rotation = labelOptions.rotation || 0; // #4443
		}
		
		// Handle auto rotation on horizontal axis
		if (this.autoRotation) {

			// Get the longest label length
			each(tickPositions, function (tick) {
				tick = ticks[tick];
				if (tick && tick.labelLength > labelLength) {
					labelLength = tick.labelLength;
				}
			});
			
			// Apply rotation only if the label is too wide for the slot, and
			// the label is wider than its height.
			if (labelLength > innerWidth && labelLength > labelMetrics.h) {
				attr.rotation = this.labelRotation;
			} else {
				this.labelRotation = 0;
			}

		// Handle word-wrap or ellipsis on vertical axis
		} else if (slotWidth) {
			// For word-wrap or ellipsis
			css = { width: innerWidth + PX };

			if (!textOverflowOption) {
				css.textOverflow = 'clip';

				// On vertical axis, only allow word wrap if there is room for more lines.
				i = tickPositions.length;
				while (!horiz && i--) {
					pos = tickPositions[i];
					label = ticks[pos].label;
					if (label) {
						// Reset ellipsis in order to get the correct bounding box (#4070)
						if (label.styles.textOverflow === 'ellipsis') {
							label.css({ textOverflow: 'clip' });
						}
						if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
							label.specCss = { textOverflow: 'ellipsis' };
						}
					}
				}
			}
		}


		// Add ellipsis if the label length is significantly longer than ideal
		if (attr.rotation) {
			css = { 
				width: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX
			};
			if (!textOverflowOption) {
				css.textOverflow = 'ellipsis';
			}
		}

		// Set the explicit or automatic label alignment
		this.labelAlign = attr.align = labelOptions.align || this.autoLabelAlign(this.labelRotation);

		// Apply general and specific CSS
		each(tickPositions, function (pos) {
			var tick = ticks[pos],
				label = tick && tick.label;
			if (label) {
				label.attr(attr); // This needs to go before the CSS in old IE (#4502)
				if (css) {
					label.css(merge(css, label.specCss));
				}
				delete label.specCss;
				tick.rotation = attr.rotation;
			}
		});

		// TODO: Why not part of getLabelPosition?
		this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side === 2);
	},

	/**
	 * Return true if the axis has associated data
	 */
	hasData: function () {
		return this.hasVisibleSeries || (defined(this.min) && defined(this.max) && !!this.tickPositions);
	},

	/**
	 * Render the tick labels to a preliminary position to get their sizes
	 */
	getOffset: function () {
		var axis = this,
			chart = axis.chart,
			renderer = chart.renderer,
			options = axis.options,
			tickPositions = axis.tickPositions,
			ticks = axis.ticks,
			horiz = axis.horiz,
			side = axis.side,
			invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,
			hasData,
			showAxis,
			titleOffset = 0,
			titleOffsetOption,
			titleMargin = 0,
			axisTitleOptions = options.title,
			labelOptions = options.labels,
			labelOffset = 0, // reset
			labelOffsetPadded,
			axisOffset = chart.axisOffset,
			clipOffset = chart.clipOffset,
			clip,
			directionFactor = [-1, 1, 1, -1][side],
			n,
			axisParent = axis.axisParent, // Used in color axis
			lineHeightCorrection;

		// For reuse in Axis.render
		hasData = axis.hasData();
		axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

		// Set/reset staggerLines
		axis.staggerLines = axis.horiz && labelOptions.staggerLines;

		// Create the axisGroup and gridGroup elements on first iteration
		if (!axis.axisGroup) {
			axis.gridGroup = renderer.g('grid')
				.attr({ zIndex: options.gridZIndex || 1 })
				.add(axisParent);
			axis.axisGroup = renderer.g('axis')
				.attr({ zIndex: options.zIndex || 2 })
				.add(axisParent);
			axis.labelGroup = renderer.g('axis-labels')
				.attr({ zIndex: labelOptions.zIndex || 7 })
				.addClass(PREFIX + axis.coll.toLowerCase() + '-labels')
				.add(axisParent);
		}

		if (hasData || axis.isLinked) {
			
			// Generate ticks
			each(tickPositions, function (pos) {
				if (!ticks[pos]) {
					ticks[pos] = new Tick(axis, pos);
				} else {
					ticks[pos].addLabel(); // update labels depending on tick interval
				}
			});

			axis.renderUnsquish();

			each(tickPositions, function (pos) {
				// left side must be align: right and right side must have align: left for labels
				if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === axis.labelAlign) {

					// get the highest offset
					labelOffset = mathMax(
						ticks[pos].getLabelSize(),
						labelOffset
					);
				}
			});

			if (axis.staggerLines) {
				labelOffset *= axis.staggerLines;
				axis.labelOffset = labelOffset;
			}


		} else { // doesn't have data
			for (n in ticks) {
				ticks[n].destroy();
				delete ticks[n];
			}
		}

		if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
			if (!axis.axisTitle) {
				axis.axisTitle = renderer.text(
					axisTitleOptions.text,
					0,
					0,
					axisTitleOptions.useHTML
				)
				.attr({
					zIndex: 7,
					rotation: axisTitleOptions.rotation || 0,
					align:
						axisTitleOptions.textAlign ||
						{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]
				})
				.addClass(PREFIX + this.coll.toLowerCase() + '-title')
				.css(axisTitleOptions.style)
				.add(axis.axisGroup);
				axis.axisTitle.isNew = true;
			}

			if (showAxis) {
				titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
				titleOffsetOption = axisTitleOptions.offset;
				titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
			}

			// hide or show the title depending on whether showEmpty is set
			axis.axisTitle[showAxis ? 'show' : 'hide']();
		}

		// handle automatic or user set offset
		axis.offset = directionFactor * pick(options.offset, axisOffset[side]);

		axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar
		lineHeightCorrection = side === 2 ? axis.tickRotCorr.y : 0;
		labelOffsetPadded = labelOffset + titleMargin +
			(labelOffset && (directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8) : labelOptions.x) - lineHeightCorrection));
		axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);

		axisOffset[side] = mathMax(
			axisOffset[side],
			axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
			labelOffsetPadded // #3027
		);

		// Decide the clipping needed to keep the graph inside the plot area and axis lines
		clip = options.offset ? 0 : mathFloor(options.lineWidth / 2) * 2; // #4308, #4371
		clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], clip);
	},

	/**
	 * Get the path for the axis line
	 */
	getLinePath: function (lineWidth) {
		var chart = this.chart,
			opposite = this.opposite,
			offset = this.offset,
			horiz = this.horiz,
			lineLeft = this.left + (opposite ? this.width : 0) + offset,
			lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;

		if (opposite) {
			lineWidth *= -1; // crispify the other way - #1480, #1687
		}

		return chart.renderer.crispLine([
				M,
				horiz ?
					this.left :
					lineLeft,
				horiz ?
					lineTop :
					this.top,
				L,
				horiz ?
					chart.chartWidth - this.right :
					lineLeft,
				horiz ?
					lineTop :
					chart.chartHeight - this.bottom
			], lineWidth);
	},

	/**
	 * Position the title
	 */
	getTitlePosition: function () {
		// compute anchor points for each of the title align options
		var horiz = this.horiz,
			axisLeft = this.left,
			axisTop = this.top,
			axisLength = this.len,
			axisTitleOptions = this.options.title,
			margin = horiz ? axisLeft : axisTop,
			opposite = this.opposite,
			offset = this.offset,
			xOption = axisTitleOptions.x || 0,
			yOption = axisTitleOptions.y || 0,
			fontSize = pInt(axisTitleOptions.style.fontSize || 12),

			// the position in the length direction of the axis
			alongAxis = {
				low: margin + (horiz ? 0 : axisLength),
				middle: margin + axisLength / 2,
				high: margin + (horiz ? axisLength : 0)
			}[axisTitleOptions.align],

			// the position in the perpendicular direction of the axis
			offAxis = (horiz ? axisTop + this.height : axisLeft) +
				(horiz ? 1 : -1) * // horizontal axis reverses the margin
				(opposite ? -1 : 1) * // so does opposite axes
				this.axisTitleMargin +
				(this.side === 2 ? fontSize : 0);

		return {
			x: horiz ?
				alongAxis + xOption :
				offAxis + (opposite ? this.width : 0) + offset + xOption,
			y: horiz ?
				offAxis + yOption - (opposite ? this.height : 0) + offset :
				alongAxis + yOption
		};
	},

	/**
	 * Render the axis
	 */
	render: function () {
		var axis = this,
			chart = axis.chart,
			renderer = chart.renderer,
			options = axis.options,
			isLog = axis.isLog,
			isLinked = axis.isLinked,
			tickPositions = axis.tickPositions,
			axisTitle = axis.axisTitle,			
			ticks = axis.ticks,
			minorTicks = axis.minorTicks,
			alternateBands = axis.alternateBands,
			stackLabelOptions = options.stackLabels,
			alternateGridColor = options.alternateGridColor,
			tickmarkOffset = axis.tickmarkOffset,
			lineWidth = options.lineWidth,
			linePath,
			hasRendered = chart.hasRendered,
			slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),
			showAxis = axis.showAxis,
			globalAnimation = renderer.globalAnimation,
			from,
			to;

		// Reset
		axis.labelEdge.length = 0;
		//axis.justifyToPlot = overflow === 'justify';
		axis.overlap = false;

		// Mark all elements inActive before we go over and mark the active ones
		each([ticks, minorTicks, alternateBands], function (coll) {
			var pos;
			for (pos in coll) {
				coll[pos].isActive = false;
			}
		});

		// If the series has data draw the ticks. Else only the line and title
		if (axis.hasData() || isLinked) {

			// minor ticks
			if (axis.minorTickInterval && !axis.categories) {
				each(axis.getMinorTickPositions(), function (pos) {
					if (!minorTicks[pos]) {
						minorTicks[pos] = new Tick(axis, pos, 'minor');
					}

					// render new ticks in old position
					if (slideInTicks && minorTicks[pos].isNew) {
						minorTicks[pos].render(null, true);
					}

					minorTicks[pos].render(null, false, 1);
				});
			}

			// Major ticks. Pull out the first item and render it last so that
			// we can get the position of the neighbour label. #808.
			if (tickPositions.length) { // #1300
				each(tickPositions, function (pos, i) {

					// linked axes need an extra check to find out if
					if (!isLinked || (pos >= axis.min && pos <= axis.max)) {

						if (!ticks[pos]) {
							ticks[pos] = new Tick(axis, pos);
						}

						// render new ticks in old position
						if (slideInTicks && ticks[pos].isNew) {
							ticks[pos].render(i, true, 0.1);
						}

						ticks[pos].render(i);
					}

				});
				// In a categorized axis, the tick marks are displayed between labels. So
				// we need to add a tick mark and grid line at the left edge of the X axis.
				if (tickmarkOffset && (axis.min === 0 || axis.single)) {
					if (!ticks[-1]) {
						ticks[-1] = new Tick(axis, -1, null, true);
					}
					ticks[-1].render(-1);
				}

			}

			// alternate grid color
			if (alternateGridColor) {
				each(tickPositions, function (pos, i) {
					to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset; 
					if (i % 2 === 0 && pos < axis.max && to <= axis.max - tickmarkOffset) { // #2248
						if (!alternateBands[pos]) {
							alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);
						}
						from = pos + tickmarkOffset; // #949
						alternateBands[pos].options = {
							from: isLog ? lin2log(from) : from,
							to: isLog ? lin2log(to) : to,
							color: alternateGridColor
						};
						alternateBands[pos].render();
						alternateBands[pos].isActive = true;
					}
				});
			}

			// custom plot lines and bands
			if (!axis._addedPlotLB) { // only first time
				each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
					axis.addPlotBandOrLine(plotLineOptions);
				});
				axis._addedPlotLB = true;
			}

		} // end if hasData

		// Remove inactive ticks
		each([ticks, minorTicks, alternateBands], function (coll) {
			var pos,
				i,
				forDestruction = [],
				delay = globalAnimation ? globalAnimation.duration || 500 : 0,
				destroyInactiveItems = function () {
					i = forDestruction.length;
					while (i--) {
						// When resizing rapidly, the same items may be destroyed in different timeouts,
						// or the may be reactivated
						if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
							coll[forDestruction[i]].destroy();
							delete coll[forDestruction[i]];
						}
					}

				};

			for (pos in coll) {

				if (!coll[pos].isActive) {
					// Render to zero opacity
					coll[pos].render(pos, false, 0);
					coll[pos].isActive = false;
					forDestruction.push(pos);
				}
			}

			// When the objects are finished fading out, destroy them
			if (coll === alternateBands || !chart.hasRendered || !delay) {
				destroyInactiveItems();
			} else if (delay) {
				setTimeout(destroyInactiveItems, delay);
			}
		});

		// Static items. As the axis group is cleared on subsequent calls
		// to render, these items are added outside the group.
		// axis line
		if (lineWidth) {
			linePath = axis.getLinePath(lineWidth);
			if (!axis.axisLine) {
				axis.axisLine = renderer.path(linePath)
					.attr({
						stroke: options.lineColor,
						'stroke-width': lineWidth,
						zIndex: 7
					})
					.add(axis.axisGroup);
			} else {
				axis.axisLine.animate({ d: linePath });
			}

			// show or hide the line depending on options.showEmpty
			axis.axisLine[showAxis ? 'show' : 'hide']();
		}

		if (axisTitle && showAxis) {

			axisTitle[axisTitle.isNew ? 'attr' : 'animate'](
				axis.getTitlePosition()
			);
			axisTitle.isNew = false;
		}

		// Stacked totals:
		if (stackLabelOptions && stackLabelOptions.enabled) {
			axis.renderStackTotals();
		}
		// End stacked totals

		axis.isDirty = false;
	},

	/**
	 * Redraw the axis to reflect changes in the data or axis extremes
	 */
	redraw: function () {
		
		if (this.visible) {
			// render the axis
			this.render();

			// move plot lines and bands
			each(this.plotLinesAndBands, function (plotLine) {
				plotLine.render();
			});
		}

		// mark associated series as dirty and ready for redraw
		each(this.series, function (series) {
			series.isDirty = true;
		});

	},

	/**
	 * Destroys an Axis instance.
	 */
	destroy: function (keepEvents) {
		var axis = this,
			stacks = axis.stacks,
			stackKey,
			plotLinesAndBands = axis.plotLinesAndBands,
			i;

		// Remove the events
		if (!keepEvents) {
			removeEvent(axis);
		}

		// Destroy each stack total
		for (stackKey in stacks) {
			destroyObjectProperties(stacks[stackKey]);

			stacks[stackKey] = null;
		}

		// Destroy collections
		each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {
			destroyObjectProperties(coll);
		});
		i = plotLinesAndBands.length;
		while (i--) { // #1975
			plotLinesAndBands[i].destroy();
		}

		// Destroy local variables
		each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {
			if (axis[prop]) {
				axis[prop] = axis[prop].destroy();
			}
		});

		// Destroy crosshair
		if (this.cross) {
			this.cross.destroy();
		}
	},

	/**
	 * Draw the crosshair
	 */
	drawCrosshair: function (e, point) { // docs: Missing docs for Axis.crosshair. Also for properties.

		var path,
			options = this.crosshair,
			animation = options.animation,
			pos,
			attribs,
			categorized;
		
		if (
			// Disabled in options
			!this.crosshair || 
			// Snap
			((defined(point) || !pick(this.crosshair.snap, true)) === false) || 
			// Not on this axis (#4095, #2888)
			(point && point.series && point.series[this.coll] !== this)
		) {
			this.hideCrosshair();
		
		} else {			

			// Get the path
			if (!pick(options.snap, true)) {
				pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
			} else if (defined(point)) {
				/*jslint eqeq: true*/
				pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834
				/*jslint eqeq: false*/
			}

			if (this.isRadial) {
				path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189
			} else {
				path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189
			}

			if (path === null) {
				this.hideCrosshair();
				return;
			}

			// Draw the cross
			if (this.cross) {
				this.cross
					.attr({ visibility: VISIBLE })[animation ? 'animate' : 'attr']({ d: path }, animation);
			} else {
				categorized = this.categories && !this.isRadial;
				attribs = {
					'stroke-width': options.width || (categorized ? this.transA : 1),
					stroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),
					zIndex: options.zIndex || 2
				};
				if (options.dashStyle) {
					attribs.dashstyle = options.dashStyle;
				}
				this.cross = this.chart.renderer.path(path).attr(attribs).add();
			}

		}

	},

	/**
	 *	Hide the crosshair.
	 */
	hideCrosshair: function () {
		if (this.cross) {
			this.cross.hide();
		}
	}
}; // end Axis

extend(Axis.prototype, AxisPlotLineOrBandExtension);

/**
 * Set the tick positions to a time unit that makes sense, for example
 * on the first of each month or on every Monday. Return an array
 * with the time positions. Used in datetime axes as well as for grouping
 * data on a datetime axis.
 *
 * @param {Object} normalizedInterval The interval in axis values (ms) and the count
 * @param {Number} min The minimum in axis values
 * @param {Number} max The maximum in axis values
 * @param {Number} startOfWeek
 */
Axis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {
	var tickPositions = [],
		i,
		higherRanks = {},
		useUTC = defaultOptions.global.useUTC,
		minYear, // used in months and years as a basis for Date.UTC()
		minDate = new Date(min - getTZOffset(min)),
		interval = normalizedInterval.unitRange,
		count = normalizedInterval.count;

	if (defined(min)) { // #1300
		minDate[setMilliseconds](interval >= timeUnits.second ? 0 : // #3935
			count * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654

		if (interval >= timeUnits.second) { // second
			minDate[setSeconds](interval >= timeUnits.minute ? 0 : // #3935
				count * mathFloor(minDate.getSeconds() / count));
		}
	
		if (interval >= timeUnits.minute) { // minute
			minDate[setMinutes](interval >= timeUnits.hour ? 0 :
				count * mathFloor(minDate[getMinutes]() / count));
		}
	
		if (interval >= timeUnits.hour) { // hour
			minDate[setHours](interval >= timeUnits.day ? 0 :
				count * mathFloor(minDate[getHours]() / count));
		}
	
		if (interval >= timeUnits.day) { // day
			minDate[setDate](interval >= timeUnits.month ? 1 :
				count * mathFloor(minDate[getDate]() / count));
		}
	
		if (interval >= timeUnits.month) { // month
			minDate[setMonth](interval >= timeUnits.year ? 0 :
				count * mathFloor(minDate[getMonth]() / count));
			minYear = minDate[getFullYear]();
		}
	
		if (interval >= timeUnits.year) { // year
			minYear -= minYear % count;
			minDate[setFullYear](minYear);
		}
	
		// week is a special case that runs outside the hierarchy
		if (interval === timeUnits.week) {
			// get start of current week, independent of count
			minDate[setDate](minDate[getDate]() - minDate[getDay]() +
				pick(startOfWeek, 1));
		}
	
	
		// get tick positions
		i = 1;
		if (timezoneOffset || getTimezoneOffset) {
			minDate = minDate.getTime();
			minDate = new Date(minDate + getTZOffset(minDate));
		}
		minYear = minDate[getFullYear]();
		var time = minDate.getTime(),
			minMonth = minDate[getMonth](),
			minDateDate = minDate[getDate](),
			localTimezoneOffset = (timeUnits.day + 
					(useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)
				) % timeUnits.day; // #950, #3359
	
		// iterate and add tick positions at appropriate values
		while (time < max) {
			tickPositions.push(time);
	
			// if the interval is years, use Date.UTC to increase years
			if (interval === timeUnits.year) {
				time = makeTime(minYear + i * count, 0);
	
			// if the interval is months, use Date.UTC to increase months
			} else if (interval === timeUnits.month) {
				time = makeTime(minYear, minMonth + i * count);
	
			// if we're using global time, the interval is not fixed as it jumps
			// one hour at the DST crossover
			} else if (!useUTC && (interval === timeUnits.day || interval === timeUnits.week)) {
				time = makeTime(minYear, minMonth, minDateDate +
					i * count * (interval === timeUnits.day ? 1 : 7));
	
			// else, the interval is fixed and we use simple addition
			} else {
				time += interval * count;
			}
	
			i++;
		}
	
		// push the last time
		tickPositions.push(time);


		// mark new days if the time is dividible by day (#1649, #1760)
		each(grep(tickPositions, function (time) {
			return interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;
		}), function (time) {
			higherRanks[time] = 'day';
		});
	}


	// record information on the chosen unit - for dynamic label formatter
	tickPositions.info = extend(normalizedInterval, {
		higherRanks: higherRanks,
		totalRange: interval * count
	});

	return tickPositions;
};

/**
 * Get a normalized tick interval for dates. Returns a configuration object with
 * unit range (interval), count and name. Used to prepare data for getTimeTicks. 
 * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
 * of segments in stock charts, the normalizing logic was extracted in order to 
 * prevent it for running over again for each segment having the same interval. 
 * #662, #697.
 */
Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {
	var units = unitsOption || [[
				'millisecond', // unit name
				[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
			], [
				'second',
				[1, 2, 5, 10, 15, 30]
			], [
				'minute',
				[1, 2, 5, 10, 15, 30]
			], [
				'hour',
				[1, 2, 3, 4, 6, 8, 12]
			], [
				'day',
				[1, 2]
			], [
				'week',
				[1, 2]
			], [
				'month',
				[1, 2, 3, 4, 6]
			], [
				'year',
				null
			]],
		unit = units[units.length - 1], // default unit is years
		interval = timeUnits[unit[0]],
		multiples = unit[1],
		count,
		i;
		
	// loop through the units to find the one that best fits the tickInterval
	for (i = 0; i < units.length; i++) {
		unit = units[i];
		interval = timeUnits[unit[0]];
		multiples = unit[1];


		if (units[i + 1]) {
			// lessThan is in the middle between the highest multiple and the next unit.
			var lessThan = (interval * multiples[multiples.length - 1] +
						timeUnits[units[i + 1][0]]) / 2;

			// break and keep the current unit
			if (tickInterval <= lessThan) {
				break;
			}
		}
	}

	// prevent 2.5 years intervals, though 25, 250 etc. are allowed
	if (interval === timeUnits.year && tickInterval < 5 * interval) {
		multiples = [1, 2, 5];
	}

	// get the count
	count = normalizeTickInterval(
		tickInterval / interval, 
		multiples,
		unit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360
	);
	
	return {
		unitRange: interval,
		count: count,
		unitName: unit[0]
	};
};/**
 * Methods defined on the Axis prototype
 */

/**
 * Set the tick positions of a logarithmic axis
 */
Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {
	var axis = this,
		options = axis.options,
		axisLength = axis.len,
		// Since we use this method for both major and minor ticks,
		// use a local variable and return the result
		positions = []; 
	
	// Reset
	if (!minor) {
		axis._minorAutoInterval = null;
	}
	
	// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
	if (interval >= 0.5) {
		interval = mathRound(interval);
		positions = axis.getLinearTickPositions(interval, min, max);
		
	// Second case: We need intermediary ticks. For example 
	// 1, 2, 4, 6, 8, 10, 20, 40 etc. 
	} else if (interval >= 0.08) {
		var roundedMin = mathFloor(min),
			intermediate,
			i,
			j,
			len,
			pos,
			lastPos,
			break2;
			
		if (interval > 0.3) {
			intermediate = [1, 2, 4];
		} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
			intermediate = [1, 2, 4, 6, 8];
		} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
			intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
		}
		
		for (i = roundedMin; i < max + 1 && !break2; i++) {
			len = intermediate.length;
			for (j = 0; j < len && !break2; j++) {
				pos = log2lin(lin2log(i) * intermediate[j]);
				if (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113
					positions.push(lastPos);
				}
				
				if (lastPos > max) {
					break2 = true;
				}
				lastPos = pos;
			}
		}
		
	// Third case: We are so deep in between whole logarithmic values that
	// we might as well handle the tick positions like a linear axis. For
	// example 1.01, 1.02, 1.03, 1.04.
	} else {
		var realMin = lin2log(min),
			realMax = lin2log(max),
			tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
			filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
			tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
			totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
		
		interval = pick(
			filteredTickIntervalOption,
			axis._minorAutoInterval,
			(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
		);
		
		interval = normalizeTickInterval(
			interval, 
			null, 
			getMagnitude(interval)
		);
		
		positions = map(axis.getLinearTickPositions(
			interval, 
			realMin,
			realMax	
		), log2lin);
		
		if (!minor) {
			axis._minorAutoInterval = interval / 5;
		}
	}
	
	// Set the axis-level tickInterval variable 
	if (!minor) {
		axis.tickInterval = interval;
	}
	return positions;
};/**
 * The tooltip object
 * @param {Object} chart The chart instance
 * @param {Object} options Tooltip options
 */
var Tooltip = Highcharts.Tooltip = function () {
	this.init.apply(this, arguments);
};

Tooltip.prototype = {

	init: function (chart, options) {

		var borderWidth = options.borderWidth,
			style = options.style,
			padding = pInt(style.padding);

		// Save the chart and options
		this.chart = chart;
		this.options = options;

		// Keep track of the current series
		//this.currentSeries = UNDEFINED;

		// List of crosshairs
		this.crosshairs = [];

		// Current values of x and y when animating
		this.now = { x: 0, y: 0 };

		// The tooltip is initially hidden
		this.isHidden = true;


		// create the label		
		this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')
			.attr({
				padding: padding,
				fill: options.backgroundColor,
				'stroke-width': borderWidth,
				r: options.borderRadius,
				zIndex: 8
			})
			.css(style)
			.css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)
			.add()
			.attr({ y: -9999 }); // #2301, #2657

		// When using canVG the shadow shows up as a gray circle
		// even if the tooltip is hidden.
		if (!useCanVG) {
			this.label.shadow(options.shadow);
		}

		// Public property for getting the shared state.
		this.shared = options.shared;
	},

	/**
	 * Destroy the tooltip and its elements.
	 */
	destroy: function () {
		// Destroy and clear local variables
		if (this.label) {
			this.label = this.label.destroy();
		}
		clearTimeout(this.hideTimer);
		clearTimeout(this.tooltipTimeout);
	},

	/**
	 * Provide a soft movement for the tooltip
	 *
	 * @param {Number} x
	 * @param {Number} y
	 * @private
	 */
	move: function (x, y, anchorX, anchorY) {
		var tooltip = this,
			now = tooltip.now,
			animate = tooltip.options.animation !== false && !tooltip.isHidden && 
				// When we get close to the target position, abort animation and land on the right place (#3056)
				(mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),
			skipAnchor = tooltip.followPointer || tooltip.len > 1;

		// Get intermediate values for animation
		extend(now, {
			x: animate ? (2 * now.x + x) / 3 : x,
			y: animate ? (now.y + y) / 2 : y,
			anchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
			anchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY
		});

		// Move to the intermediate value
		tooltip.label.attr(now);

		
		// Run on next tick of the mouse tracker
		if (animate) {
		
			// Never allow two timeouts
			clearTimeout(this.tooltipTimeout);
			
			// Set the fixed interval ticking for the smooth tooltip
			this.tooltipTimeout = setTimeout(function () {
				// The interval function may still be running during destroy, so check that the chart is really there before calling.
				if (tooltip) {
					tooltip.move(x, y, anchorX, anchorY);
				}
			}, 32);
			
		}
	},

	/**
	 * Hide the tooltip
	 */
	hide: function (delay) {
		var tooltip = this,
			hoverPoints;
		
		clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)
		if (!this.isHidden) {
			hoverPoints = this.chart.hoverPoints;

			this.hideTimer = setTimeout(function () {
				tooltip.label.fadeOut();
				tooltip.isHidden = true;
			}, pick(delay, this.options.hideDelay, 500));
		}
	},
	
	/** 
	 * Extendable method to get the anchor position of the tooltip
	 * from a point or set of points
	 */
	getAnchor: function (points, mouseEvent) {
		var ret,
			chart = this.chart,
			inverted = chart.inverted,
			plotTop = chart.plotTop,
			plotLeft = chart.plotLeft,
			plotX = 0,
			plotY = 0,
			yAxis,
			xAxis;
		
		points = splat(points);
		
		// Pie uses a special tooltipPos
		ret = points[0].tooltipPos;
		
		// When tooltip follows mouse, relate the position to the mouse
		if (this.followPointer && mouseEvent) {
			if (mouseEvent.chartX === UNDEFINED) {
				mouseEvent = chart.pointer.normalize(mouseEvent);
			}
			ret = [
				mouseEvent.chartX - chart.plotLeft,
				mouseEvent.chartY - plotTop
			];
		}
		// When shared, use the average position
		if (!ret) {
			each(points, function (point) {
				yAxis = point.series.yAxis;
				xAxis = point.series.xAxis;
				plotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0); 
				plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
					(!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
			});
			
			plotX /= points.length;
			plotY /= points.length;
			
			ret = [
				inverted ? chart.plotWidth - plotY : plotX,
				this.shared && !inverted && points.length > 1 && mouseEvent ? 
					mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)
					inverted ? chart.plotHeight - plotX : plotY
			];
		}

		return map(ret, mathRound);
	},
	
	/**
	 * Place the tooltip in a chart without spilling over
	 * and not covering the point it self.
	 */
	getPosition: function (boxWidth, boxHeight, point) {
		
		var chart = this.chart,
			distance = this.distance,
			ret = {},
			h = point.h || 0, // #4117
			swapped,
			first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop, chart.plotTop, chart.plotTop + chart.plotHeight],
			second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft, chart.plotLeft, chart.plotLeft + chart.plotWidth],
			// The far side is right or bottom
			preferFarSide = pick(point.ttBelow, (chart.inverted && !point.negative) || (!chart.inverted && point.negative)),
			/**
			 * Handle the preferred dimension. When the preferred dimension is tooltip
			 * on top or bottom of the point, it will look for space there.
			 */
			firstDimension = function (dim, outerSize, innerSize, point, min, max) {
				var roomLeft = innerSize < point - distance,
					roomRight = point + distance + innerSize < outerSize,
					alignedLeft = point - distance - innerSize,
					alignedRight = point + distance;

				if (preferFarSide && roomRight) {
					ret[dim] = alignedRight;
				} else if (!preferFarSide && roomLeft) {
					ret[dim] = alignedLeft;
				} else if (roomLeft) {
					ret[dim] = mathMin(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);
				} else if (roomRight) {
					ret[dim] = mathMax(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);
				} else {
					return false;
				}
			},
			/**
			 * Handle the secondary dimension. If the preferred dimension is tooltip
			 * on top or bottom of the point, the second dimension is to align the tooltip
			 * above the point, trying to align center but allowing left or right
			 * align within the chart box.
			 */
			secondDimension = function (dim, outerSize, innerSize, point) {
				// Too close to the edge, return false and swap dimensions
				if (point < distance || point > outerSize - distance) {
					return false;
				
				// Align left/top
				} else if (point < innerSize / 2) {
					ret[dim] = 1;
				// Align right/bottom
				} else if (point > outerSize - innerSize / 2) {
					ret[dim] = outerSize - innerSize - 2;
				// Align center
				} else {
					ret[dim] = point - innerSize / 2;
				}
			},
			/**
			 * Swap the dimensions 
			 */
			swap = function (count) {
				var temp = first;
				first = second;
				second = temp;
				swapped = count;
			},
			run = function () {
				if (firstDimension.apply(0, first) !== false) {
					if (secondDimension.apply(0, second) === false && !swapped) {
						swap(true);
						run();
					}
				} else if (!swapped) {
					swap(true);
					run();
				} else {
					ret.x = ret.y = 0;
				}
			};

		// Under these conditions, prefer the tooltip on the side of the point
		if (chart.inverted || this.len > 1) {
			swap();
		}
		run();

		return ret;
	
	},

	/**
	 * In case no user defined formatter is given, this will be used. Note that the context
	 * here is an object holding point, series, x, y etc.
	 */
	defaultFormatter: function (tooltip) {
		var items = this.points || splat(this),
			s;

		// build the header
		s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header

		// build the values
		s = s.concat(tooltip.bodyFormatter(items));

		// footer
		s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header

		return s.join('');
	},

	/**
	 * Refresh the tooltip's text and position.
	 * @param {Object} point
	 */
	refresh: function (point, mouseEvent) {
		var tooltip = this,
			chart = tooltip.chart,
			label = tooltip.label,
			options = tooltip.options,
			x,
			y,
			anchor,
			textConfig = {},
			text,
			pointConfig = [],
			formatter = options.formatter || tooltip.defaultFormatter,
			hoverPoints = chart.hoverPoints,
			borderColor,
			shared = tooltip.shared,
			currentSeries;
			
		clearTimeout(this.hideTimer);
		
		// get the reference point coordinates (pie charts use tooltipPos)
		tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
		anchor = tooltip.getAnchor(point, mouseEvent);
		x = anchor[0];
		y = anchor[1];

		// shared tooltip, array is sent over
		if (shared && !(point.series && point.series.noSharedTooltip)) {
			
			// hide previous hoverPoints and set new
			
			chart.hoverPoints = point;
			if (hoverPoints) {
				each(hoverPoints, function (point) {
					point.setState();
				});
			}

			each(point, function (item) {
				item.setState(HOVER_STATE);

				pointConfig.push(item.getLabelConfig());
			});

			textConfig = {
				x: point[0].category,
				y: point[0].y
			};
			textConfig.points = pointConfig;
			this.len = pointConfig.length;
			point = point[0];

		// single point tooltip
		} else {
			textConfig = point.getLabelConfig();
		}
		text = formatter.call(textConfig, tooltip);

		// register the current series
		currentSeries = point.series;
		this.distance = pick(currentSeries.tooltipOptions.distance, 16);

		// update the inner HTML
		if (text === false) {
			this.hide();
		} else {

			// show it
			if (tooltip.isHidden) {
				stop(label);
				label.attr('opacity', 1).show();
			}

			// update text
			label.attr({
				text: text
			});

			// set the stroke color of the box
			borderColor = options.borderColor || point.color || currentSeries.color || '#606060';
			label.attr({
				stroke: borderColor
			});
			tooltip.updatePosition({ 
				plotX: x, 
				plotY: y, 
				negative: point.negative, 
				ttBelow: point.ttBelow, 
				h: anchor[2] || 0
			});
		
			this.isHidden = false;
		}
		fireEvent(chart, 'tooltipRefresh', {
				text: text,
				x: x + chart.plotLeft,
				y: y + chart.plotTop,
				borderColor: borderColor
			});
	},
	
	/**
	 * Find the new position and perform the move
	 */
	updatePosition: function (point) {
		var chart = this.chart,
			label = this.label, 
			pos = (this.options.positioner || this.getPosition).call(
				this,
				label.width,
				label.height,
				point
			);

		// do the move
		this.move(
			mathRound(pos.x), 
			mathRound(pos.y || 0), // can be undefined (#3977) 
			point.plotX + chart.plotLeft, 
			point.plotY + chart.plotTop
		);
	},

	/** 
	 * Get the best X date format based on the closest point range on the axis.
	 */
	getXDateFormat: function (point, options, xAxis) {
		var xDateFormat,
			dateTimeLabelFormats = options.dateTimeLabelFormats,
			closestPointRange = xAxis && xAxis.closestPointRange,
			n,
			blank = '01-01 00:00:00.000',
			strpos = {
				millisecond: 15,
				second: 12,
				minute: 9,
				hour: 6,
				day: 3
			},
			date,
			lastN = 'millisecond'; // for sub-millisecond data, #4223

		if (closestPointRange) {
			date = dateFormat('%m-%d %H:%M:%S.%L', point.x);
			for (n in timeUnits) {

				// If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format
				if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek && 
						date.substr(6) === blank.substr(6)) {
					n = 'week';
					break;

				// The first format that is too great for the range
				} else if (timeUnits[n] > closestPointRange) {
					n = lastN;
					break;
				
				// If the point is placed every day at 23:59, we need to show
				// the minutes as well. #2637.
				} else if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {
					break;
				}

				// Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition
				if (n !== 'week') {
					lastN = n;
				}
			}
			
			if (n) {
				xDateFormat = dateTimeLabelFormats[n];
			}
		} else {
			xDateFormat = dateTimeLabelFormats.day;
		}

		return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
	},

	/**
	 * Format the footer/header of the tooltip
	 * #3397: abstraction to enable formatting of footer and header
	 */
	tooltipFooterHeaderFormatter: function (point, isFooter) {
		var footOrHead = isFooter ? 'footer' : 'header',
			series = point.series,
			tooltipOptions = series.tooltipOptions,
			xDateFormat = tooltipOptions.xDateFormat,
			xAxis = series.xAxis,
			isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),
			formatString = tooltipOptions[footOrHead+'Format'];

		// Guess the best date format based on the closest point distance (#568, #3418)
		if (isDateTime && !xDateFormat) {
			xDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);
		}

		// Insert the footer date format if any
		if (isDateTime && xDateFormat) {
			formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');
		}

		return format(formatString, {
			point: point,
			series: series
		});
	},

	/**
     * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,
     * abstracting this functionality allows to easily overwrite and extend it. 
	 */
	bodyFormatter: function (items) {
        return map(items, function (item) {
            var tooltipOptions = item.series.tooltipOptions;
            return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);
        });
    }
    
};

var hoverChartIndex;

// Global flag for touch support
hasTouch = doc.documentElement.ontouchstart !== UNDEFINED;

/**
 * The mouse tracker object. All methods starting with "on" are primary DOM event handlers. 
 * Subsequent methods should be named differently from what they are doing.
 * @param {Object} chart The Chart instance
 * @param {Object} options The root options object
 */
var Pointer = Highcharts.Pointer = function (chart, options) {
	this.init(chart, options);
};

Pointer.prototype = {
	/**
	 * Initialize Pointer
	 */
	init: function (chart, options) {
		
		var chartOptions = options.chart,
			chartEvents = chartOptions.events,
			zoomType = useCanVG ? '' : chartOptions.zoomType,
			inverted = chart.inverted,
			zoomX,
			zoomY;

		// Store references
		this.options = options;
		this.chart = chart;
		
		// Zoom status
		this.zoomX = zoomX = /x/.test(zoomType);
		this.zoomY = zoomY = /y/.test(zoomType);
		this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
		this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
		this.hasZoom = zoomX || zoomY;

		// Do we need to handle click on a touch device?
		this.runChartClick = chartEvents && !!chartEvents.click;

		this.pinchDown = [];
		this.lastValidTouch = {};

		if (Highcharts.Tooltip && options.tooltip.enabled) {
			chart.tooltip = new Tooltip(chart, options.tooltip);
			this.followTouchMove = pick(options.tooltip.followTouchMove, true);
		}

		this.setDOMEvents();
	}, 

	/**
	 * Add crossbrowser support for chartX and chartY
	 * @param {Object} e The event object in standard browsers
	 */
	normalize: function (e, chartPosition) {
		var chartX,
			chartY,
			ePos;

		// common IE normalizing
		e = e || window.event;

		// Framework specific normalizing (#1165)
		e = washMouseEvent(e);

		// More IE normalizing, needs to go after washMouseEvent
		if (!e.target) {
			e.target = e.srcElement;
		}
		
		// iOS (#2757)
		ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;

		// Get mouse position
		if (!chartPosition) {
			this.chartPosition = chartPosition = offset(this.chart.container);
		}

		// chartX and chartY
		if (ePos.pageX === UNDEFINED) { // IE < 9. #886.
			chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is 
				// for IE10 quirks mode within framesets
			chartY = e.y;
		} else {
			chartX = ePos.pageX - chartPosition.left;
			chartY = ePos.pageY - chartPosition.top;
		}

		return extend(e, {
			chartX: mathRound(chartX),
			chartY: mathRound(chartY)
		});
	},

	/**
	 * Get the click position in terms of axis values.
	 *
	 * @param {Object} e A pointer event
	 */
	getCoordinates: function (e) {
		var coordinates = {
				xAxis: [],
				yAxis: []
			};

		each(this.chart.axes, function (axis) {
			coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
				axis: axis,
				value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
			});
		});
		return coordinates;
	},
	
	/**
	 * With line type charts with a single tracker, get the point closest to the mouse.
	 * Run Point.onMouseOver and display tooltip for the point or points.
	 */
	runPointActions: function (e) {

		var pointer = this,
			chart = pointer.chart,
			series = chart.series,
			tooltip = chart.tooltip,
			shared = tooltip ? tooltip.shared : false,
			followPointer,
			hoverPoint = chart.hoverPoint,
			hoverSeries = chart.hoverSeries,
			i,
			distance = Number.MAX_VALUE, // #4511
			anchor,
			noSharedTooltip,
			stickToHoverSeries,
			directTouch,
			kdpoints = [],
			kdpoint,
			kdpointT;

		// For hovering over the empty parts of the plot area (hoverSeries is undefined). 
		// If there is one series with point tracking (combo chart), don't go to nearest neighbour.
		if (!shared && !hoverSeries) {
			for (i = 0; i < series.length; i++) {
				if (series[i].directTouch || !series[i].options.stickyTracking) {
					series = [];
				}
			}
		}

		// If it has a hoverPoint and that series requires direct touch (like columns, #3899), or we're on 
		// a noSharedTooltip series among shared tooltip series (#4546), use the hoverPoint . Otherwise, 
		// search the k-d tree.
		stickToHoverSeries = hoverSeries && (shared ? hoverSeries.noSharedTooltip : hoverSeries.directTouch);
		if (stickToHoverSeries && hoverPoint) {
			kdpoint = hoverPoint;

		// Handle shared tooltip or cases where a series is not yet hovered
		} else {
			// Find nearest points on all series
			each(series, function (s) {
				// Skip hidden series
				noSharedTooltip = s.noSharedTooltip && shared;
				directTouch = !shared && s.directTouch;
				if (s.visible && !noSharedTooltip && !directTouch && pick(s.options.enableMouseTracking, true)) { // #3821
					kdpointT = s.searchPoint(e, !noSharedTooltip && s.kdDimensions === 1); // #3828
					if (kdpointT) {
						kdpoints.push(kdpointT);
					}
				}
			});
			// Find absolute nearest point
			each(kdpoints, function (p) {
				if (p && typeof p.dist === 'number' && p.dist < distance) {
					distance = p.dist;
					kdpoint = p;
				}
			});
		}

		// Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926, #4200
		if (kdpoint && (kdpoint !== this.prevKDPoint || (tooltip && tooltip.isHidden))) {
			// Draw tooltip if necessary
			if (shared && !kdpoint.series.noSharedTooltip) {
				i = kdpoints.length;
				while (i--) {
					if (kdpoints[i].clientX !== kdpoint.clientX || kdpoints[i].series.noSharedTooltip) {
						kdpoints.splice(i, 1);
					}
				}
				if (kdpoints.length && tooltip) {
					tooltip.refresh(kdpoints, e);
				}

				// Do mouseover on all points (#3919, #3985, #4410)
				each(kdpoints, function (point) {
					point.onMouseOver(e, point !== ((hoverSeries && hoverSeries.directTouch && hoverPoint) || kdpoint));
				}); 
			} else {
				if (tooltip) { 
					tooltip.refresh(kdpoint, e);
				}
				if(!hoverSeries || !hoverSeries.directTouch) { // #4448
					kdpoint.onMouseOver(e); 
				}
			}
			this.prevKDPoint = kdpoint;
		
		// Update positions (regardless of kdpoint or hoverPoint)
		} else {
			followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
			if (tooltip && followPointer && !tooltip.isHidden) {
				anchor = tooltip.getAnchor([{}], e);
				tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });			
			}
		}

		// Start the event listener to pick up the tooltip 
		if (tooltip && !pointer._onDocumentMouseMove) {
			pointer._onDocumentMouseMove = function (e) {
				if (charts[hoverChartIndex]) {
					charts[hoverChartIndex].pointer.onDocumentMouseMove(e);
				}
			};
			addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
		}
		
		// Crosshair
		each(chart.axes, function (axis) {
			axis.drawCrosshair(e, pick(kdpoint, hoverPoint));
		});	
		

	},



	/**
	 * Reset the tracking by hiding the tooltip, the hover series state and the hover point
	 * 
	 * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible
	 */
	reset: function (allowMove, delay) {
		var pointer = this,
			chart = pointer.chart,
			hoverSeries = chart.hoverSeries,
			hoverPoint = chart.hoverPoint,
			hoverPoints = chart.hoverPoints,
			tooltip = chart.tooltip,
			tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;
			
		// Narrow in allowMove
		allowMove = allowMove && tooltip && tooltipPoints;
			
		// Check if the points have moved outside the plot area, #1003		
		if (allowMove  && splat(tooltipPoints)[0].plotX === UNDEFINED) {
			allowMove = false;
		}	
		// Just move the tooltip, #349
		if (allowMove) {
			tooltip.refresh(tooltipPoints);
			if (hoverPoint) { // #2500
				hoverPoint.setState(hoverPoint.state, true);
				each(chart.axes, function (axis) {
					if (pick(axis.options.crosshair && axis.options.crosshair.snap, true)) {
						axis.drawCrosshair(null, hoverPoint);
					}  else {
						axis.hideCrosshair();
					}
				});
				
			}

		// Full reset
		} else {

			if (hoverPoint) {
				hoverPoint.onMouseOut();
			}

			if (hoverPoints) {
				each(hoverPoints, function (point) {
					point.setState();
				});
			}

			if (hoverSeries) {
				hoverSeries.onMouseOut();
			}

			if (tooltip) {
				tooltip.hide(delay);
			}

			if (pointer._onDocumentMouseMove) {
				removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
				pointer._onDocumentMouseMove = null;
			}

			// Remove crosshairs
			each(chart.axes, function (axis) {
				axis.hideCrosshair();
			});
			
			pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;

		}
	},

	/**
	 * Scale series groups to a certain scale and translation
	 */
	scaleGroups: function (attribs, clip) {

		var chart = this.chart,
			seriesAttribs;

		// Scale each series
		each(chart.series, function (series) {
			seriesAttribs = attribs || series.getPlotBox(); // #1701
			if (series.xAxis && series.xAxis.zoomEnabled) {
				series.group.attr(seriesAttribs);
				if (series.markerGroup) {
					series.markerGroup.attr(seriesAttribs);
					series.markerGroup.clip(clip ? chart.clipRect : null);
				}
				if (series.dataLabelsGroup) {
					series.dataLabelsGroup.attr(seriesAttribs);
				}
			}
		});
		
		// Clip
		chart.clipRect.attr(clip || chart.clipBox);
	},

	/**
	 * Start a drag operation
	 */
	dragStart: function (e) {
		var chart = this.chart;

		// Record the start position
		chart.mouseIsDown = e.type;
		chart.cancelClick = false;
		chart.mouseDownX = this.mouseDownX = e.chartX;
		chart.mouseDownY = this.mouseDownY = e.chartY;
	},

	/**
	 * Perform a drag operation in response to a mousemove event while the mouse is down
	 */
	drag: function (e) {

		var chart = this.chart,
			chartOptions = chart.options.chart,
			chartX = e.chartX,
			chartY = e.chartY,
			zoomHor = this.zoomHor,
			zoomVert = this.zoomVert,
			plotLeft = chart.plotLeft,
			plotTop = chart.plotTop,
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			clickedInside,
			size,
			selectionMarker = this.selectionMarker,
			mouseDownX = this.mouseDownX,
			mouseDownY = this.mouseDownY,
			panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];

		// If the device supports both touch and mouse (like IE11), and we are touch-dragging
		// inside the plot area, don't handle the mouse event. #4339.
		if (selectionMarker && selectionMarker.touch) {
			return;
		}

		// If the mouse is outside the plot area, adjust to cooordinates
		// inside to prevent the selection marker from going outside
		if (chartX < plotLeft) {
			chartX = plotLeft;
		} else if (chartX > plotLeft + plotWidth) {
			chartX = plotLeft + plotWidth;
		}

		if (chartY < plotTop) {
			chartY = plotTop;
		} else if (chartY > plotTop + plotHeight) {
			chartY = plotTop + plotHeight;
		}
		
		// determine if the mouse has moved more than 10px
		this.hasDragged = Math.sqrt(
			Math.pow(mouseDownX - chartX, 2) +
			Math.pow(mouseDownY - chartY, 2)
		);
		
		if (this.hasDragged > 10) {
			clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

			// make a selection
			if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
				if (!selectionMarker) {
					this.selectionMarker = selectionMarker = chart.renderer.rect(
						plotLeft,
						plotTop,
						zoomHor ? 1 : plotWidth,
						zoomVert ? 1 : plotHeight,
						0
					)
					.attr({
						fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',
						zIndex: 7
					})
					.add();
				}
			}

			// adjust the width of the selection marker
			if (selectionMarker && zoomHor) {
				size = chartX - mouseDownX;
				selectionMarker.attr({
					width: mathAbs(size),
					x: (size > 0 ? 0 : size) + mouseDownX
				});
			}
			// adjust the height of the selection marker
			if (selectionMarker && zoomVert) {
				size = chartY - mouseDownY;
				selectionMarker.attr({
					height: mathAbs(size),
					y: (size > 0 ? 0 : size) + mouseDownY
				});
			}

			// panning
			if (clickedInside && !selectionMarker && chartOptions.panning) {
				chart.pan(e, chartOptions.panning);
			}
		}
	},

	/**
	 * On mouse up or touch end across the entire document, drop the selection.
	 */
	drop: function (e) {
		var pointer = this,
			chart = this.chart,
			hasPinched = this.hasPinched;

		if (this.selectionMarker) {
			var selectionData = {
					xAxis: [],
					yAxis: [],
					originalEvent: e.originalEvent || e
				},
				selectionBox = this.selectionMarker,
				selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
				selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
				selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
				selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
				runZoom;

			// a selection has been made
			if (this.hasDragged || hasPinched) {

				// record each axis' min and max
				each(chart.axes, function (axis) {
					if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569
						var horiz = axis.horiz,
							minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding: 0, // #1207, #3075
							selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
							selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);

						selectionData[axis.coll].push({
							axis: axis,
							min: mathMin(selectionMin, selectionMax), // for reversed axes
							max: mathMax(selectionMin, selectionMax)
						});
						runZoom = true;
					}
				});
				if (runZoom) {
					fireEvent(chart, 'selection', selectionData, function (args) { 
						chart.zoom(extend(args, hasPinched ? { animation: false } : null)); 
					});
				}

			}
			this.selectionMarker = this.selectionMarker.destroy();

			// Reset scaling preview
			if (hasPinched) {
				this.scaleGroups();
			}
		}

		// Reset all
		if (chart) { // it may be destroyed on mouse up - #877
			css(chart.container, { cursor: chart._cursor });
			chart.cancelClick = this.hasDragged > 10; // #370
			chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
			this.pinchDown = [];
		}
	},

	onContainerMouseDown: function (e) {

		e = this.normalize(e);

		// issue #295, dragging not always working in Firefox
		if (e.preventDefault) {
			e.preventDefault();
		}
		
		this.dragStart(e);
	},

	

	onDocumentMouseUp: function (e) {
		if (charts[hoverChartIndex]) {
			charts[hoverChartIndex].pointer.drop(e);
		}
	},

	/**
	 * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.
	 * Issue #149 workaround. The mouseleave event does not always fire. 
	 */
	onDocumentMouseMove: function (e) {
		var chart = this.chart,
			chartPosition = this.chartPosition;

		e = this.normalize(e, chartPosition);

		// If we're outside, hide the tooltip
		if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&
				!chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
			this.reset();
		}
	},

	/**
	 * When mouse leaves the container, hide the tooltip.
	 */
	onContainerMouseLeave: function () {
		var chart = charts[hoverChartIndex];
		if (chart) {
			chart.pointer.reset();
			chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix
		}
	},

	// The mousemove, touchmove and touchstart event handler
	onContainerMouseMove: function (e) {

		var chart = this.chart;

		hoverChartIndex = chart.index;

		e = this.normalize(e);		
		e.returnValue = false; // #2251, #3224
		
		if (chart.mouseIsDown === 'mousedown') {
			this.drag(e);
		} 
		
		// Show the tooltip and run mouse over events (#977)
		if ((this.inClass(e.target, 'highcharts-tracker') || 
				chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
			this.runPointActions(e);
		}
	},

	/**
	 * Utility to detect whether an element has, or has a parent with, a specific
	 * class name. Used on detection of tracker objects and on deciding whether
	 * hovering the tooltip should cause the active series to mouse out.
	 */
	inClass: function (element, className) {
		var elemClassName;
		while (element) {
			elemClassName = attr(element, 'class');
			if (elemClassName) {
				if (elemClassName.indexOf(className) !== -1) {
					return true;
				} else if (elemClassName.indexOf(PREFIX + 'container') !== -1) {
					return false;
				}
			}
			element = element.parentNode;
		}		
	},

	onTrackerMouseOut: function (e) {
		var series = this.chart.hoverSeries,
			relatedTarget = e.relatedTarget || e.toElement;
		
		if (series && !series.options.stickyTracking && 
				!this.inClass(relatedTarget, PREFIX + 'tooltip') &&
				!this.inClass(relatedTarget, PREFIX + 'series-' + series.index)) { // #2499, #4465
			series.onMouseOut();
		}
	},

	onContainerClick: function (e) {
		var chart = this.chart,
			hoverPoint = chart.hoverPoint, 
			plotLeft = chart.plotLeft,
			plotTop = chart.plotTop;
		
		e = this.normalize(e);
		e.originalEvent = e; // #3913

		if (!chart.cancelClick) {
			
			// On tracker click, fire the series and point events. #783, #1583
			if (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {

				// the series click event
				fireEvent(hoverPoint.series, 'click', extend(e, {
					point: hoverPoint
				}));

				// the point click event
				if (chart.hoverPoint) { // it may be destroyed (#1844)
					hoverPoint.firePointEvent('click', e);
				}

			// When clicking outside a tracker, fire a chart event
			} else {
				extend(e, this.getCoordinates(e));

				// fire a click event in the chart
				if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
					fireEvent(chart, 'click', e);
				}
			}


		}
	},

	/**
	 * Set the JS DOM events on the container and document. This method should contain
	 * a one-to-one assignment between methods and their handlers. Any advanced logic should
	 * be moved to the handler reflecting the event's name.
	 */
	setDOMEvents: function () {

		var pointer = this,
			container = pointer.chart.container;

		container.onmousedown = function (e) {
			pointer.onContainerMouseDown(e);
		};
		container.onmousemove = function (e) {
			pointer.onContainerMouseMove(e);
		};
		container.onclick = function (e) {
			pointer.onContainerClick(e);
		};
		addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);
		if (chartCount === 1) {
			addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);
		}
		if (hasTouch) {
			container.ontouchstart = function (e) {
				pointer.onContainerTouchStart(e);
			};
			container.ontouchmove = function (e) {
				pointer.onContainerTouchMove(e);
			};
			if (chartCount === 1) {
				addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);
			}
		}
		
	},

	/**
	 * Destroys the Pointer object and disconnects DOM events.
	 */
	destroy: function () {
		var prop;

		removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);
		if (!chartCount) {
			removeEvent(doc, 'mouseup', this.onDocumentMouseUp);
			removeEvent(doc, 'touchend', this.onDocumentTouchEnd);
		}

		// memory and CPU leak
		clearInterval(this.tooltipTimeout);

		for (prop in this) {
			this[prop] = null;
		}
	}
};


/* Support for touch devices */
extend(Highcharts.Pointer.prototype, {

	/**
	 * Run translation operations
	 */
	pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
		if (this.zoomHor || this.pinchHor) {
			this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
		}
		if (this.zoomVert || this.pinchVert) {
			this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
		}
	},

	/**
	 * Run translation operations for each direction (horizontal and vertical) independently
	 */
	pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
		var chart = this.chart,
			xy = horiz ? 'x' : 'y',
			XY = horiz ? 'X' : 'Y',
			sChartXY = 'chart' + XY,
			wh = horiz ? 'width' : 'height',
			plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
			selectionWH,
			selectionXY,
			clipXY,
			scale = forcedScale || 1,
			inverted = chart.inverted,
			bounds = chart.bounds[horiz ? 'h' : 'v'],
			singleTouch = pinchDown.length === 1,
			touch0Start = pinchDown[0][sChartXY],
			touch0Now = touches[0][sChartXY],
			touch1Start = !singleTouch && pinchDown[1][sChartXY],
			touch1Now = !singleTouch && touches[1][sChartXY],
			outOfBounds,
			transformScale,
			scaleKey,
			setScale = function () {
				if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis
					scale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start); 
				}
				
				clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
				selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
			};

		// Set the scale, first pass
		setScale();

		selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not

		// Out of bounds
		if (selectionXY < bounds.min) {
			selectionXY = bounds.min;
			outOfBounds = true;
		} else if (selectionXY + selectionWH > bounds.max) {
			selectionXY = bounds.max - selectionWH;
			outOfBounds = true;
		}
		
		// Is the chart dragged off its bounds, determined by dataMin and dataMax?
		if (outOfBounds) {

			// Modify the touchNow position in order to create an elastic drag movement. This indicates
			// to the user that the chart is responsive but can't be dragged further.
			touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
			if (!singleTouch) {
				touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
			}

			// Set the scale, second pass to adapt to the modified touchNow positions
			setScale();

		} else {
			lastValidTouch[xy] = [touch0Now, touch1Now];
		}

		// Set geometry for clipping, selection and transformation
		if (!inverted) { // TODO: implement clipping for inverted charts
			clip[xy] = clipXY - plotLeftTop;
			clip[wh] = selectionWH;
		}
		scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
		transformScale = inverted ? 1 / scale : scale;

		selectionMarker[wh] = selectionWH;
		selectionMarker[xy] = selectionXY;
		transform[scaleKey] = scale;
		transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
	},
	
	/**
	 * Handle touch events with two touches
	 */
	pinch: function (e) {

		var self = this,
			chart = self.chart,
			pinchDown = self.pinchDown,
			touches = e.touches,
			touchesLength = touches.length,
			lastValidTouch = self.lastValidTouch,
			hasZoom = self.hasZoom,
			selectionMarker = self.selectionMarker,
			transform = {},
			fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') && 
				chart.runTrackerClick) || self.runChartClick),
			clip = {};

		// Don't initiate panning until the user has pinched. This prevents us from 
		// blocking page scrolling as users scroll down a long page (#4210).
		if (touchesLength > 1) {
			self.initiated = true;
		}

		// On touch devices, only proceed to trigger click if a handler is defined
		if (hasZoom && self.initiated && !fireClickEvent) {
			e.preventDefault();
		}
		
		// Normalize each touch
		map(touches, function (e) {
			return self.normalize(e);
		});
		
		// Register the touch start position
		if (e.type === 'touchstart') {
			each(touches, function (e, i) {
				pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };
			});
			lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
			lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];

			// Identify the data bounds in pixels
			each(chart.axes, function (axis) {
				if (axis.zoomEnabled) {
					var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
						minPixelPadding = axis.minPixelPadding,
						min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
						max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
						absMin = mathMin(min, max),
						absMax = mathMax(min, max);

					// Store the bounds for use in the touchmove handler
					bounds.min = mathMin(axis.pos, absMin - minPixelPadding);
					bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);
				}
			});
			self.res = true; // reset on next move
		
		// Event type is touchmove, handle panning and pinching
		} else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first
			

			// Set the marker
			if (!selectionMarker) {
				self.selectionMarker = selectionMarker = extend({
					destroy: noop,
					touch: true
				}, chart.plotBox);
			}
			
			self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);

			self.hasPinched = hasZoom;

			// Scale and translate the groups to provide visual feedback during pinching
			self.scaleGroups(transform, clip);
			
			// Optionally move the tooltip on touchmove
			if (!hasZoom && self.followTouchMove && touchesLength === 1) {
				this.runPointActions(self.normalize(e));
			} else if (self.res) {
				self.res = false;
				this.reset(false, 0);
			}
		}
	},

	/**
	 * General touch handler shared by touchstart and touchmove.
	 */
	touch: function (e, start) {
		var chart = this.chart;

		hoverChartIndex = chart.index;

		if (e.touches.length === 1) {

			e = this.normalize(e);

			if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {

				// Run mouse events and display tooltip etc
				if (start) {
					this.runPointActions(e);
				}

				this.pinch(e);

			} else if (start) {
				// Hide the tooltip on touching outside the plot area (#1203)
				this.reset();
			}

		} else if (e.touches.length === 2) {
			this.pinch(e);
		}
	},

	onContainerTouchStart: function (e) {
		this.touch(e, true);
	},

	onContainerTouchMove: function (e) {
		this.touch(e);
	},

	onDocumentTouchEnd: function (e) {
		if (charts[hoverChartIndex]) {
			charts[hoverChartIndex].pointer.drop(e);
		}
	}

});
if (win.PointerEvent || win.MSPointerEvent) {
	
	// The touches object keeps track of the points being touched at all times
	var touches = {},
		hasPointerEvent = !!win.PointerEvent,
		getWebkitTouches = function () {
			var key, fake = [];
			fake.item = function (i) { return this[i]; };
			for (key in touches) {
				if (touches.hasOwnProperty(key)) {
					fake.push({
						pageX: touches[key].pageX,
						pageY: touches[key].pageY,
						target: touches[key].target
					});
				}
			}
			return fake;
		},
		translateMSPointer = function (e, method, wktype, callback) {
			var p;
			e = e.originalEvent || e;
			if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {
				callback(e);
				p = charts[hoverChartIndex].pointer;
				p[method]({
					type: wktype,
					target: e.currentTarget,
					preventDefault: noop,
					touches: getWebkitTouches()
				});				
			}
		};

	/**
	 * Extend the Pointer prototype with methods for each event handler and more
	 */
	extend(Pointer.prototype, {
		onContainerPointerDown: function (e) {
			translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {
				touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };
			});
		},
		onContainerPointerMove: function (e) {
			translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {
				touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };
				if (!touches[e.pointerId].target) {
					touches[e.pointerId].target = e.currentTarget;
				}
			});
		},
		onDocumentPointerUp: function (e) {
			translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function (e) {
				delete touches[e.pointerId];
			});
		},

		/**
		 * Add or remove the MS Pointer specific events
		 */
		batchMSEvents: function (fn) {
			fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
			fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
			fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
		}
	});

	// Disable default IE actions for pinch and such on chart element
	wrap(Pointer.prototype, 'init', function (proceed, chart, options) {
		proceed.call(this, chart, options);
		if (this.hasZoom) { // #4014
			css(chart.container, {
				'-ms-touch-action': NONE,
				'touch-action': NONE
			});
		}
	});

	// Add IE specific touch events to chart
	wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {
		proceed.apply(this);
		if (this.hasZoom || this.followTouchMove) {
			this.batchMSEvents(addEvent);
		}
	});
	// Destroy MS events also
	wrap(Pointer.prototype, 'destroy', function (proceed) {
		this.batchMSEvents(removeEvent);
		proceed.call(this);
	});
}
/**
 * The overview of the chart's series
 */
var Legend = Highcharts.Legend = function (chart, options) {
	this.init(chart, options);
};

Legend.prototype = {
	
	/**
	 * Initialize the legend
	 */
	init: function (chart, options) {
		
		var legend = this,
			itemStyle = options.itemStyle,
			padding,
			itemMarginTop = options.itemMarginTop || 0;
	
		this.options = options;

		if (!options.enabled) {
			return;
		}
	
		legend.itemStyle = itemStyle;
		legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);
		legend.itemMarginTop = itemMarginTop;
		legend.padding = padding = pick(options.padding, 8);
		legend.initialItemX = padding;
		legend.initialItemY = padding - 5; // 5 is the number of pixels above the text
		legend.maxItemWidth = 0;
		legend.chart = chart;
		legend.itemHeight = 0;
		legend.symbolWidth = pick(options.symbolWidth, 16);
		legend.pages = [];


		// Render it
		legend.render();

		// move checkboxes
		addEvent(legend.chart, 'endResize', function () { 
			legend.positionCheckboxes();
		});

	},

	/**
	 * Set the colors for the legend item
	 * @param {Object} item A Series or Point instance
	 * @param {Object} visible Dimmed or colored
	 */
	colorizeItem: function (item, visible) {
		var legend = this,
			options = legend.options,
			legendItem = item.legendItem,
			legendLine = item.legendLine,
			legendSymbol = item.legendSymbol,
			hiddenColor = legend.itemHiddenStyle.color,
			textColor = visible ? options.itemStyle.color : hiddenColor,
			symbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,
			markerOptions = item.options && item.options.marker,
			symbolAttr = { fill: symbolColor },
			key,
			val;
		
		if (legendItem) {
			legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE
		}
		if (legendLine) {
			legendLine.attr({ stroke: symbolColor });
		}
		
		if (legendSymbol) {
			
			// Apply marker options
			if (markerOptions && legendSymbol.isMarker) { // #585
				symbolAttr.stroke = symbolColor;
				markerOptions = item.convertAttribs(markerOptions);
				for (key in markerOptions) {
					val = markerOptions[key];
					if (val !== UNDEFINED) {
						symbolAttr[key] = val;
					}
				}
			}

			legendSymbol.attr(symbolAttr);
		}
	},

	/**
	 * Position the legend item
	 * @param {Object} item A Series or Point instance
	 */
	positionItem: function (item) {
		var legend = this,
			options = legend.options,
			symbolPadding = options.symbolPadding,
			ltr = !options.rtl,
			legendItemPos = item._legendItemPos,
			itemX = legendItemPos[0],
			itemY = legendItemPos[1],
			checkbox = item.checkbox,
			legendGroup = item.legendGroup;

		if (legendGroup && legendGroup.element) {
			legendGroup.translate(
				ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
				itemY
			);
		}

		if (checkbox) {
			checkbox.x = itemX;
			checkbox.y = itemY;
		}
	},

	/**
	 * Destroy a single legend item
	 * @param {Object} item The series or point
	 */
	destroyItem: function (item) {
		var checkbox = item.checkbox;

		// destroy SVG elements
		each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {
			if (item[key]) {
				item[key] = item[key].destroy();
			}
		});

		if (checkbox) {
			discardElement(item.checkbox);
		}
	},

	/**
	 * Destroys the legend.
	 */
	destroy: function () {
		var legend = this,
			legendGroup = legend.group,
			box = legend.box;

		if (box) {
			legend.box = box.destroy();
		}

		if (legendGroup) {
			legend.group = legendGroup.destroy();
		}
	},

	/**
	 * Position the checkboxes after the width is determined
	 */
	positionCheckboxes: function (scrollOffset) {
		var alignAttr = this.group.alignAttr,
			translateY,
			clipHeight = this.clipHeight || this.legendHeight;

		if (alignAttr) {
			translateY = alignAttr.translateY;
			each(this.allItems, function (item) {
				var checkbox = item.checkbox,
					top;
				
				if (checkbox) {
					top = (translateY + checkbox.y + (scrollOffset || 0) + 3);
					css(checkbox, {
						left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,
						top: top + PX,
						display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE
					});
				}
			});
		}
	},
	
	/**
	 * Render the legend title on top of the legend
	 */
	renderTitle: function () {
		var options = this.options,
			padding = this.padding,
			titleOptions = options.title,
			titleHeight = 0,
			bBox;
		
		if (titleOptions.text) {
			if (!this.title) {
				this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')
					.attr({ zIndex: 1 })
					.css(titleOptions.style)
					.add(this.group);
			}
			bBox = this.title.getBBox();
			titleHeight = bBox.height;
			this.offsetWidth = bBox.width; // #1717
			this.contentGroup.attr({ translateY: titleHeight });
		}
		this.titleHeight = titleHeight;
	},

	/**
	 * Set the legend item text
	 */
	setText: function (item) {
		var options = this.options;
		item.legendItem.attr({
			text: options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item)
		});
	},

	/**
	 * Render a single specific legend item
	 * @param {Object} item A series or point
	 */
	renderItem: function (item) {
		var legend = this,
			chart = legend.chart,
			renderer = chart.renderer,
			options = legend.options,
			horizontal = options.layout === 'horizontal',
			symbolWidth = legend.symbolWidth,
			symbolPadding = options.symbolPadding,
			itemStyle = legend.itemStyle,
			itemHiddenStyle = legend.itemHiddenStyle,
			padding = legend.padding,
			itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
			ltr = !options.rtl,
			itemHeight,
			widthOption = options.width,
			itemMarginBottom = options.itemMarginBottom || 0,
			itemMarginTop = legend.itemMarginTop,
			initialItemX = legend.initialItemX,
			bBox,
			itemWidth,
			li = item.legendItem,
			series = item.series && item.series.drawLegendSymbol ? item.series : item,
			seriesOptions = series.options,
			showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,
			useHTML = options.useHTML;

		if (!li) { // generate it once, later move it

			// Generate the group box
			// A group to hold the symbol and text. Text is to be appended in Legend class.
			item.legendGroup = renderer.g('legend-item')
				.attr({ zIndex: 1 })
				.add(legend.scrollGroup);

			// Generate the list item text and add it to the group
			item.legendItem = li = renderer.text(
					'',
					ltr ? symbolWidth + symbolPadding : -symbolPadding,
					legend.baseline || 0,
					useHTML
				)
				.css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)
				.attr({
					align: ltr ? 'left' : 'right',
					zIndex: 2
				})
				.add(item.legendGroup);

			// Get the baseline for the first item - the font size is equal for all
			if (!legend.baseline) {
				legend.fontMetrics = renderer.fontMetrics(itemStyle.fontSize, li);
				legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;
				li.attr('y', legend.baseline);
			}

			// Draw the legend symbol inside the group box
			series.drawLegendSymbol(legend, item);

			if (legend.setItemEvents) {
				legend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);
			}			

			// Colorize the items
			legend.colorizeItem(item, item.visible);

			// add the HTML checkbox on top
			if (showCheckbox) {
				legend.createCheckboxForItem(item);				
			}
		}

		// Always update the text
		legend.setText(item);

		// calculate the positions for the next line
		bBox = li.getBBox();

		itemWidth = item.checkboxOffset = 
			options.itemWidth || 
			item.legendItemWidth || 
			symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);
		legend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);

		// if the item exceeds the width, start a new line
		if (horizontal && legend.itemX - initialItemX + itemWidth >
				(widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {
			legend.itemX = initialItemX;
			legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
			legend.lastLineHeight = 0; // reset for next line (#915, #3976)
		}

		// If the item exceeds the height, start a new column
		/*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {
			legend.itemY = legend.initialItemY;
			legend.itemX += legend.maxItemWidth;
			legend.maxItemWidth = 0;
		}*/

		// Set the edge positions
		legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);
		legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
		legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915

		// cache the position of the newly generated or reordered items
		item._legendItemPos = [legend.itemX, legend.itemY];

		// advance
		if (horizontal) {
			legend.itemX += itemWidth;

		} else {
			legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
			legend.lastLineHeight = itemHeight;
		}

		// the width of the widest item
		legend.offsetWidth = widthOption || mathMax(
			(horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,
			legend.offsetWidth
		);
	},

	/**
	 * Get all items, which is one item per series for normal series and one item per point
	 * for pie series.
	 */
	getAllItems: function () {
		var allItems = [];
		each(this.chart.series, function (series) {
			var seriesOptions = series.options;

			// Handle showInLegend. If the series is linked to another series, defaults to false.
			if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {
				return;
			}

			// use points or series for the legend item depending on legendType
			allItems = allItems.concat(
					series.legendItems ||
					(seriesOptions.legendType === 'point' ?
							series.data :
							series)
			);
		});
		return allItems;
	},

	/**
	 * Adjust the chart margins by reserving space for the legend on only one side
	 * of the chart. If the position is set to a corner, top or bottom is reserved
	 * for horizontal legends and left or right for vertical ones.
	 */
	adjustMargins: function (margin, spacing) {
		var chart = this.chart, 
			options = this.options,
			// Use the first letter of each alignment option in order to detect the side 
			alignment = options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0); // #4189 - use charAt(x) notation instead of [x] for IE7
			
		if (this.display && !options.floating) {

			each([
				/(lth|ct|rth)/,
				/(rtv|rm|rbv)/,
				/(rbh|cb|lbh)/,
				/(lbv|lm|ltv)/
			], function (alignments, side) {
				if (alignments.test(alignment) && !defined(margin[side])) {
					// Now we have detected on which side of the chart we should reserve space for the legend
					chart[marginNames[side]] = mathMax(
						chart[marginNames[side]],
						chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + 
							[1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] + 
							pick(options.margin, 12) +
							spacing[side]
					);
				}
			});
		}
	},

	/**
	 * Render the legend. This method can be called both before and after
	 * chart.render. If called after, it will only rearrange items instead
	 * of creating new ones.
	 */
	render: function () {
		var legend = this,
			chart = legend.chart,
			renderer = chart.renderer,
			legendGroup = legend.group,
			allItems,
			display,
			legendWidth,
			legendHeight,
			box = legend.box,
			options = legend.options,
			padding = legend.padding,
			legendBorderWidth = options.borderWidth,
			legendBackgroundColor = options.backgroundColor;

		legend.itemX = legend.initialItemX;
		legend.itemY = legend.initialItemY;
		legend.offsetWidth = 0;
		legend.lastItemY = 0;

		if (!legendGroup) {
			legend.group = legendGroup = renderer.g('legend')
				.attr({ zIndex: 7 }) 
				.add();
			legend.contentGroup = renderer.g()
				.attr({ zIndex: 1 }) // above background
				.add(legendGroup);
			legend.scrollGroup = renderer.g()
				.add(legend.contentGroup);
		}
		
		legend.renderTitle();

		// add each series or point
		allItems = legend.getAllItems();

		// sort by legendIndex
		stableSort(allItems, function (a, b) {
			return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);
		});

		// reversed legend
		if (options.reversed) {
			allItems.reverse();
		}

		legend.allItems = allItems;
		legend.display = display = !!allItems.length;

		// render the items
		legend.lastLineHeight = 0;
		each(allItems, function (item) {
			legend.renderItem(item); 
		});

		// Get the box
		legendWidth = (options.width || legend.offsetWidth) + padding;
		legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
		legendHeight = legend.handleOverflow(legendHeight);
		legendHeight += padding;

		// Draw the border and/or background
		if (legendBorderWidth || legendBackgroundColor) {

			if (!box) {
				legend.box = box = renderer.rect(
					0,
					0,
					legendWidth,
					legendHeight,
					options.borderRadius,
					legendBorderWidth || 0
				).attr({
					stroke: options.borderColor,
					'stroke-width': legendBorderWidth || 0,
					fill: legendBackgroundColor || NONE
				})
				.add(legendGroup)
				.shadow(options.shadow);
				box.isNew = true;

			} else if (legendWidth > 0 && legendHeight > 0) {
				box[box.isNew ? 'attr' : 'animate'](
					box.crisp({ width: legendWidth, height: legendHeight })
				);
				box.isNew = false;
			}

			// hide the border if no items
			box[display ? 'show' : 'hide']();
		}
		
		legend.legendWidth = legendWidth;
		legend.legendHeight = legendHeight;

		// Now that the legend width and height are established, put the items in the 
		// final position
		each(allItems, function (item) {
			legend.positionItem(item);
		});

		// 1.x compatibility: positioning based on style
		/*var props = ['left', 'right', 'top', 'bottom'],
			prop,
			i = 4;
		while (i--) {
			prop = props[i];
			if (options.style[prop] && options.style[prop] !== 'auto') {
				options[i < 2 ? 'align' : 'verticalAlign'] = prop;
				options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);
			}
		}*/

		if (display) {
			legendGroup.align(extend({
				width: legendWidth,
				height: legendHeight
			}, options), true, 'spacingBox');
		}

		if (!chart.isResizing) {
			this.positionCheckboxes();
		}
	},
	
	/**
	 * Set up the overflow handling by adding navigation with up and down arrows below the
	 * legend.
	 */
	handleOverflow: function (legendHeight) {
		var legend = this,
			chart = this.chart,
			renderer = chart.renderer,
			options = this.options,
			optionsY = options.y,
			alignTop = options.verticalAlign === 'top',
			spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,
			maxHeight = options.maxHeight,
			clipHeight,
			clipRect = this.clipRect,
			navOptions = options.navigation,
			animation = pick(navOptions.animation, true),
			arrowSize = navOptions.arrowSize || 12,
			nav = this.nav,
			pages = this.pages,
			padding = this.padding,
			lastY,
			allItems = this.allItems,
			clipToHeight = function (height) {
				clipRect.attr({
					height: height
				});

				// useHTML
				if (legend.contentGroup.div) {
					legend.contentGroup.div.style.clip = 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)';
				}
			};

			
		// Adjust the height
		if (options.layout === 'horizontal') {
			spaceHeight /= 2;
		}
		if (maxHeight) {
			spaceHeight = mathMin(spaceHeight, maxHeight);
		}
		
		// Reset the legend height and adjust the clipping rectangle
		pages.length = 0;
		if (legendHeight > spaceHeight) {

			this.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - padding, 0);
			this.currentPage = pick(this.currentPage, 1);
			this.fullHeight = legendHeight;
			
			// Fill pages with Y positions so that the top of each a legend item defines
			// the scroll top for each page (#2098)
			each(allItems, function (item, i) {
				var y = item._legendItemPos[1],
					h = mathRound(item.legendItem.getBBox().height),
					len = pages.length;
				
				if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {
					pages.push(lastY || y);
					len++;
				}
				
				if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {
					pages.push(y);
				}
				if (y !== lastY) {
					lastY = y;
				}
			});

			// Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)
			if (!clipRect) {
				clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);
				legend.contentGroup.clip(clipRect);
			}
				
			clipToHeight(clipHeight);

			// Add navigation elements
			if (!nav) {
				this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
				this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)
					.on('click', function () {
						legend.scroll(-1, animation);
					})
					.add(nav);
				this.pager = renderer.text('', 15, 10)
					.css(navOptions.style)
					.add(nav);
				this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)
					.on('click', function () {
						legend.scroll(1, animation);
					})
					.add(nav);
			}
			
			// Set initial position
			legend.scroll(0);
			
			legendHeight = spaceHeight;
			
		} else if (nav) {
			clipToHeight(chart.chartHeight);
			nav.hide();
			this.scrollGroup.attr({
				translateY: 1
			});
			this.clipHeight = 0; // #1379
		}
		
		return legendHeight;
	},
	
	/**
	 * Scroll the legend by a number of pages
	 * @param {Object} scrollBy
	 * @param {Object} animation
	 */
	scroll: function (scrollBy, animation) {
		var pages = this.pages,
			pageCount = pages.length,
			currentPage = this.currentPage + scrollBy,
			clipHeight = this.clipHeight,
			navOptions = this.options.navigation,
			activeColor = navOptions.activeColor,
			inactiveColor = navOptions.inactiveColor,
			pager = this.pager,
			padding = this.padding,
			scrollOffset;
		
		// When resizing while looking at the last page
		if (currentPage > pageCount) {
			currentPage = pageCount;
		}
		
		if (currentPage > 0) {
			
			if (animation !== UNDEFINED) {
				setAnimation(animation, this.chart);
			}
			
			this.nav.attr({
				translateX: padding,
				translateY: clipHeight + this.padding + 7 + this.titleHeight,
				visibility: VISIBLE
			});
			this.up.attr({
					fill: currentPage === 1 ? inactiveColor : activeColor
				})
				.css({
					cursor: currentPage === 1 ? 'default' : 'pointer'
				});
			pager.attr({
				text: currentPage + '/' + pageCount
			});
			this.down.attr({
					x: 18 + this.pager.getBBox().width, // adjust to text width
					fill: currentPage === pageCount ? inactiveColor : activeColor
				})
				.css({
					cursor: currentPage === pageCount ? 'default' : 'pointer'
				});
			
			scrollOffset = -pages[currentPage - 1] + this.initialItemY;

			this.scrollGroup.animate({
				translateY: scrollOffset
			});			
			
			this.currentPage = currentPage;
			this.positionCheckboxes(scrollOffset);
		}
			
	}
	
};

/*
 * LegendSymbolMixin
 */ 

var LegendSymbolMixin = Highcharts.LegendSymbolMixin = {

	/**
	 * Get the series' symbol in the legend
	 * 
	 * @param {Object} legend The legend object
	 * @param {Object} item The series (this) or point
	 */
	drawRectangle: function (legend, item) {
		var symbolHeight = legend.options.symbolHeight || legend.fontMetrics.f;

		item.legendSymbol = this.chart.renderer.rect(
			0,
			legend.baseline - symbolHeight + 1, // #3988
			legend.symbolWidth,
			symbolHeight,
			legend.options.symbolRadius || 0
		).attr({
			zIndex: 3
		}).add(item.legendGroup);		
		
	},

	/**
	 * Get the series' symbol in the legend. This method should be overridable to create custom 
	 * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
	 * 
	 * @param {Object} legend The legend object
	 */
	drawLineMarker: function (legend) {

		var options = this.options,
			markerOptions = options.marker,
			radius,
			legendSymbol,
			symbolWidth = legend.symbolWidth,
			renderer = this.chart.renderer,
			legendItemGroup = this.legendGroup,
			verticalCenter = legend.baseline - mathRound(legend.fontMetrics.b * 0.3),
			attr;

		// Draw the line
		if (options.lineWidth) {
			attr = {
				'stroke-width': options.lineWidth
			};
			if (options.dashStyle) {
				attr.dashstyle = options.dashStyle;
			}
			this.legendLine = renderer.path([
				M,
				0,
				verticalCenter,
				L,
				symbolWidth,
				verticalCenter
			])
			.attr(attr)
			.add(legendItemGroup);
		}
		
		// Draw the marker
		if (markerOptions && markerOptions.enabled !== false) {
			radius = markerOptions.radius;
			this.legendSymbol = legendSymbol = renderer.symbol(
				this.symbol,
				(symbolWidth / 2) - radius,
				verticalCenter - radius,
				2 * radius,
				2 * radius
			)
			.add(legendItemGroup);
			legendSymbol.isMarker = true;
		}
	}
};

// Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
// and for #2580, a similar drawing flaw in Firefox 26.
// TODO: Explore if there's a general cause for this. The problem may be related 
// to nested group elements, as the legend item texts are within 4 group elements.
if (/Trident\/7\.0/.test(userAgent) || isFirefox) {
	wrap(Legend.prototype, 'positionItem', function (proceed, item) {
		var legend = this,
			runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)
				if (item._legendItemPos) {
					proceed.call(legend, item);
				}
			};

		// Do it now, for export and to get checkbox placement
		runPositionItem();
		
		// Do it after to work around the core issue
		setTimeout(runPositionItem);
	});
}
/**
 * The chart class
 * @param {Object} options
 * @param {Function} callback Function to run when the chart has loaded
 */
var Chart = Highcharts.Chart = function () {
	this.init.apply(this, arguments);
};

Chart.prototype = {

	/**
	 * Hook for modules
	 */
	callbacks: [],

	/**
	 * Initialize the chart
	 */
	init: function (userOptions, callback) {

		// Handle regular options
		var options,
			seriesOptions = userOptions.series; // skip merging data points to increase performance

		userOptions.series = null;
		options = merge(defaultOptions, userOptions); // do the merge
		options.series = userOptions.series = seriesOptions; // set back the series data
		this.userOptions = userOptions;

		var optionsChart = options.chart;
		
		// Create margin & spacing array
		this.margin = this.splashArray('margin', optionsChart);
		this.spacing = this.splashArray('spacing', optionsChart);

		var chartEvents = optionsChart.events;

		//this.runChartClick = chartEvents && !!chartEvents.click;
		this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom

		this.callback = callback;
		this.isResizing = 0;
		this.options = options;
		//chartTitleOptions = UNDEFINED;
		//chartSubtitleOptions = UNDEFINED;

		this.axes = [];
		this.series = [];
		this.hasCartesianSeries = optionsChart.showAxes;
		//this.axisOffset = UNDEFINED;
		//this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes
		//this.inverted = UNDEFINED;
		//this.loadingShown = UNDEFINED;
		//this.container = UNDEFINED;
		//this.chartWidth = UNDEFINED;
		//this.chartHeight = UNDEFINED;
		//this.marginRight = UNDEFINED;
		//this.marginBottom = UNDEFINED;
		//this.containerWidth = UNDEFINED;
		//this.containerHeight = UNDEFINED;
		//this.oldChartWidth = UNDEFINED;
		//this.oldChartHeight = UNDEFINED;

		//this.renderTo = UNDEFINED;
		//this.renderToClone = UNDEFINED;

		//this.spacingBox = UNDEFINED

		//this.legend = UNDEFINED;

		// Elements
		//this.chartBackground = UNDEFINED;
		//this.plotBackground = UNDEFINED;
		//this.plotBGImage = UNDEFINED;
		//this.plotBorder = UNDEFINED;
		//this.loadingDiv = UNDEFINED;
		//this.loadingSpan = UNDEFINED;

		var chart = this,
			eventType;

		// Add the chart to the global lookup
		chart.index = charts.length;
		charts.push(chart);
		chartCount++;

		// Set up auto resize
		if (optionsChart.reflow !== false) {
			addEvent(chart, 'load', function () {
				chart.initReflow();
			});
		}

		// Chart event handlers
		if (chartEvents) {
			for (eventType in chartEvents) {
				addEvent(chart, eventType, chartEvents[eventType]);
			}
		}

		chart.xAxis = [];
		chart.yAxis = [];

		// Expose methods and variables
		chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
		chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;

		chart.firstRender();
	},

	/**
	 * Initialize an individual series, called internally before render time
	 */
	initSeries: function (options) {
		var chart = this,
			optionsChart = chart.options.chart,
			type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
			series,
			constr = seriesTypes[type];

		// No such series type
		if (!constr) {
			error(17, true);
		}

		series = new constr();
		series.init(this, options);
		return series;
	},

	/**
	 * Check whether a given point is within the plot area
	 *
	 * @param {Number} plotX Pixel x relative to the plot area
	 * @param {Number} plotY Pixel y relative to the plot area
	 * @param {Boolean} inverted Whether the chart is inverted
	 */
	isInsidePlot: function (plotX, plotY, inverted) {
		var x = inverted ? plotY : plotX,
			y = inverted ? plotX : plotY;
			
		return x >= 0 &&
			x <= this.plotWidth &&
			y >= 0 &&
			y <= this.plotHeight;
	},

	/**
	 * Redraw legend, axes or series based on updated data
	 *
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	redraw: function (animation) {
		var chart = this,
			axes = chart.axes,
			series = chart.series,
			pointer = chart.pointer,
			legend = chart.legend,
			redrawLegend = chart.isDirtyLegend,
			hasStackedSeries,
			hasDirtyStacks,
			hasCartesianSeries = chart.hasCartesianSeries,
			isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
			seriesLength = series.length,
			i = seriesLength,
			serie,
			renderer = chart.renderer,
			isHiddenChart = renderer.isHidden(),
			afterRedraw = [];
			
		setAnimation(animation, chart);
		
		if (isHiddenChart) {
			chart.cloneRenderTo();
		}

		// Adjust title layout (reflow multiline text)
		chart.layOutTitles();

		// link stacked series
		while (i--) {
			serie = series[i];

			if (serie.options.stacking) {
				hasStackedSeries = true;
				
				if (serie.isDirty) {
					hasDirtyStacks = true;
					break;
				}
			}
		}
		if (hasDirtyStacks) { // mark others as dirty
			i = seriesLength;
			while (i--) {
				serie = series[i];
				if (serie.options.stacking) {
					serie.isDirty = true;
				}
			}
		}

		// Handle updated data in the series
		each(series, function (serie) {
			if (serie.isDirty) {
				if (serie.options.legendType === 'point') {
					if (serie.updateTotals) {
						serie.updateTotals();
					}
					redrawLegend = true;
				}
			}
		});

		// handle added or removed series
		if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed
			// draw legend graphics
			legend.render();

			chart.isDirtyLegend = false;
		}

		// reset stacks
		if (hasStackedSeries) {
			chart.getStacks();
		}


		if (hasCartesianSeries) {
			if (!chart.isResizing) {

				// reset maxTicks
				chart.maxTicks = null;

				// set axes scales
				each(axes, function (axis) {
					axis.setScale();
				});
			}
		}

		chart.getMargins(); // #3098

		if (hasCartesianSeries) {
			// If one axis is dirty, all axes must be redrawn (#792, #2169)
			each(axes, function (axis) {
				if (axis.isDirty) {
					isDirtyBox = true;
				}
			});

			// redraw axes
			each(axes, function (axis) {

				// Fire 'afterSetExtremes' only if extremes are set
				var key = axis.min + ',' + axis.max;
				if (axis.extKey !== key) { // #821, #4452
					axis.extKey = key;
					afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)
						fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751
						delete axis.eventArgs;
					});
				}
				if (isDirtyBox || hasStackedSeries) {
					axis.redraw();
				}
			});
		}
		
		// the plot areas size has changed
		if (isDirtyBox) {
			chart.drawChartBox();
		}


		// redraw affected series
		each(series, function (serie) {
			if (serie.isDirty && serie.visible &&
					(!serie.isCartesian || serie.xAxis)) { // issue #153
				serie.redraw();
			}
		});

		// move tooltip or reset
		if (pointer) {
			pointer.reset(true);
		}

		// redraw if canvas
		renderer.draw();

		// fire the event
		fireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw
		
		if (isHiddenChart) {
			chart.cloneRenderTo(true);
		}
		
		// Fire callbacks that are put on hold until after the redraw
		each(afterRedraw, function (callback) {
			callback.call();
		});
	},

	/**
	 * Get an axis, series or point object by id.
	 * @param id {String} The id as given in the configuration options
	 */
	get: function (id) {
		var chart = this,
			axes = chart.axes,
			series = chart.series;

		var i,
			j,
			points;

		// search axes
		for (i = 0; i < axes.length; i++) {
			if (axes[i].options.id === id) {
				return axes[i];
			}
		}

		// search series
		for (i = 0; i < series.length; i++) {
			if (series[i].options.id === id) {
				return series[i];
			}
		}

		// search points
		for (i = 0; i < series.length; i++) {
			points = series[i].points || [];
			for (j = 0; j < points.length; j++) {
				if (points[j].id === id) {
					return points[j];
				}
			}
		}
		return null;
	},

	/**
	 * Create the Axis instances based on the config options
	 */
	getAxes: function () {
		var chart = this,
			options = this.options,
			xAxisOptions = options.xAxis = splat(options.xAxis || {}),
			yAxisOptions = options.yAxis = splat(options.yAxis || {}),
			optionsArray,
			axis;

		// make sure the options are arrays and add some members
		each(xAxisOptions, function (axis, i) {
			axis.index = i;
			axis.isX = true;
		});

		each(yAxisOptions, function (axis, i) {
			axis.index = i;
		});

		// concatenate all axis options into one array
		optionsArray = xAxisOptions.concat(yAxisOptions);

		each(optionsArray, function (axisOptions) {
			axis = new Axis(chart, axisOptions);
		});
	},


	/**
	 * Get the currently selected points from all series
	 */
	getSelectedPoints: function () {
		var points = [];
		each(this.series, function (serie) {
			points = points.concat(grep(serie.points || [], function (point) {
				return point.selected;
			}));
		});
		return points;
	},

	/**
	 * Get the currently selected series
	 */
	getSelectedSeries: function () {
		return grep(this.series, function (serie) {
			return serie.selected;
		});
	},

	/**
	 * Show the title and subtitle of the chart
	 *
	 * @param titleOptions {Object} New title options
	 * @param subtitleOptions {Object} New subtitle options
	 *
	 */
	setTitle: function (titleOptions, subtitleOptions, redraw) {
		var chart = this,
			options = chart.options,
			chartTitleOptions,
			chartSubtitleOptions;

		chartTitleOptions = options.title = merge(options.title, titleOptions);
		chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);

		// add title and subtitle
		each([
			['title', titleOptions, chartTitleOptions],
			['subtitle', subtitleOptions, chartSubtitleOptions]
		], function (arr) {
			var name = arr[0],
				title = chart[name],
				titleOptions = arr[1],
				chartTitleOptions = arr[2];

			if (title && titleOptions) {
				chart[name] = title = title.destroy(); // remove old
			}
			
			if (chartTitleOptions && chartTitleOptions.text && !title) {
				chart[name] = chart.renderer.text(
					chartTitleOptions.text,
					0,
					0,
					chartTitleOptions.useHTML
				)
				.attr({
					align: chartTitleOptions.align,
					'class': PREFIX + name,
					zIndex: chartTitleOptions.zIndex || 4
				})
				.css(chartTitleOptions.style)
				.add();
			}	
		});
		chart.layOutTitles(redraw);
	},

	/**
	 * Lay out the chart titles and cache the full offset height for use in getMargins
	 */
	layOutTitles: function (redraw) {
		var titleOffset = 0,
			title = this.title,
			subtitle = this.subtitle,
			options = this.options,
			titleOptions = options.title,
			subtitleOptions = options.subtitle,
			requiresDirtyBox,
			renderer = this.renderer,
			autoWidth = this.spacingBox.width - 44; // 44 makes room for default context button

		if (title) {
			title
				.css({ width: (titleOptions.width || autoWidth) + PX })
				.align(extend({ 
					y: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3
				}, titleOptions), false, 'spacingBox');
			
			if (!titleOptions.floating && !titleOptions.verticalAlign) {
				titleOffset = title.getBBox().height;
			}
		}
		if (subtitle) {
			subtitle
				.css({ width: (subtitleOptions.width || autoWidth) + PX })
				.align(extend({ 
					y: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(subtitleOptions.style.fontSize, title).b 
				}, subtitleOptions), false, 'spacingBox');
			
			if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {
				titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);
			}
		}

		requiresDirtyBox = this.titleOffset !== titleOffset;				
		this.titleOffset = titleOffset; // used in getMargins

		if (!this.isDirtyBox && requiresDirtyBox) {
			this.isDirtyBox = requiresDirtyBox;
			// Redraw if necessary (#2719, #2744)		
			if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
				this.redraw();
			}
		}
	},

	/**
	 * Get chart width and height according to options and container size
	 */
	getChartSize: function () {
		var chart = this,
			optionsChart = chart.options.chart,
			widthOption = optionsChart.width,
			heightOption = optionsChart.height,
			renderTo = chart.renderToClone || chart.renderTo;

		// get inner width and height from jQuery (#824)
		if (!defined(widthOption)) {
			chart.containerWidth = adapterRun(renderTo, 'width');
		}
		if (!defined(heightOption)) {
			chart.containerHeight = adapterRun(renderTo, 'height');
		}
		
		chart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460
		chart.chartHeight = mathMax(0, pick(heightOption,
			// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
			chart.containerHeight > 19 ? chart.containerHeight : 400));
	},

	/**
	 * Create a clone of the chart's renderTo div and place it outside the viewport to allow
	 * size computation on chart.render and chart.redraw
	 */
	cloneRenderTo: function (revert) {
		var clone = this.renderToClone,
			container = this.container;
		
		// Destroy the clone and bring the container back to the real renderTo div
		if (revert) {
			if (clone) {
				this.renderTo.appendChild(container);
				discardElement(clone);
				delete this.renderToClone;
			}
		
		// Set up the clone
		} else {
			if (container && container.parentNode === this.renderTo) {
				this.renderTo.removeChild(container); // do not clone this
			}
			this.renderToClone = clone = this.renderTo.cloneNode(0);
			css(clone, {
				position: ABSOLUTE,
				top: '-9999px',
				display: 'block' // #833
			});
			if (clone.style.setProperty) { // #2631
				clone.style.setProperty('display', 'block', 'important');
			}
			doc.body.appendChild(clone);
			if (container) {
				clone.appendChild(container);
			}
		}
	},

	/**
	 * Get the containing element, determine the size and create the inner container
	 * div to hold the chart
	 */
	getContainer: function () {
		var chart = this,
			container,
			options = chart.options,
			optionsChart = options.chart,
			chartWidth,
			chartHeight,
			renderTo,
			indexAttrName = 'data-highcharts-chart',
			oldChartIndex,
			Ren,
			containerId;

		chart.renderTo = renderTo = optionsChart.renderTo;
		containerId = PREFIX + idCounter++;

		if (isString(renderTo)) {
			chart.renderTo = renderTo = doc.getElementById(renderTo);
		}
		
		// Display an error if the renderTo is wrong
		if (!renderTo) {
			error(13, true);
		}
		
		// If the container already holds a chart, destroy it. The check for hasRendered is there
		// because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart
		// attribute and the SVG contents, but not an interactive chart. So in this case,
		// charts[oldChartIndex] will point to the wrong chart if any (#2609).
		oldChartIndex = pInt(attr(renderTo, indexAttrName));
		if (!isNaN(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {
			charts[oldChartIndex].destroy();
		}		
		
		// Make a reference to the chart from the div
		attr(renderTo, indexAttrName, chart.index);

		// remove previous chart
		renderTo.innerHTML = '';

		// If the container doesn't have an offsetWidth, it has or is a child of a node
		// that has display:none. We need to temporarily move it out to a visible
		// state to determine the size, else the legend and tooltips won't render
		// properly. The allowClone option is used in sparklines as a micro optimization,
		// saving about 1-2 ms each chart.
		if (!optionsChart.skipClone && !renderTo.offsetWidth) {
			chart.cloneRenderTo();
		}

		// get the width and height
		chart.getChartSize();
		chartWidth = chart.chartWidth;
		chartHeight = chart.chartHeight;

		// create the inner container
		chart.container = container = createElement(DIV, {
				className: PREFIX + 'container' +
					(optionsChart.className ? ' ' + optionsChart.className : ''),
				id: containerId
			}, extend({
				position: RELATIVE,
				overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
					// content overflow in IE
				width: chartWidth + PX,
				height: chartHeight + PX,
				textAlign: 'left',
				lineHeight: 'normal', // #427
				zIndex: 0, // #1072
				'-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
			}, optionsChart.style),
			chart.renderToClone || renderTo
		);

		// cache the cursor (#1650)
		chart._cursor = container.style.cursor;

		// Initialize the renderer
		Ren = Highcharts[optionsChart.renderer] || Renderer;
		chart.renderer = new Ren(
			container, 
			chartWidth, 
			chartHeight, 
			optionsChart.style, 
			optionsChart.forExport, 
			options.exporting && options.exporting.allowHTML
		);

		if (useCanVG) {
			// If we need canvg library, extend and configure the renderer
			// to get the tracker for translating mouse events
			chart.renderer.create(chart, container, chartWidth, chartHeight);
		}
		// Add a reference to the charts index
		chart.renderer.chartIndex = chart.index;
	},

	/**
	 * Calculate margins by rendering axis labels in a preliminary position. Title,
	 * subtitle and legend have already been rendered at this stage, but will be
	 * moved into their final positions
	 */
	getMargins: function (skipAxes) {
		var chart = this,
			spacing = chart.spacing,
			margin = chart.margin,
			titleOffset = chart.titleOffset;

		chart.resetMargins();

		// Adjust for title and subtitle
		if (titleOffset && !defined(margin[0])) {
			chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);
		}
		
		// Adjust for legend
		chart.legend.adjustMargins(margin, spacing);

		// adjust for scroller
		if (chart.extraBottomMargin) {
			chart.marginBottom += chart.extraBottomMargin;
		}
		if (chart.extraTopMargin) {
			chart.plotTop += chart.extraTopMargin;
		}
		if (!skipAxes) {
			this.getAxisMargins();
		}
	},

	getAxisMargins: function () {

		var chart = this,
			axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left
			margin = chart.margin;
		
		// pre-render axes to get labels offset width
		if (chart.hasCartesianSeries) {
			each(chart.axes, function (axis) {
				if (axis.visible) {
					axis.getOffset();
				}
			});
		}

		// Add the axis offsets
		each(marginNames, function (m, side) {
			if (!defined(margin[side])) {
				chart[m] += axisOffset[side];
			}		
		});

		chart.setChartSize();

	},

	/**
	 * Resize the chart to its container if size is not explicitly set
	 */
	reflow: function (e) {
		var chart = this,
			optionsChart = chart.options.chart,
			renderTo = chart.renderTo,
			width = optionsChart.width || adapterRun(renderTo, 'width'),
			height = optionsChart.height || adapterRun(renderTo, 'height'),
			target = e ? e.target : win, // #805 - MooTools doesn't supply e
			doReflow = function () {
				if (chart.container) { // It may have been destroyed in the meantime (#1257)
					chart.setSize(width, height, false);
					chart.hasUserSize = null;
				}
			};
			
		// Width and height checks for display:none. Target is doc in IE8 and Opera,
		// win in Firefox, Chrome and IE9.
		if (!chart.hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093
			if (width !== chart.containerWidth || height !== chart.containerHeight) {
				clearTimeout(chart.reflowTimeout);
				if (e) { // Called from window.resize
					chart.reflowTimeout = setTimeout(doReflow, 100);
				} else { // Called directly (#2224)
					doReflow();
				}
			}
			chart.containerWidth = width;
			chart.containerHeight = height;
		}
	},

	/**
	 * Add the event handlers necessary for auto resizing
	 */
	initReflow: function () {
		var chart = this,
			reflow = function (e) {
				chart.reflow(e);
			};
			
		
		addEvent(win, 'resize', reflow);
		addEvent(chart, 'destroy', function () {
			removeEvent(win, 'resize', reflow);
		});
	},

	/**
	 * Resize the chart to a given width and height
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Object|Boolean} animation
	 */
	setSize: function (width, height, animation) {
		var chart = this,
			chartWidth,
			chartHeight,
			fireEndResize,
			renderer = chart.renderer,
			globalAnimation;

		// Handle the isResizing counter
		chart.isResizing += 1;
		fireEndResize = function () {
			if (chart) {
				fireEvent(chart, 'endResize', null, function () {
					chart.isResizing -= 1;
				});
			}
		};

		// set the animation for the current process
		setAnimation(animation, chart);

		chart.oldChartHeight = chart.chartHeight;
		chart.oldChartWidth = chart.chartWidth;
		if (defined(width)) {
			chart.chartWidth = chartWidth = mathMax(0, mathRound(width));
			chart.hasUserSize = !!chartWidth;
		}
		if (defined(height)) {
			chart.chartHeight = chartHeight = mathMax(0, mathRound(height));
		}

		// Resize the container with the global animation applied if enabled (#2503)
		globalAnimation = renderer.globalAnimation;
		(globalAnimation ? animate : css)(chart.container, {
			width: chartWidth + PX,
			height: chartHeight + PX
		}, globalAnimation);

		chart.setChartSize(true);
		renderer.setSize(chartWidth, chartHeight, animation);

		// handle axes
		chart.maxTicks = null;
		each(chart.axes, function (axis) {
			axis.isDirty = true;
			axis.setScale();
		});

		// make sure non-cartesian series are also handled
		each(chart.series, function (serie) {
			serie.isDirty = true;
		});

		chart.isDirtyLegend = true; // force legend redraw
		chart.isDirtyBox = true; // force redraw of plot and chart border

		chart.layOutTitles(); // #2857
		chart.getMargins();

		chart.redraw(animation);


		chart.oldChartHeight = null;
		fireEvent(chart, 'resize');

		// Fire endResize and set isResizing back. If animation is disabled, fire without delay
		globalAnimation = renderer.globalAnimation; // Reassign it before using it, it may have changed since the top of this function.
		if (globalAnimation === false) {
			fireEndResize();
		} else { // else set a timeout with the animation duration
			setTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);
		}
	},

	/**
	 * Set the public chart properties. This is done before and after the pre-render
	 * to determine margin sizes
	 */
	setChartSize: function (skipAxes) {
		var chart = this,
			inverted = chart.inverted,
			renderer = chart.renderer,
			chartWidth = chart.chartWidth,
			chartHeight = chart.chartHeight,
			optionsChart = chart.options.chart,
			spacing = chart.spacing,
			clipOffset = chart.clipOffset,
			clipX,
			clipY,
			plotLeft,
			plotTop,
			plotWidth,
			plotHeight,
			plotBorderWidth;

		chart.plotLeft = plotLeft = mathRound(chart.plotLeft);
		chart.plotTop = plotTop = mathRound(chart.plotTop);
		chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));
		chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));

		chart.plotSizeX = inverted ? plotHeight : plotWidth;
		chart.plotSizeY = inverted ? plotWidth : plotHeight;
		
		chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

		// Set boxes used for alignment
		chart.spacingBox = renderer.spacingBox = {
			x: spacing[3],
			y: spacing[0],
			width: chartWidth - spacing[3] - spacing[1],
			height: chartHeight - spacing[0] - spacing[2]
		};
		chart.plotBox = renderer.plotBox = {
			x: plotLeft,
			y: plotTop,
			width: plotWidth,
			height: plotHeight
		};

		plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);
		clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);
		clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);
		chart.clipBox = {
			x: clipX, 
			y: clipY, 
			width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX), 
			height: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))
		};

		if (!skipAxes) {
			each(chart.axes, function (axis) {
				axis.setAxisSize();
				axis.setAxisTranslation();
			});
		}
	},

	/**
	 * Initial margins before auto size margins are applied
	 */
	resetMargins: function () {
		var chart = this;

		each(marginNames, function (m, side) {
			chart[m] = pick(chart.margin[side], chart.spacing[side]);
		});
		chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
		chart.clipOffset = [0, 0, 0, 0];
	},

	/**
	 * Draw the borders and backgrounds for chart and plot area
	 */
	drawChartBox: function () {
		var chart = this,
			optionsChart = chart.options.chart,
			renderer = chart.renderer,
			chartWidth = chart.chartWidth,
			chartHeight = chart.chartHeight,
			chartBackground = chart.chartBackground,
			plotBackground = chart.plotBackground,
			plotBorder = chart.plotBorder,
			plotBGImage = chart.plotBGImage,
			chartBorderWidth = optionsChart.borderWidth || 0,
			chartBackgroundColor = optionsChart.backgroundColor,
			plotBackgroundColor = optionsChart.plotBackgroundColor,
			plotBackgroundImage = optionsChart.plotBackgroundImage,
			plotBorderWidth = optionsChart.plotBorderWidth || 0,
			mgn,
			bgAttr,
			plotLeft = chart.plotLeft,
			plotTop = chart.plotTop,
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			plotBox = chart.plotBox,
			clipRect = chart.clipRect,
			clipBox = chart.clipBox;

		// Chart area
		mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

		if (chartBorderWidth || chartBackgroundColor) {
			if (!chartBackground) {
				
				bgAttr = {
					fill: chartBackgroundColor || NONE
				};
				if (chartBorderWidth) { // #980
					bgAttr.stroke = optionsChart.borderColor;
					bgAttr['stroke-width'] = chartBorderWidth;
				}
				chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
						optionsChart.borderRadius, chartBorderWidth)
					.attr(bgAttr)
					.addClass(PREFIX + 'background')
					.add()
					.shadow(optionsChart.shadow);

			} else { // resize
				chartBackground.animate(
					chartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })
				);
			}
		}


		// Plot background
		if (plotBackgroundColor) {
			if (!plotBackground) {
				chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
					.attr({
						fill: plotBackgroundColor
					})
					.add()
					.shadow(optionsChart.plotShadow);
			} else {
				plotBackground.animate(plotBox);
			}
		}
		if (plotBackgroundImage) {
			if (!plotBGImage) {
				chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
					.add();
			} else {
				plotBGImage.animate(plotBox);
			}
		}
		
		// Plot clip
		if (!clipRect) {
			chart.clipRect = renderer.clipRect(clipBox);
		} else {
			clipRect.animate({
				width: clipBox.width,
				height: clipBox.height
			});
		}

		// Plot area border
		if (plotBorderWidth) {
			if (!plotBorder) {
				chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)
					.attr({
						stroke: optionsChart.plotBorderColor,
						'stroke-width': plotBorderWidth,
						fill: NONE,
						zIndex: 1
					})
					.add();
			} else {
				plotBorder.animate(
					plotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight, strokeWidth: -plotBorderWidth }) //#3282 plotBorder should be negative
				);
			}
		}

		// reset
		chart.isDirtyBox = false;
	},

	/**
	 * Detect whether a certain chart property is needed based on inspecting its options
	 * and series. This mainly applies to the chart.invert property, and in extensions to 
	 * the chart.angular and chart.polar properties.
	 */
	propFromSeries: function () {
		var chart = this,
			optionsChart = chart.options.chart,
			klass,
			seriesOptions = chart.options.series,
			i,
			value;
			
			
		each(['inverted', 'angular', 'polar'], function (key) {
			
			// The default series type's class
			klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
			
			// Get the value from available chart-wide properties
			value = (
				chart[key] || // 1. it is set before
				optionsChart[key] || // 2. it is set in the options
				(klass && klass.prototype[key]) // 3. it's default series class requires it
			);
	
			// 4. Check if any the chart's series require it
			i = seriesOptions && seriesOptions.length;
			while (!value && i--) {
				klass = seriesTypes[seriesOptions[i].type];
				if (klass && klass.prototype[key]) {
					value = true;
				}
			}
	
			// Set the chart property
			chart[key] = value;	
		});
		
	},

	/**
	 * Link two or more series together. This is done initially from Chart.render,
	 * and after Chart.addSeries and Series.remove.
	 */
	linkSeries: function () {
		var chart = this,
			chartSeries = chart.series;

		// Reset links
		each(chartSeries, function (series) {
			series.linkedSeries.length = 0;
		});

		// Apply new links
		each(chartSeries, function (series) {
			var linkedTo = series.options.linkedTo;
			if (isString(linkedTo)) {
				if (linkedTo === ':previous') {
					linkedTo = chart.series[series.index - 1];
				} else {
					linkedTo = chart.get(linkedTo);
				}
				if (linkedTo) {
					linkedTo.linkedSeries.push(series);
					series.linkedParent = linkedTo;
					series.visible = pick(series.options.visible, linkedTo.options.visible, series.visible); // #3879
				}
			}
		});
	},

	/**
	 * Render series for the chart
	 */
	renderSeries: function () {
		each(this.series, function (serie) {
			serie.translate();
			serie.render();
		});
	},
		
	/**
	 * Render labels for the chart
	 */
	renderLabels: function () {
		var chart = this,
			labels = chart.options.labels;
		if (labels.items) {
			each(labels.items, function (label) {
				var style = extend(labels.style, label.style),
					x = pInt(style.left) + chart.plotLeft,
					y = pInt(style.top) + chart.plotTop + 12;

				// delete to prevent rewriting in IE
				delete style.left;
				delete style.top;

				chart.renderer.text(
					label.html,
					x,
					y
				)
				.attr({ zIndex: 2 })
				.css(style)
				.add();

			});
		}
	},

	/**
	 * Render all graphics for the chart
	 */
	render: function () {
		var chart = this,
			axes = chart.axes,
			renderer = chart.renderer,
			options = chart.options,
			tempWidth,
			tempHeight,
			redoHorizontal,
			redoVertical;

		// Title
		chart.setTitle();


		// Legend
		chart.legend = new Legend(chart, options.legend);

		// Get stacks
		if (chart.getStacks) {
			chart.getStacks();
		}

		// Get chart margins
		chart.getMargins(true);
		chart.setChartSize();

		// Record preliminary dimensions for later comparison
		tempWidth = chart.plotWidth;
		tempHeight = chart.plotHeight = chart.plotHeight - 13; // 13 is the most common height of X axis labels

		// Get margins by pre-rendering axes
		each(axes, function (axis) {
			axis.setScale();
		});
		chart.getAxisMargins();

		// If the plot area size has changed significantly, calculate tick positions again
		redoHorizontal = tempWidth / chart.plotWidth > 1.1;
		redoVertical = tempHeight / chart.plotHeight > 1.1;

		if (redoHorizontal || redoVertical) {

			chart.maxTicks = null; // reset for second pass
			each(axes, function (axis) {
				if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
					axis.setTickInterval(true); // update to reflect the new margins
				}
			});
			chart.getMargins(); // second pass to check for new labels
		}

		// Draw the borders and backgrounds
		chart.drawChartBox();		


		// Axes
		if (chart.hasCartesianSeries) {
			each(axes, function (axis) {
				if (axis.visible) {
					axis.render();	
				}
			});
		}

		// The series
		if (!chart.seriesGroup) {
			chart.seriesGroup = renderer.g('series-group')
				.attr({ zIndex: 3 })
				.add();
		}
		chart.renderSeries();

		// Labels
		chart.renderLabels();

		// Credits
		chart.showCredits(options.credits);

		// Set flag
		chart.hasRendered = true;

	},

	/**
	 * Show chart credits based on config options
	 */
	showCredits: function (credits) {
		if (credits.enabled && !this.credits) {
			this.credits = this.renderer.text(
				credits.text,
				0,
				0
			)
			.on('click', function () {
				if (credits.href) {
					location.href = credits.href;
				}
			})
			.attr({
				align: credits.position.align,
				zIndex: 8
			})
			.css(credits.style)
			.add()
			.align(credits.position);
		}
	},

	/**
	 * Clean up memory usage
	 */
	destroy: function () {
		var chart = this,
			axes = chart.axes,
			series = chart.series,
			container = chart.container,
			i,
			parentNode = container && container.parentNode;
			
		// fire the chart.destoy event
		fireEvent(chart, 'destroy');
		
		// Delete the chart from charts lookup array
		charts[chart.index] = UNDEFINED;
		chartCount--;
		chart.renderTo.removeAttribute('data-highcharts-chart');

		// remove events
		removeEvent(chart);

		// ==== Destroy collections:
		// Destroy axes
		i = axes.length;
		while (i--) {
			axes[i] = axes[i].destroy();
		}

		// Destroy each series
		i = series.length;
		while (i--) {
			series[i] = series[i].destroy();
		}

		// ==== Destroy chart properties:
		each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', 
				'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller', 
				'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {
			var prop = chart[name];

			if (prop && prop.destroy) {
				chart[name] = prop.destroy();
			}
		});

		// remove container and all SVG
		if (container) { // can break in IE when destroyed before finished loading
			container.innerHTML = '';
			removeEvent(container);
			if (parentNode) {
				discardElement(container);
			}

		}

		// clean it all up
		for (i in chart) {
			delete chart[i];
		}

	},


	/**
	 * VML namespaces can't be added until after complete. Listening
	 * for Perini's doScroll hack is not enough.
	 */
	isReadyToRender: function () {
		var chart = this;

		// Note: in spite of JSLint's complaints, win == win.top is required
		/*jslint eqeq: true*/
		if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) {
		/*jslint eqeq: false*/
			if (useCanVG) {
				// Delay rendering until canvg library is downloaded and ready
				CanVGController.push(function () { chart.firstRender(); }, chart.options.global.canvasToolsURL);
			} else {
				doc.attachEvent('onreadystatechange', function () {
					doc.detachEvent('onreadystatechange', chart.firstRender);
					if (doc.readyState === 'complete') {
						chart.firstRender();
					}
				});
			}
			return false;
		}
		return true;
	},

	/**
	 * Prepare for first rendering after all data are loaded
	 */
	firstRender: function () {
		var chart = this,
			options = chart.options,
			callback = chart.callback;

		// Check whether the chart is ready to render
		if (!chart.isReadyToRender()) {
			return;
		}

		// Create the container
		chart.getContainer();

		// Run an early event after the container and renderer are established
		fireEvent(chart, 'init');

		
		chart.resetMargins();
		chart.setChartSize();

		// Set the common chart properties (mainly invert) from the given series
		chart.propFromSeries();

		// get axes
		chart.getAxes();

		// Initialize the series
		each(options.series || [], function (serieOptions) {
			chart.initSeries(serieOptions);
		});

		chart.linkSeries();

		// Run an event after axes and series are initialized, but before render. At this stage,
		// the series data is indexed and cached in the xData and yData arrays, so we can access
		// those before rendering. Used in Highstock. 
		fireEvent(chart, 'beforeRender'); 

		// depends on inverted and on margins being set
		if (Highcharts.Pointer) {
			chart.pointer = new Pointer(chart, options);
		}

		chart.render();

		// add canvas
		chart.renderer.draw();
		// run callbacks
		if (callback) {
			callback.apply(chart, [chart]);
		}
		each(chart.callbacks, function (fn) {
			if (chart.index !== UNDEFINED) { // Chart destroyed in its own callback (#3600)
				fn.apply(chart, [chart]);
			}
		});
		
		// Fire the load event
		fireEvent(chart, 'load');		
		
		// If the chart was rendered outside the top container, put it back in (#3679)
		chart.cloneRenderTo(true);

	},

	/**
	* Creates arrays for spacing and margin from given options.
	*/
	splashArray: function (target, options) {
		var oVar = options[target],
			tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];

		return [pick(options[target + 'Top'], tArray[0]),
				pick(options[target + 'Right'], tArray[1]),
				pick(options[target + 'Bottom'], tArray[2]),
				pick(options[target + 'Left'], tArray[3])];
	}
}; // end Chart

var CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {
	/**
	 * Get the center of the pie based on the size and center options relative to the  
	 * plot area. Borrowed by the polar and gauge series types.
	 */
	getCenter: function () {
		
		var options = this.options,
			chart = this.chart,
			slicingRoom = 2 * (options.slicedOffset || 0),
			handleSlicingRoom,
			plotWidth = chart.plotWidth - 2 * slicingRoom,
			plotHeight = chart.plotHeight - 2 * slicingRoom,
			centerOption = options.center,
			positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
			smallestSize = mathMin(plotWidth, plotHeight),
			i,
			value;

		for (i = 0; i < 4; ++i) {
			value = positions[i];
			handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));
			
			// i == 0: centerX, relative to width
			// i == 1: centerY, relative to height
			// i == 2: size, relative to smallestSize
			// i == 3: innerSize, relative to size
			positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +
				(handleSlicingRoom ? slicingRoom : 0);

		}
		// innerSize cannot be larger than size (#3632)
		if (positions[3] > positions[2]) {
			positions[3] = positions[2];
		}
		return positions;
	}
};

/**
 * The Point object and prototype. Inheritable and used as base for PiePoint
 */
var Point = function () {};
Point.prototype = {

	/**
	 * Initialize the point
	 * @param {Object} series The series object containing this point
	 * @param {Object} options The data in either number, array or object format
	 */
	init: function (series, options, x) {

		var point = this,
			colors;
		point.series = series;
		point.color = series.color; // #3445
		point.applyOptions(options, x);
		point.pointAttr = {};

		if (series.options.colorByPoint) {
			colors = series.options.colors || series.chart.options.colors;
			point.color = point.color || colors[series.colorCounter++];
			// loop back to zero
			if (series.colorCounter === colors.length) {
				series.colorCounter = 0;
			}
		}

		series.chart.pointCount++;
		return point;
	},
	/**
	 * Apply the options containing the x and y data and possible some extra properties.
	 * This is called on point init or from point.update.
	 *
	 * @param {Object} options
	 */
	applyOptions: function (options, x) {
		var point = this,
			series = point.series,
			pointValKey = series.options.pointValKey || series.pointValKey;

		options = Point.prototype.optionsToObject.call(this, options);

		// copy options directly to point
		extend(point, options);
		point.options = point.options ? extend(point.options, options) : options;

		// For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
		if (pointValKey) {
			point.y = point[pointValKey];
		}

		// If no x is set by now, get auto incremented value. All points must have an
		// x value, however the y value can be null to create a gap in the series
		if (point.x === UNDEFINED && series) {
			point.x = x === UNDEFINED ? series.autoIncrement() : x;
		}

		return point;
	},

	/**
	 * Transform number or array configs into objects
	 */
	optionsToObject: function (options) {
		var ret = {},
			series = this.series,
			keys = series.options.keys,
			pointArrayMap = keys || series.pointArrayMap || ['y'],
			valueCount = pointArrayMap.length,
			firstItemType,
			i = 0,
			j = 0;

		if (typeof options === 'number' || options === null) {
			ret[pointArrayMap[0]] = options;

		} else if (isArray(options)) {
			// with leading x value
			if (!keys && options.length > valueCount) {
				firstItemType = typeof options[0];
				if (firstItemType === 'string') {
					ret.name = options[0];
				} else if (firstItemType === 'number') {
					ret.x = options[0];
				}
				i++;
			}
			while (j < valueCount) {
				if (!keys || options[i] !== undefined) { // Skip undefined positions for keys
					ret[pointArrayMap[j]] = options[i];
				}
				i++;
				j++;
			}
		} else if (typeof options === 'object') {
			ret = options;

			// This is the fastest way to detect if there are individual point dataLabels that need
			// to be considered in drawDataLabels. These can only occur in object configs.
			if (options.dataLabels) {
				series._hasPointLabels = true;
			}

			// Same approach as above for markers
			if (options.marker) {
				series._hasPointMarkers = true;
			}
		}
		return ret;
	},

	/**
	 * Destroy a point to clear memory. Its reference still stays in series.data.
	 */
	destroy: function () {
		var point = this,
			series = point.series,
			chart = series.chart,
			hoverPoints = chart.hoverPoints,
			prop;

		chart.pointCount--;

		if (hoverPoints) {
			point.setState();
			erase(hoverPoints, point);
			if (!hoverPoints.length) {
				chart.hoverPoints = null;
			}

		}
		if (point === chart.hoverPoint) {
			point.onMouseOut();
		}

		// remove all events
		if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
			removeEvent(point);
			point.destroyElements();
		}

		if (point.legendItem) { // pies have legend items
			chart.legend.destroyItem(point);
		}

		for (prop in point) {
			point[prop] = null;
		}


	},

	/**
	 * Destroy SVG elements associated with the point
	 */
	destroyElements: function () {
		var point = this,
			props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],
			prop,
			i = 6;
		while (i--) {
			prop = props[i];
			if (point[prop]) {
				point[prop] = point[prop].destroy();
			}
		}
	},

	/**
	 * Return the configuration hash needed for the data label and tooltip formatters
	 */
	getLabelConfig: function () {
		return {
			x: this.category,
			y: this.y,
			color: this.color,
			key: this.name || this.category,
			series: this.series,
			point: this,
			percentage: this.percentage,
			total: this.total || this.stackTotal
		};
	},	

	/**
	 * Extendable method for formatting each point's tooltip line
	 *
	 * @return {String} A string to be concatenated in to the common tooltip text
	 */
	tooltipFormatter: function (pointFormat) {

		// Insert options for valueDecimals, valuePrefix, and valueSuffix
		var series = this.series,
			seriesTooltipOptions = series.tooltipOptions,
			valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
			valuePrefix = seriesTooltipOptions.valuePrefix || '',
			valueSuffix = seriesTooltipOptions.valueSuffix || '';

		// Loop over the point array map and replace unformatted values with sprintf formatting markup
		each(series.pointArrayMap || ['y'], function (key) {
			key = '{point.' + key; // without the closing bracket
			if (valuePrefix || valueSuffix) {
				pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
			}
			pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
		});

		return format(pointFormat, {
			point: this,
			series: this.series
		});
	},

	/**
	 * Fire an event on the Point object. Must not be renamed to fireEvent, as this
	 * causes a name clash in MooTools
	 * @param {String} eventType
	 * @param {Object} eventArgs Additional event arguments
	 * @param {Function} defaultFunction Default event handler
	 */
	firePointEvent: function (eventType, eventArgs, defaultFunction) {
		var point = this,
			series = this.series,
			seriesOptions = series.options;

		// load event handlers on demand to save time on mouseover/out
		if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
			this.importEvents();
		}

		// add default handler if in selection mode
		if (eventType === 'click' && seriesOptions.allowPointSelect) {
			defaultFunction = function (event) {
				// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
				if (point.select) { // Could be destroyed by prior event handlers (#2911)
					point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
				}
			};
		}

		fireEvent(this, eventType, eventArgs, defaultFunction);
	},
	visible: true
};/**
 * @classDescription The base function which all other series types inherit from. The data in the series is stored
 * in various arrays.
 *
 * - First, series.options.data contains all the original config options for
 * each point whether added by options or methods like series.addPoint.
 * - Next, series.data contains those values converted to points, but in case the series data length
 * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It
 * only contains the points that have been created on demand.
 * - Then there's series.points that contains all currently visible point objects. In case of cropping,
 * the cropped-away points are not part of this array. The series.points array starts at series.cropStart
 * compared to series.data and series.options.data. If however the series data is grouped, these can't
 * be correlated one to one.
 * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.
 * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.
 *
 * @param {Object} chart
 * @param {Object} options
 */
var Series = Highcharts.Series = function () {};

Series.prototype = {

	isCartesian: true,
	type: 'line',
	pointClass: Point,
	sorted: true, // requires the data to be sorted
	requireSorting: true,
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'lineColor',
		'stroke-width': 'lineWidth',
		fill: 'fillColor',
		r: 'radius'
	},
	directTouch: false,
	axisTypes: ['xAxis', 'yAxis'],
	colorCounter: 0,
	parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData
	init: function (chart, options) {
		var series = this,
			eventType,
			events,
			chartSeries = chart.series,
			sortByIndex = function (a, b) {
				return pick(a.options.index, a._i) - pick(b.options.index, b._i);
			};

		series.chart = chart;
		series.options = options = series.setOptions(options); // merge with plotOptions
		series.linkedSeries = [];

		// bind the axes
		series.bindAxes();

		// set some variables
		extend(series, {
			name: options.name,
			state: NORMAL_STATE,
			pointAttr: {},
			visible: options.visible !== false, // true by default
			selected: options.selected === true // false by default
		});

		// special
		if (useCanVG) {
			options.animation = false;
		}

		// register event listeners
		events = options.events;
		for (eventType in events) {
			addEvent(series, eventType, events[eventType]);
		}
		if (
			(events && events.click) ||
			(options.point && options.point.events && options.point.events.click) ||
			options.allowPointSelect
		) {
			chart.runTrackerClick = true;
		}

		series.getColor();
		series.getSymbol();

		// Set the data
		each(series.parallelArrays, function (key) {
			series[key + 'Data'] = [];
		});
		series.setData(options.data, false);

		// Mark cartesian
		if (series.isCartesian) {
			chart.hasCartesianSeries = true;
		}

		// Register it in the chart
		chartSeries.push(series);
		series._i = chartSeries.length - 1;

		// Sort series according to index option (#248, #1123, #2456)
		stableSort(chartSeries, sortByIndex);
		if (this.yAxis) {
			stableSort(this.yAxis.series, sortByIndex);
		}

		each(chartSeries, function (series, i) {
			series.index = i;
			series.name = series.name || 'Series ' + (i + 1);
		});

	},

	/**
	 * Set the xAxis and yAxis properties of cartesian series, and register the series
	 * in the axis.series array
	 */
	bindAxes: function () {
		var series = this,
			seriesOptions = series.options,
			chart = series.chart,
			axisOptions;

		each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis

			each(chart[AXIS], function (axis) { // loop through the chart's axis objects
				axisOptions = axis.options;

				// apply if the series xAxis or yAxis option mathches the number of the
				// axis, or if undefined, use the first axis
				if ((seriesOptions[AXIS] === axisOptions.index) ||
						(seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||
						(seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {

					// register this series in the axis.series lookup
					axis.series.push(series);

					// set this series.xAxis or series.yAxis reference
					series[AXIS] = axis;

					// mark dirty for redraw
					axis.isDirty = true;
				}
			});

			// The series needs an X and an Y axis
			if (!series[AXIS] && series.optionalAxis !== AXIS) {
				error(18, true);
			}

		});
	},

	/**
	 * For simple series types like line and column, the data values are held in arrays like
	 * xData and yData for quick lookup to find extremes and more. For multidimensional series
	 * like bubble and map, this can be extended with arrays like zData and valueData by
	 * adding to the series.parallelArrays array.
	 */
	updateParallelArrays: function (point, i) {
		var series = point.series,
			args = arguments,
			fn = typeof i === 'number' ?
				 // Insert the value in the given position
				function (key) {
					var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];
					series[key + 'Data'][i] = val;
				} :
				// Apply the method specified in i with the following arguments as arguments
				function (key) {
					Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));
				};

		each(series.parallelArrays, fn);
	},

	/**
	 * Return an auto incremented x value based on the pointStart and pointInterval options.
	 * This is only used if an x value is not given for the point that calls autoIncrement.
	 */
	autoIncrement: function () {

		var options = this.options,
			xIncrement = this.xIncrement,
			date,
			pointInterval,
			pointIntervalUnit = options.pointIntervalUnit;
		
		xIncrement = pick(xIncrement, options.pointStart, 0);
		
		this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);
		
		// Added code for pointInterval strings
		if (pointIntervalUnit === 'month' || pointIntervalUnit === 'year') {
			date = new Date(xIncrement);
			date = (pointIntervalUnit === 'month') ?
				+date[setMonth](date[getMonth]() + pointInterval) :
				+date[setFullYear](date[getFullYear]() + pointInterval);
			pointInterval = date - xIncrement;
		}
		
		this.xIncrement = xIncrement + pointInterval;
		return xIncrement;
	},

	/**
	 * Divide the series data into segments divided by null values.
	 */
	getSegments: function () {
		var series = this,
			lastNull = -1,
			segments = [],
			i,
			points = series.points,
			pointsLength = points.length;

		if (pointsLength) { // no action required for []

			// if connect nulls, just remove null points
			if (series.options.connectNulls) {
				i = pointsLength;
				while (i--) {
					if (points[i].y === null) {
						points.splice(i, 1);
					}
				}
				if (points.length) {
					segments = [points];
				}

			// else, split on null points
			} else {
				each(points, function (point, i) {
					if (point.y === null) {
						if (i > lastNull + 1) {
							segments.push(points.slice(lastNull + 1, i));
						}
						lastNull = i;
					} else if (i === pointsLength - 1) { // last value
						segments.push(points.slice(lastNull + 1, i + 1));
					}
				});
			}
		}

		// register it
		series.segments = segments;
	},

	/**
	 * Set the series options by merging from the options tree
	 * @param {Object} itemOptions
	 */
	setOptions: function (itemOptions) {
		var chart = this.chart,
			chartOptions = chart.options,
			plotOptions = chartOptions.plotOptions,
			userOptions = chart.userOptions || {},
			userPlotOptions = userOptions.plotOptions || {},
			typeOptions = plotOptions[this.type],
			options,
			zones;

		this.userOptions = itemOptions;

		// General series options take precedence over type options because otherwise, default
		// type options like column.animation would be overwritten by the general option.
		// But issues have been raised here (#3881), and the solution may be to distinguish 
		// between default option and userOptions like in the tooltip below.
		options = merge(
			typeOptions,
			plotOptions.series,
			itemOptions
		);

		// The tooltip options are merged between global and series specific options
		this.tooltipOptions = merge(
			defaultOptions.tooltip,
			defaultOptions.plotOptions[this.type].tooltip,
			userOptions.tooltip,
			userPlotOptions.series && userPlotOptions.series.tooltip,
			userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,
			itemOptions.tooltip
		);

		// Delete marker object if not allowed (#1125)
		if (typeOptions.marker === null) {
			delete options.marker;
		}

		// Handle color zones
		this.zoneAxis = options.zoneAxis;
		zones = this.zones = (options.zones || []).slice();
		if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
			zones.push({
				value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,
				color: options.negativeColor,
				fillColor: options.negativeFillColor
			});
		}
		if (zones.length) { // Push one extra zone for the rest
			if (defined(zones[zones.length - 1].value)) {
				zones.push({
					color: this.color,
					fillColor: this.fillColor
				});
			}
		}
		return options;
	},

	getCyclic: function (prop, value, defaults) {
		var i,
			userOptions = this.userOptions,
			indexName = '_' + prop + 'Index',
			counterName = prop + 'Counter';

		if (!value) {
			if (defined(userOptions[indexName])) { // after Series.update()
				i = userOptions[indexName];
			} else {
				userOptions[indexName] = i = this.chart[counterName] % defaults.length;
				this.chart[counterName] += 1;
			}
			value = defaults[i];
		}
		this[prop] = value;
	},

	/**
	 * Get the series' color
	 */
	getColor: function () {
		if (this.options.colorByPoint) {
			this.options.color = null; // #4359, selected slice got series.color even when colorByPoint was set.
		} else {
			this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);
		}
	},
	/**
	 * Get the series' symbol
	 */
	getSymbol: function () {
		var seriesMarkerOption = this.options.marker;

		this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);

		// don't substract radius in image symbols (#604)
		if (/^url/.test(this.symbol)) {
			seriesMarkerOption.radius = 0;
		}
	},

	drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

	/**
	 * Replace the series data with a new set of data
	 * @param {Object} data
	 * @param {Object} redraw
	 */
	setData: function (data, redraw, animation, updatePoints) {
		var series = this,
			oldData = series.points,
			oldDataLength = (oldData && oldData.length) || 0,
			dataLength,
			options = series.options,
			chart = series.chart,
			firstPoint = null,
			xAxis = series.xAxis,
			hasCategories = xAxis && !!xAxis.categories,
			i,
			turboThreshold = options.turboThreshold,
			pt,
			xData = this.xData,
			yData = this.yData,
			pointArrayMap = series.pointArrayMap,
			valueCount = pointArrayMap && pointArrayMap.length;

		data = data || [];
		dataLength = data.length;
		redraw = pick(redraw, true);

		// If the point count is the same as is was, just run Point.update which is
		// cheaper, allows animation, and keeps references to points.
		if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {
			each(data, function (point, i) {
				if (oldData[i].update) { // Linked, previously hidden series (#3709)
					oldData[i].update(point, false, null, false);
				}
			});

		} else {

			// Reset properties
			series.xIncrement = null;
			series.pointRange = hasCategories ? 1 : options.pointRange;

			series.colorCounter = 0; // for series with colorByPoint (#1547)
			
			// Update parallel arrays
			each(this.parallelArrays, function (key) {
				series[key + 'Data'].length = 0;
			});

			// In turbo mode, only one- or twodimensional arrays of numbers are allowed. The
			// first value is tested, and we assume that all the rest are defined the same
			// way. Although the 'for' loops are similar, they are repeated inside each
			// if-else conditional for max performance.
			if (turboThreshold && dataLength > turboThreshold) {

				// find the first non-null point
				i = 0;
				while (firstPoint === null && i < dataLength) {
					firstPoint = data[i];
					i++;
				}


				if (isNumber(firstPoint)) { // assume all points are numbers
					var x = pick(options.pointStart, 0),
						pointInterval = pick(options.pointInterval, 1);

					for (i = 0; i < dataLength; i++) {
						xData[i] = x;
						yData[i] = data[i];
						x += pointInterval;
					}
					series.xIncrement = x;
				} else if (isArray(firstPoint)) { // assume all points are arrays
					if (valueCount) { // [x, low, high] or [x, o, h, l, c]
						for (i = 0; i < dataLength; i++) {
							pt = data[i];
							xData[i] = pt[0];
							yData[i] = pt.slice(1, valueCount + 1);
						}
					} else { // [x, y]
						for (i = 0; i < dataLength; i++) {
							pt = data[i];
							xData[i] = pt[0];
							yData[i] = pt[1];
						}
					}
				} else {
					error(12); // Highcharts expects configs to be numbers or arrays in turbo mode
				}
			} else {
				for (i = 0; i < dataLength; i++) {
					if (data[i] !== UNDEFINED) { // stray commas in oldIE
						pt = { series: series };
						series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
						series.updateParallelArrays(pt, i);
						if (hasCategories && defined(pt.name)) { // #4401
							xAxis.names[pt.x] = pt.name; // #2046
						}
					}
				}
			}

			// Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON
			if (isString(yData[0])) {
				error(14, true);
			}

			series.data = [];
			series.options.data = data;
			//series.zData = zData;

			// destroy old points
			i = oldDataLength;
			while (i--) {
				if (oldData[i] && oldData[i].destroy) {
					oldData[i].destroy();
				}
			}

			// reset minRange (#878)
			if (xAxis) {
				xAxis.minRange = xAxis.userMinRange;
			}

			// redraw
			series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
			animation = false;
		}

		// Typically for pie series, points need to be processed and generated 
		// prior to rendering the legend
		if (options.legendType === 'point') { // docs: legendType now supported on more series types (at least column and pie)
			this.processData();
			this.generatePoints();
		}

		if (redraw) {
			chart.redraw(animation);
		}
	},

	/**
	 * Process the data by cropping away unused data points if the series is longer
	 * than the crop threshold. This saves computing time for lage series.
	 */
	processData: function (force) {
		var series = this,
			processedXData = series.xData, // copied during slice operation below
			processedYData = series.yData,
			dataLength = processedXData.length,
			croppedData,
			cropStart = 0,
			cropped,
			distance,
			closestPointRange,
			xAxis = series.xAxis,
			i, // loop variable
			options = series.options,
			cropThreshold = options.cropThreshold,
			getExtremesFromAll = series.getExtremesFromAll || options.getExtremesFromAll, // #4599
			isCartesian = series.isCartesian,
			xExtremes,
			min,
			max;

		// If the series data or axes haven't changed, don't go through this. Return false to pass
		// the message on to override methods like in data grouping.
		if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
			return false;
		}

		if (xAxis) {
			xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
			min = xExtremes.min;
			max = xExtremes.max;
		}

		// optionally filter out points outside the plot area
		if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
			
			// it's outside current extremes
			if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
				processedXData = [];
				processedYData = [];

			// only crop if it's actually spilling out
			} else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {
				croppedData = this.cropData(series.xData, series.yData, min, max);
				processedXData = croppedData.xData;
				processedYData = croppedData.yData;
				cropStart = croppedData.start;
				cropped = true;
			}
		}


		// Find the closest distance between processed points
		for (i = processedXData.length - 1; i >= 0; i--) {
			distance = processedXData[i] - processedXData[i - 1];
			
			if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
				closestPointRange = distance;

			// Unsorted data is not supported by the line tooltip, as well as data grouping and
			// navigation in Stock charts (#725) and width calculation of columns (#1900)
			} else if (distance < 0 && series.requireSorting) {
				error(15);
			}
		}

		// Record the properties
		series.cropped = cropped; // undefined or true
		series.cropStart = cropStart;
		series.processedXData = processedXData;
		series.processedYData = processedYData;

		if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
			series.pointRange = closestPointRange || 1;
		}
		series.closestPointRange = closestPointRange;

	},

	/**
	 * Iterate over xData and crop values between min and max. Returns object containing crop start/end
	 * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range
	 */
	cropData: function (xData, yData, min, max) {
		var dataLength = xData.length,
			cropStart = 0,
			cropEnd = dataLength,
			cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside
			i;

		// iterate up to find slice start
		for (i = 0; i < dataLength; i++) {
			if (xData[i] >= min) {
				cropStart = mathMax(0, i - cropShoulder);
				break;
			}
		}

		// proceed to find slice end
		for (; i < dataLength; i++) {
			if (xData[i] > max) {
				cropEnd = i + cropShoulder;
				break;
			}
		}

		return {
			xData: xData.slice(cropStart, cropEnd),
			yData: yData.slice(cropStart, cropEnd),
			start: cropStart,
			end: cropEnd
		};
	},


	/**
	 * Generate the data point after the data has been processed by cropping away
	 * unused points and optionally grouped in Highcharts Stock.
	 */
	generatePoints: function () {
		var series = this,
			options = series.options,
			dataOptions = options.data,
			data = series.data,
			dataLength,
			processedXData = series.processedXData,
			processedYData = series.processedYData,
			pointClass = series.pointClass,
			processedDataLength = processedXData.length,
			cropStart = series.cropStart || 0,
			cursor,
			hasGroupedData = series.hasGroupedData,
			point,
			points = [],
			i;

		if (!data && !hasGroupedData) {
			var arr = [];
			arr.length = dataOptions.length;
			data = series.data = arr;
		}

		for (i = 0; i < processedDataLength; i++) {
			cursor = cropStart + i;
			if (!hasGroupedData) {
				if (data[cursor]) {
					point = data[cursor];
				} else if (dataOptions[cursor] !== UNDEFINED) { // #970
					data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);
				}
				points[i] = point;
			} else {
				// splat the y data in case of ohlc data array
				points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
			}
			points[i].index = cursor; // For faster access in Point.update
		}

		// Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when
		// swithching view from non-grouped data to grouped data (#637)
		if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
			for (i = 0; i < dataLength; i++) {
				if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points
					i += processedDataLength;
				}
				if (data[i]) {
					data[i].destroyElements();
					data[i].plotX = UNDEFINED; // #1003
				}
			}
		}

		series.data = data;
		series.points = points;
	},

	/**
	 * Calculate Y extremes for visible data
	 */
	getExtremes: function (yData) {
		var xAxis = this.xAxis,
			yAxis = this.yAxis,
			xData = this.processedXData,
			yDataLength,
			activeYData = [],
			activeCounter = 0,
			xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis
			xMin = xExtremes.min,
			xMax = xExtremes.max,
			validValue,
			withinRange,
			x,
			y,
			i,
			j;

		yData = yData || this.stackedYData || this.processedYData;
		yDataLength = yData.length;

		for (i = 0; i < yDataLength; i++) {

			x = xData[i];
			y = yData[i];

			// For points within the visible range, including the first point outside the
			// visible range, consider y extremes
			validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));
			withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped ||
				((xData[i + 1] || x) >= xMin &&	(xData[i - 1] || x) <= xMax);

			if (validValue && withinRange) {

				j = y.length;
				if (j) { // array, like ohlc or range data
					while (j--) {
						if (y[j] !== null) {
							activeYData[activeCounter++] = y[j];
						}
					}
				} else {
					activeYData[activeCounter++] = y;
				}
			}
		}
		this.dataMin = arrayMin(activeYData);
		this.dataMax = arrayMax(activeYData);
	},

	/**
	 * Translate data points from raw data values to chart specific positioning data
	 * needed later in drawPoints, drawGraph and drawTracker.
	 */
	translate: function () {
		if (!this.processedXData) { // hidden series
			this.processData();
		}
		this.generatePoints();
		var series = this,
			options = series.options,
			stacking = options.stacking,
			xAxis = series.xAxis,
			categories = xAxis.categories,
			yAxis = series.yAxis,
			points = series.points,
			dataLength = points.length,
			hasModifyValue = !!series.modifyValue,
			i,
			pointPlacement = options.pointPlacement,
			dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),
			threshold = options.threshold,
			stackThreshold = options.startFromThreshold ? threshold : 0,
			plotX,
			plotY,
			lastPlotX,
			stackIndicator,
			closestPointRangePx = Number.MAX_VALUE;

		// Translate each point
		for (i = 0; i < dataLength; i++) {
			var point = points[i],
				xValue = point.x,
				yValue = point.y,
				yBottom = point.low,
				stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],
				pointStack,
				stackValues;

			// Discard disallowed y values for log axes (#3434)
			if (yAxis.isLog && yValue !== null && yValue <= 0) {
				point.y = yValue = null;
				error(10);
			}

			// Get the plotX translation
			point.plotX = plotX = mathMin(mathMax(-1e5, xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags')), 1e5); // #3923


			// Calculate the bottom y value for stacked series
			if (stacking && series.visible && stack && stack[xValue]) {
				stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
				pointStack = stack[xValue];
				stackValues = pointStack.points[stackIndicator.key];
				yBottom = stackValues[0];
				yValue = stackValues[1];

				if (yBottom === stackThreshold) {
					yBottom = pick(threshold, yAxis.min);
				}
				if (yAxis.isLog && yBottom <= 0) { // #1200, #1232
					yBottom = null;
				}

				point.total = point.stackTotal = pointStack.total;
				point.percentage = pointStack.total && (point.y / pointStack.total * 100);
				point.stackY = yValue;

				// Place the stack label
				pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);

			}

			// Set translated yBottom or remove it
			point.yBottom = defined(yBottom) ?
				yAxis.translate(yBottom, 0, 1, 0, 1) :
				null;

			// general hook, used for Highstock compare mode
			if (hasModifyValue) {
				yValue = series.modifyValue(yValue, point);
			}

			// Set the the plotY value, reset it for redraws
			point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?
				mathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201
				UNDEFINED;
			point.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519
				plotX >= 0 && plotX <= xAxis.len;


			// Set client related positions for mouse tracking
			point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514

			point.negative = point.y < (threshold || 0);

			// some API data
			point.category = categories && categories[point.x] !== UNDEFINED ?
				categories[point.x] : point.x;

			// Determine auto enabling of markers (#3635)
			if (i) {
				closestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));
			}
			lastPlotX = plotX;

		}

		series.closestPointRangePx = closestPointRangePx;

		// now that we have the cropped data, build the segments
		series.getSegments();
	},

	/**
	 * Set the clipping for the series. For animated series it is called twice, first to initiate
	 * animating the clip then the second time without the animation to set the final clip.
	 */
	setClip: function (animation) {
		var chart = this.chart,
			options = this.options,
			renderer = chart.renderer,
			inverted = chart.inverted,
			seriesClipBox = this.clipBox,
			clipBox = seriesClipBox || chart.clipBox,
			sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height, options.xAxis, options.yAxis].join(','), // #4526
			clipRect = chart[sharedClipKey],
			markerClipRect = chart[sharedClipKey + 'm'];

		// If a clipping rectangle with the same properties is currently present in the chart, use that.
		if (!clipRect) {

			// When animation is set, prepare the initial positions
			if (animation) { 
				clipBox.width = 0;

				chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(
					-99, // include the width of the first marker
					inverted ? -chart.plotLeft : -chart.plotTop,
					99,
					inverted ? chart.chartWidth : chart.chartHeight
				);
			}
			chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
			
		}
		if (animation) {
			clipRect.count += 1;
		}

		if (options.clip !== false) {
			this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
			this.markerGroup.clip(markerClipRect);
			this.sharedClipKey = sharedClipKey;
		}

		// Remove the shared clipping rectangle when all series are shown
		if (!animation) {
			clipRect.count -= 1;
			if (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {
				if (!seriesClipBox) {
					chart[sharedClipKey] = chart[sharedClipKey].destroy();
				}
				if (chart[sharedClipKey + 'm']) {
					chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
				}
			}
		}
	},

	/**
	 * Animate in the series
	 */
	animate: function (init) {
		var series = this,
			chart = series.chart,
			clipRect,
			animation = series.options.animation,
			sharedClipKey;

		// Animation option is set to true
		if (animation && !isObject(animation)) {
			animation = defaultPlotOptions[series.type].animation;
		}

		// Initialize the animation. Set up the clipping rectangle.
		if (init) {

			series.setClip(animation);

		// Run the animation
		} else {
			sharedClipKey = this.sharedClipKey;
			clipRect = chart[sharedClipKey];
			if (clipRect) {
				clipRect.animate({
					width: chart.plotSizeX
				}, animation);
			}
			if (chart[sharedClipKey + 'm']) {
				chart[sharedClipKey + 'm'].animate({
					width: chart.plotSizeX + 99
				}, animation);
			}

			// Delete this function to allow it only once
			series.animate = null;
 
		}
	},

	/**
	 * This runs after animation to land on the final plot clipping
	 */
	afterAnimate: function () {
		this.setClip();
		fireEvent(this, 'afterAnimate');
	},

	/**
	 * Draw the markers
	 */
	drawPoints: function () {
		var series = this,
			pointAttr,
			points = series.points,
			chart = series.chart,
			plotX,
			plotY,
			i,
			point,
			radius,
			symbol,
			isImage,
			graphic,
			options = series.options,
			seriesMarkerOptions = options.marker,
			seriesPointAttr = series.pointAttr[''],
			pointMarkerOptions,
			hasPointMarker,
			enabled,
			isInside,
			markerGroup = series.markerGroup,
			xAxis = series.xAxis,
			globallyEnabled = pick(
				seriesMarkerOptions.enabled, 
				xAxis.isRadial,
				series.closestPointRangePx > 2 * seriesMarkerOptions.radius
			);

		if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {

			i = points.length;
			while (i--) {
				point = points[i];
				plotX = mathFloor(point.plotX); // #1843
				plotY = point.plotY;
				graphic = point.graphic;
				pointMarkerOptions = point.marker || {};
				hasPointMarker = !!point.marker;
				enabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;
				isInside = point.isInside;

				// only draw the point if y is defined
				if (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {

					// shortcuts
					pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;
					radius = pointAttr.r;
					symbol = pick(pointMarkerOptions.symbol, series.symbol);
					isImage = symbol.indexOf('url') === 0;

					if (graphic) { // update
						graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled
							.animate(extend({
								x: plotX - radius,
								y: plotY - radius
							}, graphic.symbolName ? { // don't apply to image symbols #507
								width: 2 * radius,
								height: 2 * radius
							} : {}));
					} else if (isInside && (radius > 0 || isImage)) {
						point.graphic = graphic = chart.renderer.symbol(
							symbol,
							plotX - radius,
							plotY - radius,
							2 * radius,
							2 * radius,
							hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
						)
						.attr(pointAttr)
						.add(markerGroup);
					}

				} else if (graphic) {
					point.graphic = graphic.destroy(); // #1269
				}
			}
		}

	},

	/**
	 * Convert state properties from API naming conventions to SVG attributes
	 *
	 * @param {Object} options API options object
	 * @param {Object} base1 SVG attribute object to inherit from
	 * @param {Object} base2 Second level SVG attribute object to inherit from
	 */
	convertAttribs: function (options, base1, base2, base3) {
		var conversion = this.pointAttrToOptions,
			attr,
			option,
			obj = {};

		options = options || {};
		base1 = base1 || {};
		base2 = base2 || {};
		base3 = base3 || {};

		for (attr in conversion) {
			option = conversion[attr];
			obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
		}
		return obj;
	},

	/**
	 * Get the state attributes. Each series type has its own set of attributes
	 * that are allowed to change on a point's state change. Series wide attributes are stored for
	 * all series, and additionally point specific attributes are stored for all
	 * points with individual marker options. If such options are not defined for the point,
	 * a reference to the series wide attributes is stored in point.pointAttr.
	 */
	getAttribs: function () {
		var series = this,
			seriesOptions = series.options,
			normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,
			stateOptions = normalOptions.states,
			stateOptionsHover = stateOptions[HOVER_STATE],
			pointStateOptionsHover,
			seriesColor = series.color,
			seriesNegativeColor = series.options.negativeColor,
			normalDefaults = {
				stroke: seriesColor,
				fill: seriesColor
			},
			points = series.points || [], // #927
			i,
			j,
			threshold,
			point,
			seriesPointAttr = [],
			pointAttr,
			pointAttrToOptions = series.pointAttrToOptions,
			hasPointSpecificOptions = series.hasPointSpecificOptions,
			defaultLineColor = normalOptions.lineColor,
			defaultFillColor = normalOptions.fillColor,
			turboThreshold = seriesOptions.turboThreshold,
			zones = series.zones,
			zoneAxis = series.zoneAxis || 'y',
			attr,
			key;

		// series type specific modifications
		if (seriesOptions.marker) { // line, spline, area, areaspline, scatter

			// if no hover radius is given, default to normal radius + 2
			stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + stateOptionsHover.radiusPlus;
			stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;

		} else { // column, bar, pie

			// if no hover color is given, brighten the normal color
			stateOptionsHover.color = stateOptionsHover.color ||
				Color(stateOptionsHover.color || seriesColor)
					.brighten(stateOptionsHover.brightness).get();

			// if no hover negativeColor is given, brighten the normal negativeColor
			stateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||
				Color(stateOptionsHover.negativeColor || seriesNegativeColor)
					.brighten(stateOptionsHover.brightness).get();
		}

		// general point attributes for the series normal state
		seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

		// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
		each([HOVER_STATE, SELECT_STATE], function (state) {
			seriesPointAttr[state] =
					series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
		});

		// set it
		series.pointAttr = seriesPointAttr;


		// Generate the point-specific attribute collections if specific point
		// options are given. If not, create a referance to the series wide point
		// attributes
		i = points.length;
		if (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {
			while (i--) {
				point = points[i];
				normalOptions = (point.options && point.options.marker) || point.options;
				if (normalOptions && normalOptions.enabled === false) {
					normalOptions.radius = 0;
				}

				if (zones.length) {
					j = 0;
					threshold = zones[j];
					while (point[zoneAxis] >= threshold.value) {				
						threshold = zones[++j];
					}
					
					point.color = point.fillColor = pick(threshold.color, series.color); // #3636, #4267, #4430 - inherit color from series, when color is undefined
					
				}

				hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868

				// check if the point has specific visual options
				if (point.options) {
					for (key in pointAttrToOptions) {
						if (defined(normalOptions[pointAttrToOptions[key]])) {
							hasPointSpecificOptions = true;
						}
					}
				}

				// a specific marker config object is defined for the individual point:
				// create it's own attribute collection
				if (hasPointSpecificOptions) {
					normalOptions = normalOptions || {};
					pointAttr = [];
					stateOptions = normalOptions.states || {}; // reassign for individual point
					pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

					// Handle colors for column and pies
					if (!seriesOptions.marker || (point.negative && !pointStateOptionsHover.fillColor && !stateOptionsHover.fillColor)) { // column, bar, point or negative threshold for series with markers (#3636)
						// If no hover color is given, brighten the normal color. #1619, #2579
						pointStateOptionsHover[series.pointAttrToOptions.fill] = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||
							Color(point.color)
								.brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)
								.get();
					}

					// normal point state inherits series wide normal state
					attr = { color: point.color }; // #868
					if (!defaultFillColor) { // Individual point color or negative color markers (#2219)
						attr.fillColor = point.color;
					}
					if (!defaultLineColor) {
						attr.lineColor = point.color; // Bubbles take point color, line markers use white
					}
					// Color is explicitly set to null or undefined (#1288, #4068)
					if (normalOptions.hasOwnProperty('color') && !normalOptions.color) {
						delete normalOptions.color;
					}
					pointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);

					// inherit from point normal and series hover
					pointAttr[HOVER_STATE] = series.convertAttribs(
						stateOptions[HOVER_STATE],
						seriesPointAttr[HOVER_STATE],
						pointAttr[NORMAL_STATE]
					);

					// inherit from point normal and series hover
					pointAttr[SELECT_STATE] = series.convertAttribs(
						stateOptions[SELECT_STATE],
						seriesPointAttr[SELECT_STATE],
						pointAttr[NORMAL_STATE]
					);


				// no marker config object is created: copy a reference to the series-wide
				// attribute collection
				} else {
					pointAttr = seriesPointAttr;
				}

				point.pointAttr = pointAttr;
			}
		}
	},

	/**
	 * Clear DOM objects and free up memory
	 */
	destroy: function () {
		var series = this,
			chart = series.chart,
			issue134 = /AppleWebKit\/533/.test(userAgent),
			destroy,
			i,
			data = series.data || [],
			point,
			prop,
			axis;

		// add event hook
		fireEvent(series, 'destroy');

		// remove all events
		removeEvent(series);

		// erase from axes
		each(series.axisTypes || [], function (AXIS) {
			axis = series[AXIS];
			if (axis) {
				erase(axis.series, series);
				axis.isDirty = axis.forceRedraw = true;
			}
		});

		// remove legend items
		if (series.legendItem) {
			series.chart.legend.destroyItem(series);
		}

		// destroy all points with their elements
		i = data.length;
		while (i--) {
			point = data[i];
			if (point && point.destroy) {
				point.destroy();
			}
		}
		series.points = null;

		// Clear the animation timeout if we are destroying the series during initial animation
		clearTimeout(series.animationTimeout);

		// Destroy all SVGElements associated to the series
		for (prop in series) {
			if (series[prop] instanceof SVGElement && !series[prop].survive) { // Survive provides a hook for not destroying

				// issue 134 workaround
				destroy = issue134 && prop === 'group' ?
					'hide' :
					'destroy';

				series[prop][destroy]();
			}
		}

		// remove from hoverSeries
		if (chart.hoverSeries === series) {
			chart.hoverSeries = null;
		}
		erase(chart.series, series);

		// clear all members
		for (prop in series) {
			delete series[prop];
		}
	},

	/**
	 * Return the graph path of a segment
	 */
	getSegmentPath: function (segment) {
		var series = this,
			segmentPath = [],
			step = series.options.step;

		// build the segment line
		each(segment, function (point, i) {

			var plotX = point.plotX,
				plotY = point.plotY,
				lastPoint;

			if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
				segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));

			} else {

				// moveTo or lineTo
				segmentPath.push(i ? L : M);

				// step line?
				if (step && i) {
					lastPoint = segment[i - 1];
					if (step === 'right') {
						segmentPath.push(
							lastPoint.plotX,
							plotY,
							L
						);

					} else if (step === 'center') {
						segmentPath.push(
							(lastPoint.plotX + plotX) / 2,
							lastPoint.plotY,
							L,
							(lastPoint.plotX + plotX) / 2,
							plotY,
							L
						);

					} else {
						segmentPath.push(
							plotX,
							lastPoint.plotY,
							L
						);
					}
				}

				// normal line to next point
				segmentPath.push(
					point.plotX,
					point.plotY
				);
			}
		});

		return segmentPath;
	},

	/**
	 * Get the graph path
	 */
	getGraphPath: function () {
		var series = this,
			graphPath = [],
			segmentPath,
			singlePoints = []; // used in drawTracker

		// Divide into segments and build graph and area paths
		each(series.segments, function (segment) {

			segmentPath = series.getSegmentPath(segment);

			// add the segment to the graph, or a single point for tracking
			if (segment.length > 1) {
				graphPath = graphPath.concat(segmentPath);
			} else {
				singlePoints.push(segment[0]);
			}
		});

		// Record it for use in drawGraph and drawTracker, and return graphPath
		series.singlePoints = singlePoints;
		series.graphPath = graphPath;

		return graphPath;

	},

	/**
	 * Draw the actual graph
	 */
	drawGraph: function () {
		var series = this,
			options = this.options,
			props = [['graph', options.lineColor || this.color, options.dashStyle]],
			lineWidth = options.lineWidth,
			roundCap = options.linecap !== 'square',
			graphPath = this.getGraphPath(),
			fillColor = (this.fillGraph && this.color) || NONE, // polygon series use filled graph
			zones = this.zones;

		each(zones, function (threshold, i) {
			props.push(['zoneGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);
		});
		
		// Draw the graph
		each(props, function (prop, i) {
			var graphKey = prop[0],
				graph = series[graphKey],
				attribs;

			if (graph) {
				graph.animate({ d: graphPath });

			} else if ((lineWidth || fillColor) && graphPath.length) { // #1487
				attribs = {
					stroke: prop[1],
					'stroke-width': lineWidth,
					fill: fillColor,
					zIndex: 1 // #1069
				};
				if (prop[2]) {
					attribs.dashstyle = prop[2];
				} else if (roundCap) {
					attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
				}

				series[graphKey] = series.chart.renderer.path(graphPath)
					.attr(attribs)
					.add(series.group)
					.shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932
			}
		});
	},

	/**
	 * Clip the graphs into the positive and negative coloured graphs
	 */
	applyZones: function () {
		var series = this,
			chart = this.chart,
			renderer = chart.renderer,
			zones = this.zones,
			translatedFrom,
			translatedTo,
			clips = this.clips || [],
			clipAttr,
			graph = this.graph,
			area = this.area,
			chartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),
			axis = this[(this.zoneAxis || 'y') + 'Axis'],
			extremes,
			reversed = axis.reversed,
			inverted = chart.inverted,
			horiz = axis.horiz,
			pxRange,
			pxPosMin,
			pxPosMax,
			ignoreZones = false;

		if (zones.length && (graph || area) && axis.min !== UNDEFINED) {
			// The use of the Color Threshold assumes there are no gaps
			// so it is safe to hide the original graph and area
			if (graph) {
				graph.hide();
			}
			if (area) { 
				area.hide(); 
			}

			// Create the clips
			extremes = axis.getExtremes();
			each(zones, function (threshold, i) {

				translatedFrom = reversed ? 
					(horiz ? chart.plotWidth : 0) : 
					(horiz ? 0 : axis.toPixels(extremes.min));
				translatedFrom = mathMin(mathMax(pick(translatedTo, translatedFrom), 0), chartSizeMax);
				translatedTo = mathMin(mathMax(mathRound(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);
				
				if (ignoreZones) {
					translatedFrom = translatedTo = axis.toPixels(extremes.max);
				}

				pxRange = Math.abs(translatedFrom - translatedTo);
				pxPosMin = mathMin(translatedFrom, translatedTo);
				pxPosMax = mathMax(translatedFrom, translatedTo);
				if (axis.isXAxis) {
					clipAttr = {
						x: inverted ? pxPosMax : pxPosMin,
						y: 0,
						width: pxRange, 
						height: chartSizeMax
					};
					if (!horiz) {
						clipAttr.x = chart.plotHeight - clipAttr.x;
					}
				} else {
					clipAttr = {
						x: 0,
						y: inverted ? pxPosMax : pxPosMin,
						width: chartSizeMax, 
						height: pxRange
					};					
					if (horiz) {
						clipAttr.y = chart.plotWidth - clipAttr.y;
					}
				}

				/// VML SUPPPORT
				if (chart.inverted && renderer.isVML) {
					if (axis.isXAxis) {			
						clipAttr = {
							x: 0,
							y: reversed ? pxPosMin : pxPosMax,
							height: clipAttr.width,
							width: chart.chartWidth
						};		
					} else {				
						clipAttr = {
							x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
							y: 0,
							width: clipAttr.height,
							height: chart.chartHeight
						};	
					}				
				}
				/// END OF VML SUPPORT

				if (clips[i]) {
					clips[i].animate(clipAttr);
				} else {
					clips[i] = renderer.clipRect(clipAttr);

					if (graph) {
						series['zoneGraph' + i].clip(clips[i]);
					}

					if (area) {
						series['zoneArea' + i].clip(clips[i]);
					}
				}
				// if this zone extends out of the axis, ignore the others
				ignoreZones = threshold.value > extremes.max;
			});
			this.clips = clips;
		}
	},

	/**
	 * Initialize and perform group inversion on series.group and series.markerGroup
	 */
	invertGroups: function () {
		var series = this,
			chart = series.chart;

		// Pie, go away (#1736)
		if (!series.xAxis) {
			return;
		}

		// A fixed size is needed for inversion to work
		function setInvert() {
			var size = {
				width: series.yAxis.len,
				height: series.xAxis.len
			};

			each(['group', 'markerGroup'], function (groupName) {
				if (series[groupName]) {
					series[groupName].attr(size).invert();
				}
			});
		}

		addEvent(chart, 'resize', setInvert); // do it on resize
		addEvent(series, 'destroy', function () {
			removeEvent(chart, 'resize', setInvert);
		});

		// Do it now
		setInvert(); // do it now

		// On subsequent render and redraw, just do setInvert without setting up events again
		series.invertGroups = setInvert;
	},

	/**
	 * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and
	 * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.
	 */
	plotGroup: function (prop, name, visibility, zIndex, parent) {
		var group = this[prop],
			isNew = !group;

		// Generate it on first call
		if (isNew) {
			this[prop] = group = this.chart.renderer.g(name)
				.attr({
					visibility: visibility,
					zIndex: zIndex || 0.1 // IE8 needs this
				})
				.add(parent);

			group.addClass('highcharts-series-' + this.index);
		}
		
		// Place it on first and subsequent (redraw) calls
		group[isNew ? 'attr' : 'animate'](this.getPlotBox());
		return group;
	},

	/**
	 * Get the translation and scale for the plot area of this series
	 */
	getPlotBox: function () {
		var chart = this.chart,
			xAxis = this.xAxis,
			yAxis = this.yAxis;

		// Swap axes for inverted (#2339)
		if (chart.inverted) {
			xAxis = yAxis;
			yAxis = this.xAxis;
		}
		return {
			translateX: xAxis ? xAxis.left : chart.plotLeft,
			translateY: yAxis ? yAxis.top : chart.plotTop,
			scaleX: 1, // #1623
			scaleY: 1
		};
	},

	/**
	 * Render the graph and markers
	 */
	render: function () {
		var series = this,
			chart = series.chart,
			group,
			options = series.options,
			animation = options.animation,
			// Animation doesn't work in IE8 quirks when the group div is hidden,
			// and looks bad in other oldIE
			animDuration = (animation && !!series.animate && chart.renderer.isSVG && pick(animation.duration, 500)) || 0,
			visibility = series.visible ? VISIBLE : HIDDEN,
			zIndex = options.zIndex,
			hasRendered = series.hasRendered,
			chartSeriesGroup = chart.seriesGroup;

		// the group
		group = series.plotGroup(
			'group',
			'series',
			visibility,
			zIndex,
			chartSeriesGroup
		);

		series.markerGroup = series.plotGroup(
			'markerGroup',
			'markers',
			visibility,
			zIndex,
			chartSeriesGroup
		);

		// initiate the animation
		if (animDuration) {
			series.animate(true);
		}

		// cache attributes for shapes
		series.getAttribs();

		// SVGRenderer needs to know this before drawing elements (#1089, #1795)
		group.inverted = series.isCartesian ? chart.inverted : false;

		// draw the graph if any
		if (series.drawGraph) {
			series.drawGraph();
			series.applyZones();
		}

		each(series.points, function (point) {
			if (point.redraw) {
				point.redraw();
			}
		});

		// draw the data labels (inn pies they go before the points)
		if (series.drawDataLabels) {
			series.drawDataLabels();
		}

		// draw the points
		if (series.visible) {
			series.drawPoints();
		}


		// draw the mouse tracking area
		if (series.drawTracker && series.options.enableMouseTracking !== false) {
			series.drawTracker();
		}

		// Handle inverted series and tracker groups
		if (chart.inverted) {
			series.invertGroups();
		}

		// Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).
		if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
			group.clip(chart.clipRect);
		}

		// Run the animation
		if (animDuration) {
			series.animate();
		} 

		// Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option
		// which should be available to the user).
		if (!hasRendered) {
			if (animDuration) {
				series.animationTimeout = setTimeout(function () {
					series.afterAnimate();
				}, animDuration);
			} else {
				series.afterAnimate();
			}
		}

		series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
		// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
		series.hasRendered = true;
	},

	/**
	 * Redraw the series after an update in the axes.
	 */
	redraw: function () {
		var series = this,
			chart = series.chart,
			wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after
			wasDirty = series.isDirty,
			group = series.group,
			xAxis = series.xAxis,
			yAxis = series.yAxis;

		// reposition on resize
		if (group) {
			if (chart.inverted) {
				group.attr({
					width: chart.plotWidth,
					height: chart.plotHeight
				});
			}

			group.animate({
				translateX: pick(xAxis && xAxis.left, chart.plotLeft),
				translateY: pick(yAxis && yAxis.top, chart.plotTop)
			});
		}

		series.translate();
		series.render();
		if (wasDirtyData) {
			fireEvent(series, 'updatedData');
		}
		if (wasDirty || wasDirtyData) {			// #3945 recalculate the kdtree when dirty
			delete this.kdTree; // #3868 recalculate the kdtree with dirty data
		}
	},

	/**
	 * KD Tree && PointSearching Implementation
	 */

	kdDimensions: 1,
	kdAxisArray: ['clientX', 'plotY'],

	searchPoint: function (e, compareX) {
		var series = this,
			xAxis = series.xAxis,
			yAxis = series.yAxis,
			inverted = series.chart.inverted;
		
		return this.searchKDTree({
			clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
			plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
		}, compareX);
	},

	buildKDTree: function () {
		var series = this,
			dimensions = series.kdDimensions;

		// Internal function
		function _kdtree(points, depth, dimensions) {
			var axis, median, length = points && points.length;

			if (length) {

				// alternate between the axis
				axis = series.kdAxisArray[depth % dimensions];

				// sort point array
				points.sort(function(a, b) {
					return a[axis] - b[axis];
				});
			
				median = Math.floor(length / 2);
				
				// build and return nod
				return {
					point: points[median],
					left: _kdtree(points.slice(0, median), depth + 1, dimensions),
					right: _kdtree(points.slice(median + 1), depth + 1, dimensions)
				};
			
			}
		}

		// Start the recursive build process with a clone of the points array and null points filtered out (#3873)
		function startRecursive() {
			var points = grep(series.points || [], function (point) { // #4390
				return point.y !== null;
			});

			series.kdTree = _kdtree(points, dimensions, dimensions);
		}
		delete series.kdTree;
		
		if (series.options.kdSync) {  // For testing tooltips, don't build async
			startRecursive();
		} else {
			setTimeout(startRecursive);
		}
	},

	searchKDTree: function (point, compareX) {
		var series = this,
			kdX = this.kdAxisArray[0],
			kdY = this.kdAxisArray[1],
			kdComparer = compareX ? 'distX' : 'dist';

		// Set the one and two dimensional distance on the point object
		function setDistance(p1, p2) {
			var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,
				y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,
				r = (x || 0) + (y || 0);

			p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;
			p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;
		}
		function _search(search, tree, depth, dimensions) {
			var point = tree.point,
				axis = series.kdAxisArray[depth % dimensions],
				tdist,
				sideA,
				sideB,
				ret = point,
				nPoint1,
				nPoint2;
			
			setDistance(search, point);

			// Pick side based on distance to splitting point
			tdist = search[axis] - point[axis];
			sideA = tdist < 0 ? 'left' : 'right';
			sideB = tdist < 0 ? 'right' : 'left';

			// End of tree
			if (tree[sideA]) {
				nPoint1 =_search(search, tree[sideA], depth + 1, dimensions);

				ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);
			} 
			if (tree[sideB]) {
				// compare distance to current best to splitting point to decide wether to check side B or not
				if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
					nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
					ret = (nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret);
				}
			}
			
			return ret;
		}

		if (!this.kdTree) {
			this.buildKDTree();
		}

		if (this.kdTree) {
			return _search(point, 
				this.kdTree, this.kdDimensions, this.kdDimensions);
		}
	}

}; // end Series prototype

/**
 * The class for stack items
 */
function StackItem(axis, options, isNegative, x, stackOption) {
	
	var inverted = axis.chart.inverted;

	this.axis = axis;

	// Tells if the stack is negative
	this.isNegative = isNegative;

	// Save the options to be able to style the label
	this.options = options;

	// Save the x value to be able to position the label later
	this.x = x;

	// Initialize total value
	this.total = null;

	// This will keep each points' extremes stored by series.index and point index
	this.points = {};

	// Save the stack option on the series configuration object, and whether to treat it as percent
	this.stack = stackOption;

	// The align options and text align varies on whether the stack is negative and
	// if the chart is inverted or not.
	// First test the user supplied value, then use the dynamic.
	this.alignOptions = {
		align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
		verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
		y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
		x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
	};

	this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
}

StackItem.prototype = {
	destroy: function () {
		destroyObjectProperties(this, this.axis);
	},

	/**
	 * Renders the stack total label and adds it to the stack label group.
	 */
	render: function (group) {
		var options = this.options,
			formatOption = options.format,
			str = formatOption ?
				format(formatOption, this) : 
				options.formatter.call(this);  // format the text in the label

		// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
		if (this.label) {
			this.label.attr({text: str, visibility: HIDDEN});
		// Create new label
		} else {
			this.label =
				this.axis.chart.renderer.text(str, null, null, options.useHTML)		// dummy positions, actual position updated with setOffset method in columnseries
					.css(options.style)				// apply style
					.attr({
						align: this.textAlign,				// fix the text-anchor
						rotation: options.rotation,	// rotation
						visibility: HIDDEN					// hidden until setOffset is called
					})				
					.add(group);							// add to the labels-group
		}
	},

	/**
	 * Sets the offset that the stack has from the x value and repositions the label.
	 */
	setOffset: function (xOffset, xWidth) {
		var stackItem = this,
			axis = stackItem.axis,
			chart = axis.chart,
			inverted = chart.inverted,
			reversed = axis.reversed,
			neg = (this.isNegative && !reversed) || (!this.isNegative && reversed), // #4056
			y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates
			yZero = axis.translate(0),						// stack origin
			h = mathAbs(y - yZero),							// stack height
			x = chart.xAxis[0].translate(this.x) + xOffset,	// stack x position
			plotHeight = chart.plotHeight,
			stackBox = {	// this is the box for the complete stack
				x: inverted ? (neg ? y : y - h) : x,
				y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
				width: inverted ? h : xWidth,
				height: inverted ? xWidth : h
			},
			label = this.label,
			alignAttr;
		
		if (label) {
			label.align(this.alignOptions, null, stackBox);	// align the label to the box
				
			// Set visibility (#678)
			alignAttr = label.alignAttr;
			label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);
		}
	}
};

/**
 * Generate stacks for each series and calculate stacks total values
 */
Chart.prototype.getStacks = function () {
	var chart = this;

	// reset stacks for each yAxis
	each(chart.yAxis, function (axis) {
		if (axis.stacks && axis.hasVisibleSeries) {
			axis.oldStacks = axis.stacks;
		}
	});

	each(chart.series, function (series) {
		if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
			series.stackKey = series.type + pick(series.options.stack, '');
		}
	});
};


// Stacking methods defined on the Axis prototype

/**
 * Build the stacks from top down
 */
Axis.prototype.buildStacks = function () {
	var series = this.series,
		reversedStacks = pick(this.options.reversedStacks, true),
		i = series.length;
	if (!this.isXAxis) {
		this.usePercentage = false;
		while (i--) {
			series[reversedStacks ? i : series.length - i - 1].setStackedPoints();
		}
		// Loop up again to compute percent stack
		if (this.usePercentage) {
			for (i = 0; i < series.length; i++) {
				series[i].setPercentStacks();
			}
		}
	}
};

Axis.prototype.renderStackTotals = function () {
	var axis = this,
		chart = axis.chart,
		renderer = chart.renderer,
		stacks = axis.stacks,
		stackKey, 
		oneStack, 
		stackCategory,
		stackTotalGroup = axis.stackTotalGroup;

	// Create a separate group for the stack total labels
	if (!stackTotalGroup) {
		axis.stackTotalGroup = stackTotalGroup =
			renderer.g('stack-labels')
				.attr({
					visibility: VISIBLE,
					zIndex: 6
				})
				.add();
	}

	// plotLeft/Top will change when y axis gets wider so we need to translate the
	// stackTotalGroup at every render call. See bug #506 and #516
	stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

	// Render each stack total
	for (stackKey in stacks) {
		oneStack = stacks[stackKey];
		for (stackCategory in oneStack) {
			oneStack[stackCategory].render(stackTotalGroup);
		}
	}
};

/**
 * Set all the stacks to initial states and destroy unused ones.
 */
Axis.prototype.resetStacks = function () {
	var stacks = this.stacks,
		type,
		i;
	if (!this.isXAxis) {
		for (type in stacks) {
			for (i in stacks[type]) {

				// Clean up memory after point deletion (#1044, #4320)
				if (stacks[type][i].touched < this.stacksTouched) {
					stacks[type][i].destroy();
					delete stacks[type][i];

				// Reset stacks
				} else {
					stacks[type][i].total = null;
					stacks[type][i].cum = 0;
				}
			}
		}
	}
};

Axis.prototype.cleanStacks = function () {
	var stacks, type, i;

	if (!this.isXAxis) {
		if (this.oldStacks) {
			stacks = this.stacks = this.oldStacks;
		}

		// reset stacks
		for (type in stacks) {
			for (i in stacks[type]) {
				stacks[type][i].cum = stacks[type][i].total;
			}
		}
	}
};


// Stacking methods defnied for Series prototype

/**
 * Adds series' points value to corresponding stack
 */
Series.prototype.setStackedPoints = function () {
	if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {
		return;
	}

	var series = this,
		xData = series.processedXData,
		yData = series.processedYData,
		stackedYData = [],
		yDataLength = yData.length,
		seriesOptions = series.options,
		threshold = seriesOptions.threshold,
		stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,
		stackOption = seriesOptions.stack,
		stacking = seriesOptions.stacking,
		stackKey = series.stackKey,
		negKey = '-' + stackKey,
		negStacks = series.negStacks,
		yAxis = series.yAxis,
		stacks = yAxis.stacks,
		oldStacks = yAxis.oldStacks,
		stackIndicator,
		isNegative,
		stack,
		other,
		key,
		pointKey,
		i,
		x,
		y;


	yAxis.stacksTouched += 1;

	// loop over the non-null y values and read them into a local array
	for (i = 0; i < yDataLength; i++) {
		x = xData[i];
		y = yData[i];
		stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
		pointKey = stackIndicator.key;
		// Read stacked values into a stack based on the x value,
		// the sign of y and the stack key. Stacking is also handled for null values (#739)
		isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
		key = isNegative ? negKey : stackKey;

		// Create empty object for this stack if it doesn't exist yet
		if (!stacks[key]) {
			stacks[key] = {};
		}

		// Initialize StackItem for this x
		if (!stacks[key][x]) {
			if (oldStacks[key] && oldStacks[key][x]) {
				stacks[key][x] = oldStacks[key][x];
				stacks[key][x].total = null;
			} else {
				stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
			}
		}

		// If the StackItem doesn't exist, create it first
		stack = stacks[key][x];
		//stack.points[pointKey] = [stack.cum || stackThreshold];
		stack.points[pointKey] = [pick(stack.cum, stackThreshold)];
		stack.touched = yAxis.stacksTouched;
		

		// Add value to the stack total
		if (stacking === 'percent') {

			// Percent stacked column, totals are the same for the positive and negative stacks
			other = isNegative ? stackKey : negKey;
			if (negStacks && stacks[other] && stacks[other][x]) {
				other = stacks[other][x];
				stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;

			// Percent stacked areas
			} else {
				stack.total = correctFloat(stack.total + (mathAbs(y) || 0));
			}
		} else {
			stack.total = correctFloat(stack.total + (y || 0));
		}

		stack.cum = pick(stack.cum, stackThreshold) + (y || 0);

		stack.points[pointKey].push(stack.cum);
		stackedYData[i] = stack.cum;

	}

	if (stacking === 'percent') {
		yAxis.usePercentage = true;
	}

	this.stackedYData = stackedYData; // To be used in getExtremes

	// Reset old stacks
	yAxis.oldStacks = {};
};

/**
 * Iterate over all stacks and compute the absolute values to percent
 */
Series.prototype.setPercentStacks = function () {
	var series = this,
		stackKey = series.stackKey,
		stacks = series.yAxis.stacks,
		processedXData = series.processedXData,
		stackIndicator;

	each([stackKey, '-' + stackKey], function (key) {
		var i = processedXData.length,
			x,
			stack,
			pointExtremes,
			totalFactor;

		while (i--) {
			x = processedXData[i];
			stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
			stack = stacks[key] && stacks[key][x];
			pointExtremes = stack && stack.points[stackIndicator.key];
			if (pointExtremes) {
				totalFactor = stack.total ? 100 / stack.total : 0;
				pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value
				pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value
				series.stackedYData[i] = pointExtremes[1];
			}
		}
	});
};

/**
* Get stack indicator, according to it's x-value, to determine points with the same x-value
*/
Series.prototype.getStackIndicator = function(stackIndicator, x, index) {
	if (!defined(stackIndicator) || stackIndicator.x !== x) {
		stackIndicator = {
			x: x,
			index: 0
		};
	} else {
		stackIndicator.index++;
	}
	
	stackIndicator.key = [index, x, stackIndicator.index].join(',');

	return stackIndicator;
};

// Extend the Chart prototype for dynamic methods
extend(Chart.prototype, {

	/**
	 * Add a series dynamically after  time
	 *
	 * @param {Object} options The config options
	 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 *
	 * @return {Object} series The newly created series object
	 */
	addSeries: function (options, redraw, animation) {
		var series,
			chart = this;

		if (options) {
			redraw = pick(redraw, true); // defaults to true

			fireEvent(chart, 'addSeries', { options: options }, function () {
				series = chart.initSeries(options);

				chart.isDirtyLegend = true; // the series array is out of sync with the display
				chart.linkSeries();
				if (redraw) {
					chart.redraw(animation);
				}
			});
		}

		return series;
	},

	/**
     * Add an axis to the chart
     * @param {Object} options The axis option
     * @param {Boolean} isX Whether it is an X axis or a value axis
     */
	addAxis: function (options, isX, redraw, animation) {
		var key = isX ? 'xAxis' : 'yAxis',
			chartOptions = this.options,
			axis;

		/*jslint unused: false*/
		axis = new Axis(this, merge(options, {
			index: this[key].length,
			isX: isX
		}));
		/*jslint unused: true*/

		// Push the new axis options to the chart options
		chartOptions[key] = splat(chartOptions[key] || {});
		chartOptions[key].push(options);

		if (pick(redraw, true)) {
			this.redraw(animation);
		}
	},

	/**
	 * Dim the chart and show a loading text or symbol
	 * @param {String} str An optional text to show in the loading label instead of the default one
	 */
	showLoading: function (str) {
		var chart = this,
			options = chart.options,
			loadingDiv = chart.loadingDiv,
			loadingOptions = options.loading,
			setLoadingSize = function () {
				if (loadingDiv) {
					css(loadingDiv, {
						left: chart.plotLeft + PX,
						top: chart.plotTop + PX,
						width: chart.plotWidth + PX,
						height: chart.plotHeight + PX
					});
				}
			};

		// create the layer at the first call
		if (!loadingDiv) {
			chart.loadingDiv = loadingDiv = createElement(DIV, {
				className: PREFIX + 'loading'
			}, extend(loadingOptions.style, {
				zIndex: 10,
				display: NONE
			}), chart.container);

			chart.loadingSpan = createElement(
				'span',
				null,
				loadingOptions.labelStyle,
				loadingDiv
			);
			addEvent(chart, 'redraw', setLoadingSize); // #1080
		}

		// update text
		chart.loadingSpan.innerHTML = str || options.lang.loading;

		// show it
		if (!chart.loadingShown) {
			css(loadingDiv, {
				opacity: 0,
				display: ''				
			});
			animate(loadingDiv, {
				opacity: loadingOptions.style.opacity
			}, {
				duration: loadingOptions.showDuration || 0
			});
			chart.loadingShown = true;
		}
		setLoadingSize();
	},

	/**
	 * Hide the loading layer
	 */
	hideLoading: function () {
		var options = this.options,
			loadingDiv = this.loadingDiv;

		if (loadingDiv) {
			animate(loadingDiv, {
				opacity: 0
			}, {
				duration: options.loading.hideDuration || 100,
				complete: function () {
					css(loadingDiv, { display: NONE });
				}
			});
		}
		this.loadingShown = false;
	}
});

// extend the Point prototype for dynamic methods
extend(Point.prototype, {
	/**
	 * Update the point with new options (typically x/y data) and optionally redraw the series.
	 *
	 * @param {Object} options Point options as defined in the series.data array
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 *
	 */
	update: function (options, redraw, animation, runEvent) {
		var point = this,
			series = point.series,
			graphic = point.graphic,
			i,
			chart = series.chart,
			seriesOptions = series.options,
			names = series.xAxis && series.xAxis.names;

		redraw = pick(redraw, true);

		function update() {

			point.applyOptions(options);

			// Update visuals
			if (point.y === null && graphic) { // #4146
				point.graphic = graphic.destroy();
			}
			if (isObject(options) && !isArray(options)) {
				// Defer the actual redraw until getAttribs has been called (#3260)
				point.redraw = function () {
					if (graphic && graphic.element) {
						if (options && options.marker && options.marker.symbol) {
							point.graphic = graphic.destroy();
						}
					}
					if (options && options.dataLabels && point.dataLabel) { // #2468
						point.dataLabel = point.dataLabel.destroy();
					}
					point.redraw = null;
				};
			}

			// record changes in the parallel arrays
			i = point.index;
			series.updateParallelArrays(point, i);
			if (names && point.name) {
				names[point.x] = point.name;
			}

			seriesOptions.data[i] = point.options;

			// redraw
			series.isDirty = series.isDirtyData = true;
			if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
				chart.isDirtyBox = true;
			}

			if (seriesOptions.legendType === 'point') { // #1831, #1885
				chart.isDirtyLegend = true;
			}
			if (redraw) {
				chart.redraw(animation);
			}
		}

		// Fire the event with a default handler of doing the update
		if (runEvent === false) { // When called from setData
			update();
		} else {
			point.firePointEvent('update', { options: options }, update);
		}
	},

	/**
	 * Remove a point and optionally redraw the series and if necessary the axes
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	remove: function (redraw, animation) {
		this.series.removePoint(inArray(this, this.series.data), redraw, animation);
	}
});

// Extend the series prototype for dynamic methods
extend(Series.prototype, {
	/**
	 * Add a point dynamically after chart load time
	 * @param {Object} options Point options as given in series.data
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean} shift If shift is true, a point is shifted off the start
	 *    of the series as one is appended to the end.
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	addPoint: function (options, redraw, shift, animation) {
		var series = this,
			seriesOptions = series.options,
			data = series.data,
			graph = series.graph,
			area = series.area,
			chart = series.chart,
			names = series.xAxis && series.xAxis.names,
			currentShift = (graph && graph.shift) || 0,
			shiftShapes = ['graph', 'area'],
			dataOptions = seriesOptions.data,
			point,
			isInTheMiddle,
			xData = series.xData,
			i,
			x;

		setAnimation(animation, chart);

		// Make graph animate sideways
		if (shift) {
			i = series.zones.length;
			while (i--) {
				shiftShapes.push('zoneGraph' + i, 'zoneArea' + i);
			}
			each(shiftShapes, function (shape) {
				if (series[shape]) {
					series[shape].shift = currentShift + (seriesOptions.step ? 2 : 1);
				}
			});
		}
		if (area) {
			area.isArea = true; // needed in animation, both with and without shift
		}

		// Optional redraw, defaults to true
		redraw = pick(redraw, true);

		// Get options and push the point to xData, yData and series.options. In series.generatePoints
		// the Point instance will be created on demand and pushed to the series.data array.
		point = { series: series };
		series.pointClass.prototype.applyOptions.apply(point, [options]);
		x = point.x;

		// Get the insertion point
		i = xData.length;
		if (series.requireSorting && x < xData[i - 1]) {
			isInTheMiddle = true;
			while (i && xData[i - 1] > x) {
				i--;
			}
		}

		series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item
		series.updateParallelArrays(point, i); // update it

		if (names && point.name) {
			names[x] = point.name;
		}
		dataOptions.splice(i, 0, options);

		if (isInTheMiddle) {
			series.data.splice(i, 0, null);
			series.processData();
		}

		// Generate points to be added to the legend (#1329)
		if (seriesOptions.legendType === 'point') {
			series.generatePoints();
		}

		// Shift the first point off the parallel arrays
		// todo: consider series.removePoint(i) method
		if (shift) {
			if (data[0] && data[0].remove) {
				data[0].remove(false);
			} else {
				data.shift();
				series.updateParallelArrays(point, 'shift');

				dataOptions.shift();
			}
		}

		// redraw
		series.isDirty = true;
		series.isDirtyData = true;
		if (redraw) {
			series.getAttribs(); // #1937
			chart.redraw();
		}
	},

	/**
	 * Remove a point (rendered or not), by index
	 */
	removePoint: function (i, redraw, animation) {

		var series = this,
			data = series.data,
			point = data[i],
			points = series.points,
			chart = series.chart,
			remove = function () {

				if (data.length === points.length) {
					points.splice(i, 1);
				}
				data.splice(i, 1);
				series.options.data.splice(i, 1);
				series.updateParallelArrays(point || { series: series }, 'splice', i, 1);

				if (point) {
					point.destroy();
				}

				// redraw
				series.isDirty = true;
				series.isDirtyData = true;
				if (redraw) {
					chart.redraw();
				}
			};

		setAnimation(animation, chart);
		redraw = pick(redraw, true);

		// Fire the event with a default handler of removing the point
		if (point) {
			point.firePointEvent('remove', null, remove);
		} else {
			remove();
		}
	},

	/**
	 * Remove a series and optionally redraw the chart
	 *
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */

	remove: function (redraw, animation) {
		var series = this,
			chart = series.chart;
		redraw = pick(redraw, true);

		if (!series.isRemoving) {  /* prevent triggering native event in jQuery
				(calling the remove function from the remove event) */
			series.isRemoving = true;

			// fire the event with a default handler of removing the point
			fireEvent(series, 'remove', null, function () {


				// destroy elements
				series.destroy();


				// redraw
				chart.isDirtyLegend = chart.isDirtyBox = true;
				chart.linkSeries();

				if (redraw) {
					chart.redraw(animation);
				}
			});

		}
		series.isRemoving = false;
	},

	/**
	 * Update the series with a new set of options
	 */
	update: function (newOptions, redraw) {
		var series = this,
			chart = this.chart,
			// must use user options when changing type because this.options is merged
			// in with type specific plotOptions
			oldOptions = this.userOptions,
			oldType = this.type,
			proto = seriesTypes[oldType].prototype,
			preserve = ['group', 'markerGroup', 'dataLabelsGroup'],
			n;

		// If we're changing type or zIndex, create new groups (#3380, #3404)
		if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {
			preserve.length = 0;
		}

		// Make sure groups are not destroyed (#3094)
		each(preserve, function (prop) {
			preserve[prop] = series[prop];
			delete series[prop];
		});

		// Do the merge, with some forced options
		newOptions = merge(oldOptions, {
			animation: false,
			index: this.index,
			pointStart: this.xData[0] // when updating after addPoint
		}, { data: this.options.data }, newOptions);

		// Destroy the series and delete all properties. Reinsert all methods 
		// and properties from the new type prototype (#2270, #3719)
		this.remove(false);
		for (n in proto) {
			this[n] = UNDEFINED;
		}
		extend(this, seriesTypes[newOptions.type || oldType].prototype);

		// Re-register groups (#3094)
		each(preserve, function (prop) {
			series[prop] = preserve[prop];
		});

		this.init(chart, newOptions);
		chart.linkSeries(); // Links are lost in this.remove (#3028)
		if (pick(redraw, true)) {
			chart.redraw(false);
		}
	}
});

// Extend the Axis.prototype for dynamic methods
extend(Axis.prototype, {

	/**
	 * Update the axis with a new options structure
	 */
	update: function (newOptions, redraw) {
		var chart = this.chart;

		newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);

		this.destroy(true);
		this._addedPlotLB = this.chart._labelPanes = UNDEFINED; // #1611, #2887, #4314

		this.init(chart, extend(newOptions, { events: UNDEFINED }));

		chart.isDirtyBox = true;
		if (pick(redraw, true)) {
			chart.redraw();
		}
	},

	/**
     * Remove the axis from the chart
     */
	remove: function (redraw) {
		var chart = this.chart,
			key = this.coll, // xAxis or yAxis
			axisSeries = this.series,
			i = axisSeries.length;

		// Remove associated series (#2687)
		while (i--) {
			if (axisSeries[i]) {
				axisSeries[i].remove(false);
			}
		}

		// Remove the axis
		erase(chart.axes, this);
		erase(chart[key], this);
		chart.options[key].splice(this.options.index, 1);
		each(chart[key], function (axis, i) { // Re-index, #1706
			axis.options.index = i;
		});
		this.destroy();
		chart.isDirtyBox = true;

		if (pick(redraw, true)) {
			chart.redraw();
		}
	},

	/**
	 * Update the axis title by options
	 */
	setTitle: function (newTitleOptions, redraw) {
		this.update({ title: newTitleOptions }, redraw);
	},

	/**
	 * Set new axis categories and optionally redraw
	 * @param {Array} categories
	 * @param {Boolean} redraw
	 */
	setCategories: function (categories, redraw) {
		this.update({ categories: categories }, redraw);
	}

});


/**
 * LineSeries object
 */
var LineSeries = extendClass(Series);
seriesTypes.line = LineSeries;

/**
 * Set the default options for area
 */
defaultPlotOptions.area = merge(defaultSeriesOptions, {
	softThreshold: false,
	threshold: 0
	// trackByArea: false,
	// lineColor: null, // overrides color, but lets fillColor be unaltered
	// fillOpacity: 0.75,
	// fillColor: null
});

/**
 * AreaSeries object
 */
var AreaSeries = extendClass(Series, {
	type: 'area',
	/**
	 * For stacks, don't split segments on null values. Instead, draw null values with 
	 * no marker. Also insert dummy points for any X position that exists in other series
	 * in the stack.
	 */ 
	getSegments: function () {
		var series = this,
			segments = [],
			segment = [],
			keys = [],
			xAxis = this.xAxis,
			yAxis = this.yAxis,
			stack = yAxis.stacks[this.stackKey],
			pointMap = {},
			plotX,
			plotY,
			points = this.points,
			connectNulls = this.options.connectNulls,
			stackIndicator,
			i,
			x;

		if (this.options.stacking && !this.cropped) { // cropped causes artefacts in Stock, and perf issue
			// Create a map where we can quickly look up the points by their X value.
			for (i = 0; i < points.length; i++) {
				pointMap[points[i].x] = points[i];
			}

			// Sort the keys (#1651)
			for (x in stack) {
				if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)
					keys.push(+x);
				}
			}
			keys.sort(function (a, b) {
				return a - b;
			});

			each(keys, function (x) {
				var threshold = null,
					stackPoint;

				if (connectNulls && (!pointMap[x] || pointMap[x].y === null)) { // #1836
					return;

				// The point exists, push it to the segment
				} else if (pointMap[x]) {
					segment.push(pointMap[x]);

				// There is no point for this X value in this series, so we 
				// insert a dummy point in order for the areas to be drawn
				// correctly.
				} else {

					// Loop down the stack to find the series below this one that has
					// a value (#1991)
					for (i = series.index; i <= yAxis.series.length; i++) {		
						stackIndicator = series.getStackIndicator(null, x, i);
						stackPoint = stack[x].points[stackIndicator.key];
						if (stackPoint) {
							threshold = stackPoint[1];
							break;
						}
					}

					plotX = xAxis.translate(x);
					plotY = yAxis.getThreshold(threshold);
					segment.push({ 
						y: null, 
						plotX: plotX,
						clientX: plotX, 
						plotY: plotY, 
						yBottom: plotY,
						onMouseOver: noop
					});
				}
			});

			if (segment.length) {
				segments.push(segment);
			}

		} else {
			Series.prototype.getSegments.call(this);
			segments = this.segments;
		}

		this.segments = segments;
	},
	
	/**
	 * Extend the base Series getSegmentPath method by adding the path for the area.
	 * This path is pushed to the series.areaPath property.
	 */
	getSegmentPath: function (segment) {
		
		var segmentPath = Series.prototype.getSegmentPath.call(this, segment), // call base method
			areaSegmentPath = [].concat(segmentPath), // work on a copy for the area path
			i,
			options = this.options,
			segLength = segmentPath.length,
			translatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181
			yBottom;
		
		if (segLength === 3) { // for animation from 1 to two points
			areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
		}
		if (options.stacking && !this.closedStacks) {
			
			// Follow stack back. Todo: implement areaspline. A general solution could be to 
			// reverse the entire graphPath of the previous series, though may be hard with
			// splines and with series with different extremes
			for (i = segment.length - 1; i >= 0; i--) {

				yBottom = pick(segment[i].yBottom, translatedThreshold);
			
				// step line?
				if (i < segment.length - 1 && options.step) {
					areaSegmentPath.push(segment[i + 1].plotX, yBottom);
				}
				
				areaSegmentPath.push(segment[i].plotX, yBottom);
			}

		} else { // follow zero line back
			this.closeSegment(areaSegmentPath, segment, translatedThreshold);
		}
		this.areaPath = this.areaPath.concat(areaSegmentPath);
		return segmentPath;
	},
	
	/**
	 * Extendable method to close the segment path of an area. This is overridden in polar 
	 * charts.
	 */
	closeSegment: function (path, segment, translatedThreshold) {
		path.push(
			L,
			segment[segment.length - 1].plotX,
			translatedThreshold,
			L,
			segment[0].plotX,
			translatedThreshold
		);
	},
	
	/**
	 * Draw the graph and the underlying area. This method calls the Series base
	 * function and adds the area. The areaPath is calculated in the getSegmentPath
	 * method called from Series.prototype.drawGraph.
	 */
	drawGraph: function () {
		
		// Define or reset areaPath
		this.areaPath = [];
		
		// Call the base method
		Series.prototype.drawGraph.apply(this);
		
		// Define local variables
		var series = this,
			areaPath = this.areaPath,
			options = this.options,
			zones = this.zones,
			props = [['area', this.color, options.fillColor]]; // area name, main color, fill color
		
		each(zones, function (threshold, i) {
			props.push(['zoneArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);
		});
		each(props, function (prop) {
			var areaKey = prop[0],
				area = series[areaKey];
				
			// Create or update the area
			if (area) { // update
				area.animate({ d: areaPath });
	
			} else { // create
				series[areaKey] = series.chart.renderer.path(areaPath)
					.attr({
						fill: pick(
							prop[2],
							Color(prop[1]).setOpacity(pick(options.fillOpacity, 0.75)).get()
						),
						zIndex: 0 // #1069
					}).add(series.group);
			}
		});
	},

	drawLegendSymbol: LegendSymbolMixin.drawRectangle
});

seriesTypes.area = AreaSeries;
/**
 * Set the default options for spline
 */
defaultPlotOptions.spline = merge(defaultSeriesOptions);

/**
 * SplineSeries object
 */
var SplineSeries = extendClass(Series, {
	type: 'spline',

	/**
	 * Get the spline segment from a given point's previous neighbour to the given point
	 */
	getPointSpline: function (segment, point, i) {
		var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
			denom = smoothing + 1,
			plotX = point.plotX,
			plotY = point.plotY,
			lastPoint = segment[i - 1],
			nextPoint = segment[i + 1],
			leftContX,
			leftContY,
			rightContX,
			rightContY,
			ret;

		// find control points
		if (lastPoint && nextPoint) {
		
			var lastX = lastPoint.plotX,
				lastY = lastPoint.plotY,
				nextX = nextPoint.plotX,
				nextY = nextPoint.plotY,
				correction;

			leftContX = (smoothing * plotX + lastX) / denom;
			leftContY = (smoothing * plotY + lastY) / denom;
			rightContX = (smoothing * plotX + nextX) / denom;
			rightContY = (smoothing * plotY + nextY) / denom;

			// have the two control points make a straight line through main point
			correction = ((rightContY - leftContY) * (rightContX - plotX)) /
				(rightContX - leftContX) + plotY - rightContY;

			leftContY += correction;
			rightContY += correction;

			// to prevent false extremes, check that control points are between
			// neighbouring points' y values
			if (leftContY > lastY && leftContY > plotY) {
				leftContY = mathMax(lastY, plotY);
				rightContY = 2 * plotY - leftContY; // mirror of left control point
			} else if (leftContY < lastY && leftContY < plotY) {
				leftContY = mathMin(lastY, plotY);
				rightContY = 2 * plotY - leftContY;
			}
			if (rightContY > nextY && rightContY > plotY) {
				rightContY = mathMax(nextY, plotY);
				leftContY = 2 * plotY - rightContY;
			} else if (rightContY < nextY && rightContY < plotY) {
				rightContY = mathMin(nextY, plotY);
				leftContY = 2 * plotY - rightContY;
			}

			// record for drawing in next point
			point.rightContX = rightContX;
			point.rightContY = rightContY;

		}
		
		// Visualize control points for debugging
		/*
		if (leftContX) {
			this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)
				.attr({
					stroke: 'red',
					'stroke-width': 1,
					fill: 'none'
				})
				.add();
			this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,
				'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
				.attr({
					stroke: 'red',
					'stroke-width': 1
				})
				.add();
			this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)
				.attr({
					stroke: 'green',
					'stroke-width': 1,
					fill: 'none'
				})
				.add();
			this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,
				'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
				.attr({
					stroke: 'green',
					'stroke-width': 1
				})
				.add();
		}
		*/

		// moveTo or lineTo
		if (!i) {
			ret = [M, plotX, plotY];
		} else { // curve from last point to this
			ret = [
				'C',
				lastPoint.rightContX || lastPoint.plotX,
				lastPoint.rightContY || lastPoint.plotY,
				leftContX || plotX,
				leftContY || plotY,
				plotX,
				plotY
			];
			lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
		}
		return ret;
	}
});
seriesTypes.spline = SplineSeries;

/**
 * Set the default options for areaspline
 */
defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);

/**
 * AreaSplineSeries object
 */
var areaProto = AreaSeries.prototype,
	AreaSplineSeries = extendClass(SplineSeries, {
		type: 'areaspline',
		closedStacks: true, // instead of following the previous graph back, follow the threshold back
		
		// Mix in methods from the area series
		getSegmentPath: areaProto.getSegmentPath,
		closeSegment: areaProto.closeSegment,
		drawGraph: areaProto.drawGraph,
		drawLegendSymbol: LegendSymbolMixin.drawRectangle
	});

seriesTypes.areaspline = AreaSplineSeries;

/**
 * Set the default options for column
 */
defaultPlotOptions.column = merge(defaultSeriesOptions, {
	borderColor: '#FFFFFF',
	//borderWidth: 1,
	borderRadius: 0,
	//colorByPoint: undefined,
	groupPadding: 0.2,
	//grouping: true,
	marker: null, // point options are specified in the base options
	pointPadding: 0.1,
	//pointWidth: null,
	minPointLength: 0,
	cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes
	pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories
	states: {
		hover: {
			brightness: 0.1,
			shadow: false,
			halo: false
		},
		select: {
			color: '#C0C0C0',
			borderColor: '#000000',
			shadow: false
		}
	},
	dataLabels: {
		align: null, // auto
		verticalAlign: null, // auto
		y: null
	},
	softThreshold: false,
	startFromThreshold: true, // docs (but false doesn't work well): http://jsfiddle.net/highcharts/hz8fopan/14/
	stickyTracking: false,
	tooltip: {
		distance: 6
	},
	threshold: 0
});

/**
 * ColumnSeries object
 */
var ColumnSeries = extendClass(Series, {
	type: 'column',
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'borderColor',
		fill: 'color',
		r: 'borderRadius'
	},
	cropShoulder: 0,
	directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.
	trackerGroups: ['group', 'dataLabelsGroup'],
	negStacks: true, // use separate negative stacks, unlike area stacks where a negative 
		// point is substracted from previous (#1910)
	
	/**
	 * Initialize the series
	 */
	init: function () {
		Series.prototype.init.apply(this, arguments);

		var series = this,
			chart = series.chart;

		// if the series is added dynamically, force redraw of other
		// series affected by a new column
		if (chart.hasRendered) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.type === series.type) {
					otherSeries.isDirty = true;
				}
			});
		}
	},

	/**
	 * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,
	 * pointWidth etc. 
	 */
	getColumnMetrics: function () {

		var series = this,
			options = series.options,
			xAxis = series.xAxis,
			yAxis = series.yAxis,
			reversedXAxis = xAxis.reversed,
			stackKey,
			stackGroups = {},
			columnIndex,
			columnCount = 0;

		// Get the total number of column type series.
		// This is called on every series. Consider moving this logic to a
		// chart.orderStacks() function and call it on init, addSeries and removeSeries
		if (options.grouping === false) {
			columnCount = 1;
		} else {
			each(series.chart.series, function (otherSeries) {
				var otherOptions = otherSeries.options,
					otherYAxis = otherSeries.yAxis;
				if (otherSeries.type === series.type && otherSeries.visible &&
						yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086
					if (otherOptions.stacking) {
						stackKey = otherSeries.stackKey;
						if (stackGroups[stackKey] === UNDEFINED) {
							stackGroups[stackKey] = columnCount++;
						}
						columnIndex = stackGroups[stackKey];
					} else if (otherOptions.grouping !== false) { // #1162
						columnIndex = columnCount++;
					}
					otherSeries.columnIndex = columnIndex;
				}
			});
		}

		var categoryWidth = mathMin(
				mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610
				xAxis.len // #1535
			),
			groupPadding = categoryWidth * options.groupPadding,
			groupWidth = categoryWidth - 2 * groupPadding,
			pointOffsetWidth = groupWidth / columnCount,
			pointWidth = mathMin(
				options.maxPointWidth || xAxis.len,
				pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))
			),
			pointPadding = (pointOffsetWidth - pointWidth) / 2,
			colIndex = (reversedXAxis ? 
				columnCount - (series.columnIndex || 0) : // #1251
				series.columnIndex) || 0,
			pointXOffset = pointPadding + (groupPadding + colIndex *
				pointOffsetWidth - (categoryWidth / 2)) *
				(reversedXAxis ? -1 : 1);

		// Save it for reading in linked series (Error bars particularly)
		return (series.columnMetrics = { 
			width: pointWidth, 
			offset: pointXOffset 
		});
			
	},

	/**
	 * Make the columns crisp. The edges are rounded to the nearest full pixel.
	 */
	crispCol: function (x, y, w, h) {
		var chart = this.chart,
			borderWidth = this.borderWidth,
			xCrisp = -(borderWidth % 2 ? 0.5 : 0),
			yCrisp = borderWidth % 2 ? 0.5 : 1,
			right,
			bottom,
			fromTop;

		if (chart.inverted && chart.renderer.isVML) {
			yCrisp += 1;
		}
		
		// Horizontal. We need to first compute the exact right edge, then round it
		// and compute the width from there.
		right = Math.round(x + w) + xCrisp;
		x = Math.round(x) + xCrisp;
		w = right - x;

		// Vertical
		fromTop = mathAbs(y) <= 0.5; // #4504
		bottom = Math.round(y + h) + yCrisp;
		y = Math.round(y) + yCrisp;
		h = bottom - y;

		// Top edges are exceptions
		if (fromTop) {
			y -= 1;
			h += 1;
		}

		return {
			x: x,
			y: y,
			width: w,
			height: h
		};
	},

	/**
	 * Translate each point to the plot area coordinate system and find shape positions
	 */
	translate: function () {
		var series = this,
			chart = series.chart,
			options = series.options,
			borderWidth = series.borderWidth = pick(
				options.borderWidth, 
				series.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635
			),
			yAxis = series.yAxis,
			threshold = options.threshold,
			translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
			minPointLength = pick(options.minPointLength, 5),
			metrics = series.getColumnMetrics(),
			pointWidth = metrics.width,
			seriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width
			pointXOffset = series.pointXOffset = metrics.offset;

		if (chart.inverted) {
			translatedThreshold -= 0.5; // #3355
		}

		// When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual
		// columns to have individual sizes. When pointPadding is greater, we strive for equal-width
		// columns (#2694).
		if (options.pointPadding) {
			seriesBarW = mathCeil(seriesBarW);
		}

		Series.prototype.translate.apply(series);

		// Record the new values
		each(series.points, function (point) {
			var yBottom = mathMin(pick(point.yBottom, translatedThreshold), 9e4), // #3575
				safeDistance = 999 + mathAbs(yBottom),
				plotY = mathMin(mathMax(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)
				barX = point.plotX + pointXOffset,
				barW = seriesBarW,
				barY = mathMin(plotY, yBottom),
				up,
				barH = mathMax(plotY, yBottom) - barY;

			// Handle options.minPointLength
			if (mathAbs(barH) < minPointLength) {
				if (minPointLength) {
					barH = minPointLength;
					up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);
					barY = mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
							yBottom - minPointLength : // keep position
							translatedThreshold - (up ? minPointLength : 0); // #1485, #4051
				}
			}

			// Cache for access in polar
			point.barX = barX;
			point.pointWidth = pointWidth;

			// Fix the tooltip on center of grouped columns (#1216, #424, #3648)
			point.tooltipPos = chart.inverted ? 
				[yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] : 
				[barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];

			// Register shape type and arguments to be used in drawPoints
			point.shapeType = 'rect';
			point.shapeArgs = series.crispCol(barX, barY, barW, barH);
		});

	},

	getSymbol: noop,
	
	/**
	 * Use a solid rectangle like the area series types
	 */
	drawLegendSymbol: LegendSymbolMixin.drawRectangle,
	
	
	/**
	 * Columns have no graph
	 */
	drawGraph: noop,

	/**
	 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
	 * apply for columns and bars. This method is inherited by scatter series.
	 *
	 */
	drawPoints: function () {
		var series = this,
			chart = this.chart,
			options = series.options,
			renderer = chart.renderer,
			animationLimit = options.animationLimit || 250,
			shapeArgs,
			pointAttr;

		// draw the columns
		each(series.points, function (point) {
			var plotY = point.plotY,
				graphic = point.graphic,
				borderAttr;

			if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
				shapeArgs = point.shapeArgs;

				borderAttr = defined(series.borderWidth) ? {
					'stroke-width': series.borderWidth
				} : {};

				pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];
				
				if (graphic) { // update
					stop(graphic);
					graphic.attr(borderAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs));

				} else {
					point.graphic = graphic = renderer[point.shapeType](shapeArgs)
						.attr(borderAttr)
						.attr(pointAttr)
						.add(point.group || series.group)
						.shadow(options.shadow, null, options.stacking && !options.borderRadius);
				}

			} else if (graphic) {
				point.graphic = graphic.destroy(); // #1269
			}
		});
	},

	/**
	 * Animate the column heights one by one from zero
	 * @param {Boolean} init Whether to initialize the animation or run it
	 */
	animate: function (init) {
		var series = this,
			yAxis = this.yAxis,
			options = series.options,
			inverted = this.chart.inverted,
			attr = {},
			translatedThreshold;

		if (hasSVG) { // VML is too slow anyway
			if (init) {
				attr.scaleY = 0.001;
				translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));
				if (inverted) {
					attr.translateX = translatedThreshold - yAxis.len;
				} else {
					attr.translateY = translatedThreshold;
				}
				series.group.attr(attr);

			} else { // run the animation
				
				attr.scaleY = 1;
				attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;
				series.group.animate(attr, series.options.animation);

				// delete this function to allow it only once
				series.animate = null;
			}
		}
	},
	
	/**
	 * Remove this series from the chart
	 */
	remove: function () {
		var series = this,
			chart = series.chart;

		// column and bar series affects other series of the same type
		// as they are either stacked or grouped
		if (chart.hasRendered) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.type === series.type) {
					otherSeries.isDirty = true;
				}
			});
		}

		Series.prototype.remove.apply(series, arguments);
	}
});
seriesTypes.column = ColumnSeries;
/**
 * Set the default options for bar
 */
defaultPlotOptions.bar = merge(defaultPlotOptions.column);
/**
 * The Bar series class
 */
var BarSeries = extendClass(ColumnSeries, {
	type: 'bar',
	inverted: true
});
seriesTypes.bar = BarSeries;

/**
 * Set the default options for scatter
 */
defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
	lineWidth: 0,
	marker: {
		enabled: true // Overrides auto-enabling in line series (#3647)
	},
	tooltip: {
		headerFormat: '<span style="color:{point.color}">\u25CF</span> <span style="font-size: 10px;"> {series.name}</span><br/>',
		pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
	}
});

/**
 * The scatter series class
 */
var ScatterSeries = extendClass(Series, {
	type: 'scatter',
	sorted: false,
	requireSorting: false,
	noSharedTooltip: true,
	trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
	takeOrdinalPosition: false, // #2342
	kdDimensions: 2,
	drawGraph: function () {
		if (this.options.lineWidth) {
			Series.prototype.drawGraph.call(this);
		}
	}
});

seriesTypes.scatter = ScatterSeries;

/**
 * Set the default options for pie
 */
defaultPlotOptions.pie = merge(defaultSeriesOptions, {
	borderColor: '#FFFFFF',
	borderWidth: 1,
	center: [null, null],
	clip: false,
	colorByPoint: true, // always true for pies
	dataLabels: {
		// align: null,
		// connectorWidth: 1,
		// connectorColor: point.color,
		// connectorPadding: 5,
		distance: 30,
		enabled: true,
		formatter: function () { // #2945
			return this.y === null ? undefined : this.point.name;
		},
		// softConnector: true,
		x: 0
		// y: 0
	},
	ignoreHiddenPoint: true,
	//innerSize: 0,
	legendType: 'point',
	marker: null, // point options are specified in the base options
	size: null,
	showInLegend: false,
	slicedOffset: 10,
	states: {
		hover: {
			brightness: 0.1,
			shadow: false
		}
	},
	stickyTracking: false,
	tooltip: {
		followPointer: true
	}
});

/**
 * Extended point object for pies
 */
var PiePoint = extendClass(Point, {
	/**
	 * Initiate the pie slice
	 */
	init: function () {

		Point.prototype.init.apply(this, arguments);

		var point = this,
			toggleSlice;

		point.name = pick(point.name, 'Slice');

		// add event listener for select
		toggleSlice = function (e) {
			point.slice(e.type === 'select');
		};
		addEvent(point, 'select', toggleSlice);
		addEvent(point, 'unselect', toggleSlice);

		return point;
	},

	/**
	 * Toggle the visibility of the pie slice
	 * @param {Boolean} vis Whether to show the slice or not. If undefined, the
	 *    visibility is toggled
	 */
	setVisible: function (vis, redraw) {
		var point = this,
			series = point.series,
			chart = series.chart,
			ignoreHiddenPoint = series.options.ignoreHiddenPoint;
		
		redraw = pick(redraw, ignoreHiddenPoint);

		if (vis !== point.visible) {

			// If called without an argument, toggle visibility
			point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;
			series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

			// Show and hide associated elements. This is performed regardless of redraw or not,
			// because chart.redraw only handles full series.
			each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {
				if (point[key]) {
					point[key][vis ? 'show' : 'hide'](true);
				}
			});

			if (point.legendItem) {
				chart.legend.colorizeItem(point, vis);
			}

			// #4170, hide halo after hiding point
			if (!vis && point.state === 'hover') {
				point.setState('');
			}
			
			// Handle ignore hidden slices
			if (ignoreHiddenPoint) {
				series.isDirty = true;
			}

			if (redraw) {
				chart.redraw();
			}
		}
	},

	/**
	 * Set or toggle whether the slice is cut out from the pie
	 * @param {Boolean} sliced When undefined, the slice state is toggled
	 * @param {Boolean} redraw Whether to redraw the chart. True by default.
	 */
	slice: function (sliced, redraw, animation) {
		var point = this,
			series = point.series,
			chart = series.chart,
			translation;

		setAnimation(animation, chart);

		// redraw is true by default
		redraw = pick(redraw, true);

		// if called without an argument, toggle
		point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
		series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

		translation = sliced ? point.slicedTranslation : {
			translateX: 0,
			translateY: 0
		};

		point.graphic.animate(translation);
		
		if (point.shadowGroup) {
			point.shadowGroup.animate(translation);
		}

	},

	haloPath: function (size) {
		var shapeArgs = this.shapeArgs,
			chart = this.series.chart;

		return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
			innerR: this.shapeArgs.r,
			start: shapeArgs.start,
			end: shapeArgs.end
		});
	}
});

/**
 * The Pie series class
 */
var PieSeries = {
	type: 'pie',
	isCartesian: false,
	pointClass: PiePoint,
	requireSorting: false,
	directTouch: true,
	noSharedTooltip: true,
	trackerGroups: ['group', 'dataLabelsGroup'],
	axisTypes: [],
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'borderColor',
		'stroke-width': 'borderWidth',
		fill: 'color'
	},

	/**
	 * Animate the pies in
	 */
	animate: function (init) {
		var series = this,
			points = series.points,
			startAngleRad = series.startAngleRad;

		if (!init) {
			each(points, function (point) {
				var graphic = point.graphic,
					args = point.shapeArgs;

				if (graphic) {
					// start values
					graphic.attr({
						r: point.startR || (series.center[3] / 2), // animate from inner radius (#779)
						start: startAngleRad,
						end: startAngleRad
					});

					// animate
					graphic.animate({
						r: args.r,
						start: args.start,
						end: args.end
					}, series.options.animation);
				}
			});

			// delete this function to allow it only once
			series.animate = null;
		}
	},

	/**
	 * Recompute total chart sum and update percentages of points.
	 */
	updateTotals: function () {
		var i,
			total = 0,
			points = this.points,
			len = points.length,
			point,
			ignoreHiddenPoint = this.options.ignoreHiddenPoint;

		// Get the total sum
		for (i = 0; i < len; i++) {
			point = points[i];
			total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;
		}
		this.total = total;

		// Set each point's properties
		for (i = 0; i < len; i++) {
			point = points[i];
			point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;
			point.total = total;
		}
	},

	/**
	 * Extend the generatePoints method by adding total and percentage properties to each point
	 */
	generatePoints: function () {
		Series.prototype.generatePoints.call(this);
		this.updateTotals();
	},
	
	/**
	 * Do translation for pie slices
	 */
	translate: function (positions) {
		this.generatePoints();
		
		var series = this,
			cumulative = 0,
			precision = 1000, // issue #172
			options = series.options,
			slicedOffset = options.slicedOffset,
			connectorOffset = slicedOffset + options.borderWidth,
			start,
			end,
			angle,
			startAngle = options.startAngle || 0,
			startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),
			endAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),
			circ = endAngleRad - startAngleRad, //2 * mathPI,
			points = series.points,
			radiusX, // the x component of the radius vector for a given point
			radiusY,
			labelDistance = options.dataLabels.distance,
			ignoreHiddenPoint = options.ignoreHiddenPoint,
			i,
			len = points.length,
			point;

		// Get positions - either an integer or a percentage string must be given.
		// If positions are passed as a parameter, we're in a recursive loop for adjusting
		// space for data labels.
		if (!positions) {
			series.center = positions = series.getCenter();
		}

		// utility for getting the x value from a given y, used for anticollision logic in data labels
		series.getX = function (y, left) {

			angle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));

			return positions[0] +
				(left ? -1 : 1) *
				(mathCos(angle) * (positions[2] / 2 + labelDistance));
		};

		// Calculate the geometry for each point
		for (i = 0; i < len; i++) {
			
			point = points[i];
			
			// set start and end angle
			start = startAngleRad + (cumulative * circ);
			if (!ignoreHiddenPoint || point.visible) {
				cumulative += point.percentage / 100;
			}
			end = startAngleRad + (cumulative * circ);

			// set the shape
			point.shapeType = 'arc';
			point.shapeArgs = {
				x: positions[0],
				y: positions[1],
				r: positions[2] / 2,
				innerR: positions[3] / 2,
				start: mathRound(start * precision) / precision,
				end: mathRound(end * precision) / precision
			};

			// The angle must stay within -90 and 270 (#2645)
			angle = (end + start) / 2;
			if (angle > 1.5 * mathPI) {
				angle -= 2 * mathPI;
			} else if (angle < -mathPI / 2) {
				angle += 2 * mathPI;
			}

			// Center for the sliced out slice
			point.slicedTranslation = {
				translateX: mathRound(mathCos(angle) * slicedOffset),
				translateY: mathRound(mathSin(angle) * slicedOffset)
			};

			// set the anchor point for tooltips
			radiusX = mathCos(angle) * positions[2] / 2;
			radiusY = mathSin(angle) * positions[2] / 2;
			point.tooltipPos = [
				positions[0] + radiusX * 0.7,
				positions[1] + radiusY * 0.7
			];
			
			point.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;
			point.angle = angle;

			// set the anchor point for data labels
			connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678
			point.labelPos = [
				positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
				positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
				positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
				positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
				positions[0] + radiusX, // landing point for connector
				positions[1] + radiusY, // a/a
				labelDistance < 0 ? // alignment
					'center' :
					point.half ? 'right' : 'left', // alignment
				angle // center angle
			];

		}
	},
	
	drawGraph: null,

	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,
			chart = series.chart,
			renderer = chart.renderer,
			groupTranslation,
			//center,
			graphic,
			//group,
			shadow = series.options.shadow,
			shadowGroup,
			shapeArgs,
			attr;

		if (shadow && !series.shadowGroup) {
			series.shadowGroup = renderer.g('shadow')
				.add(series.group);
		}

		// draw the slices
		each(series.points, function (point) {
			if (point.y !== null) {
				graphic = point.graphic;
				shapeArgs = point.shapeArgs;
				shadowGroup = point.shadowGroup;

				// put the shadow behind all points
				if (shadow && !shadowGroup) {
					shadowGroup = point.shadowGroup = renderer.g('shadow')
						.add(series.shadowGroup);
				}

				// if the point is sliced, use special translation, else use plot area traslation
				groupTranslation = point.sliced ? point.slicedTranslation : {
					translateX: 0,
					translateY: 0
				};

				//group.translate(groupTranslation[0], groupTranslation[1]);
				if (shadowGroup) {
					shadowGroup.attr(groupTranslation);
				}

				// draw the slice
				if (graphic) {
					graphic
						.setRadialReference(series.center)
						.animate(extend(shapeArgs, groupTranslation));				
				} else {
					attr = { 'stroke-linejoin': 'round' };
					if (!point.visible) {
						attr.visibility = 'hidden';
					}

					point.graphic = graphic = renderer[point.shapeType](shapeArgs)
						.setRadialReference(series.center)
						.attr(
							point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]
						)
						.attr(attr)
						.attr(groupTranslation)
						.add(series.group)
						.shadow(shadow, shadowGroup);	
				}
			}
		});

	},


	searchPoint: noop,

	/**
	 * Utility for sorting data labels
	 */
	sortByAngle: function (points, sign) {
		points.sort(function (a, b) {
			return a.angle !== undefined && (b.angle - a.angle) * sign;
		});
	},		

	/**
	 * Use a simple symbol from LegendSymbolMixin
	 */
	drawLegendSymbol: LegendSymbolMixin.drawRectangle,

	/**
	 * Use the getCenter method from drawLegendSymbol
	 */
	getCenter: CenteredSeriesMixin.getCenter,

	/**
	 * Pies don't have point marker symbols
	 */
	getSymbol: noop

};
PieSeries = extendClass(Series, PieSeries);
seriesTypes.pie = PieSeries;

/**
 * Draw the data labels
 */
Series.prototype.drawDataLabels = function () {

	var series = this,
		seriesOptions = series.options,
		cursor = seriesOptions.cursor,
		options = seriesOptions.dataLabels,
		points = series.points,
		pointOptions,
		generalOptions,
		hasRendered = series.hasRendered || 0,
		str,
		dataLabelsGroup,
		renderer = series.chart.renderer;

	if (options.enabled || series._hasPointLabels) {

		// Process default alignment of data labels for columns
		if (series.dlProcessOptions) {
			series.dlProcessOptions(options);
		}

		// Create a separate group for the data labels to avoid rotation
		dataLabelsGroup = series.plotGroup(
			'dataLabelsGroup',
			'data-labels',
			options.defer ? HIDDEN : VISIBLE,
			options.zIndex || 6
		);

		if (pick(options.defer, true)) {
			dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300
			if (!hasRendered) {
				addEvent(series, 'afterAnimate', function () {
					if (series.visible) { // #3023, #3024
						dataLabelsGroup.show();
					}
					dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });
				});
			}
		}

		// Make the labels for each point
		generalOptions = options;
		each(points, function (point) {

			var enabled,
				dataLabel = point.dataLabel,
				labelConfig,
				attr,
				name,
				rotation,
				connector = point.connector,
				isNew = true,
				style,
				moreStyle = {};

			// Determine if each data label is enabled
			pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps
			enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled); // #2282


			// If the point is outside the plot area, destroy it. #678, #820
			if (dataLabel && !enabled) {
				point.dataLabel = dataLabel.destroy();

			// Individual labels are disabled if the are explicitly disabled
			// in the point options, or if they fall outside the plot area.
			} else if (enabled) {

				// Create individual options structure that can be extended without
				// affecting others
				options = merge(generalOptions, pointOptions);
				style = options.style;

				rotation = options.rotation;

				// Get the string
				labelConfig = point.getLabelConfig();
				str = options.format ?
					format(options.format, labelConfig) :
					options.formatter.call(labelConfig, options);

				// Determine the color
				style.color = pick(options.color, style.color, series.color, 'black');


				// update existing label
				if (dataLabel) {

					if (defined(str)) {
						dataLabel
							.attr({
								text: str
							});
						isNew = false;

					} else { // #1437 - the label is shown conditionally
						point.dataLabel = dataLabel = dataLabel.destroy();
						if (connector) {
							point.connector = connector.destroy();
						}
					}

				// create new label
				} else if (defined(str)) {
					attr = {
						//align: align,
						fill: options.backgroundColor,
						stroke: options.borderColor,
						'stroke-width': options.borderWidth,
						r: options.borderRadius || 0,
						rotation: rotation,
						padding: options.padding,
						zIndex: 1
					};
					
					// Get automated contrast color
					if (style.color === 'contrast') {
						moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ? 
							renderer.getContrast(point.color || series.color) : 
							'#000000';
					}
					if (cursor) {
						moreStyle.cursor = cursor;
					}
					

					// Remove unused attributes (#947)
					for (name in attr) {
						if (attr[name] === UNDEFINED) {
							delete attr[name];
						}
					}

					dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation
						str,
						0,
						-999,
						options.shape,
						null,
						null,
						options.useHTML
					)
					.attr(attr)
					.css(extend(style, moreStyle))
					.add(dataLabelsGroup)
					.shadow(options.shadow);

				}

				if (dataLabel) {
					// Now the data label is created and placed at 0,0, so we need to align it
					series.alignDataLabel(point, dataLabel, options, null, isNew);
				}
			}
		});
	}
};

/**
 * Align each individual data label
 */
Series.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {
	var chart = this.chart,
		inverted = chart.inverted,
		plotX = pick(point.plotX, -999),
		plotY = pick(point.plotY, -999),
		bBox = dataLabel.getBBox(),
		baseline = chart.renderer.fontMetrics(options.style.fontSize).b,
		rotCorr, // rotation correction
		// Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)
		visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||
			(alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),
		alignAttr; // the final position;

	if (visible) {

		// The alignment box is a singular point
		alignTo = extend({
			x: inverted ? chart.plotWidth - plotY : plotX,
			y: mathRound(inverted ? chart.plotHeight - plotX : plotY),
			width: 0,
			height: 0
		}, alignTo);

		// Add the text size for alignment calculation
		extend(options, {
			width: bBox.width,
			height: bBox.height
		});

		// Allow a hook for changing alignment in the last moment, then do the alignment
		if (options.rotation) { // Fancy box alignment isn't supported for rotated text
			rotCorr = chart.renderer.rotCorr(baseline, options.rotation); // #3723
			dataLabel[isNew ? 'attr' : 'animate']({
					x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
					y: alignTo.y + options.y + alignTo.height / 2
				})
				.attr({ // #3003
					align: options.align
				});
		} else {
			dataLabel.align(options, null, alignTo);
			alignAttr = dataLabel.alignAttr;

			// Handle justify or crop
			if (pick(options.overflow, 'justify') === 'justify') {
				this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);

			} else if (pick(options.crop, true)) {
				// Now check that the data label is within the plot area
				visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);

			}

			// When we're using a shape, make it possible with a connector or an arrow pointing to thie point
			if (options.shape) {
				dataLabel.attr({
					anchorX: point.plotX,
					anchorY: point.plotY
				});
			}

		}
	}

	// Show or hide based on the final aligned position
	if (!visible) {
		stop(dataLabel);
		dataLabel.attr({ y: -999 });
		dataLabel.placed = false; // don't animate back in
	}

};

/**
 * If data labels fall partly outside the plot area, align them back in, in a way that
 * doesn't hide the point.
 */
Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {
	var chart = this.chart,
		align = options.align,
		verticalAlign = options.verticalAlign,
		off,
		justified,
		padding = dataLabel.box ? 0 : (dataLabel.padding || 0);

	// Off left
	off = alignAttr.x + padding;
	if (off < 0) {
		if (align === 'right') {
			options.align = 'left';
		} else {
			options.x = -off;
		}
		justified = true;
	}

	// Off right
	off = alignAttr.x + bBox.width - padding;
	if (off > chart.plotWidth) {
		if (align === 'left') {
			options.align = 'right';
		} else {
			options.x = chart.plotWidth - off;
		}
		justified = true;
	}

	// Off top
	off = alignAttr.y + padding;
	if (off < 0) {
		if (verticalAlign === 'bottom') {
			options.verticalAlign = 'top';
		} else {
			options.y = -off;
		}
		justified = true;
	}

	// Off bottom
	off = alignAttr.y + bBox.height - padding;
	if (off > chart.plotHeight) {
		if (verticalAlign === 'top') {
			options.verticalAlign = 'bottom';
		} else {
			options.y = chart.plotHeight - off;
		}
		justified = true;
	}

	if (justified) {
		dataLabel.placed = !isNew;
		dataLabel.align(options, null, alignTo);
	}
};

/**
 * Override the base drawDataLabels method by pie specific functionality
 */
if (seriesTypes.pie) {
	seriesTypes.pie.prototype.drawDataLabels = function () {
		var series = this,
			data = series.data,
			point,
			chart = series.chart,
			options = series.options.dataLabels,
			connectorPadding = pick(options.connectorPadding, 10),
			connectorWidth = pick(options.connectorWidth, 1),
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			connector,
			connectorPath,
			softConnector = pick(options.softConnector, true),
			distanceOption = options.distance,
			seriesCenter = series.center,
			radius = seriesCenter[2] / 2,
			centerY = seriesCenter[1],
			outside = distanceOption > 0,
			dataLabel,
			dataLabelWidth,
			labelPos,
			labelHeight,
			halves = [// divide the points into right and left halves for anti collision
				[], // right
				[]  // left
			],
			x,
			y,
			visibility,
			rankArr,
			i,
			j,
			overflow = [0, 0, 0, 0], // top, right, bottom, left
			sort = function (a, b) {
				return b.y - a.y;
			};

		// get out if not enabled
		if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
			return;
		}

		// run parent method
		Series.prototype.drawDataLabels.apply(series);

		// arrange points for detection collision
		each(data, function (point) {
			if (point.dataLabel && point.visible) { // #407, #2510
				halves[point.half].push(point);
			}
		});

		/* Loop over the points in each half, starting from the top and bottom
		 * of the pie to detect overlapping labels.
		 */
		i = 2;
		while (i--) {

			var slots = [],
				slotsLength,
				usedSlots = [],
				points = halves[i],
				pos,
				bottom,
				length = points.length,
				slotIndex;

			if (!length) {
				continue;
			}

			// Sort by angle
			series.sortByAngle(points, i - 0.5);

			// Assume equal label heights on either hemisphere (#2630)
			j = labelHeight = 0;
			while (!labelHeight && points[j]) { // #1569
				labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968
				j++;
			}

			// Only do anti-collision when we are outside the pie and have connectors (#856)
			if (distanceOption > 0) {

				// Build the slots
				bottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);
				for (pos = mathMax(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {
					slots.push(pos);
				}
				slotsLength = slots.length;


				/* Visualize the slots
				if (!series.slotElements) {
					series.slotElements = [];
				}
				if (i === 1) {
					series.slotElements.forEach(function (elem) {
						elem.destroy();
					});
					series.slotElements.length = 0;
				}
					
				slots.forEach(function (pos, no) {
					var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
						slotY = pos + chart.plotTop;
					
					if (!isNaN(slotX)) {
						series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)
							.attr({
								'stroke-width': 1,
								stroke: 'silver',
								fill: 'rgba(0,0,255,0.1)'
							})
							.add());
						series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)
							.attr({
								fill: 'silver'
							}).add());
					}
				});
				// */

				// if there are more values than available slots, remove lowest values
				if (length > slotsLength) {
					// create an array for sorting and ranking the points within each quarter
					rankArr = [].concat(points);
					rankArr.sort(sort);
					j = length;
					while (j--) {
						rankArr[j].rank = j;
					}
					j = length;
					while (j--) {
						if (points[j].rank >= slotsLength) {
							points.splice(j, 1);
						}
					}
					length = points.length;
				}

				// The label goes to the nearest open slot, but not closer to the edge than
				// the label's index.
				for (j = 0; j < length; j++) {

					point = points[j];
					labelPos = point.labelPos;

					var closest = 9999,
						distance,
						slotI;

					// find the closest slot index
					for (slotI = 0; slotI < slotsLength; slotI++) {
						distance = mathAbs(slots[slotI] - labelPos[1]);
						if (distance < closest) {
							closest = distance;
							slotIndex = slotI;
						}
					}

					// if that slot index is closer to the edges of the slots, move it
					// to the closest appropriate slot
					if (slotIndex < j && slots[j] !== null) { // cluster at the top
						slotIndex = j;
					} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom
						slotIndex = slotsLength - length + j;
						while (slots[slotIndex] === null) { // make sure it is not taken
							slotIndex++;
						}
					} else {
						// Slot is taken, find next free slot below. In the next run, the next slice will find the
						// slot above these, because it is the closest one
						while (slots[slotIndex] === null) { // make sure it is not taken
							slotIndex++;
						}
					}

					usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
					slots[slotIndex] = null; // mark as taken
				}
				// sort them in order to fill in from the top
				usedSlots.sort(sort);
			}

			// now the used slots are sorted, fill them up sequentially
			for (j = 0; j < length; j++) {

				var slot, naturalY;

				point = points[j];
				labelPos = point.labelPos;
				dataLabel = point.dataLabel;
				visibility = point.visible === false ? HIDDEN : 'inherit';
				naturalY = labelPos[1];

				if (distanceOption > 0) {
					slot = usedSlots.pop();
					slotIndex = slot.i;

					// if the slot next to currrent slot is free, the y value is allowed
					// to fall back to the natural position
					y = slot.y;
					if ((naturalY > y && slots[slotIndex + 1] !== null) ||
							(naturalY < y &&  slots[slotIndex - 1] !== null)) {
						y = mathMin(mathMax(0, naturalY), chart.plotHeight);
					}

				} else {
					y = naturalY;
				}

				// get the x - use the natural x position for first and last slot, to prevent the top
				// and botton slice connectors from touching each other on either side
				x = options.justify ?
					seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :
					series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);


				// Record the placement and visibility
				dataLabel._attr = {
					visibility: visibility,
					align: labelPos[6]
				};
				dataLabel._pos = {
					x: x + options.x +
						({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
					y: y + options.y - 10 // 10 is for the baseline (label vs text)
				};
				dataLabel.connX = x;
				dataLabel.connY = y;


				// Detect overflowing data labels
				if (this.options.size === null) {
					dataLabelWidth = dataLabel.width;
					// Overflow left
					if (x - dataLabelWidth < connectorPadding) {
						overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);

					// Overflow right
					} else if (x + dataLabelWidth > plotWidth - connectorPadding) {
						overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
					}

					// Overflow top
					if (y - labelHeight / 2 < 0) {
						overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);

					// Overflow left
					} else if (y + labelHeight / 2 > plotHeight) {
						overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);
					}
				}
			} // for each point
		} // for each half

		// Do not apply the final placement and draw the connectors until we have verified
		// that labels are not spilling over.
		if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {

			// Place the labels in the final position
			this.placeDataLabels();

			// Draw the connectors
			if (outside && connectorWidth) {
				each(this.points, function (point) {
					connector = point.connector;
					labelPos = point.labelPos;
					dataLabel = point.dataLabel;

					if (dataLabel && dataLabel._pos && point.visible) {
						visibility = dataLabel._attr.visibility;
						x = dataLabel.connX;
						y = dataLabel.connY;
						connectorPath = softConnector ? [
							M,
							x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
							'C',
							x, y, // first break, next to the label
							2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
							labelPos[2], labelPos[3], // second break
							L,
							labelPos[4], labelPos[5] // base
						] : [
							M,
							x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
							L,
							labelPos[2], labelPos[3], // second break
							L,
							labelPos[4], labelPos[5] // base
						];

						if (connector) {
							connector.animate({ d: connectorPath });
							connector.attr('visibility', visibility);

						} else {
							point.connector = connector = series.chart.renderer.path(connectorPath).attr({
								'stroke-width': connectorWidth,
								stroke: options.connectorColor || point.color || '#606060',
								visibility: visibility
								//zIndex: 0 // #2722 (reversed)
							})
							.add(series.dataLabelsGroup);
						}
					} else if (connector) {
						point.connector = connector.destroy();
					}
				});
			}
		}
	};
	/**
	 * Perform the final placement of the data labels after we have verified that they
	 * fall within the plot area.
	 */
	seriesTypes.pie.prototype.placeDataLabels = function () {
		each(this.points, function (point) {
			var dataLabel = point.dataLabel,
				_pos;

			if (dataLabel && point.visible) {
				_pos = dataLabel._pos;
				if (_pos) {
					dataLabel.attr(dataLabel._attr);
					dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
					dataLabel.moved = true;
				} else if (dataLabel) {
					dataLabel.attr({ y: -999 });
				}
			}
		});
	};

	seriesTypes.pie.prototype.alignDataLabel =  noop;

	/**
	 * Verify whether the data labels are allowed to draw, or we should run more translation and data
	 * label positioning to keep them inside the plot area. Returns true when data labels are ready
	 * to draw.
	 */
	seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {

		var center = this.center,
			options = this.options,
			centerOption = options.center,
			minSize = options.minSize || 80,
			newSize = minSize,
			ret;

		// Handle horizontal size and center
		if (centerOption[0] !== null) { // Fixed center
			newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);

		} else { // Auto center
			newSize = mathMax(
				center[2] - overflow[1] - overflow[3], // horizontal overflow
				minSize
			);
			center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center
		}

		// Handle vertical size and center
		if (centerOption[1] !== null) { // Fixed center
			newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);

		} else { // Auto center
			newSize = mathMax(
				mathMin(
					newSize,
					center[2] - overflow[0] - overflow[2] // vertical overflow
				),
				minSize
			);
			center[1] += (overflow[0] - overflow[2]) / 2; // vertical center
		}

		// If the size must be decreased, we need to run translate and drawDataLabels again
		if (newSize < center[2]) {
			center[2] = newSize;
			center[3] = Math.min(relativeLength(options.innerSize || 0, newSize), newSize); // #3632
			this.translate(center);
			each(this.points, function (point) {
				if (point.dataLabel) {
					point.dataLabel._pos = null; // reset
				}
			});

			if (this.drawDataLabels) {
				this.drawDataLabels();
			}
		// Else, return true to indicate that the pie and its labels is within the plot area
		} else {
			ret = true;
		}
		return ret;
	};
}

if (seriesTypes.column) {

	/**
	 * Override the basic data label alignment by adjusting for the position of the column
	 */
	seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {
		var inverted = this.chart.inverted,
			series = point.series,
			dlBox = point.dlBox || point.shapeArgs, // data label box for alignment
			below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series
			inside = pick(options.inside, !!this.options.stacking); // draw it inside the box?

		// Align to the column itself, or the top of it
		if (dlBox) { // Area range uses this method but not alignTo
			alignTo = merge(dlBox);

			if (inverted) {
				alignTo = {
					x: series.yAxis.len - alignTo.y - alignTo.height,
					y: series.xAxis.len - alignTo.x - alignTo.width,
					width: alignTo.height,
					height: alignTo.width
				};
			}

			// Compute the alignment box
			if (!inside) {
				if (inverted) {
					alignTo.x += below ? 0 : alignTo.width;
					alignTo.width = 0;
				} else {
					alignTo.y += below ? alignTo.height : 0;
					alignTo.height = 0;
				}
			}
		}


		// When alignment is undefined (typically columns and bars), display the individual
		// point below or above the point depending on the threshold
		options.align = pick(
			options.align,
			!inverted || inside ? 'center' : below ? 'right' : 'left'
		);
		options.verticalAlign = pick(
			options.verticalAlign,
			inverted || inside ? 'middle' : below ? 'top' : 'bottom'
		);

		// Call the parent method
		Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
	};
}



/**
 * Highcharts JS v4.1.9 (2015-10-07)
 * Highcharts module to hide overlapping data labels. This module is included by default in Highmaps.
 *
 * (c) 2010-2014 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

/*global Highcharts, HighchartsAdapter */
(function (H) {
	var Chart = H.Chart,
		each = H.each,
		pick = H.pick,
		addEvent = HighchartsAdapter.addEvent;

	// Collect potensial overlapping data labels. Stack labels probably don't need to be 
	// considered because they are usually accompanied by data labels that lie inside the columns.
	Chart.prototype.callbacks.push(function (chart) {
		function collectAndHide() {
			var labels = [];

			each(chart.series, function (series) {
				var dlOptions = series.options.dataLabels,
					collections = series.dataLabelCollections || ['dataLabel']; // Range series have two collections
				if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866
					each(collections, function (coll) {
						each(series.points, function (point) {
							if (point[coll]) {
								point[coll].labelrank = pick(point.labelrank, point.shapeArgs && point.shapeArgs.height); // #4118
								labels.push(point[coll]);
							}
						});
					});
				}
			});
			chart.hideOverlappingLabels(labels);
		}

		// Do it now ...
		collectAndHide();

		// ... and after each chart redraw
		addEvent(chart, 'redraw', collectAndHide);

	});

	/**
	 * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth 
	 * visual imression.
	 */		
	Chart.prototype.hideOverlappingLabels = function (labels) {

		var len = labels.length,
			label,
			i,
			j,
			label1,
			label2,
			isIntersecting,
			pos1,
			pos2,
			padding,
			intersectRect = function (x1, y1, w1, h1, x2, y2, w2, h2) {
				return !(
					x2 > x1 + w1 ||
					x2 + w2 < x1 ||
					y2 > y1 + h1 ||
					y2 + h2 < y1
				);
			};
	
		// Mark with initial opacity
		for (i = 0; i < len; i++) {
			label = labels[i];
			if (label) {
				label.oldOpacity = label.opacity;
				label.newOpacity = 1;
			}
		}

		// Prevent a situation in a gradually rising slope, that each label
		// will hide the previous one because the previous one always has
		// lower rank.
		labels.sort(function (a, b) {
			return (b.labelrank || 0) - (a.labelrank || 0);
		});

		// Detect overlapping labels
		for (i = 0; i < len; i++) {
			label1 = labels[i];

			for (j = i + 1; j < len; ++j) {
				label2 = labels[j];
				if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0) {
					pos1 = label1.alignAttr;
					pos2 = label2.alignAttr;
					padding = 2 * (label1.box ? 0 : label1.padding); // Substract the padding if no background or border (#4333)
					isIntersecting = intersectRect(
						pos1.x,
						pos1.y,
						label1.width - padding,
						label1.height - padding,
						pos2.x,
						pos2.y,
						label2.width - padding,
						label2.height - padding
					);

					if (isIntersecting) {
						(label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
					}
				}
			}
		}

		// Hide or show
		each(labels, function (label) {
			var complete,
				newOpacity;

			if (label) {
				newOpacity = label.newOpacity;

				if (label.oldOpacity !== newOpacity && label.placed) {

					// Make sure the label is completely hidden to avoid catching clicks (#4362)
					if (newOpacity) {
						label.show(true);
					} else {
						complete = function () {
							label.hide();
						};
					}

					// Animate or set the opacity					
					label.alignAttr.opacity = newOpacity;
					label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);
					
				}
				label.isOld = true;
			}
		});
	};

}(Highcharts));/**
 * TrackerMixin for points and graphs
 */

var TrackerMixin = Highcharts.TrackerMixin = {

	drawTrackerPoint: function () {
		var series = this,
			chart = series.chart,
			pointer = chart.pointer,
			cursor = series.options.cursor,
			css = cursor && { cursor: cursor },
			onMouseOver = function (e) {
				var target = e.target,
				point;

				while (target && !point) {
					point = target.point;
					target = target.parentNode;
				}

				if (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart
					point.onMouseOver(e);
				}
			};

		// Add reference to the point
		each(series.points, function (point) {
			if (point.graphic) {
				point.graphic.element.point = point;
			}
			if (point.dataLabel) {
				point.dataLabel.element.point = point;
			}
		});

		// Add the event listeners, we need to do this only once
		if (!series._hasTracking) {
			each(series.trackerGroups, function (key) {
				if (series[key]) { // we don't always have dataLabelsGroup
					series[key]
						.addClass(PREFIX + 'tracker')
						.on('mouseover', onMouseOver)
						.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
						.css(css);
					if (hasTouch) {
						series[key].on('touchstart', onMouseOver);
					}
				}
			});
			series._hasTracking = true;
		}
	},

	/**
	 * Draw the tracker object that sits above all data labels and markers to
	 * track mouse events on the graph or points. For the line type charts
	 * the tracker uses the same graphPath, but with a greater stroke width
	 * for better control.
	 */
	drawTrackerGraph: function () {
		var series = this,
			options = series.options,
			trackByArea = options.trackByArea,
			trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
			trackerPathLength = trackerPath.length,
			chart = series.chart,
			pointer = chart.pointer,
			renderer = chart.renderer,
			snap = chart.options.tooltip.snap,
			tracker = series.tracker,
			cursor = options.cursor,
			css = cursor && { cursor: cursor },
			singlePoints = series.singlePoints,
			singlePoint,
			i,
			onMouseOver = function () {
				if (chart.hoverSeries !== series) {
					series.onMouseOver();
				}
			},
			/*
			 * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable
			 * IE6: 0.002
			 * IE7: 0.002
			 * IE8: 0.002
			 * IE9: 0.00000000001 (unlimited)
			 * IE10: 0.0001 (exporting only)
			 * FF: 0.00000000001 (unlimited)
			 * Chrome: 0.000001
			 * Safari: 0.000001
			 * Opera: 0.00000000001 (unlimited)
			 */
			TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';

		// Extend end points. A better way would be to use round linecaps,
		// but those are not clickable in VML.
		if (trackerPathLength && !trackByArea) {
			i = trackerPathLength + 1;
			while (i--) {
				if (trackerPath[i] === M) { // extend left side
					trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
				}
				if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
					trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
				}
			}
		}

		// handle single points
		for (i = 0; i < singlePoints.length; i++) {
			singlePoint = singlePoints[i];
			trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
			L, singlePoint.plotX + snap, singlePoint.plotY);
		}

		// draw the tracker
		if (tracker) {
			tracker.attr({ d: trackerPath });
		} else { // create

			series.tracker = renderer.path(trackerPath)
			.attr({
				'stroke-linejoin': 'round', // #1225
				visibility: series.visible ? VISIBLE : HIDDEN,
				stroke: TRACKER_FILL,
				fill: trackByArea ? TRACKER_FILL : NONE,
				'stroke-width' : options.lineWidth + (trackByArea ? 0 : 2 * snap),
				zIndex: 2
			})
			.add(series.group);

			// The tracker is added to the series group, which is clipped, but is covered
			// by the marker group. So the marker group also needs to capture events.
			each([series.tracker, series.markerGroup], function (tracker) {
				tracker.addClass(PREFIX + 'tracker')
					.on('mouseover', onMouseOver)
					.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
					.css(css);

				if (hasTouch) {
					tracker.on('touchstart', onMouseOver);
				}
			});
		}
	}
};
/* End TrackerMixin */


/**
 * Add tracking event listener to the series group, so the point graphics
 * themselves act as trackers
 */ 

if (seriesTypes.column) {
	ColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;	
}

if (seriesTypes.pie) {
	seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
}

if (seriesTypes.scatter) {
	ScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
}

/* 
 * Extend Legend for item events 
 */ 
extend(Legend.prototype, {

	setItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {
	var legend = this;
	// Set the events on the item group, or in case of useHTML, the item itself (#1249)
	(useHTML ? legendItem : item.legendGroup).on('mouseover', function () {
			item.setState(HOVER_STATE);
			legendItem.css(legend.options.itemHoverStyle);
		})
		.on('mouseout', function () {
			legendItem.css(item.visible ? itemStyle : itemHiddenStyle);
			item.setState();
		})
		.on('click', function (event) {
			var strLegendItemClick = 'legendItemClick',
				fnLegendItemClick = function () {
					if (item.setVisible) {
						item.setVisible();
					}
				};
				
			// Pass over the click/touch event. #4.
			event = {
				browserEvent: event
			};

			// click the name or symbol
			if (item.firePointEvent) { // point
				item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
			} else {
				fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
			}
		});
	},

	createCheckboxForItem: function (item) {
		var legend = this;

		item.checkbox = createElement('input', {
			type: 'checkbox',
			checked: item.selected,
			defaultChecked: item.selected // required by IE7
		}, legend.options.itemCheckboxStyle, legend.chart.container);

		addEvent(item.checkbox, 'click', function (event) {
			var target = event.target;
			fireEvent(item.series || item, 'checkboxClick', { // #3712
					checked: target.checked,
					item: item
				},
				function () {
					item.select();
				}
			);
		});
	}	
});

/* 
 * Add pointer cursor to legend itemstyle in defaultOptions
 */
defaultOptions.legend.itemStyle.cursor = 'pointer';


/* 
 * Extend the Chart object with interaction
 */

extend(Chart.prototype, {
	/**
	 * Display the zoom button
	 */
	showResetZoom: function () {
		var chart = this,
			lang = defaultOptions.lang,
			btnOptions = chart.options.chart.resetZoomButton,
			theme = btnOptions.theme,
			states = theme.states,
			alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';
			
		this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function () { chart.zoomOut(); }, theme, states && states.hover)
			.attr({
				align: btnOptions.position.align,
				title: lang.resetZoomTitle
			})
			.add()
			.align(btnOptions.position, false, alignTo);
			
	},

	/**
	 * Zoom out to 1:1
	 */
	zoomOut: function () {
		var chart = this;
		fireEvent(chart, 'selection', { resetSelection: true }, function () { 
			chart.zoom();
		});
	},

	/**
	 * Zoom into a given portion of the chart given by axis coordinates
	 * @param {Object} event
	 */
	zoom: function (event) {
		var chart = this,
			hasZoomed,
			pointer = chart.pointer,
			displayButton = false,
			resetZoomButton;

		// If zoom is called with no arguments, reset the axes
		if (!event || event.resetSelection) {
			each(chart.axes, function (axis) {
				hasZoomed = axis.zoom();
			});
		} else { // else, zoom in on all axes
			each(event.xAxis.concat(event.yAxis), function (axisData) {
				var axis = axisData.axis,
					isXAxis = axis.isXAxis;

				// don't zoom more than minRange
				if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {
					hasZoomed = axis.zoom(axisData.min, axisData.max);
					if (axis.displayBtn) {
						displayButton = true;
					}
				}
			});
		}
		
		// Show or hide the Reset zoom button
		resetZoomButton = chart.resetZoomButton;
		if (displayButton && !resetZoomButton) {
			chart.showResetZoom();
		} else if (!displayButton && isObject(resetZoomButton)) {
			chart.resetZoomButton = resetZoomButton.destroy();
		}
		

		// Redraw
		if (hasZoomed) {
			chart.redraw(
				pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation
			);
		}
	},

	/**
	 * Pan the chart by dragging the mouse across the pane. This function is called
	 * on mouse move, and the distance to pan is computed from chartX compared to
	 * the first chartX position in the dragging operation.
	 */
	pan: function (e, panning) {

		var chart = this,
			hoverPoints = chart.hoverPoints,
			doRedraw;

		// remove active points for shared tooltip
		if (hoverPoints) {
			each(hoverPoints, function (point) {
				point.setState();
			});
		}

		each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps
			var mousePos = e[isX ? 'chartX' : 'chartY'],
				axis = chart[isX ? 'xAxis' : 'yAxis'][0],
				startPos = chart[isX ? 'mouseDownX' : 'mouseDownY'],
				halfPointRange = (axis.pointRange || 0) / 2,
				extremes = axis.getExtremes(),
				newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,
				newMax = axis.toValue(startPos + chart[isX ? 'plotWidth' : 'plotHeight'] - mousePos, true) - halfPointRange,
				goingLeft = startPos > mousePos; // #3613

			if (axis.series.length && 
					(goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) && 
					(!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {
				axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });
				doRedraw = true;
			}

			chart[isX ? 'mouseDownX' : 'mouseDownY'] = mousePos; // set new reference for next run
		});

		if (doRedraw) {
			chart.redraw(false);
		}
		css(chart.container, { cursor: 'move' });
	}
});

/*
 * Extend the Point object with interaction
 */
extend(Point.prototype, {
	/**
	 * Toggle the selection status of a point
	 * @param {Boolean} selected Whether to select or unselect the point.
	 * @param {Boolean} accumulate Whether to add to the previous selection. By default,
	 *		 this happens if the control key (Cmd on Mac) was pressed during clicking.
	 */
	select: function (selected, accumulate) {
		var point = this,
			series = point.series,
			chart = series.chart;

		selected = pick(selected, !point.selected);

		// fire the event with the defalut handler
		point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
			point.selected = point.options.selected = selected;
			series.options.data[inArray(point, series.data)] = point.options;

			point.setState(selected && SELECT_STATE);

			// unselect all other points unless Ctrl or Cmd + click
			if (!accumulate) {
				each(chart.getSelectedPoints(), function (loopPoint) {
					if (loopPoint.selected && loopPoint !== point) {
						loopPoint.selected = loopPoint.options.selected = false;
						series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
						loopPoint.setState(NORMAL_STATE);
							loopPoint.firePointEvent('unselect');
					}
				});
			}
		});
	},

	/**
	 * Runs on mouse over the point
	 *
	 * @param {Object} e The event arguments
	 * @param {Boolean} byProximity Falsy for kd points that are closest to the mouse, or to 
	 *        actually hovered points. True for other points in shared tooltip.
	 */
	onMouseOver: function (e, byProximity) {
		var point = this,
			series = point.series,
			chart = series.chart,
			tooltip = chart.tooltip,
			hoverPoint = chart.hoverPoint;

		if (chart.hoverSeries !== series) {
			series.onMouseOver();
		}		

		// set normal state to previous series
		if (hoverPoint && hoverPoint !== point) {
			hoverPoint.onMouseOut();
		}

		if (point.series) { // It may have been destroyed, #4130

			// trigger the event
			point.firePointEvent('mouseOver');

			// update the tooltip
			if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
				tooltip.refresh(point, e);
			}

			// hover this
			point.setState(HOVER_STATE);
			if (!byProximity) {
				chart.hoverPoint = point;
			}
		}
	},

	/**
	 * Runs on mouse out from the point
	 */
	onMouseOut: function () {
		var chart = this.series.chart,
			hoverPoints = chart.hoverPoints;

		this.firePointEvent('mouseOut');

		if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240
			this.setState();
			chart.hoverPoint = null;
		}
	},

	/**
	 * Import events from the series' and point's options. Only do it on
	 * demand, to save processing time on hovering.
	 */
	importEvents: function () {
		if (!this.hasImportedEvents) {
			var point = this,
				options = merge(point.series.options.point, point.options),
				events = options.events,
				eventType;

			point.events = events;

			for (eventType in events) {
				addEvent(point, eventType, events[eventType]);
			}
			this.hasImportedEvents = true;

		}
	},

	/**
	 * Set the point's state
	 * @param {String} state
	 */
	setState: function (state, move) {
		var point = this,
			plotX = mathFloor(point.plotX), // #4586
			plotY = point.plotY,
			series = point.series,
			stateOptions = series.options.states,
			markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
			normalDisabled = markerOptions && !markerOptions.enabled,
			markerStateOptions = markerOptions && markerOptions.states[state],
			stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
			stateMarkerGraphic = series.stateMarkerGraphic,
			pointMarker = point.marker || {},
			chart = series.chart,
			radius,
			halo = series.halo,
			haloOptions,
			newSymbol,
			pointAttr;

		state = state || NORMAL_STATE; // empty string
		pointAttr = point.pointAttr[state] || series.pointAttr[state];

		if (
				// already has this state
				(state === point.state && !move) ||
				// selected points don't respond to hover
				(point.selected && state !== SELECT_STATE) ||
				// series' state options is disabled
				(stateOptions[state] && stateOptions[state].enabled === false) ||
				// general point marker's state options is disabled
				(state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||
				// individual point marker's state options is disabled
				(state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610

			) {
			return;
		}

		// apply hover styles to the existing point
		if (point.graphic) {
			radius = markerOptions && point.graphic.symbolName && pointAttr.r;
			point.graphic.attr(merge(
				pointAttr,
				radius ? { // new symbol attributes (#507, #612)
					x: plotX - radius,
					y: plotY - radius,
					width: 2 * radius,
					height: 2 * radius
				} : {}
			));

			// Zooming in from a range with no markers to a range with markers
			if (stateMarkerGraphic) {
				stateMarkerGraphic.hide();
			}
		} else {
			// if a graphic is not applied to each point in the normal state, create a shared
			// graphic for the hover state
			if (state && markerStateOptions) {
				radius = markerStateOptions.radius;
				newSymbol = pointMarker.symbol || series.symbol;

				// If the point has another symbol than the previous one, throw away the
				// state marker graphic and force a new one (#1459)
				if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
					stateMarkerGraphic = stateMarkerGraphic.destroy();
				}

				// Add a new state marker graphic
				if (!stateMarkerGraphic) {
					if (newSymbol) {
						series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
							newSymbol,
							plotX - radius,
							plotY - radius,
							2 * radius,
							2 * radius
						)
						.attr(pointAttr)
						.add(series.markerGroup);
						stateMarkerGraphic.currentSymbol = newSymbol;
					}

				// Move the existing graphic
				} else {
					stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054
						x: plotX - radius,
						y: plotY - radius
					});
				}
			}

			if (stateMarkerGraphic) {
				stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450
				stateMarkerGraphic.element.point = point; // #4310
			}
		}

		// Show me your halo
		haloOptions = stateOptions[state] && stateOptions[state].halo;
		if (haloOptions && haloOptions.size) {
			if (!halo) {
				series.halo = halo = chart.renderer.path()
					.add(chart.seriesGroup);
			}
			halo.attr(extend({
				fill: Color(point.color || series.color).setOpacity(haloOptions.opacity).get()
			}, haloOptions.attributes))[move ? 'animate' : 'attr']({
				d: point.haloPath(haloOptions.size)
			});
		} else if (halo) {
			halo.attr({ d: [] });
		}

		point.state = state;
	},

	haloPath: function (size) {
		var series = this.series,
			chart = series.chart,
			plotBox = series.getPlotBox(),
			inverted = chart.inverted;

		return chart.renderer.symbols.circle(
			plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : this.plotX) - size, 
			plotBox.translateY + (inverted ? series.xAxis.len - this.plotX : this.plotY) - size, 
			size * 2, 
			size * 2
		);
	}
});

/*
 * Extend the Series object with interaction
 */

extend(Series.prototype, {
	/**
	 * Series mouse over handler
	 */
	onMouseOver: function () {
		var series = this,
			chart = series.chart,
			hoverSeries = chart.hoverSeries;

		// set normal state to previous series
		if (hoverSeries && hoverSeries !== series) {
			hoverSeries.onMouseOut();
		}

		// trigger the event, but to save processing time,
		// only if defined
		if (series.options.events.mouseOver) {
			fireEvent(series, 'mouseOver');
		}

		// hover this
		series.setState(HOVER_STATE);
		chart.hoverSeries = series;
	},

	/**
	 * Series mouse out handler
	 */
	onMouseOut: function () {
		// trigger the event only if listeners exist
		var series = this,
			options = series.options,
			chart = series.chart,
			tooltip = chart.tooltip,
			hoverPoint = chart.hoverPoint;

		chart.hoverSeries = null; // #182, set to null before the mouseOut event fires

		// trigger mouse out on the point, which must be in this series
		if (hoverPoint) {
			hoverPoint.onMouseOut();
		}

		// fire the mouse out event
		if (series && options.events.mouseOut) {
			fireEvent(series, 'mouseOut');
		}


		// hide the tooltip
		if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
			tooltip.hide();
		}

		// set normal state
		series.setState();
	},

	/**
	 * Set the state of the graph
	 */
	setState: function (state) {
		var series = this,
			options = series.options,
			graph = series.graph,
			stateOptions = options.states,
			lineWidth = options.lineWidth,
			attribs,
			i = 0;

		state = state || NORMAL_STATE;

		if (series.state !== state) {
			series.state = state;

			if (stateOptions[state] && stateOptions[state].enabled === false) {
				return;
			}

			if (state) {
				lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035
			}

			if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
				attribs = {
					'stroke-width': lineWidth
				};
				// use attr because animate will cause any other animation on the graph to stop
				graph.attr(attribs);
				while (series['zoneGraph' + i]) {
					series['zoneGraph' + i].attr(attribs);
					i = i + 1;
				}
			}
		}
	},

	/**
	 * Set the visibility of the graph
	 *
	 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
	 *				the visibility is toggled.
	 */
	setVisible: function (vis, redraw) {
		var series = this,
			chart = series.chart,
			legendItem = series.legendItem,
			showOrHide,
			ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
			oldVisibility = series.visible;

		// if called without an argument, toggle visibility
		series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;
		showOrHide = vis ? 'show' : 'hide';

		// show or hide elements
		each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {
			if (series[key]) {
				series[key][showOrHide]();
			}
		});


		// hide tooltip (#1361)
		if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
			series.onMouseOut();
		}


		if (legendItem) {
			chart.legend.colorizeItem(series, vis);
		}


		// rescale or adapt to resized chart
		series.isDirty = true;
		// in a stack, all other series are affected
		if (series.options.stacking) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.options.stacking && otherSeries.visible) {
					otherSeries.isDirty = true;
				}
			});
		}

		// show or hide linked series
		each(series.linkedSeries, function (otherSeries) {
			otherSeries.setVisible(vis, false);
		});

		if (ignoreHiddenSeries) {
			chart.isDirtyBox = true;
		}
		if (redraw !== false) {
			chart.redraw();
		}

		fireEvent(series, showOrHide);
	},

	/**
	 * Show the graph
	 */
	show: function () {
		this.setVisible(true);
	},

	/**
	 * Hide the graph
	 */
	hide: function () {
		this.setVisible(false);
	},


	/**
	 * Set the selected state of the graph
	 *
	 * @param selected {Boolean} True to select the series, false to unselect. If
	 *				UNDEFINED, the selection state is toggled.
	 */
	select: function (selected) {
		var series = this;
		// if called without an argument, toggle
		series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

		if (series.checkbox) {
			series.checkbox.checked = selected;
		}

		fireEvent(series, selected ? 'select' : 'unselect');
	},

	drawTracker: TrackerMixin.drawTrackerGraph
});
// global variables
extend(Highcharts, {
	
	// Constructors
	Color: Color,
	Point: Point,
	Tick: Tick,	
	Renderer: Renderer,
	SVGElement: SVGElement,
	SVGRenderer: SVGRenderer,
	
	// Various
	arrayMin: arrayMin,
	arrayMax: arrayMax,
	charts: charts,
	dateFormat: dateFormat,
	error: error,
	format: format,
	pathAnim: pathAnim,
	getOptions: getOptions,
	hasBidiBug: hasBidiBug,
	isTouchDevice: isTouchDevice,
	setOptions: setOptions,
	addEvent: addEvent,
	removeEvent: removeEvent,
	createElement: createElement,
	discardElement: discardElement,
	css: css,
	each: each,
	map: map,
	merge: merge,
	splat: splat,
	extendClass: extendClass,
	pInt: pInt,
	svg: hasSVG,
	canvas: useCanVG,
	vml: !hasSVG && !useCanVG,
	product: PRODUCT,
	version: VERSION
});

}());
;

module.exports = window.Highcharts;
},{"./adapters/standalone-framework":23}],25:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.1.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:01Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],26:[function(require,module,exports){
var App = {

}

module.exports = App;
},{}],27:[function(require,module,exports){
var Backbone = require('backbone');

var ProductModel = require('../models/product')

var BulbCollection = Backbone.Collection.extend({
	model: ProductModel,
	url: function() {
		return 'api/bulb'
	}
})

module.exports = BulbCollection;
},{"../models/product":30,"backbone":1}],28:[function(require,module,exports){
var Backbone = require('backbone');

var ProductModel = require('../models/product')

var FanCollection = Backbone.Collection.extend({
	model: ProductModel,
	url: function() {
		return 'api/fan'
	}
})

module.exports = FanCollection;
},{"../models/product":30,"backbone":1}],29:[function(require,module,exports){
// Dependencies
var $ = require('jquery');
var Backbone = require('backbone');
var Handlebars = require('hbsfy/runtime');

// App
var App = require('./app')


// Views
var HomeView = require('./views/home.js');
var homeView = new HomeView();

var AboutView = require('./views/about.js');
var aboutView = new AboutView();

var CompareView = require('./views/compare.js');
var compareView = new CompareView();

var ProductProfileView = require('./views/product-profile.js');
var productProfileView = new ProductProfileView();


$(function() {

	var AppRouter = Backbone.Router.extend({
	    
	    routes: {
	    	'(/)': 'index',
	    	'about(/)': 'about',
	    	'compare(/)': 'compare',
	        // 'add-product(/)': 'addProduct',
	        'product/:id(/)': 'productProfile',
	        '*actions': 'defaultRoute'
	    },

	    index: function() {
	    	homeView.render();
	    },

	    about: function() {
	    	aboutView.render();
	    },

	    compare: function() {
	    	console.log('compare');
	    	compareView.render();
	    },

	    // addProduct: function() {
	    // 	console.log('Add Product');
	    // },

	    productProfile: function(id) {
	    	productProfileView.render(id);
	    },

	    defaultRoute: function() {
	    	console.log('404');
	    }


	});

	// Instantiate the router
	App.appRouter = new AppRouter;

	// Start Backbone history a necessary step for bookmarkable URL's
	Backbone.history.start();




})
},{"./app":26,"./views/about.js":35,"./views/compare.js":36,"./views/home.js":37,"./views/product-profile.js":38,"backbone":1,"hbsfy/runtime":22,"jquery":25}],30:[function(require,module,exports){
var Backbone = require('backbone');

var ProductModel = Backbone.Model.extend({

	url: function() {

		console.log('url in product model')
		return '/api/product/' + this.product_id
	}
	
})

module.exports = ProductModel;
},{"backbone":1}],31:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div>\n	<div>	\n		<h2>Invest Now to Save Later</h2>\n	</div>\n</div>\n<div class=\"about-content\">\n	<h1>About Us</h1>\n	<p>Our Goal is to make information more accessible to consumers. We want to help consumers see the long-term savings they can expect when purchasing higher-quality electricity-consuming products.</p>\n	<h1>Things to Consider:</h1>\n	<div class=\"about-details\">\n		<h2>DC Motor</h2>\n		<div class=\"media-object\">\n			<div class=\"media-graphic\" style=\"background-image: url(/images/dc_motor.jpg);\"></div>\n			<div class=\"media-content\">\n				<p>The specific type of DC motor used in ceiling fans is a brushless DC motor, (aka synchronous DC motor). A DC motor uses an internal array of magnets of opposing polarity. This creates a magnetic field that creates the torque required to rotate the motor's rotor. This process requires less electrical energy, translating into a 70% or greater reduction in power consumption over standard AC motors.</p>\n			</div>\n		</div>\n		<h2>CFM &#38; Airflow Efficiency</h2>\n		<div class=\"media-object\">\n			<div class=\"media-graphic\"style=\"background-image: url(/images/airflow.jpg);\"></div>\n			<div class=\"media-content\">\n				<p>CFM is key when determining a fans airflow efficiency. Airflow efficiency is the CFM divided by the watts/amount of energy used to run the fan at its highest speed. A CFM of 75 is the minimum number to make a fan efficient. So you could have a fan that moves a lot of air (with a high CFM) but does so at a high wattage, so the fan may not be considered efficient.</p>\n			</div>\n		</div>\n		<h2>Thermostat</h2>\n		<div class=\"media-object\">\n			<div class=\"media-graphic\" style=\"background-image: url(/images/thermostat.jpg);\"></div>\n			<div class=\"media-content\">\n				<p>Ceiling fans that include a thermostat can automatically turn your fan on and off and set the fan speed based on room temperature, conserving energy.</p>\n			</div>\n		</div>\n	</div>\n</div>";
},"useData":true});

},{"hbsfy/runtime":22}],32:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"product-comparison-chart\"></div>\n<table class=\"compare-selections\" border=\"1\">\n	<tr>\n		<td>Brand</td>\n		<td>brand1</td>\n		<td>brand2</td>\n	</tr>\n	<tr>\n		<td>Model</td>\n		<td>model1</td>\n		<td>model2</td>\n	</tr>\n	<tr>\n		<td>price</td>\n		<td>$75</td>\n		<td>$225</td>\n	</tr>\n	<tr>\n		<td>Electric cost/Mo</td>\n		<td>$5</td>\n		<td>$3</td>\n	</tr>\n	<tr>\n		<td>Width (in.)</td>\n		<td>52</td>\n		<td>52</td>\n	</tr>\n	<tr>\n		<td>Airflow (CFM)</td>\n		<td>1800</td>\n		<td>3500</td>\n	</tr>\n	<tr>\n		<td>Thermostat</td>\n		<td>No</td>\n		<td>Yes</td>\n	</tr>\n	<tr>\n		<td>Remote</td>\n		<td>No</td>\n		<td>Yes</td>\n	</tr>\n	<tr>\n		<td>Lightbulb</td>\n		<td>17 Watt CFL</td>\n		<td>18 Watt LED</td>\n	</tr>\n</table>";
},"useData":true});

},{"hbsfy/runtime":22}],33:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"tagline\">	\n	<h2>Invest Now to Save Later</h2>\n</div>\n<div class=\"showcase\">\n	<div class=\"banner\">\n		<div class=\"banner-text\">Brands</div>\n		<div class=\"logos\"></div>\n	</div>\n</div>\n<div class=\"user-selections\"></div>\n<div class=\"products\">\n	<section>\n		<h2>Ceiling fans</h2>\n		<div class=\"tiles fans\">\n		</div>\n	</section>\n	<section>\n		<h2>Light Bulbs</h2>\n		<div class=\"tiles bulbs\">\n		</div>\n	</section>\n</div>";
},"useData":true});

},{"hbsfy/runtime":22}],34:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : {}, alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "	<div data-id=\""
    + alias4(((helper = (helper = helpers.product_id || (depth0 != null ? depth0.product_id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"product_id","hash":{},"data":data}) : helper)))
    + "\" class=\"tile\">\n		<div class=\"tile-image\"\n			style=\"background-image: url(/images/"
    + alias4(((helper = (helper = helpers.file_path || (depth0 != null ? depth0.file_path : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"file_path","hash":{},"data":data}) : helper)))
    + ".jpg);\"> \n		</div>\n		<div class=\"tile-details\">\n			<div class=\"tile-details1\">"
    + alias4(((helper = (helper = helpers.brand_name || (depth0 != null ? depth0.brand_name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"brand_name","hash":{},"data":data}) : helper)))
    + "</div> \n			<div class=\"tile-details2\">"
    + alias4(((helper = (helper = helpers.model || (depth0 != null ? depth0.model : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"model","hash":{},"data":data}) : helper)))
    + "</div>\n			<div class=\"control\">\n				<button>Info</button>\n				<button>Choose</button>\n			</div>\n		</div>\n	</div>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},depth0,{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
},"useData":true});

},{"hbsfy/runtime":22}],35:[function(require,module,exports){
var $ = require('jquery');
var Backbone = require('backbone');
var pageTemplate = require('../templates/about.hbs');

var AboutView = Backbone.View.extend({
	el: '.content',

	render: function() {
		var result = pageTemplate()

		this.$el.html(result)
	}
})

module.exports = AboutView;
},{"../templates/about.hbs":31,"backbone":1,"jquery":25}],36:[function(require,module,exports){
var $ = require('jquery');
var HighCharts = require('highcharts-browserify');
var Backbone = require('backbone');
var pageTemplate = require('../templates/compare.hbs');
// var chartTemplate = require('../product_compare_chart');

var CompareView = Backbone.View.extend({
	el: '.content',

	render: function() {
		var result = pageTemplate()

		this.$el.html(result)

		console.log('before chart');


		new Highcharts.Chart({
			chart: {
				renderTo: $('.product-comparison-chart')[0],
	            type: 'line'
	        },
	        title: {
	            text: 'Energy Cost'
	        },
	        xAxis: {
	            categories: ['Purchase Date', 'Year 3']
	        },
	        yAxis: {
	            title: {
	                text: 'Initial Cost'
	            }
	        },
	        series: [{
	            name: 'Product 1',
	            data: [200, 500]
	        }, {
	            name: 'Product 2',
	            data: [300, 450]
	        }]
		})
		

		// var chartTemplate = new ChartTemplate()
		// chartTemplate.fetch().done(function(chart) {
	
		// // raw non-backbone array of objects
		// console.log('got to charts');
		// var result = pageTemplate(chart)
		// $('.product-comparison-chart').html(result);

		// })
	}
})

module.exports = CompareView;


// chart div   .product-comparison-chart
},{"../templates/compare.hbs":32,"backbone":1,"highcharts-browserify":24,"jquery":25}],37:[function(require,module,exports){
var $ = require('jquery');
var Backbone = require('backbone');
var pageTemplate = require('../templates/home.hbs');
var productTileTemplate = require('../templates/product_tile.hbs')

// Collections
// var ProductCollection = require('../collections/product.js');
var FanCollection = require('../collections/fan.js')
var BulbCollection = require('../collections/bulb.js')


var HomeView = Backbone.View.extend({
	el: '.content',

	render: function() {
		// console.log('render home view')
		var result = pageTemplate()

		this.$el.html(result)

		// var productCollection = new ProductCollection()
		// productCollection.fetch().done(function(products) {
			
		// 	// raw non-backbone array of objects
		// 	console.log(products);
		// 	var result = productTileTemplate(products)
		// 	$('.tiles').html(result);

		var fanCollection = new FanCollection()
		fanCollection.fetch().done(function(fans) {
		
			// raw non-backbone array of objects
			var result = productTileTemplate(fans)
			$('.tiles.fans').html(result);
		})

		var bulbCollection = new BulbCollection()
		bulbCollection.fetch().done(function(bulbs) {
		
			// raw non-backbone array of objects
			var result = productTileTemplate(bulbs)
			$('.tiles.bulbs').html(result);

		})
	}
})

module.exports = HomeView;
},{"../collections/bulb.js":27,"../collections/fan.js":28,"../templates/home.hbs":33,"../templates/product_tile.hbs":34,"backbone":1,"jquery":25}],38:[function(require,module,exports){
var $ = require('jquery');
var Backbone = require('backbone');
var pageTemplate = require('../templates/product_tile.hbs');

//Models
var ProductModel = require('../models/product')


var ProductProfileView = Backbone.View.extend({
	
	el: '.content',

	render: function(product_id) {
		var _this = this

		var productModel = new ProductModel({id: product_id})
		productModel.fetch().done(function(product){
			var result = pageTemplate(product[0])
		 	_this.$el.html(result)
		})
		

	}
})

module.exports = ProductProfileView;





},{"../models/product":30,"../templates/product_tile.hbs":34,"backbone":1,"jquery":25}]},{},[29])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFja2JvbmUvYmFja2JvbmUuanMiLCJub2RlX21vZHVsZXMvYmFja2JvbmUvbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzLnJ1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvZGVjb3JhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2RlY29yYXRvcnMvaW5saW5lLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvZXhjZXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2VhY2guanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2hlbHBlci1taXNzaW5nLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9pZi5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9nLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9sb29rdXAuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL3dpdGguanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9sb2dnZXIuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL25vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL25vLWNvbmZsaWN0LmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL3NhZmUtc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL2hic2Z5L3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvaGlnaGNoYXJ0cy1icm93c2VyaWZ5L2FkYXB0ZXJzL3N0YW5kYWxvbmUtZnJhbWV3b3JrLmpzIiwibm9kZV9tb2R1bGVzL2hpZ2hjaGFydHMtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJzcmMvYXBwLmpzIiwic3JjL2NvbGxlY3Rpb25zL2J1bGIuanMiLCJzcmMvY29sbGVjdGlvbnMvZmFuLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL21vZGVscy9wcm9kdWN0LmpzIiwic3JjL3RlbXBsYXRlcy9hYm91dC5oYnMiLCJzcmMvdGVtcGxhdGVzL2NvbXBhcmUuaGJzIiwic3JjL3RlbXBsYXRlcy9ob21lLmhicyIsInNyYy90ZW1wbGF0ZXMvcHJvZHVjdF90aWxlLmhicyIsInNyYy92aWV3cy9hYm91dC5qcyIsInNyYy92aWV3cy9jb21wYXJlLmpzIiwic3JjL3ZpZXdzL2hvbWUuanMiLCJzcmMvdmlld3MvcHJvZHVjdC1wcm9maWxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0MkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OzhCQzVnRHNCLG1CQUFtQjs7SUFBN0IsSUFBSTs7Ozs7b0NBSU8sMEJBQTBCOzs7O21DQUMzQix3QkFBd0I7Ozs7K0JBQ3ZCLG9CQUFvQjs7SUFBL0IsS0FBSzs7aUNBQ1Esc0JBQXNCOztJQUFuQyxPQUFPOztvQ0FFSSwwQkFBMEI7Ozs7O0FBR2pELFNBQVMsTUFBTSxHQUFHO0FBQ2hCLE1BQUksRUFBRSxHQUFHLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7O0FBRTFDLE9BQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3ZCLElBQUUsQ0FBQyxVQUFVLG9DQUFhLENBQUM7QUFDM0IsSUFBRSxDQUFDLFNBQVMsbUNBQVksQ0FBQztBQUN6QixJQUFFLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNqQixJQUFFLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixDQUFDOztBQUU3QyxJQUFFLENBQUMsRUFBRSxHQUFHLE9BQU8sQ0FBQztBQUNoQixJQUFFLENBQUMsUUFBUSxHQUFHLFVBQVMsSUFBSSxFQUFFO0FBQzNCLFdBQU8sT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7R0FDbkMsQ0FBQzs7QUFFRixTQUFPLEVBQUUsQ0FBQztDQUNYOztBQUVELElBQUksSUFBSSxHQUFHLE1BQU0sRUFBRSxDQUFDO0FBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDOztBQUVyQixrQ0FBVyxJQUFJLENBQUMsQ0FBQzs7QUFFakIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQzs7cUJBRVIsSUFBSTs7Ozs7Ozs7Ozs7OztxQkNwQ3lCLFNBQVM7O3lCQUMvQixhQUFhOzs7O3VCQUNFLFdBQVc7OzBCQUNSLGNBQWM7O3NCQUNuQyxVQUFVOzs7O0FBRXRCLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQzs7QUFDeEIsSUFBTSxpQkFBaUIsR0FBRyxDQUFDLENBQUM7OztBQUU1QixJQUFNLGdCQUFnQixHQUFHO0FBQzlCLEdBQUMsRUFBRSxhQUFhO0FBQ2hCLEdBQUMsRUFBRSxlQUFlO0FBQ2xCLEdBQUMsRUFBRSxlQUFlO0FBQ2xCLEdBQUMsRUFBRSxVQUFVO0FBQ2IsR0FBQyxFQUFFLGtCQUFrQjtBQUNyQixHQUFDLEVBQUUsaUJBQWlCO0FBQ3BCLEdBQUMsRUFBRSxVQUFVO0NBQ2QsQ0FBQzs7O0FBRUYsSUFBTSxVQUFVLEdBQUcsaUJBQWlCLENBQUM7O0FBRTlCLFNBQVMscUJBQXFCLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUU7QUFDbkUsTUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLElBQUksRUFBRSxDQUFDO0FBQzdCLE1BQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxJQUFJLEVBQUUsQ0FBQztBQUMvQixNQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsSUFBSSxFQUFFLENBQUM7O0FBRW5DLGtDQUF1QixJQUFJLENBQUMsQ0FBQztBQUM3Qix3Q0FBMEIsSUFBSSxDQUFDLENBQUM7Q0FDakM7O0FBRUQscUJBQXFCLENBQUMsU0FBUyxHQUFHO0FBQ2hDLGFBQVcsRUFBRSxxQkFBcUI7O0FBRWxDLFFBQU0scUJBQVE7QUFDZCxLQUFHLEVBQUUsb0JBQU8sR0FBRzs7QUFFZixnQkFBYyxFQUFFLHdCQUFTLElBQUksRUFBRSxFQUFFLEVBQUU7QUFDakMsUUFBSSxnQkFBUyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssVUFBVSxFQUFFO0FBQ3RDLFVBQUksRUFBRSxFQUFFO0FBQUUsY0FBTSwyQkFBYyx5Q0FBeUMsQ0FBQyxDQUFDO09BQUU7QUFDM0Usb0JBQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztLQUM1QixNQUFNO0FBQ0wsVUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDekI7R0FDRjtBQUNELGtCQUFnQixFQUFFLDBCQUFTLElBQUksRUFBRTtBQUMvQixXQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDM0I7O0FBRUQsaUJBQWUsRUFBRSx5QkFBUyxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQ3ZDLFFBQUksZ0JBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLFVBQVUsRUFBRTtBQUN0QyxvQkFBTyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQzdCLE1BQU07QUFDTCxVQUFJLE9BQU8sT0FBTyxLQUFLLFdBQVcsRUFBRTtBQUNsQyxjQUFNLHlFQUEwRCxJQUFJLG9CQUFpQixDQUFDO09BQ3ZGO0FBQ0QsVUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUM7S0FDL0I7R0FDRjtBQUNELG1CQUFpQixFQUFFLDJCQUFTLElBQUksRUFBRTtBQUNoQyxXQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDNUI7O0FBRUQsbUJBQWlCLEVBQUUsMkJBQVMsSUFBSSxFQUFFLEVBQUUsRUFBRTtBQUNwQyxRQUFJLGdCQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxVQUFVLEVBQUU7QUFDdEMsVUFBSSxFQUFFLEVBQUU7QUFBRSxjQUFNLDJCQUFjLDRDQUE0QyxDQUFDLENBQUM7T0FBRTtBQUM5RSxvQkFBTyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQy9CLE1BQU07QUFDTCxVQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQUM1QjtHQUNGO0FBQ0QscUJBQW1CLEVBQUUsNkJBQVMsSUFBSSxFQUFFO0FBQ2xDLFdBQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUM5QjtDQUNGLENBQUM7O0FBRUssSUFBSSxHQUFHLEdBQUcsb0JBQU8sR0FBRyxDQUFDOzs7UUFFcEIsV0FBVztRQUFFLE1BQU07Ozs7Ozs7Ozs7OztnQ0M3RUEscUJBQXFCOzs7O0FBRXpDLFNBQVMseUJBQXlCLENBQUMsUUFBUSxFQUFFO0FBQ2xELGdDQUFlLFFBQVEsQ0FBQyxDQUFDO0NBQzFCOzs7Ozs7OztxQkNKb0IsVUFBVTs7cUJBRWhCLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsVUFBUyxFQUFFLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUU7QUFDM0UsUUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2IsUUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7QUFDbkIsV0FBSyxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7QUFDcEIsU0FBRyxHQUFHLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTs7QUFFL0IsWUFBSSxRQUFRLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQztBQUNsQyxpQkFBUyxDQUFDLFFBQVEsR0FBRyxjQUFPLEVBQUUsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzFELFlBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDL0IsaUJBQVMsQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQzlCLGVBQU8sR0FBRyxDQUFDO09BQ1osQ0FBQztLQUNIOztBQUVELFNBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUM7O0FBRTdDLFdBQU8sR0FBRyxDQUFDO0dBQ1osQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7QUNwQkQsSUFBTSxVQUFVLEdBQUcsQ0FBQyxhQUFhLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFbkcsU0FBUyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtBQUNoQyxNQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLEdBQUc7TUFDdEIsSUFBSSxZQUFBO01BQ0osTUFBTSxZQUFBLENBQUM7QUFDWCxNQUFJLEdBQUcsRUFBRTtBQUNQLFFBQUksR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztBQUN0QixVQUFNLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7O0FBRTFCLFdBQU8sSUFBSSxLQUFLLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUM7R0FDeEM7O0FBRUQsTUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQzs7O0FBRzFELE9BQUssSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ2hELFFBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7R0FDOUM7OztBQUdELE1BQUksS0FBSyxDQUFDLGlCQUFpQixFQUFFO0FBQzNCLFNBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDMUM7O0FBRUQsTUFBSSxHQUFHLEVBQUU7QUFDUCxRQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztBQUN2QixRQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztHQUN0QjtDQUNGOztBQUVELFNBQVMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQzs7cUJBRW5CLFNBQVM7Ozs7Ozs7Ozs7Ozs7eUNDbENlLGdDQUFnQzs7OzsyQkFDOUMsZ0JBQWdCOzs7O29DQUNQLDBCQUEwQjs7Ozt5QkFDckMsY0FBYzs7OzswQkFDYixlQUFlOzs7OzZCQUNaLGtCQUFrQjs7OzsyQkFDcEIsZ0JBQWdCOzs7O0FBRWxDLFNBQVMsc0JBQXNCLENBQUMsUUFBUSxFQUFFO0FBQy9DLHlDQUEyQixRQUFRLENBQUMsQ0FBQztBQUNyQywyQkFBYSxRQUFRLENBQUMsQ0FBQztBQUN2QixvQ0FBc0IsUUFBUSxDQUFDLENBQUM7QUFDaEMseUJBQVcsUUFBUSxDQUFDLENBQUM7QUFDckIsMEJBQVksUUFBUSxDQUFDLENBQUM7QUFDdEIsNkJBQWUsUUFBUSxDQUFDLENBQUM7QUFDekIsMkJBQWEsUUFBUSxDQUFDLENBQUM7Q0FDeEI7Ozs7Ozs7O3FCQ2hCcUQsVUFBVTs7cUJBRWpELFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsb0JBQW9CLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3ZFLFFBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPO1FBQ3pCLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUVwQixRQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUU7QUFDcEIsYUFBTyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDakIsTUFBTSxJQUFJLE9BQU8sS0FBSyxLQUFLLElBQUksT0FBTyxJQUFJLElBQUksRUFBRTtBQUMvQyxhQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN0QixNQUFNLElBQUksZUFBUSxPQUFPLENBQUMsRUFBRTtBQUMzQixVQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQ3RCLFlBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUNmLGlCQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzlCOztBQUVELGVBQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO09BQ2hELE1BQU07QUFDTCxlQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztPQUN0QjtLQUNGLE1BQU07QUFDTCxVQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixZQUFJLElBQUksR0FBRyxtQkFBWSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDckMsWUFBSSxDQUFDLFdBQVcsR0FBRyx5QkFBa0IsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzdFLGVBQU8sR0FBRyxFQUFDLElBQUksRUFBRSxJQUFJLEVBQUMsQ0FBQztPQUN4Qjs7QUFFRCxhQUFPLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDN0I7R0FDRixDQUFDLENBQUM7Q0FDSjs7Ozs7Ozs7Ozs7OztxQkMvQjhFLFVBQVU7O3lCQUNuRSxjQUFjOzs7O3FCQUVyQixVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxVQUFTLE9BQU8sRUFBRSxPQUFPLEVBQUU7QUFDekQsUUFBSSxDQUFDLE9BQU8sRUFBRTtBQUNaLFlBQU0sMkJBQWMsNkJBQTZCLENBQUMsQ0FBQztLQUNwRDs7QUFFRCxRQUFJLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRTtRQUNmLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTztRQUN6QixDQUFDLEdBQUcsQ0FBQztRQUNMLEdBQUcsR0FBRyxFQUFFO1FBQ1IsSUFBSSxZQUFBO1FBQ0osV0FBVyxZQUFBLENBQUM7O0FBRWhCLFFBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQy9CLGlCQUFXLEdBQUcseUJBQWtCLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7S0FDakY7O0FBRUQsUUFBSSxrQkFBVyxPQUFPLENBQUMsRUFBRTtBQUFFLGFBQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQUU7O0FBRTFELFFBQUksT0FBTyxDQUFDLElBQUksRUFBRTtBQUNoQixVQUFJLEdBQUcsbUJBQVksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2xDOztBQUVELGFBQVMsYUFBYSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFO0FBQ3pDLFVBQUksSUFBSSxFQUFFO0FBQ1IsWUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUM7QUFDakIsWUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDbkIsWUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLEtBQUssQ0FBQyxDQUFDO0FBQ3pCLFlBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQzs7QUFFbkIsWUFBSSxXQUFXLEVBQUU7QUFDZixjQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsR0FBRyxLQUFLLENBQUM7U0FDeEM7T0FDRjs7QUFFRCxTQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDN0IsWUFBSSxFQUFFLElBQUk7QUFDVixtQkFBVyxFQUFFLG1CQUFZLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsV0FBVyxHQUFHLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztPQUMvRSxDQUFDLENBQUM7S0FDSjs7QUFFRCxRQUFJLE9BQU8sSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRLEVBQUU7QUFDMUMsVUFBSSxlQUFRLE9BQU8sQ0FBQyxFQUFFO0FBQ3BCLGFBQUssSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3ZDLGNBQUksQ0FBQyxJQUFJLE9BQU8sRUFBRTtBQUNoQix5QkFBYSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxLQUFLLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7V0FDL0M7U0FDRjtPQUNGLE1BQU07QUFDTCxZQUFJLFFBQVEsWUFBQSxDQUFDOztBQUViLGFBQUssSUFBSSxHQUFHLElBQUksT0FBTyxFQUFFO0FBQ3ZCLGNBQUksT0FBTyxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsRUFBRTs7OztBQUkvQixnQkFBSSxRQUFRLEtBQUssU0FBUyxFQUFFO0FBQzFCLDJCQUFhLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUNoQztBQUNELG9CQUFRLEdBQUcsR0FBRyxDQUFDO0FBQ2YsYUFBQyxFQUFFLENBQUM7V0FDTDtTQUNGO0FBQ0QsWUFBSSxRQUFRLEtBQUssU0FBUyxFQUFFO0FBQzFCLHVCQUFhLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDdEM7T0FDRjtLQUNGOztBQUVELFFBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUNYLFNBQUcsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDckI7O0FBRUQsV0FBTyxHQUFHLENBQUM7R0FDWixDQUFDLENBQUM7Q0FDSjs7Ozs7Ozs7Ozs7Ozt5QkM5RXFCLGNBQWM7Ozs7cUJBRXJCLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsZUFBZSxFQUFFLGlDQUFnQztBQUN2RSxRQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFOztBQUUxQixhQUFPLFNBQVMsQ0FBQztLQUNsQixNQUFNOztBQUVMLFlBQU0sMkJBQWMsbUJBQW1CLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0tBQ3ZGO0dBQ0YsQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7cUJDWmlDLFVBQVU7O3FCQUU3QixVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxVQUFTLFdBQVcsRUFBRSxPQUFPLEVBQUU7QUFDM0QsUUFBSSxrQkFBVyxXQUFXLENBQUMsRUFBRTtBQUFFLGlCQUFXLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUFFOzs7OztBQUt0RSxRQUFJLEFBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsSUFBSSxDQUFDLFdBQVcsSUFBSyxlQUFRLFdBQVcsQ0FBQyxFQUFFO0FBQ3ZFLGFBQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUM5QixNQUFNO0FBQ0wsYUFBTyxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3pCO0dBQ0YsQ0FBQyxDQUFDOztBQUVILFVBQVEsQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLFVBQVMsV0FBVyxFQUFFLE9BQU8sRUFBRTtBQUMvRCxXQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsRUFBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBQyxDQUFDLENBQUM7R0FDdkgsQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7cUJDbkJjLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLGtDQUFpQztBQUM5RCxRQUFJLElBQUksR0FBRyxDQUFDLFNBQVMsQ0FBQztRQUNsQixPQUFPLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDOUMsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzdDLFVBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDekI7O0FBRUQsUUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0FBQ2QsUUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUU7QUFDOUIsV0FBSyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0tBQzVCLE1BQU0sSUFBSSxPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksRUFBRTtBQUNyRCxXQUFLLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7S0FDNUI7QUFDRCxRQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDOztBQUVoQixZQUFRLENBQUMsR0FBRyxNQUFBLENBQVosUUFBUSxFQUFTLElBQUksQ0FBQyxDQUFDO0dBQ3hCLENBQUMsQ0FBQztDQUNKOzs7Ozs7Ozs7O3FCQ2xCYyxVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxVQUFTLEdBQUcsRUFBRSxLQUFLLEVBQUU7QUFDckQsV0FBTyxHQUFHLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0dBQzFCLENBQUMsQ0FBQztDQUNKOzs7Ozs7Ozs7O3FCQ0o4RSxVQUFVOztxQkFFMUUsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3pELFFBQUksa0JBQVcsT0FBTyxDQUFDLEVBQUU7QUFBRSxhQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUFFOztBQUUxRCxRQUFJLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUVwQixRQUFJLENBQUMsZUFBUSxPQUFPLENBQUMsRUFBRTtBQUNyQixVQUFJLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQ3hCLFVBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQy9CLFlBQUksR0FBRyxtQkFBWSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakMsWUFBSSxDQUFDLFdBQVcsR0FBRyx5QkFBa0IsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ2hGOztBQUVELGFBQU8sRUFBRSxDQUFDLE9BQU8sRUFBRTtBQUNqQixZQUFJLEVBQUUsSUFBSTtBQUNWLG1CQUFXLEVBQUUsbUJBQVksQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7T0FDaEUsQ0FBQyxDQUFDO0tBQ0osTUFBTTtBQUNMLGFBQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUM5QjtHQUNGLENBQUMsQ0FBQztDQUNKOzs7Ozs7Ozs7O3FCQ3ZCcUIsU0FBUzs7QUFFL0IsSUFBSSxNQUFNLEdBQUc7QUFDWCxXQUFTLEVBQUUsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUM7QUFDN0MsT0FBSyxFQUFFLE1BQU07OztBQUdiLGFBQVcsRUFBRSxxQkFBUyxLQUFLLEVBQUU7QUFDM0IsUUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7QUFDN0IsVUFBSSxRQUFRLEdBQUcsZUFBUSxNQUFNLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0FBQzlELFVBQUksUUFBUSxJQUFJLENBQUMsRUFBRTtBQUNqQixhQUFLLEdBQUcsUUFBUSxDQUFDO09BQ2xCLE1BQU07QUFDTCxhQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztPQUM3QjtLQUNGOztBQUVELFdBQU8sS0FBSyxDQUFDO0dBQ2Q7OztBQUdELEtBQUcsRUFBRSxhQUFTLEtBQUssRUFBYztBQUMvQixTQUFLLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7QUFFbEMsUUFBSSxPQUFPLE9BQU8sS0FBSyxXQUFXLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxFQUFFO0FBQy9FLFVBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDckMsVUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRTs7QUFDcEIsY0FBTSxHQUFHLEtBQUssQ0FBQztPQUNoQjs7d0NBUG1CLE9BQU87QUFBUCxlQUFPOzs7QUFRM0IsYUFBTyxDQUFDLE1BQU0sT0FBQyxDQUFmLE9BQU8sRUFBWSxPQUFPLENBQUMsQ0FBQztLQUM3QjtHQUNGO0NBQ0YsQ0FBQzs7cUJBRWEsTUFBTTs7Ozs7Ozs7Ozs7cUJDakNOLFVBQVMsVUFBVSxFQUFFOztBQUVsQyxNQUFJLElBQUksR0FBRyxPQUFPLE1BQU0sS0FBSyxXQUFXLEdBQUcsTUFBTSxHQUFHLE1BQU07TUFDdEQsV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7O0FBRWxDLFlBQVUsQ0FBQyxVQUFVLEdBQUcsWUFBVztBQUNqQyxRQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssVUFBVSxFQUFFO0FBQ2xDLFVBQUksQ0FBQyxVQUFVLEdBQUcsV0FBVyxDQUFDO0tBQy9CO0FBQ0QsV0FBTyxVQUFVLENBQUM7R0FDbkIsQ0FBQztDQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FCQ1pzQixTQUFTOztJQUFwQixLQUFLOzt5QkFDSyxhQUFhOzs7O29CQUM4QixRQUFROztBQUVsRSxTQUFTLGFBQWEsQ0FBQyxZQUFZLEVBQUU7QUFDMUMsTUFBTSxnQkFBZ0IsR0FBRyxZQUFZLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7TUFDdkQsZUFBZSwwQkFBb0IsQ0FBQzs7QUFFMUMsTUFBSSxnQkFBZ0IsS0FBSyxlQUFlLEVBQUU7QUFDeEMsUUFBSSxnQkFBZ0IsR0FBRyxlQUFlLEVBQUU7QUFDdEMsVUFBTSxlQUFlLEdBQUcsdUJBQWlCLGVBQWUsQ0FBQztVQUNuRCxnQkFBZ0IsR0FBRyx1QkFBaUIsZ0JBQWdCLENBQUMsQ0FBQztBQUM1RCxZQUFNLDJCQUFjLHlGQUF5RixHQUN2RyxxREFBcUQsR0FBRyxlQUFlLEdBQUcsbURBQW1ELEdBQUcsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLENBQUM7S0FDaEssTUFBTTs7QUFFTCxZQUFNLDJCQUFjLHdGQUF3RixHQUN0RyxpREFBaUQsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7S0FDbkY7R0FDRjtDQUNGOztBQUVNLFNBQVMsUUFBUSxDQUFDLFlBQVksRUFBRSxHQUFHLEVBQUU7O0FBRTFDLE1BQUksQ0FBQyxHQUFHLEVBQUU7QUFDUixVQUFNLDJCQUFjLG1DQUFtQyxDQUFDLENBQUM7R0FDMUQ7QUFDRCxNQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRTtBQUN2QyxVQUFNLDJCQUFjLDJCQUEyQixHQUFHLE9BQU8sWUFBWSxDQUFDLENBQUM7R0FDeEU7O0FBRUQsY0FBWSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQzs7OztBQUlsRCxLQUFHLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7O0FBRTVDLFdBQVMsb0JBQW9CLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUU7QUFDdkQsUUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFO0FBQ2hCLGFBQU8sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2xELFVBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUNmLGVBQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO09BQ3ZCO0tBQ0Y7O0FBRUQsV0FBTyxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztBQUN0RSxRQUFJLE1BQU0sR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7O0FBRXhFLFFBQUksTUFBTSxJQUFJLElBQUksSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO0FBQ2pDLGFBQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxlQUFlLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDekYsWUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztLQUMzRDtBQUNELFFBQUksTUFBTSxJQUFJLElBQUksRUFBRTtBQUNsQixVQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7QUFDbEIsWUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMvQixhQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzVDLGNBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDNUIsa0JBQU07V0FDUDs7QUFFRCxlQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEM7QUFDRCxjQUFNLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztPQUMzQjtBQUNELGFBQU8sTUFBTSxDQUFDO0tBQ2YsTUFBTTtBQUNMLFlBQU0sMkJBQWMsY0FBYyxHQUFHLE9BQU8sQ0FBQyxJQUFJLEdBQUcsMERBQTBELENBQUMsQ0FBQztLQUNqSDtHQUNGOzs7QUFHRCxNQUFJLFNBQVMsR0FBRztBQUNkLFVBQU0sRUFBRSxnQkFBUyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFCLFVBQUksRUFBRSxJQUFJLElBQUksR0FBRyxDQUFBLEFBQUMsRUFBRTtBQUNsQixjQUFNLDJCQUFjLEdBQUcsR0FBRyxJQUFJLEdBQUcsbUJBQW1CLEdBQUcsR0FBRyxDQUFDLENBQUM7T0FDN0Q7QUFDRCxhQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNsQjtBQUNELFVBQU0sRUFBRSxnQkFBUyxNQUFNLEVBQUUsSUFBSSxFQUFFO0FBQzdCLFVBQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDMUIsV0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM1QixZQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFO0FBQ3hDLGlCQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN4QjtPQUNGO0tBQ0Y7QUFDRCxVQUFNLEVBQUUsZ0JBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUNqQyxhQUFPLE9BQU8sT0FBTyxLQUFLLFVBQVUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQztLQUN4RTs7QUFFRCxvQkFBZ0IsRUFBRSxLQUFLLENBQUMsZ0JBQWdCO0FBQ3hDLGlCQUFhLEVBQUUsb0JBQW9COztBQUVuQyxNQUFFLEVBQUUsWUFBUyxDQUFDLEVBQUU7QUFDZCxVQUFJLEdBQUcsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUIsU0FBRyxDQUFDLFNBQVMsR0FBRyxZQUFZLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ3ZDLGFBQU8sR0FBRyxDQUFDO0tBQ1o7O0FBRUQsWUFBUSxFQUFFLEVBQUU7QUFDWixXQUFPLEVBQUUsaUJBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFO0FBQ25FLFVBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1VBQ2pDLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLFVBQUksSUFBSSxJQUFJLE1BQU0sSUFBSSxXQUFXLElBQUksbUJBQW1CLEVBQUU7QUFDeEQsc0JBQWMsR0FBRyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLG1CQUFtQixFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztPQUMzRixNQUFNLElBQUksQ0FBQyxjQUFjLEVBQUU7QUFDMUIsc0JBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO09BQzlEO0FBQ0QsYUFBTyxjQUFjLENBQUM7S0FDdkI7O0FBRUQsUUFBSSxFQUFFLGNBQVMsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUMzQixhQUFPLEtBQUssSUFBSSxLQUFLLEVBQUUsRUFBRTtBQUN2QixhQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztPQUN2QjtBQUNELGFBQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDRCxTQUFLLEVBQUUsZUFBUyxLQUFLLEVBQUUsTUFBTSxFQUFFO0FBQzdCLFVBQUksR0FBRyxHQUFHLEtBQUssSUFBSSxNQUFNLENBQUM7O0FBRTFCLFVBQUksS0FBSyxJQUFJLE1BQU0sSUFBSyxLQUFLLEtBQUssTUFBTSxBQUFDLEVBQUU7QUFDekMsV0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztPQUN2Qzs7QUFFRCxhQUFPLEdBQUcsQ0FBQztLQUNaOztBQUVELFFBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUk7QUFDakIsZ0JBQVksRUFBRSxZQUFZLENBQUMsUUFBUTtHQUNwQyxDQUFDOztBQUVGLFdBQVMsR0FBRyxDQUFDLE9BQU8sRUFBZ0I7UUFBZCxPQUFPLHlEQUFHLEVBQUU7O0FBQ2hDLFFBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7O0FBRXhCLE9BQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDcEIsUUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLElBQUksWUFBWSxDQUFDLE9BQU8sRUFBRTtBQUM1QyxVQUFJLEdBQUcsUUFBUSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztLQUNoQztBQUNELFFBQUksTUFBTSxZQUFBO1FBQ04sV0FBVyxHQUFHLFlBQVksQ0FBQyxjQUFjLEdBQUcsRUFBRSxHQUFHLFNBQVMsQ0FBQztBQUMvRCxRQUFJLFlBQVksQ0FBQyxTQUFTLEVBQUU7QUFDMUIsVUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO0FBQ2xCLGNBQU0sR0FBRyxPQUFPLEtBQUssT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztPQUM1RixNQUFNO0FBQ0wsY0FBTSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7T0FDcEI7S0FDRjs7QUFFRCxhQUFTLElBQUksQ0FBQyxPQUFPLGdCQUFlO0FBQ2xDLGFBQU8sRUFBRSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztLQUNySDtBQUNELFFBQUksR0FBRyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLE1BQU0sSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQ3RHLFdBQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztHQUMvQjtBQUNELEtBQUcsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDOztBQUVqQixLQUFHLENBQUMsTUFBTSxHQUFHLFVBQVMsT0FBTyxFQUFFO0FBQzdCLFFBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFO0FBQ3BCLGVBQVMsQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFbEUsVUFBSSxZQUFZLENBQUMsVUFBVSxFQUFFO0FBQzNCLGlCQUFTLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDdEU7QUFDRCxVQUFJLFlBQVksQ0FBQyxVQUFVLElBQUksWUFBWSxDQUFDLGFBQWEsRUFBRTtBQUN6RCxpQkFBUyxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO09BQzVFO0tBQ0YsTUFBTTtBQUNMLGVBQVMsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUNwQyxlQUFTLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDdEMsZUFBUyxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO0tBQzNDO0dBQ0YsQ0FBQzs7QUFFRixLQUFHLENBQUMsTUFBTSxHQUFHLFVBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFO0FBQ2xELFFBQUksWUFBWSxDQUFDLGNBQWMsSUFBSSxDQUFDLFdBQVcsRUFBRTtBQUMvQyxZQUFNLDJCQUFjLHdCQUF3QixDQUFDLENBQUM7S0FDL0M7QUFDRCxRQUFJLFlBQVksQ0FBQyxTQUFTLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDckMsWUFBTSwyQkFBYyx5QkFBeUIsQ0FBQyxDQUFDO0tBQ2hEOztBQUVELFdBQU8sV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0dBQ2pGLENBQUM7QUFDRixTQUFPLEdBQUcsQ0FBQztDQUNaOztBQUVNLFNBQVMsV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFO0FBQzVGLFdBQVMsSUFBSSxDQUFDLE9BQU8sRUFBZ0I7UUFBZCxPQUFPLHlEQUFHLEVBQUU7O0FBQ2pDLFFBQUksYUFBYSxHQUFHLE1BQU0sQ0FBQztBQUMzQixRQUFJLE1BQU0sSUFBSSxPQUFPLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQ25DLG1CQUFhLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDMUM7O0FBRUQsV0FBTyxFQUFFLENBQUMsU0FBUyxFQUNmLE9BQU8sRUFDUCxTQUFTLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxRQUFRLEVBQ3JDLE9BQU8sQ0FBQyxJQUFJLElBQUksSUFBSSxFQUNwQixXQUFXLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUN4RCxhQUFhLENBQUMsQ0FBQztHQUNwQjs7QUFFRCxNQUFJLEdBQUcsaUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQzs7QUFFekUsTUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7QUFDakIsTUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDeEMsTUFBSSxDQUFDLFdBQVcsR0FBRyxtQkFBbUIsSUFBSSxDQUFDLENBQUM7QUFDNUMsU0FBTyxJQUFJLENBQUM7Q0FDYjs7QUFFTSxTQUFTLGNBQWMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN4RCxNQUFJLENBQUMsT0FBTyxFQUFFO0FBQ1osUUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLGdCQUFnQixFQUFFO0FBQ3JDLGFBQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQ3pDLE1BQU07QUFDTCxhQUFPLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDMUM7R0FDRixNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRTs7QUFFekMsV0FBTyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7QUFDdkIsV0FBTyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7R0FDckM7QUFDRCxTQUFPLE9BQU8sQ0FBQztDQUNoQjs7QUFFTSxTQUFTLGFBQWEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN2RCxTQUFPLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztBQUN2QixNQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDZixXQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO0dBQ3ZFOztBQUVELE1BQUksWUFBWSxZQUFBLENBQUM7QUFDakIsTUFBSSxPQUFPLENBQUMsRUFBRSxJQUFJLE9BQU8sQ0FBQyxFQUFFLEtBQUssSUFBSSxFQUFFO0FBQ3JDLFdBQU8sQ0FBQyxJQUFJLEdBQUcsa0JBQVksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pDLGdCQUFZLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUUxRCxRQUFJLFlBQVksQ0FBQyxRQUFRLEVBQUU7QUFDekIsYUFBTyxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsUUFBUSxFQUFFLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUM5RTtHQUNGOztBQUVELE1BQUksT0FBTyxLQUFLLFNBQVMsSUFBSSxZQUFZLEVBQUU7QUFDekMsV0FBTyxHQUFHLFlBQVksQ0FBQztHQUN4Qjs7QUFFRCxNQUFJLE9BQU8sS0FBSyxTQUFTLEVBQUU7QUFDekIsVUFBTSwyQkFBYyxjQUFjLEdBQUcsT0FBTyxDQUFDLElBQUksR0FBRyxxQkFBcUIsQ0FBQyxDQUFDO0dBQzVFLE1BQU0sSUFBSSxPQUFPLFlBQVksUUFBUSxFQUFFO0FBQ3RDLFdBQU8sT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztHQUNsQztDQUNGOztBQUVNLFNBQVMsSUFBSSxHQUFHO0FBQUUsU0FBTyxFQUFFLENBQUM7Q0FBRTs7QUFFckMsU0FBUyxRQUFRLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtBQUMvQixNQUFJLENBQUMsSUFBSSxJQUFJLEVBQUUsTUFBTSxJQUFJLElBQUksQ0FBQSxBQUFDLEVBQUU7QUFDOUIsUUFBSSxHQUFHLElBQUksR0FBRyxrQkFBWSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDckMsUUFBSSxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7R0FDckI7QUFDRCxTQUFPLElBQUksQ0FBQztDQUNiOztBQUVELFNBQVMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUU7QUFDekUsTUFBSSxFQUFFLENBQUMsU0FBUyxFQUFFO0FBQ2hCLFFBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNmLFFBQUksR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLE1BQU0sSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUM1RixTQUFLLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztHQUMzQjtBQUNELFNBQU8sSUFBSSxDQUFDO0NBQ2I7Ozs7Ozs7O0FDM1FELFNBQVMsVUFBVSxDQUFDLE1BQU0sRUFBRTtBQUMxQixNQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztDQUN0Qjs7QUFFRCxVQUFVLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxZQUFXO0FBQ3ZFLFNBQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7Q0FDekIsQ0FBQzs7cUJBRWEsVUFBVTs7Ozs7Ozs7Ozs7Ozs7O0FDVHpCLElBQU0sTUFBTSxHQUFHO0FBQ2IsS0FBRyxFQUFFLE9BQU87QUFDWixLQUFHLEVBQUUsTUFBTTtBQUNYLEtBQUcsRUFBRSxNQUFNO0FBQ1gsS0FBRyxFQUFFLFFBQVE7QUFDYixLQUFHLEVBQUUsUUFBUTtBQUNiLEtBQUcsRUFBRSxRQUFRO0FBQ2IsS0FBRyxFQUFFLFFBQVE7Q0FDZCxDQUFDOztBQUVGLElBQU0sUUFBUSxHQUFHLFlBQVk7SUFDdkIsUUFBUSxHQUFHLFdBQVcsQ0FBQzs7QUFFN0IsU0FBUyxVQUFVLENBQUMsR0FBRyxFQUFFO0FBQ3ZCLFNBQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ3BCOztBQUVNLFNBQVMsTUFBTSxDQUFDLEdBQUcsb0JBQW1CO0FBQzNDLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3pDLFNBQUssSUFBSSxHQUFHLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQzVCLFVBQUksTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRTtBQUMzRCxXQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQzlCO0tBQ0Y7R0FDRjs7QUFFRCxTQUFPLEdBQUcsQ0FBQztDQUNaOztBQUVNLElBQUksUUFBUSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDOzs7Ozs7QUFLaEQsSUFBSSxVQUFVLEdBQUcsb0JBQVMsS0FBSyxFQUFFO0FBQy9CLFNBQU8sT0FBTyxLQUFLLEtBQUssVUFBVSxDQUFDO0NBQ3BDLENBQUM7OztBQUdGLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ25CLFVBSU0sVUFBVSxHQUpoQixVQUFVLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDM0IsV0FBTyxPQUFPLEtBQUssS0FBSyxVQUFVLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxtQkFBbUIsQ0FBQztHQUNwRixDQUFDO0NBQ0g7UUFDTyxVQUFVLEdBQVYsVUFBVTs7Ozs7QUFJWCxJQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxJQUFJLFVBQVMsS0FBSyxFQUFFO0FBQ3RELFNBQU8sQUFBQyxLQUFLLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxHQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO0NBQ2pHLENBQUM7Ozs7O0FBR0ssU0FBUyxPQUFPLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUNwQyxPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ2hELFFBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUN0QixhQUFPLENBQUMsQ0FBQztLQUNWO0dBQ0Y7QUFDRCxTQUFPLENBQUMsQ0FBQyxDQUFDO0NBQ1g7O0FBR00sU0FBUyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUU7QUFDdkMsTUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLEVBQUU7O0FBRTlCLFFBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7QUFDM0IsYUFBTyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7S0FDeEIsTUFBTSxJQUFJLE1BQU0sSUFBSSxJQUFJLEVBQUU7QUFDekIsYUFBTyxFQUFFLENBQUM7S0FDWCxNQUFNLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDbEIsYUFBTyxNQUFNLEdBQUcsRUFBRSxDQUFDO0tBQ3BCOzs7OztBQUtELFVBQU0sR0FBRyxFQUFFLEdBQUcsTUFBTSxDQUFDO0dBQ3RCOztBQUVELE1BQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO0FBQUUsV0FBTyxNQUFNLENBQUM7R0FBRTtBQUM5QyxTQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0NBQzdDOztBQUVNLFNBQVMsT0FBTyxDQUFDLEtBQUssRUFBRTtBQUM3QixNQUFJLENBQUMsS0FBSyxJQUFJLEtBQUssS0FBSyxDQUFDLEVBQUU7QUFDekIsV0FBTyxJQUFJLENBQUM7R0FDYixNQUFNLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQy9DLFdBQU8sSUFBSSxDQUFDO0dBQ2IsTUFBTTtBQUNMLFdBQU8sS0FBSyxDQUFDO0dBQ2Q7Q0FDRjs7QUFFTSxTQUFTLFdBQVcsQ0FBQyxNQUFNLEVBQUU7QUFDbEMsTUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUMvQixPQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztBQUN2QixTQUFPLEtBQUssQ0FBQztDQUNkOztBQUVNLFNBQVMsV0FBVyxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUU7QUFDdkMsUUFBTSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7QUFDbEIsU0FBTyxNQUFNLENBQUM7Q0FDZjs7QUFFTSxTQUFTLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxFQUFFLEVBQUU7QUFDakQsU0FBTyxDQUFDLFdBQVcsR0FBRyxXQUFXLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQSxHQUFJLEVBQUUsQ0FBQztDQUNwRDs7OztBQzNHRDtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvOWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxL1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyAgICAgQmFja2JvbmUuanMgMS4yLjNcblxuLy8gICAgIChjKSAyMDEwLTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBCYWNrYm9uZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vICAgICBGb3IgYWxsIGRldGFpbHMgYW5kIGRvY3VtZW50YXRpb246XG4vLyAgICAgaHR0cDovL2JhY2tib25lanMub3JnXG5cbihmdW5jdGlvbihmYWN0b3J5KSB7XG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgKGBzZWxmYCkgaW4gdGhlIGJyb3dzZXIsIG9yIGBnbG9iYWxgIG9uIHRoZSBzZXJ2ZXIuXG4gIC8vIFdlIHVzZSBgc2VsZmAgaW5zdGVhZCBvZiBgd2luZG93YCBmb3IgYFdlYldvcmtlcmAgc3VwcG9ydC5cbiAgdmFyIHJvb3QgPSAodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09IHNlbGYgJiYgc2VsZikgfHxcbiAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbC5nbG9iYWwgPT0gZ2xvYmFsICYmIGdsb2JhbCk7XG5cbiAgLy8gU2V0IHVwIEJhY2tib25lIGFwcHJvcHJpYXRlbHkgZm9yIHRoZSBlbnZpcm9ubWVudC4gU3RhcnQgd2l0aCBBTUQuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWyd1bmRlcnNjb3JlJywgJ2pxdWVyeScsICdleHBvcnRzJ10sIGZ1bmN0aW9uKF8sICQsIGV4cG9ydHMpIHtcbiAgICAgIC8vIEV4cG9ydCBnbG9iYWwgZXZlbiBpbiBBTUQgY2FzZSBpbiBjYXNlIHRoaXMgc2NyaXB0IGlzIGxvYWRlZCB3aXRoXG4gICAgICAvLyBvdGhlcnMgdGhhdCBtYXkgc3RpbGwgZXhwZWN0IGEgZ2xvYmFsIEJhY2tib25lLlxuICAgICAgcm9vdC5CYWNrYm9uZSA9IGZhY3Rvcnkocm9vdCwgZXhwb3J0cywgXywgJCk7XG4gICAgfSk7XG5cbiAgLy8gTmV4dCBmb3IgTm9kZS5qcyBvciBDb21tb25KUy4galF1ZXJ5IG1heSBub3QgYmUgbmVlZGVkIGFzIGEgbW9kdWxlLlxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpLCAkO1xuICAgIHRyeSB7ICQgPSByZXF1aXJlKCdqcXVlcnknKTsgfSBjYXRjaChlKSB7fVxuICAgIGZhY3Rvcnkocm9vdCwgZXhwb3J0cywgXywgJCk7XG5cbiAgLy8gRmluYWxseSwgYXMgYSBicm93c2VyIGdsb2JhbC5cbiAgfSBlbHNlIHtcbiAgICByb290LkJhY2tib25lID0gZmFjdG9yeShyb290LCB7fSwgcm9vdC5fLCAocm9vdC5qUXVlcnkgfHwgcm9vdC5aZXB0byB8fCByb290LmVuZGVyIHx8IHJvb3QuJCkpO1xuICB9XG5cbn0oZnVuY3Rpb24ocm9vdCwgQmFja2JvbmUsIF8sICQpIHtcblxuICAvLyBJbml0aWFsIFNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYEJhY2tib25lYCB2YXJpYWJsZSwgc28gdGhhdCBpdCBjYW4gYmVcbiAgLy8gcmVzdG9yZWQgbGF0ZXIgb24sIGlmIGBub0NvbmZsaWN0YCBpcyB1c2VkLlxuICB2YXIgcHJldmlvdXNCYWNrYm9uZSA9IHJvb3QuQmFja2JvbmU7XG5cbiAgLy8gQ3JlYXRlIGEgbG9jYWwgcmVmZXJlbmNlIHRvIGEgY29tbW9uIGFycmF5IG1ldGhvZCB3ZSdsbCB3YW50IHRvIHVzZSBsYXRlci5cbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeS4gS2VlcCBpbiBzeW5jIHdpdGggYHBhY2thZ2UuanNvbmAuXG4gIEJhY2tib25lLlZFUlNJT04gPSAnMS4yLjMnO1xuXG4gIC8vIEZvciBCYWNrYm9uZSdzIHB1cnBvc2VzLCBqUXVlcnksIFplcHRvLCBFbmRlciwgb3IgTXkgTGlicmFyeSAoa2lkZGluZykgb3duc1xuICAvLyB0aGUgYCRgIHZhcmlhYmxlLlxuICBCYWNrYm9uZS4kID0gJDtcblxuICAvLyBSdW5zIEJhY2tib25lLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBCYWNrYm9uZWAgdmFyaWFibGVcbiAgLy8gdG8gaXRzIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgQmFja2JvbmUgb2JqZWN0LlxuICBCYWNrYm9uZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5CYWNrYm9uZSA9IHByZXZpb3VzQmFja2JvbmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVHVybiBvbiBgZW11bGF0ZUhUVFBgIHRvIHN1cHBvcnQgbGVnYWN5IEhUVFAgc2VydmVycy4gU2V0dGluZyB0aGlzIG9wdGlvblxuICAvLyB3aWxsIGZha2UgYFwiUEFUQ0hcImAsIGBcIlBVVFwiYCBhbmQgYFwiREVMRVRFXCJgIHJlcXVlc3RzIHZpYSB0aGUgYF9tZXRob2RgIHBhcmFtZXRlciBhbmRcbiAgLy8gc2V0IGEgYFgtSHR0cC1NZXRob2QtT3ZlcnJpZGVgIGhlYWRlci5cbiAgQmFja2JvbmUuZW11bGF0ZUhUVFAgPSBmYWxzZTtcblxuICAvLyBUdXJuIG9uIGBlbXVsYXRlSlNPTmAgdG8gc3VwcG9ydCBsZWdhY3kgc2VydmVycyB0aGF0IGNhbid0IGRlYWwgd2l0aCBkaXJlY3RcbiAgLy8gYGFwcGxpY2F0aW9uL2pzb25gIHJlcXVlc3RzIC4uLiB0aGlzIHdpbGwgZW5jb2RlIHRoZSBib2R5IGFzXG4gIC8vIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgIGluc3RlYWQgYW5kIHdpbGwgc2VuZCB0aGUgbW9kZWwgaW4gYVxuICAvLyBmb3JtIHBhcmFtIG5hbWVkIGBtb2RlbGAuXG4gIEJhY2tib25lLmVtdWxhdGVKU09OID0gZmFsc2U7XG5cbiAgLy8gUHJveHkgQmFja2JvbmUgY2xhc3MgbWV0aG9kcyB0byBVbmRlcnNjb3JlIGZ1bmN0aW9ucywgd3JhcHBpbmcgdGhlIG1vZGVsJ3NcbiAgLy8gYGF0dHJpYnV0ZXNgIG9iamVjdCBvciBjb2xsZWN0aW9uJ3MgYG1vZGVsc2AgYXJyYXkgYmVoaW5kIHRoZSBzY2VuZXMuXG4gIC8vXG4gIC8vIGNvbGxlY3Rpb24uZmlsdGVyKGZ1bmN0aW9uKG1vZGVsKSB7IHJldHVybiBtb2RlbC5nZXQoJ2FnZScpID4gMTAgfSk7XG4gIC8vIGNvbGxlY3Rpb24uZWFjaCh0aGlzLmFkZFZpZXcpO1xuICAvL1xuICAvLyBgRnVuY3Rpb24jYXBwbHlgIGNhbiBiZSBzbG93IHNvIHdlIHVzZSB0aGUgbWV0aG9kJ3MgYXJnIGNvdW50LCBpZiB3ZSBrbm93IGl0LlxuICB2YXIgYWRkTWV0aG9kID0gZnVuY3Rpb24obGVuZ3RoLCBtZXRob2QsIGF0dHJpYnV0ZSkge1xuICAgIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0pO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfW21ldGhvZF0odGhpc1thdHRyaWJ1dGVdLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0sIGNiKGl0ZXJhdGVlLCB0aGlzKSwgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oaXRlcmF0ZWUsIGRlZmF1bHRWYWwsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0sIGNiKGl0ZXJhdGVlLCB0aGlzKSwgZGVmYXVsdFZhbCwgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgZGVmYXVsdDogcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KHRoaXNbYXR0cmlidXRlXSk7XG4gICAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdmFyIGFkZFVuZGVyc2NvcmVNZXRob2RzID0gZnVuY3Rpb24oQ2xhc3MsIG1ldGhvZHMsIGF0dHJpYnV0ZSkge1xuICAgIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbihsZW5ndGgsIG1ldGhvZCkge1xuICAgICAgaWYgKF9bbWV0aG9kXSkgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBhZGRNZXRob2QobGVuZ3RoLCBtZXRob2QsIGF0dHJpYnV0ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gU3VwcG9ydCBgY29sbGVjdGlvbi5zb3J0QnkoJ2F0dHInKWAgYW5kIGBjb2xsZWN0aW9uLmZpbmRXaGVyZSh7aWQ6IDF9KWAuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKGl0ZXJhdGVlLCBpbnN0YW5jZSkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSByZXR1cm4gaXRlcmF0ZWU7XG4gICAgaWYgKF8uaXNPYmplY3QoaXRlcmF0ZWUpICYmICFpbnN0YW5jZS5faXNNb2RlbChpdGVyYXRlZSkpIHJldHVybiBtb2RlbE1hdGNoZXIoaXRlcmF0ZWUpO1xuICAgIGlmIChfLmlzU3RyaW5nKGl0ZXJhdGVlKSkgcmV0dXJuIGZ1bmN0aW9uKG1vZGVsKSB7IHJldHVybiBtb2RlbC5nZXQoaXRlcmF0ZWUpOyB9O1xuICAgIHJldHVybiBpdGVyYXRlZTtcbiAgfTtcbiAgdmFyIG1vZGVsTWF0Y2hlciA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgdmFyIG1hdGNoZXIgPSBfLm1hdGNoZXMoYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgcmV0dXJuIG1hdGNoZXIobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBCYWNrYm9uZS5FdmVudHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuICAvLyBhIGN1c3RvbSBldmVudCBjaGFubmVsLiBZb3UgbWF5IGJpbmQgYSBjYWxsYmFjayB0byBhbiBldmVudCB3aXRoIGBvbmAgb3JcbiAgLy8gcmVtb3ZlIHdpdGggYG9mZmA7IGB0cmlnZ2VyYC1pbmcgYW4gZXZlbnQgZmlyZXMgYWxsIGNhbGxiYWNrcyBpblxuICAvLyBzdWNjZXNzaW9uLlxuICAvL1xuICAvLyAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAvLyAgICAgXy5leHRlbmQob2JqZWN0LCBCYWNrYm9uZS5FdmVudHMpO1xuICAvLyAgICAgb2JqZWN0Lm9uKCdleHBhbmQnLCBmdW5jdGlvbigpeyBhbGVydCgnZXhwYW5kZWQnKTsgfSk7XG4gIC8vICAgICBvYmplY3QudHJpZ2dlcignZXhwYW5kJyk7XG4gIC8vXG4gIHZhciBFdmVudHMgPSBCYWNrYm9uZS5FdmVudHMgPSB7fTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBzcGxpdCBldmVudCBzdHJpbmdzLlxuICB2YXIgZXZlbnRTcGxpdHRlciA9IC9cXHMrLztcblxuICAvLyBJdGVyYXRlcyBvdmVyIHRoZSBzdGFuZGFyZCBgZXZlbnQsIGNhbGxiYWNrYCAoYXMgd2VsbCBhcyB0aGUgZmFuY3kgbXVsdGlwbGVcbiAgLy8gc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBgXCJjaGFuZ2UgYmx1clwiLCBjYWxsYmFja2AgYW5kIGpRdWVyeS1zdHlsZSBldmVudFxuICAvLyBtYXBzIGB7ZXZlbnQ6IGNhbGxiYWNrfWApLlxuICB2YXIgZXZlbnRzQXBpID0gZnVuY3Rpb24oaXRlcmF0ZWUsIGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpIHtcbiAgICB2YXIgaSA9IDAsIG5hbWVzO1xuICAgIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gSGFuZGxlIGV2ZW50IG1hcHMuXG4gICAgICBpZiAoY2FsbGJhY2sgIT09IHZvaWQgMCAmJiAnY29udGV4dCcgaW4gb3B0cyAmJiBvcHRzLmNvbnRleHQgPT09IHZvaWQgMCkgb3B0cy5jb250ZXh0ID0gY2FsbGJhY2s7XG4gICAgICBmb3IgKG5hbWVzID0gXy5rZXlzKG5hbWUpOyBpIDwgbmFtZXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIGV2ZW50cyA9IGV2ZW50c0FwaShpdGVyYXRlZSwgZXZlbnRzLCBuYW1lc1tpXSwgbmFtZVtuYW1lc1tpXV0sIG9wdHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSAmJiBldmVudFNwbGl0dGVyLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIEhhbmRsZSBzcGFjZSBzZXBhcmF0ZWQgZXZlbnQgbmFtZXMgYnkgZGVsZWdhdGluZyB0aGVtIGluZGl2aWR1YWxseS5cbiAgICAgIGZvciAobmFtZXMgPSBuYW1lLnNwbGl0KGV2ZW50U3BsaXR0ZXIpOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXZlbnRzID0gaXRlcmF0ZWUoZXZlbnRzLCBuYW1lc1tpXSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaW5hbGx5LCBzdGFuZGFyZCBldmVudHMuXG4gICAgICBldmVudHMgPSBpdGVyYXRlZShldmVudHMsIG5hbWUsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfTtcblxuICAvLyBCaW5kIGFuIGV2ZW50IHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi4gUGFzc2luZyBgXCJhbGxcImAgd2lsbCBiaW5kXG4gIC8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuICBFdmVudHMub24gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHJldHVybiBpbnRlcm5hbE9uKHRoaXMsIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBHdWFyZCB0aGUgYGxpc3RlbmluZ2AgYXJndW1lbnQgZnJvbSB0aGUgcHVibGljIEFQSS5cbiAgdmFyIGludGVybmFsT24gPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0LCBsaXN0ZW5pbmcpIHtcbiAgICBvYmouX2V2ZW50cyA9IGV2ZW50c0FwaShvbkFwaSwgb2JqLl9ldmVudHMgfHwge30sIG5hbWUsIGNhbGxiYWNrLCB7XG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIGN0eDogb2JqLFxuICAgICAgICBsaXN0ZW5pbmc6IGxpc3RlbmluZ1xuICAgIH0pO1xuXG4gICAgaWYgKGxpc3RlbmluZykge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IG9iai5fbGlzdGVuZXJzIHx8IChvYmouX2xpc3RlbmVycyA9IHt9KTtcbiAgICAgIGxpc3RlbmVyc1tsaXN0ZW5pbmcuaWRdID0gbGlzdGVuaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gSW52ZXJzaW9uLW9mLWNvbnRyb2wgdmVyc2lvbnMgb2YgYG9uYC4gVGVsbCAqdGhpcyogb2JqZWN0IHRvIGxpc3RlbiB0b1xuICAvLyBhbiBldmVudCBpbiBhbm90aGVyIG9iamVjdC4uLiBrZWVwaW5nIHRyYWNrIG9mIHdoYXQgaXQncyBsaXN0ZW5pbmcgdG9cbiAgLy8gZm9yIGVhc2llciB1bmJpbmRpbmcgbGF0ZXIuXG4gIEV2ZW50cy5saXN0ZW5UbyA9ICBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiB0aGlzO1xuICAgIHZhciBpZCA9IG9iai5fbGlzdGVuSWQgfHwgKG9iai5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvIHx8ICh0aGlzLl9saXN0ZW5pbmdUbyA9IHt9KTtcbiAgICB2YXIgbGlzdGVuaW5nID0gbGlzdGVuaW5nVG9baWRdO1xuXG4gICAgLy8gVGhpcyBvYmplY3QgaXMgbm90IGxpc3RlbmluZyB0byBhbnkgb3RoZXIgZXZlbnRzIG9uIGBvYmpgIHlldC5cbiAgICAvLyBTZXR1cCB0aGUgbmVjZXNzYXJ5IHJlZmVyZW5jZXMgdG8gdHJhY2sgdGhlIGxpc3RlbmluZyBjYWxsYmFja3MuXG4gICAgaWYgKCFsaXN0ZW5pbmcpIHtcbiAgICAgIHZhciB0aGlzSWQgPSB0aGlzLl9saXN0ZW5JZCB8fCAodGhpcy5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgICAgbGlzdGVuaW5nID0gbGlzdGVuaW5nVG9baWRdID0ge29iajogb2JqLCBvYmpJZDogaWQsIGlkOiB0aGlzSWQsIGxpc3RlbmluZ1RvOiBsaXN0ZW5pbmdUbywgY291bnQ6IDB9O1xuICAgIH1cblxuICAgIC8vIEJpbmQgY2FsbGJhY2tzIG9uIG9iaiwgYW5kIGtlZXAgdHJhY2sgb2YgdGhlbSBvbiBsaXN0ZW5pbmcuXG4gICAgaW50ZXJuYWxPbihvYmosIG5hbWUsIGNhbGxiYWNrLCB0aGlzLCBsaXN0ZW5pbmcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFRoZSByZWR1Y2luZyBBUEkgdGhhdCBhZGRzIGEgY2FsbGJhY2sgdG8gdGhlIGBldmVudHNgIG9iamVjdC5cbiAgdmFyIG9uQXBpID0gZnVuY3Rpb24oZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdIHx8IChldmVudHNbbmFtZV0gPSBbXSk7XG4gICAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCwgY3R4ID0gb3B0aW9ucy5jdHgsIGxpc3RlbmluZyA9IG9wdGlvbnMubGlzdGVuaW5nO1xuICAgICAgaWYgKGxpc3RlbmluZykgbGlzdGVuaW5nLmNvdW50Kys7XG5cbiAgICAgIGhhbmRsZXJzLnB1c2goeyBjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGN0eDogY29udGV4dCB8fCBjdHgsIGxpc3RlbmluZzogbGlzdGVuaW5nIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAvLyBjYWxsYmFja3Mgd2l0aCB0aGF0IGZ1bmN0aW9uLiBJZiBgY2FsbGJhY2tgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gIC8vIGNhbGxiYWNrcyBmb3IgdGhlIGV2ZW50LiBJZiBgbmFtZWAgaXMgbnVsbCwgcmVtb3ZlcyBhbGwgYm91bmRcbiAgLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuICBFdmVudHMub2ZmID0gIGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuICAgIHRoaXMuX2V2ZW50cyA9IGV2ZW50c0FwaShvZmZBcGksIHRoaXMuX2V2ZW50cywgbmFtZSwgY2FsbGJhY2ssIHtcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgbGlzdGVuZXJzOiB0aGlzLl9saXN0ZW5lcnNcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gIC8vIHRvIGV2ZXJ5IG9iamVjdCBpdCdzIGN1cnJlbnRseSBsaXN0ZW5pbmcgdG8uXG4gIEV2ZW50cy5zdG9wTGlzdGVuaW5nID0gIGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbztcbiAgICBpZiAoIWxpc3RlbmluZ1RvKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBpZHMgPSBvYmogPyBbb2JqLl9saXN0ZW5JZF0gOiBfLmtleXMobGlzdGVuaW5nVG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5pbmcgPSBsaXN0ZW5pbmdUb1tpZHNbaV1dO1xuXG4gICAgICAvLyBJZiBsaXN0ZW5pbmcgZG9lc24ndCBleGlzdCwgdGhpcyBvYmplY3QgaXMgbm90IGN1cnJlbnRseVxuICAgICAgLy8gbGlzdGVuaW5nIHRvIG9iai4gQnJlYWsgb3V0IGVhcmx5LlxuICAgICAgaWYgKCFsaXN0ZW5pbmcpIGJyZWFrO1xuXG4gICAgICBsaXN0ZW5pbmcub2JqLm9mZihuYW1lLCBjYWxsYmFjaywgdGhpcyk7XG4gICAgfVxuICAgIGlmIChfLmlzRW1wdHkobGlzdGVuaW5nVG8pKSB0aGlzLl9saXN0ZW5pbmdUbyA9IHZvaWQgMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFRoZSByZWR1Y2luZyBBUEkgdGhhdCByZW1vdmVzIGEgY2FsbGJhY2sgZnJvbSB0aGUgYGV2ZW50c2Agb2JqZWN0LlxuICB2YXIgb2ZmQXBpID0gZnVuY3Rpb24oZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghZXZlbnRzKSByZXR1cm47XG5cbiAgICB2YXIgaSA9IDAsIGxpc3RlbmluZztcbiAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCwgbGlzdGVuZXJzID0gb3B0aW9ucy5saXN0ZW5lcnM7XG5cbiAgICAvLyBEZWxldGUgYWxsIGV2ZW50cyBsaXN0ZW5lcnMgYW5kIFwiZHJvcFwiIGV2ZW50cy5cbiAgICBpZiAoIW5hbWUgJiYgIWNhbGxiYWNrICYmICFjb250ZXh0KSB7XG4gICAgICB2YXIgaWRzID0gXy5rZXlzKGxpc3RlbmVycyk7XG4gICAgICBmb3IgKDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaXN0ZW5pbmcgPSBsaXN0ZW5lcnNbaWRzW2ldXTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tsaXN0ZW5pbmcuaWRdO1xuICAgICAgICBkZWxldGUgbGlzdGVuaW5nLmxpc3RlbmluZ1RvW2xpc3RlbmluZy5vYmpJZF07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IF8ua2V5cyhldmVudHMpO1xuICAgIGZvciAoOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcblxuICAgICAgLy8gQmFpbCBvdXQgaWYgdGhlcmUgYXJlIG5vIGV2ZW50cyBzdG9yZWQuXG4gICAgICBpZiAoIWhhbmRsZXJzKSBicmVhaztcblxuICAgICAgLy8gUmVwbGFjZSBldmVudHMgaWYgdGhlcmUgYXJlIGFueSByZW1haW5pbmcuICBPdGhlcndpc2UsIGNsZWFuIHVwLlxuICAgICAgdmFyIHJlbWFpbmluZyA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW2pdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGhhbmRsZXIuY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIGNhbGxiYWNrICE9PSBoYW5kbGVyLmNhbGxiYWNrLl9jYWxsYmFjayB8fFxuICAgICAgICAgICAgICBjb250ZXh0ICYmIGNvbnRleHQgIT09IGhhbmRsZXIuY29udGV4dFxuICAgICAgICApIHtcbiAgICAgICAgICByZW1haW5pbmcucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0ZW5pbmcgPSBoYW5kbGVyLmxpc3RlbmluZztcbiAgICAgICAgICBpZiAobGlzdGVuaW5nICYmIC0tbGlzdGVuaW5nLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2xpc3RlbmluZy5pZF07XG4gICAgICAgICAgICBkZWxldGUgbGlzdGVuaW5nLmxpc3RlbmluZ1RvW2xpc3RlbmluZy5vYmpJZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0YWlsIGV2ZW50IGlmIHRoZSBsaXN0IGhhcyBhbnkgZXZlbnRzLiAgT3RoZXJ3aXNlLCBjbGVhbiB1cC5cbiAgICAgIGlmIChyZW1haW5pbmcubGVuZ3RoKSB7XG4gICAgICAgIGV2ZW50c1tuYW1lXSA9IHJlbWFpbmluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBldmVudHNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfLnNpemUoZXZlbnRzKSkgcmV0dXJuIGV2ZW50cztcbiAgfTtcblxuICAvLyBCaW5kIGFuIGV2ZW50IHRvIG9ubHkgYmUgdHJpZ2dlcmVkIGEgc2luZ2xlIHRpbWUuIEFmdGVyIHRoZSBmaXJzdCB0aW1lXG4gIC8vIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkLCBpdHMgbGlzdGVuZXIgd2lsbCBiZSByZW1vdmVkLiBJZiBtdWx0aXBsZSBldmVudHNcbiAgLy8gYXJlIHBhc3NlZCBpbiB1c2luZyB0aGUgc3BhY2Utc2VwYXJhdGVkIHN5bnRheCwgdGhlIGhhbmRsZXIgd2lsbCBmaXJlXG4gIC8vIG9uY2UgZm9yIGVhY2ggZXZlbnQsIG5vdCBvbmNlIGZvciBhIGNvbWJpbmF0aW9uIG9mIGFsbCBldmVudHMuXG4gIEV2ZW50cy5vbmNlID0gIGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgLy8gTWFwIHRoZSBldmVudCBpbnRvIGEgYHtldmVudDogb25jZX1gIG9iamVjdC5cbiAgICB2YXIgZXZlbnRzID0gZXZlbnRzQXBpKG9uY2VNYXAsIHt9LCBuYW1lLCBjYWxsYmFjaywgXy5iaW5kKHRoaXMub2ZmLCB0aGlzKSk7XG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnRzLCB2b2lkIDAsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEludmVyc2lvbi1vZi1jb250cm9sIHZlcnNpb25zIG9mIGBvbmNlYC5cbiAgRXZlbnRzLmxpc3RlblRvT25jZSA9ICBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgLy8gTWFwIHRoZSBldmVudCBpbnRvIGEgYHtldmVudDogb25jZX1gIG9iamVjdC5cbiAgICB2YXIgZXZlbnRzID0gZXZlbnRzQXBpKG9uY2VNYXAsIHt9LCBuYW1lLCBjYWxsYmFjaywgXy5iaW5kKHRoaXMuc3RvcExpc3RlbmluZywgdGhpcywgb2JqKSk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuVG8ob2JqLCBldmVudHMpO1xuICB9O1xuXG4gIC8vIFJlZHVjZXMgdGhlIGV2ZW50IGNhbGxiYWNrcyBpbnRvIGEgbWFwIG9mIGB7ZXZlbnQ6IG9uY2VXcmFwcGVyfWAuXG4gIC8vIGBvZmZlcmAgdW5iaW5kcyB0aGUgYG9uY2VXcmFwcGVyYCBhZnRlciBpdCBoYXMgYmVlbiBjYWxsZWQuXG4gIHZhciBvbmNlTWFwID0gZnVuY3Rpb24obWFwLCBuYW1lLCBjYWxsYmFjaywgb2ZmZXIpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBvbmNlID0gbWFwW25hbWVdID0gXy5vbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICBvZmZlcihuYW1lLCBvbmNlKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgICAgb25jZS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuICAvLyBUcmlnZ2VyIG9uZSBvciBtYW55IGV2ZW50cywgZmlyaW5nIGFsbCBib3VuZCBjYWxsYmFja3MuIENhbGxiYWNrcyBhcmVcbiAgLy8gcGFzc2VkIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBgdHJpZ2dlcmAgaXMsIGFwYXJ0IGZyb20gdGhlIGV2ZW50IG5hbWVcbiAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gIC8vIHJlY2VpdmUgdGhlIHRydWUgbmFtZSBvZiB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50KS5cbiAgRXZlbnRzLnRyaWdnZXIgPSAgZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heCgwLCBhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuXG4gICAgZXZlbnRzQXBpKHRyaWdnZXJBcGksIHRoaXMuX2V2ZW50cywgbmFtZSwgdm9pZCAwLCBhcmdzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBIYW5kbGVzIHRyaWdnZXJpbmcgdGhlIGFwcHJvcHJpYXRlIGV2ZW50IGNhbGxiYWNrcy5cbiAgdmFyIHRyaWdnZXJBcGkgPSBmdW5jdGlvbihvYmpFdmVudHMsIG5hbWUsIGNiLCBhcmdzKSB7XG4gICAgaWYgKG9iakV2ZW50cykge1xuICAgICAgdmFyIGV2ZW50cyA9IG9iakV2ZW50c1tuYW1lXTtcbiAgICAgIHZhciBhbGxFdmVudHMgPSBvYmpFdmVudHMuYWxsO1xuICAgICAgaWYgKGV2ZW50cyAmJiBhbGxFdmVudHMpIGFsbEV2ZW50cyA9IGFsbEV2ZW50cy5zbGljZSgpO1xuICAgICAgaWYgKGV2ZW50cykgdHJpZ2dlckV2ZW50cyhldmVudHMsIGFyZ3MpO1xuICAgICAgaWYgKGFsbEV2ZW50cykgdHJpZ2dlckV2ZW50cyhhbGxFdmVudHMsIFtuYW1lXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqRXZlbnRzO1xuICB9O1xuXG4gIC8vIEEgZGlmZmljdWx0LXRvLWJlbGlldmUsIGJ1dCBvcHRpbWl6ZWQgaW50ZXJuYWwgZGlzcGF0Y2ggZnVuY3Rpb24gZm9yXG4gIC8vIHRyaWdnZXJpbmcgZXZlbnRzLiBUcmllcyB0byBrZWVwIHRoZSB1c3VhbCBjYXNlcyBzcGVlZHkgKG1vc3QgaW50ZXJuYWxcbiAgLy8gQmFja2JvbmUgZXZlbnRzIGhhdmUgMyBhcmd1bWVudHMpLlxuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uKGV2ZW50cywgYXJncykge1xuICAgIHZhciBldiwgaSA9IC0xLCBsID0gZXZlbnRzLmxlbmd0aCwgYTEgPSBhcmdzWzBdLCBhMiA9IGFyZ3NbMV0sIGEzID0gYXJnc1syXTtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4KTsgcmV0dXJuO1xuICAgICAgY2FzZSAxOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEpOyByZXR1cm47XG4gICAgICBjYXNlIDI6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIpOyByZXR1cm47XG4gICAgICBjYXNlIDM6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIsIGEzKTsgcmV0dXJuO1xuICAgICAgZGVmYXVsdDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suYXBwbHkoZXYuY3R4LCBhcmdzKTsgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICAvLyBBbGlhc2VzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgRXZlbnRzLmJpbmQgICA9IEV2ZW50cy5vbjtcbiAgRXZlbnRzLnVuYmluZCA9IEV2ZW50cy5vZmY7XG5cbiAgLy8gQWxsb3cgdGhlIGBCYWNrYm9uZWAgb2JqZWN0IHRvIHNlcnZlIGFzIGEgZ2xvYmFsIGV2ZW50IGJ1cywgZm9yIGZvbGtzIHdob1xuICAvLyB3YW50IGdsb2JhbCBcInB1YnN1YlwiIGluIGEgY29udmVuaWVudCBwbGFjZS5cbiAgXy5leHRlbmQoQmFja2JvbmUsIEV2ZW50cyk7XG5cbiAgLy8gQmFja2JvbmUuTW9kZWxcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBCYWNrYm9uZSAqKk1vZGVscyoqIGFyZSB0aGUgYmFzaWMgZGF0YSBvYmplY3QgaW4gdGhlIGZyYW1ld29yayAtLVxuICAvLyBmcmVxdWVudGx5IHJlcHJlc2VudGluZyBhIHJvdyBpbiBhIHRhYmxlIGluIGEgZGF0YWJhc2Ugb24geW91ciBzZXJ2ZXIuXG4gIC8vIEEgZGlzY3JldGUgY2h1bmsgb2YgZGF0YSBhbmQgYSBidW5jaCBvZiB1c2VmdWwsIHJlbGF0ZWQgbWV0aG9kcyBmb3JcbiAgLy8gcGVyZm9ybWluZyBjb21wdXRhdGlvbnMgYW5kIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGF0IGRhdGEuXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IG1vZGVsIHdpdGggdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGVzLiBBIGNsaWVudCBpZCAoYGNpZGApXG4gIC8vIGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGFuZCBhc3NpZ25lZCBmb3IgeW91LlxuICB2YXIgTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbCA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgYXR0cnMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKHRoaXMuY2lkUHJlZml4KTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jb2xsZWN0aW9uKSB0aGlzLmNvbGxlY3Rpb24gPSBvcHRpb25zLmNvbGxlY3Rpb247XG4gICAgaWYgKG9wdGlvbnMucGFyc2UpIGF0dHJzID0gdGhpcy5wYXJzZShhdHRycywgb3B0aW9ucykgfHwge307XG4gICAgYXR0cnMgPSBfLmRlZmF1bHRzKHt9LCBhdHRycywgXy5yZXN1bHQodGhpcywgJ2RlZmF1bHRzJykpO1xuICAgIHRoaXMuc2V0KGF0dHJzLCBvcHRpb25zKTtcbiAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBBdHRhY2ggYWxsIGluaGVyaXRhYmxlIG1ldGhvZHMgdG8gdGhlIE1vZGVsIHByb3RvdHlwZS5cbiAgXy5leHRlbmQoTW9kZWwucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIEEgaGFzaCBvZiBhdHRyaWJ1dGVzIHdob3NlIGN1cnJlbnQgYW5kIHByZXZpb3VzIHZhbHVlIGRpZmZlci5cbiAgICBjaGFuZ2VkOiBudWxsLFxuXG4gICAgLy8gVGhlIHZhbHVlIHJldHVybmVkIGR1cmluZyB0aGUgbGFzdCBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICB2YWxpZGF0aW9uRXJyb3I6IG51bGwsXG5cbiAgICAvLyBUaGUgZGVmYXVsdCBuYW1lIGZvciB0aGUgSlNPTiBgaWRgIGF0dHJpYnV0ZSBpcyBgXCJpZFwiYC4gTW9uZ29EQiBhbmRcbiAgICAvLyBDb3VjaERCIHVzZXJzIG1heSB3YW50IHRvIHNldCB0aGlzIHRvIGBcIl9pZFwiYC5cbiAgICBpZEF0dHJpYnV0ZTogJ2lkJyxcblxuICAgIC8vIFRoZSBwcmVmaXggaXMgdXNlZCB0byBjcmVhdGUgdGhlIGNsaWVudCBpZCB3aGljaCBpcyB1c2VkIHRvIGlkZW50aWZ5IG1vZGVscyBsb2NhbGx5LlxuICAgIC8vIFlvdSBtYXkgd2FudCB0byBvdmVycmlkZSB0aGlzIGlmIHlvdSdyZSBleHBlcmllbmNpbmcgbmFtZSBjbGFzaGVzIHdpdGggbW9kZWwgaWRzLlxuICAgIGNpZFByZWZpeDogJ2MnLFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgbW9kZWwncyBgYXR0cmlidXRlc2Agb2JqZWN0LlxuICAgIHRvSlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQgLS0gYnV0IG92ZXJyaWRlIHRoaXMgaWYgeW91IG5lZWRcbiAgICAvLyBjdXN0b20gc3luY2luZyBzZW1hbnRpY3MgZm9yICp0aGlzKiBwYXJ0aWN1bGFyIG1vZGVsLlxuICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJhY2tib25lLnN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgZ2V0OiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIEhUTUwtZXNjYXBlZCB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgZXNjYXBlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gXy5lc2NhcGUodGhpcy5nZXQoYXR0cikpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXR0cmlidXRlIGNvbnRhaW5zIGEgdmFsdWUgdGhhdCBpcyBub3QgbnVsbFxuICAgIC8vIG9yIHVuZGVmaW5lZC5cbiAgICBoYXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChhdHRyKSAhPSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBTcGVjaWFsLWNhc2VkIHByb3h5IHRvIHVuZGVyc2NvcmUncyBgXy5tYXRjaGVzYCBtZXRob2QuXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIHJldHVybiAhIV8uaXRlcmF0ZWUoYXR0cnMsIHRoaXMpKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0LCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBUaGlzIGlzXG4gICAgLy8gdGhlIGNvcmUgcHJpbWl0aXZlIG9wZXJhdGlvbiBvZiBhIG1vZGVsLCB1cGRhdGluZyB0aGUgZGF0YSBhbmQgbm90aWZ5aW5nXG4gICAgLy8gYW55b25lIHdobyBuZWVkcyB0byBrbm93IGFib3V0IHRoZSBjaGFuZ2UgaW4gc3RhdGUuIFRoZSBoZWFydCBvZiB0aGUgYmVhc3QuXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbCwgb3B0aW9ucykge1xuICAgICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gdGhpcztcblxuICAgICAgLy8gSGFuZGxlIGJvdGggYFwia2V5XCIsIHZhbHVlYCBhbmQgYHtrZXk6IHZhbHVlfWAgLXN0eWxlIGFyZ3VtZW50cy5cbiAgICAgIHZhciBhdHRycztcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhdHRycyA9IGtleTtcbiAgICAgICAgb3B0aW9ucyA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChhdHRycyA9IHt9KVtrZXldID0gdmFsO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gICAgICAvLyBSdW4gdmFsaWRhdGlvbi5cbiAgICAgIGlmICghdGhpcy5fdmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIEV4dHJhY3QgYXR0cmlidXRlcyBhbmQgb3B0aW9ucy5cbiAgICAgIHZhciB1bnNldCAgICAgID0gb3B0aW9ucy51bnNldDtcbiAgICAgIHZhciBzaWxlbnQgICAgID0gb3B0aW9ucy5zaWxlbnQ7XG4gICAgICB2YXIgY2hhbmdlcyAgICA9IFtdO1xuICAgICAgdmFyIGNoYW5naW5nICAgPSB0aGlzLl9jaGFuZ2luZztcbiAgICAgIHRoaXMuX2NoYW5naW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFjaGFuZ2luZykge1xuICAgICAgICB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgPSBfLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIHZhciBjaGFuZ2VkID0gdGhpcy5jaGFuZ2VkO1xuICAgICAgdmFyIHByZXYgICAgPSB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXM7XG5cbiAgICAgIC8vIEZvciBlYWNoIGBzZXRgIGF0dHJpYnV0ZSwgdXBkYXRlIG9yIGRlbGV0ZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgdmFsID0gYXR0cnNbYXR0cl07XG4gICAgICAgIGlmICghXy5pc0VxdWFsKGN1cnJlbnRbYXR0cl0sIHZhbCkpIGNoYW5nZXMucHVzaChhdHRyKTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwocHJldlthdHRyXSwgdmFsKSkge1xuICAgICAgICAgIGNoYW5nZWRbYXR0cl0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGNoYW5nZWRbYXR0cl07XG4gICAgICAgIH1cbiAgICAgICAgdW5zZXQgPyBkZWxldGUgY3VycmVudFthdHRyXSA6IGN1cnJlbnRbYXR0cl0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgYGlkYC5cbiAgICAgIHRoaXMuaWQgPSB0aGlzLmdldCh0aGlzLmlkQXR0cmlidXRlKTtcblxuICAgICAgLy8gVHJpZ2dlciBhbGwgcmVsZXZhbnQgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGgpIHRoaXMuX3BlbmRpbmcgPSBvcHRpb25zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgY2hhbmdlc1tpXSwgdGhpcywgY3VycmVudFtjaGFuZ2VzW2ldXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gWW91IG1pZ2h0IGJlIHdvbmRlcmluZyB3aHkgdGhlcmUncyBhIGB3aGlsZWAgbG9vcCBoZXJlLiBDaGFuZ2VzIGNhblxuICAgICAgLy8gYmUgcmVjdXJzaXZlbHkgbmVzdGVkIHdpdGhpbiBgXCJjaGFuZ2VcImAgZXZlbnRzLlxuICAgICAgaWYgKGNoYW5naW5nKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMuX3BlbmRpbmc7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NoYW5naW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gYHVuc2V0YCBpcyBhIG5vb3BcbiAgICAvLyBpZiB0aGUgYXR0cmlidXRlIGRvZXNuJ3QgZXhpc3QuXG4gICAgdW5zZXQ6IGZ1bmN0aW9uKGF0dHIsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChhdHRyLCB2b2lkIDAsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIENsZWFyIGFsbCBhdHRyaWJ1dGVzIG9uIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC5cbiAgICBjbGVhcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzKSBhdHRyc1trZXldID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHJzLCBfLmV4dGVuZCh7fSwgb3B0aW9ucywge3Vuc2V0OiB0cnVlfSkpO1xuICAgIH0sXG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIG1vZGVsIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGBcImNoYW5nZVwiYCBldmVudC5cbiAgICAvLyBJZiB5b3Ugc3BlY2lmeSBhbiBhdHRyaWJ1dGUgbmFtZSwgZGV0ZXJtaW5lIGlmIHRoYXQgYXR0cmlidXRlIGhhcyBjaGFuZ2VkLlxuICAgIGhhc0NoYW5nZWQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChhdHRyID09IG51bGwpIHJldHVybiAhXy5pc0VtcHR5KHRoaXMuY2hhbmdlZCk7XG4gICAgICByZXR1cm4gXy5oYXModGhpcy5jaGFuZ2VkLCBhdHRyKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgYXR0cmlidXRlcyB0aGF0IGhhdmUgY2hhbmdlZCwgb3JcbiAgICAvLyBmYWxzZSBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlZCBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIGRldGVybWluaW5nIHdoYXRcbiAgICAvLyBwYXJ0cyBvZiBhIHZpZXcgbmVlZCB0byBiZSB1cGRhdGVkIGFuZC9vciB3aGF0IGF0dHJpYnV0ZXMgbmVlZCB0byBiZVxuICAgIC8vIHBlcnNpc3RlZCB0byB0aGUgc2VydmVyLiBVbnNldCBhdHRyaWJ1dGVzIHdpbGwgYmUgc2V0IHRvIHVuZGVmaW5lZC5cbiAgICAvLyBZb3UgY2FuIGFsc28gcGFzcyBhbiBhdHRyaWJ1dGVzIG9iamVjdCB0byBkaWZmIGFnYWluc3QgdGhlIG1vZGVsLFxuICAgIC8vIGRldGVybWluaW5nIGlmIHRoZXJlICp3b3VsZCBiZSogYSBjaGFuZ2UuXG4gICAgY2hhbmdlZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGRpZmYpIHtcbiAgICAgIGlmICghZGlmZikgcmV0dXJuIHRoaXMuaGFzQ2hhbmdlZCgpID8gXy5jbG9uZSh0aGlzLmNoYW5nZWQpIDogZmFsc2U7XG4gICAgICB2YXIgb2xkID0gdGhpcy5fY2hhbmdpbmcgPyB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgOiB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICB2YXIgY2hhbmdlZCA9IHt9O1xuICAgICAgZm9yICh2YXIgYXR0ciBpbiBkaWZmKSB7XG4gICAgICAgIHZhciB2YWwgPSBkaWZmW2F0dHJdO1xuICAgICAgICBpZiAoXy5pc0VxdWFsKG9sZFthdHRyXSwgdmFsKSkgY29udGludWU7XG4gICAgICAgIGNoYW5nZWRbYXR0cl0gPSB2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gXy5zaXplKGNoYW5nZWQpID8gY2hhbmdlZCA6IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHByZXZpb3VzIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSwgcmVjb3JkZWQgYXQgdGhlIHRpbWUgdGhlIGxhc3RcbiAgICAvLyBgXCJjaGFuZ2VcImAgZXZlbnQgd2FzIGZpcmVkLlxuICAgIHByZXZpb3VzOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoYXR0ciA9PSBudWxsIHx8ICF0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlc1thdHRyXTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFsbCBvZiB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbW9kZWwgYXQgdGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzXG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIHByZXZpb3VzQXR0cmlidXRlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBGZXRjaCB0aGUgbW9kZWwgZnJvbSB0aGUgc2VydmVyLCBtZXJnaW5nIHRoZSByZXNwb25zZSB3aXRoIHRoZSBtb2RlbCdzXG4gICAgLy8gbG9jYWwgYXR0cmlidXRlcy4gQW55IGNoYW5nZWQgYXR0cmlidXRlcyB3aWxsIHRyaWdnZXIgYSBcImNoYW5nZVwiIGV2ZW50LlxuICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe3BhcnNlOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIHZhciBzZXJ2ZXJBdHRycyA9IG9wdGlvbnMucGFyc2UgPyBtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKSA6IHJlc3A7XG4gICAgICAgIGlmICghbW9kZWwuc2V0KHNlcnZlckF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcy5jYWxsKG9wdGlvbnMuY29udGV4dCwgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzLCBhbmQgc3luYyB0aGUgbW9kZWwgdG8gdGhlIHNlcnZlci5cbiAgICAvLyBJZiB0aGUgc2VydmVyIHJldHVybnMgYW4gYXR0cmlidXRlcyBoYXNoIHRoYXQgZGlmZmVycywgdGhlIG1vZGVsJ3NcbiAgICAvLyBzdGF0ZSB3aWxsIGJlIGBzZXRgIGFnYWluLlxuICAgIHNhdmU6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7dmFsaWRhdGU6IHRydWUsIHBhcnNlOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgICB2YXIgd2FpdCA9IG9wdGlvbnMud2FpdDtcblxuICAgICAgLy8gSWYgd2UncmUgbm90IHdhaXRpbmcgYW5kIGF0dHJpYnV0ZXMgZXhpc3QsIHNhdmUgYWN0cyBhc1xuICAgICAgLy8gYHNldChhdHRyKS5zYXZlKG51bGwsIG9wdHMpYCB3aXRoIHZhbGlkYXRpb24uIE90aGVyd2lzZSwgY2hlY2sgaWZcbiAgICAgIC8vIHRoZSBtb2RlbCB3aWxsIGJlIHZhbGlkIHdoZW4gdGhlIGF0dHJpYnV0ZXMsIGlmIGFueSwgYXJlIHNldC5cbiAgICAgIGlmIChhdHRycyAmJiAhd2FpdCkge1xuICAgICAgICBpZiAoIXRoaXMuc2V0KGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQWZ0ZXIgYSBzdWNjZXNzZnVsIHNlcnZlci1zaWRlIHNhdmUsIHRoZSBjbGllbnQgaXMgKG9wdGlvbmFsbHkpXG4gICAgICAvLyB1cGRhdGVkIHdpdGggdGhlIHNlcnZlci1zaWRlIHN0YXRlLlxuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIC8vIEVuc3VyZSBhdHRyaWJ1dGVzIGFyZSByZXN0b3JlZCBkdXJpbmcgc3luY2hyb25vdXMgc2F2ZXMuXG4gICAgICAgIG1vZGVsLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgc2VydmVyQXR0cnMgPSBvcHRpb25zLnBhcnNlID8gbW9kZWwucGFyc2UocmVzcCwgb3B0aW9ucykgOiByZXNwO1xuICAgICAgICBpZiAod2FpdCkgc2VydmVyQXR0cnMgPSBfLmV4dGVuZCh7fSwgYXR0cnMsIHNlcnZlckF0dHJzKTtcbiAgICAgICAgaWYgKHNlcnZlckF0dHJzICYmICFtb2RlbC5zZXQoc2VydmVyQXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwob3B0aW9ucy5jb250ZXh0LCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBTZXQgdGVtcG9yYXJ5IGF0dHJpYnV0ZXMgaWYgYHt3YWl0OiB0cnVlfWAgdG8gcHJvcGVybHkgZmluZCBuZXcgaWRzLlxuICAgICAgaWYgKGF0dHJzICYmIHdhaXQpIHRoaXMuYXR0cmlidXRlcyA9IF8uZXh0ZW5kKHt9LCBhdHRyaWJ1dGVzLCBhdHRycyk7XG5cbiAgICAgIHZhciBtZXRob2QgPSB0aGlzLmlzTmV3KCkgPyAnY3JlYXRlJyA6IChvcHRpb25zLnBhdGNoID8gJ3BhdGNoJyA6ICd1cGRhdGUnKTtcbiAgICAgIGlmIChtZXRob2QgPT09ICdwYXRjaCcgJiYgIW9wdGlvbnMuYXR0cnMpIG9wdGlvbnMuYXR0cnMgPSBhdHRycztcbiAgICAgIHZhciB4aHIgPSB0aGlzLnN5bmMobWV0aG9kLCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgLy8gUmVzdG9yZSBhdHRyaWJ1dGVzLlxuICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuXG4gICAgLy8gRGVzdHJveSB0aGlzIG1vZGVsIG9uIHRoZSBzZXJ2ZXIgaWYgaXQgd2FzIGFscmVhZHkgcGVyc2lzdGVkLlxuICAgIC8vIE9wdGltaXN0aWNhbGx5IHJlbW92ZXMgdGhlIG1vZGVsIGZyb20gaXRzIGNvbGxlY3Rpb24sIGlmIGl0IGhhcyBvbmUuXG4gICAgLy8gSWYgYHdhaXQ6IHRydWVgIGlzIHBhc3NlZCwgd2FpdHMgZm9yIHRoZSBzZXJ2ZXIgdG8gcmVzcG9uZCBiZWZvcmUgcmVtb3ZhbC5cbiAgICBkZXN0cm95OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIHZhciB3YWl0ID0gb3B0aW9ucy53YWl0O1xuXG4gICAgICB2YXIgZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtb2RlbC5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ2Rlc3Ryb3knLCBtb2RlbCwgbW9kZWwuY29sbGVjdGlvbiwgb3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIGlmICh3YWl0KSBkZXN0cm95KCk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwob3B0aW9ucy5jb250ZXh0LCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghbW9kZWwuaXNOZXcoKSkgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciB4aHIgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcbiAgICAgICAgXy5kZWZlcihvcHRpb25zLnN1Y2Nlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB4aHIgPSB0aGlzLnN5bmMoJ2RlbGV0ZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKCF3YWl0KSBkZXN0cm95KCk7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH0sXG5cbiAgICAvLyBEZWZhdWx0IFVSTCBmb3IgdGhlIG1vZGVsJ3MgcmVwcmVzZW50YXRpb24gb24gdGhlIHNlcnZlciAtLSBpZiB5b3UncmVcbiAgICAvLyB1c2luZyBCYWNrYm9uZSdzIHJlc3RmdWwgbWV0aG9kcywgb3ZlcnJpZGUgdGhpcyB0byBjaGFuZ2UgdGhlIGVuZHBvaW50XG4gICAgLy8gdGhhdCB3aWxsIGJlIGNhbGxlZC5cbiAgICB1cmw6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJhc2UgPVxuICAgICAgICBfLnJlc3VsdCh0aGlzLCAndXJsUm9vdCcpIHx8XG4gICAgICAgIF8ucmVzdWx0KHRoaXMuY29sbGVjdGlvbiwgJ3VybCcpIHx8XG4gICAgICAgIHVybEVycm9yKCk7XG4gICAgICBpZiAodGhpcy5pc05ldygpKSByZXR1cm4gYmFzZTtcbiAgICAgIHZhciBpZCA9IHRoaXMuZ2V0KHRoaXMuaWRBdHRyaWJ1dGUpO1xuICAgICAgcmV0dXJuIGJhc2UucmVwbGFjZSgvW15cXC9dJC8sICckJi8nKSArIGVuY29kZVVSSUNvbXBvbmVudChpZCk7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gdGhlIGhhc2ggb2YgYXR0cmlidXRlcyB0byBiZSBgc2V0YCBvblxuICAgIC8vIHRoZSBtb2RlbC4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMganVzdCB0byBwYXNzIHRoZSByZXNwb25zZSBhbG9uZy5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIGlkZW50aWNhbCBhdHRyaWJ1dGVzIHRvIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBBIG1vZGVsIGlzIG5ldyBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzYXZlZCB0byB0aGUgc2VydmVyLCBhbmQgbGFja3MgYW4gaWQuXG4gICAgaXNOZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhcyh0aGlzLmlkQXR0cmlidXRlKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIG1vZGVsIGlzIGN1cnJlbnRseSBpbiBhIHZhbGlkIHN0YXRlLlxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZSh7fSwgXy5kZWZhdWx0cyh7dmFsaWRhdGU6IHRydWV9LCBvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJ1biB2YWxpZGF0aW9uIGFnYWluc3QgdGhlIG5leHQgY29tcGxldGUgc2V0IG9mIG1vZGVsIGF0dHJpYnV0ZXMsXG4gICAgLy8gcmV0dXJuaW5nIGB0cnVlYCBpZiBhbGwgaXMgd2VsbC4gT3RoZXJ3aXNlLCBmaXJlIGFuIGBcImludmFsaWRcImAgZXZlbnQuXG4gICAgX3ZhbGlkYXRlOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zLnZhbGlkYXRlIHx8ICF0aGlzLnZhbGlkYXRlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGF0dHJzID0gXy5leHRlbmQoe30sIHRoaXMuYXR0cmlidXRlcywgYXR0cnMpO1xuICAgICAgdmFyIGVycm9yID0gdGhpcy52YWxpZGF0aW9uRXJyb3IgPSB0aGlzLnZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSB8fCBudWxsO1xuICAgICAgaWYgKCFlcnJvcikgcmV0dXJuIHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBlcnJvciwgXy5leHRlbmQob3B0aW9ucywge3ZhbGlkYXRpb25FcnJvcjogZXJyb3J9KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBNb2RlbCwgbWFwcGVkIHRvIHRoZVxuICAvLyBudW1iZXIgb2YgYXJndW1lbnRzIHRoZXkgdGFrZS5cbiAgdmFyIG1vZGVsTWV0aG9kcyA9IHsga2V5czogMSwgdmFsdWVzOiAxLCBwYWlyczogMSwgaW52ZXJ0OiAxLCBwaWNrOiAwLFxuICAgICAgb21pdDogMCwgY2hhaW46IDEsIGlzRW1wdHk6IDEgfTtcblxuICAvLyBNaXggaW4gZWFjaCBVbmRlcnNjb3JlIG1ldGhvZCBhcyBhIHByb3h5IHRvIGBNb2RlbCNhdHRyaWJ1dGVzYC5cbiAgYWRkVW5kZXJzY29yZU1ldGhvZHMoTW9kZWwsIG1vZGVsTWV0aG9kcywgJ2F0dHJpYnV0ZXMnKTtcblxuICAvLyBCYWNrYm9uZS5Db2xsZWN0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBJZiBtb2RlbHMgdGVuZCB0byByZXByZXNlbnQgYSBzaW5nbGUgcm93IG9mIGRhdGEsIGEgQmFja2JvbmUgQ29sbGVjdGlvbiBpc1xuICAvLyBtb3JlIGFuYWxvZ291cyB0byBhIHRhYmxlIGZ1bGwgb2YgZGF0YSAuLi4gb3IgYSBzbWFsbCBzbGljZSBvciBwYWdlIG9mIHRoYXRcbiAgLy8gdGFibGUsIG9yIGEgY29sbGVjdGlvbiBvZiByb3dzIHRoYXQgYmVsb25nIHRvZ2V0aGVyIGZvciBhIHBhcnRpY3VsYXIgcmVhc29uXG4gIC8vIC0tIGFsbCBvZiB0aGUgbWVzc2FnZXMgaW4gdGhpcyBwYXJ0aWN1bGFyIGZvbGRlciwgYWxsIG9mIHRoZSBkb2N1bWVudHNcbiAgLy8gYmVsb25naW5nIHRvIHRoaXMgcGFydGljdWxhciBhdXRob3IsIGFuZCBzbyBvbi4gQ29sbGVjdGlvbnMgbWFpbnRhaW5cbiAgLy8gaW5kZXhlcyBvZiB0aGVpciBtb2RlbHMsIGJvdGggaW4gb3JkZXIsIGFuZCBmb3IgbG9va3VwIGJ5IGBpZGAuXG5cbiAgLy8gQ3JlYXRlIGEgbmV3ICoqQ29sbGVjdGlvbioqLCBwZXJoYXBzIHRvIGNvbnRhaW4gYSBzcGVjaWZpYyB0eXBlIG9mIGBtb2RlbGAuXG4gIC8vIElmIGEgYGNvbXBhcmF0b3JgIGlzIHNwZWNpZmllZCwgdGhlIENvbGxlY3Rpb24gd2lsbCBtYWludGFpblxuICAvLyBpdHMgbW9kZWxzIGluIHNvcnQgb3JkZXIsIGFzIHRoZXkncmUgYWRkZWQgYW5kIHJlbW92ZWQuXG4gIHZhciBDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgaWYgKG9wdGlvbnMubW9kZWwpIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIGlmIChvcHRpb25zLmNvbXBhcmF0b3IgIT09IHZvaWQgMCkgdGhpcy5jb21wYXJhdG9yID0gb3B0aW9ucy5jb21wYXJhdG9yO1xuICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKG1vZGVscykgdGhpcy5yZXNldChtb2RlbHMsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XG4gIH07XG5cbiAgLy8gRGVmYXVsdCBvcHRpb25zIGZvciBgQ29sbGVjdGlvbiNzZXRgLlxuICB2YXIgc2V0T3B0aW9ucyA9IHthZGQ6IHRydWUsIHJlbW92ZTogdHJ1ZSwgbWVyZ2U6IHRydWV9O1xuICB2YXIgYWRkT3B0aW9ucyA9IHthZGQ6IHRydWUsIHJlbW92ZTogZmFsc2V9O1xuXG4gIC8vIFNwbGljZXMgYGluc2VydGAgaW50byBgYXJyYXlgIGF0IGluZGV4IGBhdGAuXG4gIHZhciBzcGxpY2UgPSBmdW5jdGlvbihhcnJheSwgaW5zZXJ0LCBhdCkge1xuICAgIGF0ID0gTWF0aC5taW4oTWF0aC5tYXgoYXQsIDApLCBhcnJheS5sZW5ndGgpO1xuICAgIHZhciB0YWlsID0gQXJyYXkoYXJyYXkubGVuZ3RoIC0gYXQpO1xuICAgIHZhciBsZW5ndGggPSBpbnNlcnQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFpbC5sZW5ndGg7IGkrKykgdGFpbFtpXSA9IGFycmF5W2kgKyBhdF07XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSBhcnJheVtpICsgYXRdID0gaW5zZXJ0W2ldO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0YWlsLmxlbmd0aDsgaSsrKSBhcnJheVtpICsgbGVuZ3RoICsgYXRdID0gdGFpbFtpXTtcbiAgfTtcblxuICAvLyBEZWZpbmUgdGhlIENvbGxlY3Rpb24ncyBpbmhlcml0YWJsZSBtZXRob2RzLlxuICBfLmV4dGVuZChDb2xsZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBtb2RlbCBmb3IgYSBjb2xsZWN0aW9uIGlzIGp1c3QgYSAqKkJhY2tib25lLk1vZGVsKiouXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBtb3N0IGNhc2VzLlxuICAgIG1vZGVsOiBNb2RlbCxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29sbGVjdGlvbiBpcyBhbiBhcnJheSBvZiB0aGVcbiAgICAvLyBtb2RlbHMnIGF0dHJpYnV0ZXMuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLnRvSlNPTihvcHRpb25zKTsgfSk7XG4gICAgfSxcblxuICAgIC8vIFByb3h5IGBCYWNrYm9uZS5zeW5jYCBieSBkZWZhdWx0LlxuICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJhY2tib25lLnN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwsIG9yIGxpc3Qgb2YgbW9kZWxzIHRvIHRoZSBzZXQuIGBtb2RlbHNgIG1heSBiZSBCYWNrYm9uZVxuICAgIC8vIE1vZGVscyBvciByYXcgSmF2YVNjcmlwdCBvYmplY3RzIHRvIGJlIGNvbnZlcnRlZCB0byBNb2RlbHMsIG9yIGFueVxuICAgIC8vIGNvbWJpbmF0aW9uIG9mIHRoZSB0d28uXG4gICAgYWRkOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChtb2RlbHMsIF8uZXh0ZW5kKHttZXJnZTogZmFsc2V9LCBvcHRpb25zLCBhZGRPcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsLCBvciBhIGxpc3Qgb2YgbW9kZWxzIGZyb20gdGhlIHNldC5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gW21vZGVsc10gOiBfLmNsb25lKG1vZGVscyk7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuX3JlbW92ZU1vZGVscyhtb2RlbHMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCAmJiByZW1vdmVkKSB0aGlzLnRyaWdnZXIoJ3VwZGF0ZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gcmVtb3ZlZFswXSA6IHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSBhIGNvbGxlY3Rpb24gYnkgYHNldGAtaW5nIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCBhZGRpbmcgbmV3IG9uZXMsXG4gICAgLy8gcmVtb3ZpbmcgbW9kZWxzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LCBhbmQgbWVyZ2luZyBtb2RlbHMgdGhhdFxuICAgIC8vIGFscmVhZHkgZXhpc3QgaW4gdGhlIGNvbGxlY3Rpb24sIGFzIG5lY2Vzc2FyeS4gU2ltaWxhciB0byAqKk1vZGVsI3NldCoqLFxuICAgIC8vIHRoZSBjb3JlIG9wZXJhdGlvbiBmb3IgdXBkYXRpbmcgdGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBjb2xsZWN0aW9uLlxuICAgIHNldDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICBpZiAobW9kZWxzID09IG51bGwpIHJldHVybjtcblxuICAgICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMoe30sIG9wdGlvbnMsIHNldE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2UgJiYgIXRoaXMuX2lzTW9kZWwobW9kZWxzKSkgbW9kZWxzID0gdGhpcy5wYXJzZShtb2RlbHMsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IFttb2RlbHNdIDogbW9kZWxzLnNsaWNlKCk7XG5cbiAgICAgIHZhciBhdCA9IG9wdGlvbnMuYXQ7XG4gICAgICBpZiAoYXQgIT0gbnVsbCkgYXQgPSArYXQ7XG4gICAgICBpZiAoYXQgPCAwKSBhdCArPSB0aGlzLmxlbmd0aCArIDE7XG5cbiAgICAgIHZhciBzZXQgPSBbXTtcbiAgICAgIHZhciB0b0FkZCA9IFtdO1xuICAgICAgdmFyIHRvUmVtb3ZlID0gW107XG4gICAgICB2YXIgbW9kZWxNYXAgPSB7fTtcblxuICAgICAgdmFyIGFkZCA9IG9wdGlvbnMuYWRkO1xuICAgICAgdmFyIG1lcmdlID0gb3B0aW9ucy5tZXJnZTtcbiAgICAgIHZhciByZW1vdmUgPSBvcHRpb25zLnJlbW92ZTtcblxuICAgICAgdmFyIHNvcnQgPSBmYWxzZTtcbiAgICAgIHZhciBzb3J0YWJsZSA9IHRoaXMuY29tcGFyYXRvciAmJiAoYXQgPT0gbnVsbCkgJiYgb3B0aW9ucy5zb3J0ICE9PSBmYWxzZTtcbiAgICAgIHZhciBzb3J0QXR0ciA9IF8uaXNTdHJpbmcodGhpcy5jb21wYXJhdG9yKSA/IHRoaXMuY29tcGFyYXRvciA6IG51bGw7XG5cbiAgICAgIC8vIFR1cm4gYmFyZSBvYmplY3RzIGludG8gbW9kZWwgcmVmZXJlbmNlcywgYW5kIHByZXZlbnQgaW52YWxpZCBtb2RlbHNcbiAgICAgIC8vIGZyb20gYmVpbmcgYWRkZWQuXG4gICAgICB2YXIgbW9kZWw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtb2RlbCA9IG1vZGVsc1tpXTtcblxuICAgICAgICAvLyBJZiBhIGR1cGxpY2F0ZSBpcyBmb3VuZCwgcHJldmVudCBpdCBmcm9tIGJlaW5nIGFkZGVkIGFuZFxuICAgICAgICAvLyBvcHRpb25hbGx5IG1lcmdlIGl0IGludG8gdGhlIGV4aXN0aW5nIG1vZGVsLlxuICAgICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChtb2RlbCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgIGlmIChtZXJnZSAmJiBtb2RlbCAhPT0gZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHRoaXMuX2lzTW9kZWwobW9kZWwpID8gbW9kZWwuYXR0cmlidXRlcyA6IG1vZGVsO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFyc2UpIGF0dHJzID0gZXhpc3RpbmcucGFyc2UoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgZXhpc3Rpbmcuc2V0KGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzb3J0YWJsZSAmJiAhc29ydCkgc29ydCA9IGV4aXN0aW5nLmhhc0NoYW5nZWQoc29ydEF0dHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW1vZGVsTWFwW2V4aXN0aW5nLmNpZF0pIHtcbiAgICAgICAgICAgIG1vZGVsTWFwW2V4aXN0aW5nLmNpZF0gPSB0cnVlO1xuICAgICAgICAgICAgc2V0LnB1c2goZXhpc3RpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlbHNbaV0gPSBleGlzdGluZztcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3LCB2YWxpZCBtb2RlbCwgcHVzaCBpdCB0byB0aGUgYHRvQWRkYCBsaXN0LlxuICAgICAgICB9IGVsc2UgaWYgKGFkZCkge1xuICAgICAgICAgIG1vZGVsID0gbW9kZWxzW2ldID0gdGhpcy5fcHJlcGFyZU1vZGVsKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgIHRvQWRkLnB1c2gobW9kZWwpO1xuICAgICAgICAgICAgdGhpcy5fYWRkUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIG1vZGVsTWFwW21vZGVsLmNpZF0gPSB0cnVlO1xuICAgICAgICAgICAgc2V0LnB1c2gobW9kZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgc3RhbGUgbW9kZWxzLlxuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1vZGVsID0gdGhpcy5tb2RlbHNbaV07XG4gICAgICAgICAgaWYgKCFtb2RlbE1hcFttb2RlbC5jaWRdKSB0b1JlbW92ZS5wdXNoKG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9SZW1vdmUubGVuZ3RoKSB0aGlzLl9yZW1vdmVNb2RlbHModG9SZW1vdmUsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZWUgaWYgc29ydGluZyBpcyBuZWVkZWQsIHVwZGF0ZSBgbGVuZ3RoYCBhbmQgc3BsaWNlIGluIG5ldyBtb2RlbHMuXG4gICAgICB2YXIgb3JkZXJDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgcmVwbGFjZSA9ICFzb3J0YWJsZSAmJiBhZGQgJiYgcmVtb3ZlO1xuICAgICAgaWYgKHNldC5sZW5ndGggJiYgcmVwbGFjZSkge1xuICAgICAgICBvcmRlckNoYW5nZWQgPSB0aGlzLmxlbmd0aCAhPSBzZXQubGVuZ3RoIHx8IF8uc29tZSh0aGlzLm1vZGVscywgZnVuY3Rpb24obW9kZWwsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIG1vZGVsICE9PSBzZXRbaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2RlbHMubGVuZ3RoID0gMDtcbiAgICAgICAgc3BsaWNlKHRoaXMubW9kZWxzLCBzZXQsIDApO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubW9kZWxzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAodG9BZGQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzb3J0YWJsZSkgc29ydCA9IHRydWU7XG4gICAgICAgIHNwbGljZSh0aGlzLm1vZGVscywgdG9BZGQsIGF0ID09IG51bGwgPyB0aGlzLmxlbmd0aCA6IGF0KTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLm1vZGVscy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpbGVudGx5IHNvcnQgdGhlIGNvbGxlY3Rpb24gaWYgYXBwcm9wcmlhdGUuXG4gICAgICBpZiAoc29ydCkgdGhpcy5zb3J0KHtzaWxlbnQ6IHRydWV9KTtcblxuICAgICAgLy8gVW5sZXNzIHNpbGVuY2VkLCBpdCdzIHRpbWUgdG8gZmlyZSBhbGwgYXBwcm9wcmlhdGUgYWRkL3NvcnQgZXZlbnRzLlxuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXQgIT0gbnVsbCkgb3B0aW9ucy5pbmRleCA9IGF0ICsgaTtcbiAgICAgICAgICBtb2RlbCA9IHRvQWRkW2ldO1xuICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ2FkZCcsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ydCB8fCBvcmRlckNoYW5nZWQpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodG9BZGQubGVuZ3RoIHx8IHRvUmVtb3ZlLmxlbmd0aCkgdGhpcy50cmlnZ2VyKCd1cGRhdGUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHRoZSBhZGRlZCAob3IgbWVyZ2VkKSBtb2RlbCAob3IgbW9kZWxzKS5cbiAgICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcbiAgICB9LFxuXG4gICAgLy8gV2hlbiB5b3UgaGF2ZSBtb3JlIGl0ZW1zIHRoYW4geW91IHdhbnQgdG8gYWRkIG9yIHJlbW92ZSBpbmRpdmlkdWFsbHksXG4gICAgLy8geW91IGNhbiByZXNldCB0aGUgZW50aXJlIHNldCB3aXRoIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCB3aXRob3V0IGZpcmluZ1xuICAgIC8vIGFueSBncmFudWxhciBgYWRkYCBvciBgcmVtb3ZlYCBldmVudHMuIEZpcmVzIGByZXNldGAgd2hlbiBmaW5pc2hlZC5cbiAgICAvLyBVc2VmdWwgZm9yIGJ1bGsgb3BlcmF0aW9ucyBhbmQgb3B0aW1pemF0aW9ucy5cbiAgICByZXNldDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKHRoaXMubW9kZWxzW2ldLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMucHJldmlvdXNNb2RlbHMgPSB0aGlzLm1vZGVscztcbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICBtb2RlbHMgPSB0aGlzLmFkZChtb2RlbHMsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3Jlc2V0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHB1c2g6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogdGhpcy5sZW5ndGh9LCBvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBwb3A6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQodGhpcy5sZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgdW5zaGlmdDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiAwfSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2hpZnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQoMCk7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBTbGljZSBvdXQgYSBzdWItYXJyYXkgb2YgbW9kZWxzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNsaWNlLmFwcGx5KHRoaXMubW9kZWxzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBtb2RlbCBmcm9tIHRoZSBzZXQgYnkgaWQuXG4gICAgZ2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZCh0aGlzLl9pc01vZGVsKG9iaikgPyBvYmouYXR0cmlidXRlcyA6IG9iaik7XG4gICAgICByZXR1cm4gdGhpcy5fYnlJZFtvYmpdIHx8IHRoaXMuX2J5SWRbaWRdIHx8IHRoaXMuX2J5SWRbb2JqLmNpZF07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgbW9kZWwgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggKz0gdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlbHNbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gbW9kZWxzIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXMgb2ZcbiAgICAvLyBgZmlsdGVyYC5cbiAgICB3aGVyZTogZnVuY3Rpb24oYXR0cnMsIGZpcnN0KSB7XG4gICAgICByZXR1cm4gdGhpc1tmaXJzdCA/ICdmaW5kJyA6ICdmaWx0ZXInXShhdHRycyk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0aGUgZmlyc3QgbW9kZWwgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIHNpbXBsZSBjYXNlc1xuICAgIC8vIG9mIGBmaW5kYC5cbiAgICBmaW5kV2hlcmU6IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICByZXR1cm4gdGhpcy53aGVyZShhdHRycywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8vIEZvcmNlIHRoZSBjb2xsZWN0aW9uIHRvIHJlLXNvcnQgaXRzZWxmLiBZb3UgZG9uJ3QgbmVlZCB0byBjYWxsIHRoaXMgdW5kZXJcbiAgICAvLyBub3JtYWwgY2lyY3Vtc3RhbmNlcywgYXMgdGhlIHNldCB3aWxsIG1haW50YWluIHNvcnQgb3JkZXIgYXMgZWFjaCBpdGVtXG4gICAgLy8gaXMgYWRkZWQuXG4gICAgc29ydDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLmNvbXBhcmF0b3I7XG4gICAgICBpZiAoIWNvbXBhcmF0b3IpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNvcnQgYSBzZXQgd2l0aG91dCBhIGNvbXBhcmF0b3InKTtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBjb21wYXJhdG9yLmxlbmd0aDtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oY29tcGFyYXRvcikpIGNvbXBhcmF0b3IgPSBfLmJpbmQoY29tcGFyYXRvciwgdGhpcyk7XG5cbiAgICAgIC8vIFJ1biBzb3J0IGJhc2VkIG9uIHR5cGUgb2YgYGNvbXBhcmF0b3JgLlxuICAgICAgaWYgKGxlbmd0aCA9PT0gMSB8fCBfLmlzU3RyaW5nKGNvbXBhcmF0b3IpKSB7XG4gICAgICAgIHRoaXMubW9kZWxzID0gdGhpcy5zb3J0QnkoY29tcGFyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1vZGVscy5zb3J0KGNvbXBhcmF0b3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUGx1Y2sgYW4gYXR0cmlidXRlIGZyb20gZWFjaCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICBwbHVjazogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIF8uaW52b2tlKHRoaXMubW9kZWxzLCAnZ2V0JywgYXR0cik7XG4gICAgfSxcblxuICAgIC8vIEZldGNoIHRoZSBkZWZhdWx0IHNldCBvZiBtb2RlbHMgZm9yIHRoaXMgY29sbGVjdGlvbiwgcmVzZXR0aW5nIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gd2hlbiB0aGV5IGFycml2ZS4gSWYgYHJlc2V0OiB0cnVlYCBpcyBwYXNzZWQsIHRoZSByZXNwb25zZVxuICAgIC8vIGRhdGEgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgYHJlc2V0YCBtZXRob2QgaW5zdGVhZCBvZiBgc2V0YC5cbiAgICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtwYXJzZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvcHRpb25zLnJlc2V0ID8gJ3Jlc2V0JyA6ICdzZXQnO1xuICAgICAgICBjb2xsZWN0aW9uW21ldGhvZF0ocmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwob3B0aW9ucy5jb250ZXh0LCBjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgY29sbGVjdGlvbi50cmlnZ2VyKCdzeW5jJywgY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBtb2RlbCBpbiB0aGlzIGNvbGxlY3Rpb24uIEFkZCB0aGUgbW9kZWwgdG8gdGhlXG4gICAgLy8gY29sbGVjdGlvbiBpbW1lZGlhdGVseSwgdW5sZXNzIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICAvLyB3YWl0IGZvciB0aGUgc2VydmVyIHRvIGFncmVlLlxuICAgIGNyZWF0ZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgdmFyIHdhaXQgPSBvcHRpb25zLndhaXQ7XG4gICAgICBtb2RlbCA9IHRoaXMuX3ByZXBhcmVNb2RlbChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAoIW1vZGVsKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIXdhaXQpIHRoaXMuYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24obW9kZWwsIHJlc3AsIGNhbGxiYWNrT3B0cykge1xuICAgICAgICBpZiAod2FpdCkgY29sbGVjdGlvbi5hZGQobW9kZWwsIGNhbGxiYWNrT3B0cyk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwoY2FsbGJhY2tPcHRzLmNvbnRleHQsIG1vZGVsLCByZXNwLCBjYWxsYmFja09wdHMpO1xuICAgICAgfTtcbiAgICAgIG1vZGVsLnNhdmUobnVsbCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gYSBsaXN0IG9mIG1vZGVscyB0byBiZSBhZGRlZCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgaXQgdGhyb3VnaC5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHdpdGggYW4gaWRlbnRpY2FsIGxpc3Qgb2YgbW9kZWxzIGFzIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm1vZGVscywge1xuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgY29tcGFyYXRvcjogdGhpcy5jb21wYXJhdG9yXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gRGVmaW5lIGhvdyB0byB1bmlxdWVseSBpZGVudGlmeSBtb2RlbHMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgbW9kZWxJZDogZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnNbdGhpcy5tb2RlbC5wcm90b3R5cGUuaWRBdHRyaWJ1dGUgfHwgJ2lkJ107XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgbWV0aG9kIHRvIHJlc2V0IGFsbCBpbnRlcm5hbCBzdGF0ZS4gQ2FsbGVkIHdoZW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBpcyBmaXJzdCBpbml0aWFsaXplZCBvciByZXNldC5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5tb2RlbHMgPSBbXTtcbiAgICAgIHRoaXMuX2J5SWQgID0ge307XG4gICAgfSxcblxuICAgIC8vIFByZXBhcmUgYSBoYXNoIG9mIGF0dHJpYnV0ZXMgKG9yIG90aGVyIG1vZGVsKSB0byBiZSBhZGRlZCB0byB0aGlzXG4gICAgLy8gY29sbGVjdGlvbi5cbiAgICBfcHJlcGFyZU1vZGVsOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuX2lzTW9kZWwoYXR0cnMpKSB7XG4gICAgICAgIGlmICghYXR0cnMuY29sbGVjdGlvbikgYXR0cnMuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhdHRycztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgb3B0aW9ucy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBtb2RlbCA9IG5ldyB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgIGlmICghbW9kZWwudmFsaWRhdGlvbkVycm9yKSByZXR1cm4gbW9kZWw7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBtb2RlbC52YWxpZGF0aW9uRXJyb3IsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGJ5IGJvdGggcmVtb3ZlIGFuZCBzZXQuXG4gICAgX3JlbW92ZU1vZGVsczogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5nZXQobW9kZWxzW2ldKTtcbiAgICAgICAgaWYgKCFtb2RlbCkgY29udGludWU7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKG1vZGVsKTtcbiAgICAgICAgdGhpcy5tb2RlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgb3B0aW9ucy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ3JlbW92ZScsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZWQucHVzaChtb2RlbCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZVJlZmVyZW5jZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlZC5sZW5ndGggPyByZW1vdmVkIDogZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIE1ldGhvZCBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3Qgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBtb2RlbCBmb3JcbiAgICAvLyB0aGUgcHVycG9zZXMgb2YgYWRkaW5nIHRvIHRoZSBjb2xsZWN0aW9uLlxuICAgIF9pc01vZGVsOiBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgIHJldHVybiBtb2RlbCBpbnN0YW5jZW9mIE1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfYWRkUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5fYnlJZFttb2RlbC5jaWRdID0gbW9kZWw7XG4gICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgICBpZiAoaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFtpZF0gPSBtb2RlbDtcbiAgICAgIG1vZGVsLm9uKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gc2V2ZXIgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgIF9yZW1vdmVSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBkZWxldGUgdGhpcy5fYnlJZFttb2RlbC5jaWRdO1xuICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKGlkICE9IG51bGwpIGRlbGV0ZSB0aGlzLl9ieUlkW2lkXTtcbiAgICAgIGlmICh0aGlzID09PSBtb2RlbC5jb2xsZWN0aW9uKSBkZWxldGUgbW9kZWwuY29sbGVjdGlvbjtcbiAgICAgIG1vZGVsLm9mZignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIGNhbGxlZCBldmVyeSB0aW1lIGEgbW9kZWwgaW4gdGhlIHNldCBmaXJlcyBhbiBldmVudC5cbiAgICAvLyBTZXRzIG5lZWQgdG8gdXBkYXRlIHRoZWlyIGluZGV4ZXMgd2hlbiBtb2RlbHMgY2hhbmdlIGlkcy4gQWxsIG90aGVyXG4gICAgLy8gZXZlbnRzIHNpbXBseSBwcm94eSB0aHJvdWdoLiBcImFkZFwiIGFuZCBcInJlbW92ZVwiIGV2ZW50cyB0aGF0IG9yaWdpbmF0ZVxuICAgIC8vIGluIG90aGVyIGNvbGxlY3Rpb25zIGFyZSBpZ25vcmVkLlxuICAgIF9vbk1vZGVsRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBtb2RlbCwgY29sbGVjdGlvbiwgb3B0aW9ucykge1xuICAgICAgaWYgKChldmVudCA9PT0gJ2FkZCcgfHwgZXZlbnQgPT09ICdyZW1vdmUnKSAmJiBjb2xsZWN0aW9uICE9PSB0aGlzKSByZXR1cm47XG4gICAgICBpZiAoZXZlbnQgPT09ICdkZXN0cm95JykgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgaWYgKGV2ZW50ID09PSAnY2hhbmdlJykge1xuICAgICAgICB2YXIgcHJldklkID0gdGhpcy5tb2RlbElkKG1vZGVsLnByZXZpb3VzQXR0cmlidXRlcygpKTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAocHJldklkICE9PSBpZCkge1xuICAgICAgICAgIGlmIChwcmV2SWQgIT0gbnVsbCkgZGVsZXRlIHRoaXMuX2J5SWRbcHJldklkXTtcbiAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFtpZF0gPSBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBDb2xsZWN0aW9uLlxuICAvLyA5MCUgb2YgdGhlIGNvcmUgdXNlZnVsbmVzcyBvZiBCYWNrYm9uZSBDb2xsZWN0aW9ucyBpcyBhY3R1YWxseSBpbXBsZW1lbnRlZFxuICAvLyByaWdodCBoZXJlOlxuICB2YXIgY29sbGVjdGlvbk1ldGhvZHMgPSB7IGZvckVhY2g6IDMsIGVhY2g6IDMsIG1hcDogMywgY29sbGVjdDogMywgcmVkdWNlOiA0LFxuICAgICAgZm9sZGw6IDQsIGluamVjdDogNCwgcmVkdWNlUmlnaHQ6IDQsIGZvbGRyOiA0LCBmaW5kOiAzLCBkZXRlY3Q6IDMsIGZpbHRlcjogMyxcbiAgICAgIHNlbGVjdDogMywgcmVqZWN0OiAzLCBldmVyeTogMywgYWxsOiAzLCBzb21lOiAzLCBhbnk6IDMsIGluY2x1ZGU6IDMsIGluY2x1ZGVzOiAzLFxuICAgICAgY29udGFpbnM6IDMsIGludm9rZTogMCwgbWF4OiAzLCBtaW46IDMsIHRvQXJyYXk6IDEsIHNpemU6IDEsIGZpcnN0OiAzLFxuICAgICAgaGVhZDogMywgdGFrZTogMywgaW5pdGlhbDogMywgcmVzdDogMywgdGFpbDogMywgZHJvcDogMywgbGFzdDogMyxcbiAgICAgIHdpdGhvdXQ6IDAsIGRpZmZlcmVuY2U6IDAsIGluZGV4T2Y6IDMsIHNodWZmbGU6IDEsIGxhc3RJbmRleE9mOiAzLFxuICAgICAgaXNFbXB0eTogMSwgY2hhaW46IDEsIHNhbXBsZTogMywgcGFydGl0aW9uOiAzLCBncm91cEJ5OiAzLCBjb3VudEJ5OiAzLFxuICAgICAgc29ydEJ5OiAzLCBpbmRleEJ5OiAzfTtcblxuICAvLyBNaXggaW4gZWFjaCBVbmRlcnNjb3JlIG1ldGhvZCBhcyBhIHByb3h5IHRvIGBDb2xsZWN0aW9uI21vZGVsc2AuXG4gIGFkZFVuZGVyc2NvcmVNZXRob2RzKENvbGxlY3Rpb24sIGNvbGxlY3Rpb25NZXRob2RzLCAnbW9kZWxzJyk7XG5cbiAgLy8gQmFja2JvbmUuVmlld1xuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gQmFja2JvbmUgVmlld3MgYXJlIGFsbW9zdCBtb3JlIGNvbnZlbnRpb24gdGhhbiB0aGV5IGFyZSBhY3R1YWwgY29kZS4gQSBWaWV3XG4gIC8vIGlzIHNpbXBseSBhIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGxvZ2ljYWwgY2h1bmsgb2YgVUkgaW4gdGhlXG4gIC8vIERPTS4gVGhpcyBtaWdodCBiZSBhIHNpbmdsZSBpdGVtLCBhbiBlbnRpcmUgbGlzdCwgYSBzaWRlYmFyIG9yIHBhbmVsLCBvclxuICAvLyBldmVuIHRoZSBzdXJyb3VuZGluZyBmcmFtZSB3aGljaCB3cmFwcyB5b3VyIHdob2xlIGFwcC4gRGVmaW5pbmcgYSBjaHVuayBvZlxuICAvLyBVSSBhcyBhICoqVmlldyoqIGFsbG93cyB5b3UgdG8gZGVmaW5lIHlvdXIgRE9NIGV2ZW50cyBkZWNsYXJhdGl2ZWx5LCB3aXRob3V0XG4gIC8vIGhhdmluZyB0byB3b3JyeSBhYm91dCByZW5kZXIgb3JkZXIgLi4uIGFuZCBtYWtlcyBpdCBlYXN5IGZvciB0aGUgdmlldyB0b1xuICAvLyByZWFjdCB0byBzcGVjaWZpYyBjaGFuZ2VzIGluIHRoZSBzdGF0ZSBvZiB5b3VyIG1vZGVscy5cblxuICAvLyBDcmVhdGluZyBhIEJhY2tib25lLlZpZXcgY3JlYXRlcyBpdHMgaW5pdGlhbCBlbGVtZW50IG91dHNpZGUgb2YgdGhlIERPTSxcbiAgLy8gaWYgYW4gZXhpc3RpbmcgZWxlbWVudCBpcyBub3QgcHJvdmlkZWQuLi5cbiAgdmFyIFZpZXcgPSBCYWNrYm9uZS5WaWV3ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuY2lkID0gXy51bmlxdWVJZCgndmlldycpO1xuICAgIF8uZXh0ZW5kKHRoaXMsIF8ucGljayhvcHRpb25zLCB2aWV3T3B0aW9ucykpO1xuICAgIHRoaXMuX2Vuc3VyZUVsZW1lbnQoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDYWNoZWQgcmVnZXggdG8gc3BsaXQga2V5cyBmb3IgYGRlbGVnYXRlYC5cbiAgdmFyIGRlbGVnYXRlRXZlbnRTcGxpdHRlciA9IC9eKFxcUyspXFxzKiguKikkLztcblxuICAvLyBMaXN0IG9mIHZpZXcgb3B0aW9ucyB0byBiZSBzZXQgYXMgcHJvcGVydGllcy5cbiAgdmFyIHZpZXdPcHRpb25zID0gWydtb2RlbCcsICdjb2xsZWN0aW9uJywgJ2VsJywgJ2lkJywgJ2F0dHJpYnV0ZXMnLCAnY2xhc3NOYW1lJywgJ3RhZ05hbWUnLCAnZXZlbnRzJ107XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLlZpZXcqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChWaWV3LnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBgdGFnTmFtZWAgb2YgYSBWaWV3J3MgZWxlbWVudCBpcyBgXCJkaXZcImAuXG4gICAgdGFnTmFtZTogJ2RpdicsXG5cbiAgICAvLyBqUXVlcnkgZGVsZWdhdGUgZm9yIGVsZW1lbnQgbG9va3VwLCBzY29wZWQgdG8gRE9NIGVsZW1lbnRzIHdpdGhpbiB0aGVcbiAgICAvLyBjdXJyZW50IHZpZXcuIFRoaXMgc2hvdWxkIGJlIHByZWZlcnJlZCB0byBnbG9iYWwgbG9va3VwcyB3aGVyZSBwb3NzaWJsZS5cbiAgICAkOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMuJGVsLmZpbmQoc2VsZWN0b3IpO1xuICAgIH0sXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyAqKnJlbmRlcioqIGlzIHRoZSBjb3JlIGZ1bmN0aW9uIHRoYXQgeW91ciB2aWV3IHNob3VsZCBvdmVycmlkZSwgaW4gb3JkZXJcbiAgICAvLyB0byBwb3B1bGF0ZSBpdHMgZWxlbWVudCAoYHRoaXMuZWxgKSwgd2l0aCB0aGUgYXBwcm9wcmlhdGUgSFRNTC4gVGhlXG4gICAgLy8gY29udmVudGlvbiBpcyBmb3IgKipyZW5kZXIqKiB0byBhbHdheXMgcmV0dXJuIGB0aGlzYC5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcgYnkgdGFraW5nIHRoZSBlbGVtZW50IG91dCBvZiB0aGUgRE9NLCBhbmQgcmVtb3ZpbmcgYW55XG4gICAgLy8gYXBwbGljYWJsZSBCYWNrYm9uZS5FdmVudHMgbGlzdGVuZXJzLlxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50KCk7XG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdGhpcyB2aWV3J3MgZWxlbWVudCBmcm9tIHRoZSBkb2N1bWVudCBhbmQgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgIC8vIGF0dGFjaGVkIHRvIGl0LiBFeHBvc2VkIGZvciBzdWJjbGFzc2VzIHVzaW5nIGFuIGFsdGVybmF0aXZlIERPTVxuICAgIC8vIG1hbmlwdWxhdGlvbiBBUEkuXG4gICAgX3JlbW92ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy4kZWwucmVtb3ZlKCk7XG4gICAgfSxcblxuICAgIC8vIENoYW5nZSB0aGUgdmlldydzIGVsZW1lbnQgKGB0aGlzLmVsYCBwcm9wZXJ0eSkgYW5kIHJlLWRlbGVnYXRlIHRoZVxuICAgIC8vIHZpZXcncyBldmVudHMgb24gdGhlIG5ldyBlbGVtZW50LlxuICAgIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgdGhpcy5fc2V0RWxlbWVudChlbGVtZW50KTtcbiAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGVzIHRoZSBgdGhpcy5lbGAgYW5kIGB0aGlzLiRlbGAgcmVmZXJlbmNlcyBmb3IgdGhpcyB2aWV3IHVzaW5nIHRoZVxuICAgIC8vIGdpdmVuIGBlbGAuIGBlbGAgY2FuIGJlIGEgQ1NTIHNlbGVjdG9yIG9yIGFuIEhUTUwgc3RyaW5nLCBhIGpRdWVyeVxuICAgIC8vIGNvbnRleHQgb3IgYW4gZWxlbWVudC4gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byB1dGlsaXplIGFuXG4gICAgLy8gYWx0ZXJuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiBBUEkgYW5kIGFyZSBvbmx5IHJlcXVpcmVkIHRvIHNldCB0aGVcbiAgICAvLyBgdGhpcy5lbGAgcHJvcGVydHkuXG4gICAgX3NldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB0aGlzLiRlbCA9IGVsIGluc3RhbmNlb2YgQmFja2JvbmUuJCA/IGVsIDogQmFja2JvbmUuJChlbCk7XG4gICAgICB0aGlzLmVsID0gdGhpcy4kZWxbMF07XG4gICAgfSxcblxuICAgIC8vIFNldCBjYWxsYmFja3MsIHdoZXJlIGB0aGlzLmV2ZW50c2AgaXMgYSBoYXNoIG9mXG4gICAgLy9cbiAgICAvLyAqe1wiZXZlbnQgc2VsZWN0b3JcIjogXCJjYWxsYmFja1wifSpcbiAgICAvL1xuICAgIC8vICAgICB7XG4gICAgLy8gICAgICAgJ21vdXNlZG93biAudGl0bGUnOiAgJ2VkaXQnLFxuICAgIC8vICAgICAgICdjbGljayAuYnV0dG9uJzogICAgICdzYXZlJyxcbiAgICAvLyAgICAgICAnY2xpY2sgLm9wZW4nOiAgICAgICBmdW5jdGlvbihlKSB7IC4uLiB9XG4gICAgLy8gICAgIH1cbiAgICAvL1xuICAgIC8vIHBhaXJzLiBDYWxsYmFja3Mgd2lsbCBiZSBib3VuZCB0byB0aGUgdmlldywgd2l0aCBgdGhpc2Agc2V0IHByb3Blcmx5LlxuICAgIC8vIFVzZXMgZXZlbnQgZGVsZWdhdGlvbiBmb3IgZWZmaWNpZW5jeS5cbiAgICAvLyBPbWl0dGluZyB0aGUgc2VsZWN0b3IgYmluZHMgdGhlIGV2ZW50IHRvIGB0aGlzLmVsYC5cbiAgICBkZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG4gICAgICBldmVudHMgfHwgKGV2ZW50cyA9IF8ucmVzdWx0KHRoaXMsICdldmVudHMnKSk7XG4gICAgICBpZiAoIWV2ZW50cykgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBldmVudHMpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGV2ZW50c1trZXldO1xuICAgICAgICBpZiAoIV8uaXNGdW5jdGlvbihtZXRob2QpKSBtZXRob2QgPSB0aGlzW21ldGhvZF07XG4gICAgICAgIGlmICghbWV0aG9kKSBjb250aW51ZTtcbiAgICAgICAgdmFyIG1hdGNoID0ga2V5Lm1hdGNoKGRlbGVnYXRlRXZlbnRTcGxpdHRlcik7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUobWF0Y2hbMV0sIG1hdGNoWzJdLCBfLmJpbmQobWV0aG9kLCB0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSB2aWV3J3MgZWxlbWVudCAob3IgYSBjaGlsZCBlbGVtZW50XG4gICAgLy8gdXNpbmcgYHNlbGVjdG9yYCkuIFRoaXMgb25seSB3b3JrcyBmb3IgZGVsZWdhdGUtYWJsZSBldmVudHM6IG5vdCBgZm9jdXNgLFxuICAgIC8vIGBibHVyYCwgYW5kIG5vdCBgY2hhbmdlYCwgYHN1Ym1pdGAsIGFuZCBgcmVzZXRgIGluIEludGVybmV0IEV4cGxvcmVyLlxuICAgIGRlbGVnYXRlOiBmdW5jdGlvbihldmVudE5hbWUsIHNlbGVjdG9yLCBsaXN0ZW5lcikge1xuICAgICAgdGhpcy4kZWwub24oZXZlbnROYW1lICsgJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCwgc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBDbGVhcnMgYWxsIGNhbGxiYWNrcyBwcmV2aW91c2x5IGJvdW5kIHRvIHRoZSB2aWV3IGJ5IGBkZWxlZ2F0ZUV2ZW50c2AuXG4gICAgLy8gWW91IHVzdWFsbHkgZG9uJ3QgbmVlZCB0byB1c2UgdGhpcywgYnV0IG1heSB3aXNoIHRvIGlmIHlvdSBoYXZlIG11bHRpcGxlXG4gICAgLy8gQmFja2JvbmUgdmlld3MgYXR0YWNoZWQgdG8gdGhlIHNhbWUgRE9NIGVsZW1lbnQuXG4gICAgdW5kZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy4kZWwpIHRoaXMuJGVsLm9mZignLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBIGZpbmVyLWdyYWluZWQgYHVuZGVsZWdhdGVFdmVudHNgIGZvciByZW1vdmluZyBhIHNpbmdsZSBkZWxlZ2F0ZWQgZXZlbnQuXG4gICAgLy8gYHNlbGVjdG9yYCBhbmQgYGxpc3RlbmVyYCBhcmUgYm90aCBvcHRpb25hbC5cbiAgICB1bmRlbGVnYXRlOiBmdW5jdGlvbihldmVudE5hbWUsIHNlbGVjdG9yLCBsaXN0ZW5lcikge1xuICAgICAgdGhpcy4kZWwub2ZmKGV2ZW50TmFtZSArICcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQsIHNlbGVjdG9yLCBsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUHJvZHVjZXMgYSBET00gZWxlbWVudCB0byBiZSBhc3NpZ25lZCB0byB5b3VyIHZpZXcuIEV4cG9zZWQgZm9yXG4gICAgLy8gc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfY3JlYXRlRWxlbWVudDogZnVuY3Rpb24odGFnTmFtZSkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgfSxcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBWaWV3IGhhcyBhIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgIC8vIElmIGB0aGlzLmVsYCBpcyBhIHN0cmluZywgcGFzcyBpdCB0aHJvdWdoIGAkKClgLCB0YWtlIHRoZSBmaXJzdFxuICAgIC8vIG1hdGNoaW5nIGVsZW1lbnQsIGFuZCByZS1hc3NpZ24gaXQgdG8gYGVsYC4gT3RoZXJ3aXNlLCBjcmVhdGVcbiAgICAvLyBhbiBlbGVtZW50IGZyb20gdGhlIGBpZGAsIGBjbGFzc05hbWVgIGFuZCBgdGFnTmFtZWAgcHJvcGVydGllcy5cbiAgICBfZW5zdXJlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gXy5leHRlbmQoe30sIF8ucmVzdWx0KHRoaXMsICdhdHRyaWJ1dGVzJykpO1xuICAgICAgICBpZiAodGhpcy5pZCkgYXR0cnMuaWQgPSBfLnJlc3VsdCh0aGlzLCAnaWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSBhdHRyc1snY2xhc3MnXSA9IF8ucmVzdWx0KHRoaXMsICdjbGFzc05hbWUnKTtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KHRoaXMuX2NyZWF0ZUVsZW1lbnQoXy5yZXN1bHQodGhpcywgJ3RhZ05hbWUnKSkpO1xuICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVzKGF0dHJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudChfLnJlc3VsdCh0aGlzLCAnZWwnKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFNldCBhdHRyaWJ1dGVzIGZyb20gYSBoYXNoIG9uIHRoaXMgdmlldydzIGVsZW1lbnQuICBFeHBvc2VkIGZvclxuICAgIC8vIHN1YmNsYXNzZXMgdXNpbmcgYW4gYWx0ZXJuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiBBUEkuXG4gICAgX3NldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuJGVsLmF0dHIoYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIEJhY2tib25lLnN5bmNcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gY2hhbmdlIHRoZSBtYW5uZXIgaW4gd2hpY2ggQmFja2JvbmUgcGVyc2lzdHNcbiAgLy8gbW9kZWxzIHRvIHRoZSBzZXJ2ZXIuIFlvdSB3aWxsIGJlIHBhc3NlZCB0aGUgdHlwZSBvZiByZXF1ZXN0LCBhbmQgdGhlXG4gIC8vIG1vZGVsIGluIHF1ZXN0aW9uLiBCeSBkZWZhdWx0LCBtYWtlcyBhIFJFU1RmdWwgQWpheCByZXF1ZXN0XG4gIC8vIHRvIHRoZSBtb2RlbCdzIGB1cmwoKWAuIFNvbWUgcG9zc2libGUgY3VzdG9taXphdGlvbnMgY291bGQgYmU6XG4gIC8vXG4gIC8vICogVXNlIGBzZXRUaW1lb3V0YCB0byBiYXRjaCByYXBpZC1maXJlIHVwZGF0ZXMgaW50byBhIHNpbmdsZSByZXF1ZXN0LlxuICAvLyAqIFNlbmQgdXAgdGhlIG1vZGVscyBhcyBYTUwgaW5zdGVhZCBvZiBKU09OLlxuICAvLyAqIFBlcnNpc3QgbW9kZWxzIHZpYSBXZWJTb2NrZXRzIGluc3RlYWQgb2YgQWpheC5cbiAgLy9cbiAgLy8gVHVybiBvbiBgQmFja2JvbmUuZW11bGF0ZUhUVFBgIGluIG9yZGVyIHRvIHNlbmQgYFBVVGAgYW5kIGBERUxFVEVgIHJlcXVlc3RzXG4gIC8vIGFzIGBQT1NUYCwgd2l0aCBhIGBfbWV0aG9kYCBwYXJhbWV0ZXIgY29udGFpbmluZyB0aGUgdHJ1ZSBIVFRQIG1ldGhvZCxcbiAgLy8gYXMgd2VsbCBhcyBhbGwgcmVxdWVzdHMgd2l0aCB0aGUgYm9keSBhcyBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkYFxuICAvLyBpbnN0ZWFkIG9mIGBhcHBsaWNhdGlvbi9qc29uYCB3aXRoIHRoZSBtb2RlbCBpbiBhIHBhcmFtIG5hbWVkIGBtb2RlbGAuXG4gIC8vIFVzZWZ1bCB3aGVuIGludGVyZmFjaW5nIHdpdGggc2VydmVyLXNpZGUgbGFuZ3VhZ2VzIGxpa2UgKipQSFAqKiB0aGF0IG1ha2VcbiAgLy8gaXQgZGlmZmljdWx0IHRvIHJlYWQgdGhlIGJvZHkgb2YgYFBVVGAgcmVxdWVzdHMuXG4gIEJhY2tib25lLnN5bmMgPSBmdW5jdGlvbihtZXRob2QsIG1vZGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIHR5cGUgPSBtZXRob2RNYXBbbWV0aG9kXTtcblxuICAgIC8vIERlZmF1bHQgb3B0aW9ucywgdW5sZXNzIHNwZWNpZmllZC5cbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSksIHtcbiAgICAgIGVtdWxhdGVIVFRQOiBCYWNrYm9uZS5lbXVsYXRlSFRUUCxcbiAgICAgIGVtdWxhdGVKU09OOiBCYWNrYm9uZS5lbXVsYXRlSlNPTlxuICAgIH0pO1xuXG4gICAgLy8gRGVmYXVsdCBKU09OLXJlcXVlc3Qgb3B0aW9ucy5cbiAgICB2YXIgcGFyYW1zID0ge3R5cGU6IHR5cGUsIGRhdGFUeXBlOiAnanNvbid9O1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSBhIFVSTC5cbiAgICBpZiAoIW9wdGlvbnMudXJsKSB7XG4gICAgICBwYXJhbXMudXJsID0gXy5yZXN1bHQobW9kZWwsICd1cmwnKSB8fCB1cmxFcnJvcigpO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGhhdmUgdGhlIGFwcHJvcHJpYXRlIHJlcXVlc3QgZGF0YS5cbiAgICBpZiAob3B0aW9ucy5kYXRhID09IG51bGwgJiYgbW9kZWwgJiYgKG1ldGhvZCA9PT0gJ2NyZWF0ZScgfHwgbWV0aG9kID09PSAndXBkYXRlJyB8fCBtZXRob2QgPT09ICdwYXRjaCcpKSB7XG4gICAgICBwYXJhbXMuY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICBwYXJhbXMuZGF0YSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYXR0cnMgfHwgbW9kZWwudG9KU09OKG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICAvLyBGb3Igb2xkZXIgc2VydmVycywgZW11bGF0ZSBKU09OIGJ5IGVuY29kaW5nIHRoZSByZXF1ZXN0IGludG8gYW4gSFRNTC1mb3JtLlxuICAgIGlmIChvcHRpb25zLmVtdWxhdGVKU09OKSB7XG4gICAgICBwYXJhbXMuY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgIHBhcmFtcy5kYXRhID0gcGFyYW1zLmRhdGEgPyB7bW9kZWw6IHBhcmFtcy5kYXRhfSA6IHt9O1xuICAgIH1cblxuICAgIC8vIEZvciBvbGRlciBzZXJ2ZXJzLCBlbXVsYXRlIEhUVFAgYnkgbWltaWNraW5nIHRoZSBIVFRQIG1ldGhvZCB3aXRoIGBfbWV0aG9kYFxuICAgIC8vIEFuZCBhbiBgWC1IVFRQLU1ldGhvZC1PdmVycmlkZWAgaGVhZGVyLlxuICAgIGlmIChvcHRpb25zLmVtdWxhdGVIVFRQICYmICh0eXBlID09PSAnUFVUJyB8fCB0eXBlID09PSAnREVMRVRFJyB8fCB0eXBlID09PSAnUEFUQ0gnKSkge1xuICAgICAgcGFyYW1zLnR5cGUgPSAnUE9TVCc7XG4gICAgICBpZiAob3B0aW9ucy5lbXVsYXRlSlNPTikgcGFyYW1zLmRhdGEuX21ldGhvZCA9IHR5cGU7XG4gICAgICB2YXIgYmVmb3JlU2VuZCA9IG9wdGlvbnMuYmVmb3JlU2VuZDtcbiAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignWC1IVFRQLU1ldGhvZC1PdmVycmlkZScsIHR5cGUpO1xuICAgICAgICBpZiAoYmVmb3JlU2VuZCkgcmV0dXJuIGJlZm9yZVNlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgcHJvY2VzcyBkYXRhIG9uIGEgbm9uLUdFVCByZXF1ZXN0LlxuICAgIGlmIChwYXJhbXMudHlwZSAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuZW11bGF0ZUpTT04pIHtcbiAgICAgIHBhcmFtcy5wcm9jZXNzRGF0YSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFBhc3MgYWxvbmcgYHRleHRTdGF0dXNgIGFuZCBgZXJyb3JUaHJvd25gIGZyb20galF1ZXJ5LlxuICAgIHZhciBlcnJvciA9IG9wdGlvbnMuZXJyb3I7XG4gICAgb3B0aW9ucy5lcnJvciA9IGZ1bmN0aW9uKHhociwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgIG9wdGlvbnMudGV4dFN0YXR1cyA9IHRleHRTdGF0dXM7XG4gICAgICBvcHRpb25zLmVycm9yVGhyb3duID0gZXJyb3JUaHJvd247XG4gICAgICBpZiAoZXJyb3IpIGVycm9yLmNhbGwob3B0aW9ucy5jb250ZXh0LCB4aHIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICB9O1xuXG4gICAgLy8gTWFrZSB0aGUgcmVxdWVzdCwgYWxsb3dpbmcgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgYW55IEFqYXggb3B0aW9ucy5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgPSBCYWNrYm9uZS5hamF4KF8uZXh0ZW5kKHBhcmFtcywgb3B0aW9ucykpO1xuICAgIG1vZGVsLnRyaWdnZXIoJ3JlcXVlc3QnLCBtb2RlbCwgeGhyLCBvcHRpb25zKTtcbiAgICByZXR1cm4geGhyO1xuICB9O1xuXG4gIC8vIE1hcCBmcm9tIENSVUQgdG8gSFRUUCBmb3Igb3VyIGRlZmF1bHQgYEJhY2tib25lLnN5bmNgIGltcGxlbWVudGF0aW9uLlxuICB2YXIgbWV0aG9kTWFwID0ge1xuICAgICdjcmVhdGUnOiAnUE9TVCcsXG4gICAgJ3VwZGF0ZSc6ICdQVVQnLFxuICAgICdwYXRjaCc6ICAnUEFUQ0gnLFxuICAgICdkZWxldGUnOiAnREVMRVRFJyxcbiAgICAncmVhZCc6ICAgJ0dFVCdcbiAgfTtcblxuICAvLyBTZXQgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYEJhY2tib25lLmFqYXhgIHRvIHByb3h5IHRocm91Z2ggdG8gYCRgLlxuICAvLyBPdmVycmlkZSB0aGlzIGlmIHlvdSdkIGxpa2UgdG8gdXNlIGEgZGlmZmVyZW50IGxpYnJhcnkuXG4gIEJhY2tib25lLmFqYXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQmFja2JvbmUuJC5hamF4LmFwcGx5KEJhY2tib25lLiQsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQmFja2JvbmUuUm91dGVyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJvdXRlcnMgbWFwIGZhdXgtVVJMcyB0byBhY3Rpb25zLCBhbmQgZmlyZSBldmVudHMgd2hlbiByb3V0ZXMgYXJlXG4gIC8vIG1hdGNoZWQuIENyZWF0aW5nIGEgbmV3IG9uZSBzZXRzIGl0cyBgcm91dGVzYCBoYXNoLCBpZiBub3Qgc2V0IHN0YXRpY2FsbHkuXG4gIHZhciBSb3V0ZXIgPSBCYWNrYm9uZS5Sb3V0ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICBpZiAob3B0aW9ucy5yb3V0ZXMpIHRoaXMucm91dGVzID0gb3B0aW9ucy5yb3V0ZXM7XG4gICAgdGhpcy5fYmluZFJvdXRlcygpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENhY2hlZCByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBtYXRjaGluZyBuYW1lZCBwYXJhbSBwYXJ0cyBhbmQgc3BsYXR0ZWRcbiAgLy8gcGFydHMgb2Ygcm91dGUgc3RyaW5ncy5cbiAgdmFyIG9wdGlvbmFsUGFyYW0gPSAvXFwoKC4qPylcXCkvZztcbiAgdmFyIG5hbWVkUGFyYW0gICAgPSAvKFxcKFxcPyk/OlxcdysvZztcbiAgdmFyIHNwbGF0UGFyYW0gICAgPSAvXFwqXFx3Ky9nO1xuICB2YXIgZXNjYXBlUmVnRXhwICA9IC9bXFwte31cXFtcXF0rPy4sXFxcXFxcXiR8I1xcc10vZztcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuUm91dGVyKiogcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAgXy5leHRlbmQoUm91dGVyLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBNYW51YWxseSBiaW5kIGEgc2luZ2xlIG5hbWVkIHJvdXRlIHRvIGEgY2FsbGJhY2suIEZvciBleGFtcGxlOlxuICAgIC8vXG4gICAgLy8gICAgIHRoaXMucm91dGUoJ3NlYXJjaC86cXVlcnkvcDpudW0nLCAnc2VhcmNoJywgZnVuY3Rpb24ocXVlcnksIG51bSkge1xuICAgIC8vICAgICAgIC4uLlxuICAgIC8vICAgICB9KTtcbiAgICAvL1xuICAgIHJvdXRlOiBmdW5jdGlvbihyb3V0ZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghXy5pc1JlZ0V4cChyb3V0ZSkpIHJvdXRlID0gdGhpcy5fcm91dGVUb1JlZ0V4cChyb3V0ZSk7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmFtZTtcbiAgICAgICAgbmFtZSA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSB0aGlzW25hbWVdO1xuICAgICAgdmFyIHJvdXRlciA9IHRoaXM7XG4gICAgICBCYWNrYm9uZS5oaXN0b3J5LnJvdXRlKHJvdXRlLCBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgICB2YXIgYXJncyA9IHJvdXRlci5fZXh0cmFjdFBhcmFtZXRlcnMocm91dGUsIGZyYWdtZW50KTtcbiAgICAgICAgaWYgKHJvdXRlci5leGVjdXRlKGNhbGxiYWNrLCBhcmdzLCBuYW1lKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICByb3V0ZXIudHJpZ2dlci5hcHBseShyb3V0ZXIsIFsncm91dGU6JyArIG5hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgcm91dGVyLnRyaWdnZXIoJ3JvdXRlJywgbmFtZSwgYXJncyk7XG4gICAgICAgICAgQmFja2JvbmUuaGlzdG9yeS50cmlnZ2VyKCdyb3V0ZScsIHJvdXRlciwgbmFtZSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEV4ZWN1dGUgYSByb3V0ZSBoYW5kbGVyIHdpdGggdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuICBUaGlzIGlzIGFuXG4gICAgLy8gZXhjZWxsZW50IHBsYWNlIHRvIGRvIHByZS1yb3V0ZSBzZXR1cCBvciBwb3N0LXJvdXRlIGNsZWFudXAuXG4gICAgZXhlY3V0ZTogZnVuY3Rpb24oY2FsbGJhY2ssIGFyZ3MsIG5hbWUpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSxcblxuICAgIC8vIFNpbXBsZSBwcm94eSB0byBgQmFja2JvbmUuaGlzdG9yeWAgdG8gc2F2ZSBhIGZyYWdtZW50IGludG8gdGhlIGhpc3RvcnkuXG4gICAgbmF2aWdhdGU6IGZ1bmN0aW9uKGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKGZyYWdtZW50LCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBCaW5kIGFsbCBkZWZpbmVkIHJvdXRlcyB0byBgQmFja2JvbmUuaGlzdG9yeWAuIFdlIGhhdmUgdG8gcmV2ZXJzZSB0aGVcbiAgICAvLyBvcmRlciBvZiB0aGUgcm91dGVzIGhlcmUgdG8gc3VwcG9ydCBiZWhhdmlvciB3aGVyZSB0aGUgbW9zdCBnZW5lcmFsXG4gICAgLy8gcm91dGVzIGNhbiBiZSBkZWZpbmVkIGF0IHRoZSBib3R0b20gb2YgdGhlIHJvdXRlIG1hcC5cbiAgICBfYmluZFJvdXRlczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMucm91dGVzKSByZXR1cm47XG4gICAgICB0aGlzLnJvdXRlcyA9IF8ucmVzdWx0KHRoaXMsICdyb3V0ZXMnKTtcbiAgICAgIHZhciByb3V0ZSwgcm91dGVzID0gXy5rZXlzKHRoaXMucm91dGVzKTtcbiAgICAgIHdoaWxlICgocm91dGUgPSByb3V0ZXMucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yb3V0ZShyb3V0ZSwgdGhpcy5yb3V0ZXNbcm91dGVdKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIHJvdXRlIHN0cmluZyBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLCBzdWl0YWJsZSBmb3IgbWF0Y2hpbmdcbiAgICAvLyBhZ2FpbnN0IHRoZSBjdXJyZW50IGxvY2F0aW9uIGhhc2guXG4gICAgX3JvdXRlVG9SZWdFeHA6IGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICByb3V0ZSA9IHJvdXRlLnJlcGxhY2UoZXNjYXBlUmVnRXhwLCAnXFxcXCQmJylcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZShvcHRpb25hbFBhcmFtLCAnKD86JDEpPycpXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2UobmFtZWRQYXJhbSwgZnVuY3Rpb24obWF0Y2gsIG9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyBtYXRjaCA6ICcoW14vP10rKSc7XG4gICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZShzcGxhdFBhcmFtLCAnKFteP10qPyknKTtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHJvdXRlICsgJyg/OlxcXFw/KFtcXFxcc1xcXFxTXSopKT8kJyk7XG4gICAgfSxcblxuICAgIC8vIEdpdmVuIGEgcm91dGUsIGFuZCBhIFVSTCBmcmFnbWVudCB0aGF0IGl0IG1hdGNoZXMsIHJldHVybiB0aGUgYXJyYXkgb2ZcbiAgICAvLyBleHRyYWN0ZWQgZGVjb2RlZCBwYXJhbWV0ZXJzLiBFbXB0eSBvciB1bm1hdGNoZWQgcGFyYW1ldGVycyB3aWxsIGJlXG4gICAgLy8gdHJlYXRlZCBhcyBgbnVsbGAgdG8gbm9ybWFsaXplIGNyb3NzLWJyb3dzZXIgYmVoYXZpb3IuXG4gICAgX2V4dHJhY3RQYXJhbWV0ZXJzOiBmdW5jdGlvbihyb3V0ZSwgZnJhZ21lbnQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSByb3V0ZS5leGVjKGZyYWdtZW50KS5zbGljZSgxKTtcbiAgICAgIHJldHVybiBfLm1hcChwYXJhbXMsIGZ1bmN0aW9uKHBhcmFtLCBpKSB7XG4gICAgICAgIC8vIERvbid0IGRlY29kZSB0aGUgc2VhcmNoIHBhcmFtcy5cbiAgICAgICAgaWYgKGkgPT09IHBhcmFtcy5sZW5ndGggLSAxKSByZXR1cm4gcGFyYW0gfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIHBhcmFtID8gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKSA6IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuSGlzdG9yeVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSGFuZGxlcyBjcm9zcy1icm93c2VyIGhpc3RvcnkgbWFuYWdlbWVudCwgYmFzZWQgb24gZWl0aGVyXG4gIC8vIFtwdXNoU3RhdGVdKGh0dHA6Ly9kaXZlaW50b2h0bWw1LmluZm8vaGlzdG9yeS5odG1sKSBhbmQgcmVhbCBVUkxzLCBvclxuICAvLyBbb25oYXNoY2hhbmdlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RPTS93aW5kb3cub25oYXNoY2hhbmdlKVxuICAvLyBhbmQgVVJMIGZyYWdtZW50cy4gSWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgbmVpdGhlciAob2xkIElFLCBuYXRjaCksXG4gIC8vIGZhbGxzIGJhY2sgdG8gcG9sbGluZy5cbiAgdmFyIEhpc3RvcnkgPSBCYWNrYm9uZS5IaXN0b3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIHRoaXMuY2hlY2tVcmwgPSBfLmJpbmQodGhpcy5jaGVja1VybCwgdGhpcyk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCBgSGlzdG9yeWAgY2FuIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMubG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG4gICAgICB0aGlzLmhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgYSBsZWFkaW5nIGhhc2gvc2xhc2ggYW5kIHRyYWlsaW5nIHNwYWNlLlxuICB2YXIgcm91dGVTdHJpcHBlciA9IC9eWyNcXC9dfFxccyskL2c7XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcy5cbiAgdmFyIHJvb3RTdHJpcHBlciA9IC9eXFwvK3xcXC8rJC9nO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIHVybHMgb2YgaGFzaC5cbiAgdmFyIHBhdGhTdHJpcHBlciA9IC8jLiokLztcblxuICAvLyBIYXMgdGhlIGhpc3RvcnkgaGFuZGxpbmcgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQ/XG4gIEhpc3Rvcnkuc3RhcnRlZCA9IGZhbHNlO1xuXG4gIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5IaXN0b3J5KiogcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAgXy5leHRlbmQoSGlzdG9yeS5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gVGhlIGRlZmF1bHQgaW50ZXJ2YWwgdG8gcG9sbCBmb3IgaGFzaCBjaGFuZ2VzLCBpZiBuZWNlc3NhcnksIGlzXG4gICAgLy8gdHdlbnR5IHRpbWVzIGEgc2Vjb25kLlxuICAgIGludGVydmFsOiA1MCxcblxuICAgIC8vIEFyZSB3ZSBhdCB0aGUgYXBwIHJvb3Q/XG4gICAgYXRSb290OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5sb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9bXlxcL10kLywgJyQmLycpO1xuICAgICAgcmV0dXJuIHBhdGggPT09IHRoaXMucm9vdCAmJiAhdGhpcy5nZXRTZWFyY2goKTtcbiAgICB9LFxuXG4gICAgLy8gRG9lcyB0aGUgcGF0aG5hbWUgbWF0Y2ggdGhlIHJvb3Q/XG4gICAgbWF0Y2hSb290OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5kZWNvZGVGcmFnbWVudCh0aGlzLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIHZhciByb290ID0gcGF0aC5zbGljZSgwLCB0aGlzLnJvb3QubGVuZ3RoIC0gMSkgKyAnLyc7XG4gICAgICByZXR1cm4gcm9vdCA9PT0gdGhpcy5yb290O1xuICAgIH0sXG5cbiAgICAvLyBVbmljb2RlIGNoYXJhY3RlcnMgaW4gYGxvY2F0aW9uLnBhdGhuYW1lYCBhcmUgcGVyY2VudCBlbmNvZGVkIHNvIHRoZXkncmVcbiAgICAvLyBkZWNvZGVkIGZvciBjb21wYXJpc29uLiBgJTI1YCBzaG91bGQgbm90IGJlIGRlY29kZWQgc2luY2UgaXQgbWF5IGJlIHBhcnRcbiAgICAvLyBvZiBhbiBlbmNvZGVkIHBhcmFtZXRlci5cbiAgICBkZWNvZGVGcmFnbWVudDogZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUkkoZnJhZ21lbnQucmVwbGFjZSgvJTI1L2csICclMjUyNScpKTtcbiAgICB9LFxuXG4gICAgLy8gSW4gSUU2LCB0aGUgaGFzaCBmcmFnbWVudCBhbmQgc2VhcmNoIHBhcmFtcyBhcmUgaW5jb3JyZWN0IGlmIHRoZVxuICAgIC8vIGZyYWdtZW50IGNvbnRhaW5zIGA/YC5cbiAgICBnZXRTZWFyY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hdGNoID0gdGhpcy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyMuKi8sICcnKS5tYXRjaCgvXFw/LisvKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzBdIDogJyc7XG4gICAgfSxcblxuICAgIC8vIEdldHMgdGhlIHRydWUgaGFzaCB2YWx1ZS4gQ2Fubm90IHVzZSBsb2NhdGlvbi5oYXNoIGRpcmVjdGx5IGR1ZSB0byBidWdcbiAgICAvLyBpbiBGaXJlZm94IHdoZXJlIGxvY2F0aW9uLmhhc2ggd2lsbCBhbHdheXMgYmUgZGVjb2RlZC5cbiAgICBnZXRIYXNoOiBmdW5jdGlvbih3aW5kb3cpIHtcbiAgICAgIHZhciBtYXRjaCA9ICh3aW5kb3cgfHwgdGhpcykubG9jYXRpb24uaHJlZi5tYXRjaCgvIyguKikkLyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHBhdGhuYW1lIGFuZCBzZWFyY2ggcGFyYW1zLCB3aXRob3V0IHRoZSByb290LlxuICAgIGdldFBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmRlY29kZUZyYWdtZW50KFxuICAgICAgICB0aGlzLmxvY2F0aW9uLnBhdGhuYW1lICsgdGhpcy5nZXRTZWFyY2goKVxuICAgICAgKS5zbGljZSh0aGlzLnJvb3QubGVuZ3RoIC0gMSk7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc2xpY2UoMSkgOiBwYXRoO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGNyb3NzLWJyb3dzZXIgbm9ybWFsaXplZCBVUkwgZnJhZ21lbnQgZnJvbSB0aGUgcGF0aCBvciBoYXNoLlxuICAgIGdldEZyYWdtZW50OiBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgaWYgKGZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VzZVB1c2hTdGF0ZSB8fCAhdGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldFBhdGgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0SGFzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZShyb3V0ZVN0cmlwcGVyLCAnJyk7XG4gICAgfSxcblxuICAgIC8vIFN0YXJ0IHRoZSBoYXNoIGNoYW5nZSBoYW5kbGluZywgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgY3VycmVudCBVUkwgbWF0Y2hlc1xuICAgIC8vIGFuIGV4aXN0aW5nIHJvdXRlLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChIaXN0b3J5LnN0YXJ0ZWQpIHRocm93IG5ldyBFcnJvcignQmFja2JvbmUuaGlzdG9yeSBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQnKTtcbiAgICAgIEhpc3Rvcnkuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvbi4gRG8gd2UgbmVlZCBhbiBpZnJhbWU/XG4gICAgICAvLyBJcyBwdXNoU3RhdGUgZGVzaXJlZCAuLi4gaXMgaXQgYXZhaWxhYmxlP1xuICAgICAgdGhpcy5vcHRpb25zICAgICAgICAgID0gXy5leHRlbmQoe3Jvb3Q6ICcvJ30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnJvb3QgICAgICAgICAgICAgPSB0aGlzLm9wdGlvbnMucm9vdDtcbiAgICAgIHRoaXMuX3dhbnRzSGFzaENoYW5nZSA9IHRoaXMub3B0aW9ucy5oYXNoQ2hhbmdlICE9PSBmYWxzZTtcbiAgICAgIHRoaXMuX2hhc0hhc2hDaGFuZ2UgICA9ICdvbmhhc2hjaGFuZ2UnIGluIHdpbmRvdyAmJiAoZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09PSB2b2lkIDAgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gNyk7XG4gICAgICB0aGlzLl91c2VIYXNoQ2hhbmdlICAgPSB0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgdGhpcy5faGFzSGFzaENoYW5nZTtcbiAgICAgIHRoaXMuX3dhbnRzUHVzaFN0YXRlICA9ICEhdGhpcy5vcHRpb25zLnB1c2hTdGF0ZTtcbiAgICAgIHRoaXMuX2hhc1B1c2hTdGF0ZSAgICA9ICEhKHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkucHVzaFN0YXRlKTtcbiAgICAgIHRoaXMuX3VzZVB1c2hTdGF0ZSAgICA9IHRoaXMuX3dhbnRzUHVzaFN0YXRlICYmIHRoaXMuX2hhc1B1c2hTdGF0ZTtcbiAgICAgIHRoaXMuZnJhZ21lbnQgICAgICAgICA9IHRoaXMuZ2V0RnJhZ21lbnQoKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHJvb3QgdG8gYWx3YXlzIGluY2x1ZGUgYSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgIHRoaXMucm9vdCA9ICgnLycgKyB0aGlzLnJvb3QgKyAnLycpLnJlcGxhY2Uocm9vdFN0cmlwcGVyLCAnLycpO1xuXG4gICAgICAvLyBUcmFuc2l0aW9uIGZyb20gaGFzaENoYW5nZSB0byBwdXNoU3RhdGUgb3IgdmljZSB2ZXJzYSBpZiBib3RoIGFyZVxuICAgICAgLy8gcmVxdWVzdGVkLlxuICAgICAgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c1B1c2hTdGF0ZSkge1xuXG4gICAgICAgIC8vIElmIHdlJ3ZlIHN0YXJ0ZWQgb2ZmIHdpdGggYSByb3V0ZSBmcm9tIGEgYHB1c2hTdGF0ZWAtZW5hYmxlZFxuICAgICAgICAvLyBicm93c2VyLCBidXQgd2UncmUgY3VycmVudGx5IGluIGEgYnJvd3NlciB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBpdC4uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc1B1c2hTdGF0ZSAmJiAhdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290LnNsaWNlKDAsIC0xKSB8fCAnLyc7XG4gICAgICAgICAgdGhpcy5sb2NhdGlvbi5yZXBsYWNlKHJvb3QgKyAnIycgKyB0aGlzLmdldFBhdGgoKSk7XG4gICAgICAgICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IGFzIGJyb3dzZXIgd2lsbCBkbyByZWRpcmVjdCB0byBuZXcgdXJsXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gT3IgaWYgd2UndmUgc3RhcnRlZCBvdXQgd2l0aCBhIGhhc2gtYmFzZWQgcm91dGUsIGJ1dCB3ZSdyZSBjdXJyZW50bHlcbiAgICAgICAgLy8gaW4gYSBicm93c2VyIHdoZXJlIGl0IGNvdWxkIGJlIGBwdXNoU3RhdGVgLWJhc2VkIGluc3RlYWQuLi5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUgJiYgdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHRoaXMubmF2aWdhdGUodGhpcy5nZXRIYXNoKCksIHtyZXBsYWNlOiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyBQcm94eSBhbiBpZnJhbWUgdG8gaGFuZGxlIGxvY2F0aW9uIGV2ZW50cyBpZiB0aGUgYnJvd3NlciBkb2Vzbid0XG4gICAgICAvLyBzdXBwb3J0IHRoZSBgaGFzaGNoYW5nZWAgZXZlbnQsIEhUTUw1IGhpc3RvcnksIG9yIHRoZSB1c2VyIHdhbnRzXG4gICAgICAvLyBgaGFzaENoYW5nZWAgYnV0IG5vdCBgcHVzaFN0YXRlYC5cbiAgICAgIGlmICghdGhpcy5faGFzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgIXRoaXMuX3VzZVB1c2hTdGF0ZSkge1xuICAgICAgICB0aGlzLmlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICB0aGlzLmlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICAgICAgdGhpcy5pZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5pZnJhbWUudGFiSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAvLyBVc2luZyBgYXBwZW5kQ2hpbGRgIHdpbGwgdGhyb3cgb24gSUUgPCA5IGlmIHRoZSBkb2N1bWVudCBpcyBub3QgcmVhZHkuXG4gICAgICAgIHZhciBpV2luZG93ID0gYm9keS5pbnNlcnRCZWZvcmUodGhpcy5pZnJhbWUsIGJvZHkuZmlyc3RDaGlsZCkuY29udGVudFdpbmRvdztcbiAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5vcGVuKCk7XG4gICAgICAgIGlXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgICAgaVdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyMnICsgdGhpcy5mcmFnbWVudDtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGEgY3Jvc3MtcGxhdGZvcm0gYGFkZEV2ZW50TGlzdGVuZXJgIHNoaW0gZm9yIG9sZGVyIGJyb3dzZXJzLlxuICAgICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfTtcblxuICAgICAgLy8gRGVwZW5kaW5nIG9uIHdoZXRoZXIgd2UncmUgdXNpbmcgcHVzaFN0YXRlIG9yIGhhc2hlcywgYW5kIHdoZXRoZXJcbiAgICAgIC8vICdvbmhhc2hjaGFuZ2UnIGlzIHN1cHBvcnRlZCwgZGV0ZXJtaW5lIGhvdyB3ZSBjaGVjayB0aGUgVVJMIHN0YXRlLlxuICAgICAgaWYgKHRoaXMuX3VzZVB1c2hTdGF0ZSkge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuY2hlY2tVcmwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fdXNlSGFzaENoYW5nZSAmJiAhdGhpcy5pZnJhbWUpIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuY2hlY2tVcmwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrVXJsLCB0aGlzLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2lsZW50KSByZXR1cm4gdGhpcy5sb2FkVXJsKCk7XG4gICAgfSxcblxuICAgIC8vIERpc2FibGUgQmFja2JvbmUuaGlzdG9yeSwgcGVyaGFwcyB0ZW1wb3JhcmlseS4gTm90IHVzZWZ1bCBpbiBhIHJlYWwgYXBwLFxuICAgIC8vIGJ1dCBwb3NzaWJseSB1c2VmdWwgZm9yIHVuaXQgdGVzdGluZyBSb3V0ZXJzLlxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQWRkIGEgY3Jvc3MtcGxhdGZvcm0gYHJlbW92ZUV2ZW50TGlzdGVuZXJgIHNoaW0gZm9yIG9sZGVyIGJyb3dzZXJzLlxuICAgICAgdmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciB8fCBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfTtcblxuICAgICAgLy8gUmVtb3ZlIHdpbmRvdyBsaXN0ZW5lcnMuXG4gICAgICBpZiAodGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl91c2VIYXNoQ2hhbmdlICYmICF0aGlzLmlmcmFtZSkge1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhbiB1cCB0aGUgaWZyYW1lIGlmIG5lY2Vzc2FyeS5cbiAgICAgIGlmICh0aGlzLmlmcmFtZSkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuaWZyYW1lKTtcbiAgICAgICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBTb21lIGVudmlyb25tZW50cyB3aWxsIHRocm93IHdoZW4gY2xlYXJpbmcgYW4gdW5kZWZpbmVkIGludGVydmFsLlxuICAgICAgaWYgKHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwpIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tVcmxJbnRlcnZhbCk7XG4gICAgICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgcm91dGUgdG8gYmUgdGVzdGVkIHdoZW4gdGhlIGZyYWdtZW50IGNoYW5nZXMuIFJvdXRlcyBhZGRlZCBsYXRlclxuICAgIC8vIG1heSBvdmVycmlkZSBwcmV2aW91cyByb3V0ZXMuXG4gICAgcm91dGU6IGZ1bmN0aW9uKHJvdXRlLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5oYW5kbGVycy51bnNoaWZ0KHtyb3V0ZTogcm91dGUsIGNhbGxiYWNrOiBjYWxsYmFja30pO1xuICAgIH0sXG5cbiAgICAvLyBDaGVja3MgdGhlIGN1cnJlbnQgVVJMIHRvIHNlZSBpZiBpdCBoYXMgY2hhbmdlZCwgYW5kIGlmIGl0IGhhcyxcbiAgICAvLyBjYWxscyBgbG9hZFVybGAsIG5vcm1hbGl6aW5nIGFjcm9zcyB0aGUgaGlkZGVuIGlmcmFtZS5cbiAgICBjaGVja1VybDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldEZyYWdtZW50KCk7XG5cbiAgICAgIC8vIElmIHRoZSB1c2VyIHByZXNzZWQgdGhlIGJhY2sgYnV0dG9uLCB0aGUgaWZyYW1lJ3MgaGFzaCB3aWxsIGhhdmVcbiAgICAgIC8vIGNoYW5nZWQgYW5kIHdlIHNob3VsZCB1c2UgdGhhdCBmb3IgY29tcGFyaXNvbi5cbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50ICYmIHRoaXMuaWZyYW1lKSB7XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldEhhc2godGhpcy5pZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodGhpcy5pZnJhbWUpIHRoaXMubmF2aWdhdGUoY3VycmVudCk7XG4gICAgICB0aGlzLmxvYWRVcmwoKTtcbiAgICB9LFxuXG4gICAgLy8gQXR0ZW1wdCB0byBsb2FkIHRoZSBjdXJyZW50IFVSTCBmcmFnbWVudC4gSWYgYSByb3V0ZSBzdWNjZWVkcyB3aXRoIGFcbiAgICAvLyBtYXRjaCwgcmV0dXJucyBgdHJ1ZWAuIElmIG5vIGRlZmluZWQgcm91dGVzIG1hdGNoZXMgdGhlIGZyYWdtZW50LFxuICAgIC8vIHJldHVybnMgYGZhbHNlYC5cbiAgICBsb2FkVXJsOiBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgLy8gSWYgdGhlIHJvb3QgZG9lc24ndCBtYXRjaCwgbm8gcm91dGVzIGNhbiBtYXRjaCBlaXRoZXIuXG4gICAgICBpZiAoIXRoaXMubWF0Y2hSb290KCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgICAgcmV0dXJuIF8uc29tZSh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgIGlmIChoYW5kbGVyLnJvdXRlLnRlc3QoZnJhZ21lbnQpKSB7XG4gICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhmcmFnbWVudCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBTYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGFzaCBoaXN0b3J5LCBvciByZXBsYWNlIHRoZSBVUkwgc3RhdGUgaWYgdGhlXG4gICAgLy8gJ3JlcGxhY2UnIG9wdGlvbiBpcyBwYXNzZWQuIFlvdSBhcmUgcmVzcG9uc2libGUgZm9yIHByb3Blcmx5IFVSTC1lbmNvZGluZ1xuICAgIC8vIHRoZSBmcmFnbWVudCBpbiBhZHZhbmNlLlxuICAgIC8vXG4gICAgLy8gVGhlIG9wdGlvbnMgb2JqZWN0IGNhbiBjb250YWluIGB0cmlnZ2VyOiB0cnVlYCBpZiB5b3Ugd2lzaCB0byBoYXZlIHRoZVxuICAgIC8vIHJvdXRlIGNhbGxiYWNrIGJlIGZpcmVkIChub3QgdXN1YWxseSBkZXNpcmFibGUpLCBvciBgcmVwbGFjZTogdHJ1ZWAsIGlmXG4gICAgLy8geW91IHdpc2ggdG8gbW9kaWZ5IHRoZSBjdXJyZW50IFVSTCB3aXRob3V0IGFkZGluZyBhbiBlbnRyeSB0byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghSGlzdG9yeS5zdGFydGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucyA9PT0gdHJ1ZSkgb3B0aW9ucyA9IHt0cmlnZ2VyOiAhIW9wdGlvbnN9O1xuXG4gICAgICAvLyBOb3JtYWxpemUgdGhlIGZyYWdtZW50LlxuICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdtZW50IHx8ICcnKTtcblxuICAgICAgLy8gRG9uJ3QgaW5jbHVkZSBhIHRyYWlsaW5nIHNsYXNoIG9uIHRoZSByb290LlxuICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICBpZiAoZnJhZ21lbnQgPT09ICcnIHx8IGZyYWdtZW50LmNoYXJBdCgwKSA9PT0gJz8nKSB7XG4gICAgICAgIHJvb3QgPSByb290LnNsaWNlKDAsIC0xKSB8fCAnLyc7XG4gICAgICB9XG4gICAgICB2YXIgdXJsID0gcm9vdCArIGZyYWdtZW50O1xuXG4gICAgICAvLyBTdHJpcCB0aGUgaGFzaCBhbmQgZGVjb2RlIGZvciBtYXRjaGluZy5cbiAgICAgIGZyYWdtZW50ID0gdGhpcy5kZWNvZGVGcmFnbWVudChmcmFnbWVudC5yZXBsYWNlKHBhdGhTdHJpcHBlciwgJycpKTtcblxuICAgICAgaWYgKHRoaXMuZnJhZ21lbnQgPT09IGZyYWdtZW50KSByZXR1cm47XG4gICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQ7XG5cbiAgICAgIC8vIElmIHB1c2hTdGF0ZSBpcyBhdmFpbGFibGUsIHdlIHVzZSBpdCB0byBzZXQgdGhlIGZyYWdtZW50IGFzIGEgcmVhbCBVUkwuXG4gICAgICBpZiAodGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeVtvcHRpb25zLnJlcGxhY2UgPyAncmVwbGFjZVN0YXRlJyA6ICdwdXNoU3RhdGUnXSh7fSwgZG9jdW1lbnQudGl0bGUsIHVybCk7XG5cbiAgICAgIC8vIElmIGhhc2ggY2hhbmdlcyBoYXZlbid0IGJlZW4gZXhwbGljaXRseSBkaXNhYmxlZCwgdXBkYXRlIHRoZSBoYXNoXG4gICAgICAvLyBmcmFnbWVudCB0byBzdG9yZSBoaXN0b3J5LlxuICAgICAgfSBlbHNlIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlSGFzaCh0aGlzLmxvY2F0aW9uLCBmcmFnbWVudCwgb3B0aW9ucy5yZXBsYWNlKTtcbiAgICAgICAgaWYgKHRoaXMuaWZyYW1lICYmIChmcmFnbWVudCAhPT0gdGhpcy5nZXRIYXNoKHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cpKSkge1xuICAgICAgICAgIHZhciBpV2luZG93ID0gdGhpcy5pZnJhbWUuY29udGVudFdpbmRvdztcblxuICAgICAgICAgIC8vIE9wZW5pbmcgYW5kIGNsb3NpbmcgdGhlIGlmcmFtZSB0cmlja3MgSUU3IGFuZCBlYXJsaWVyIHRvIHB1c2ggYVxuICAgICAgICAgIC8vIGhpc3RvcnkgZW50cnkgb24gaGFzaC10YWcgY2hhbmdlLiAgV2hlbiByZXBsYWNlIGlzIHRydWUsIHdlIGRvbid0XG4gICAgICAgICAgLy8gd2FudCB0aGlzLlxuICAgICAgICAgIGlmICghb3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICAgICAgICBpV2luZG93LmRvY3VtZW50Lm9wZW4oKTtcbiAgICAgICAgICAgIGlXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl91cGRhdGVIYXNoKGlXaW5kb3cubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICB9XG5cbiAgICAgIC8vIElmIHlvdSd2ZSB0b2xkIHVzIHRoYXQgeW91IGV4cGxpY2l0bHkgZG9uJ3Qgd2FudCBmYWxsYmFjayBoYXNoY2hhbmdlLVxuICAgICAgLy8gYmFzZWQgaGlzdG9yeSwgdGhlbiBgbmF2aWdhdGVgIGJlY29tZXMgYSBwYWdlIHJlZnJlc2guXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRyaWdnZXIpIHJldHVybiB0aGlzLmxvYWRVcmwoZnJhZ21lbnQpO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgdGhlIGhhc2ggbG9jYXRpb24sIGVpdGhlciByZXBsYWNpbmcgdGhlIGN1cnJlbnQgZW50cnksIG9yIGFkZGluZ1xuICAgIC8vIGEgbmV3IG9uZSB0byB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgIF91cGRhdGVIYXNoOiBmdW5jdGlvbihsb2NhdGlvbiwgZnJhZ21lbnQsIHJlcGxhY2UpIHtcbiAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgIHZhciBocmVmID0gbG9jYXRpb24uaHJlZi5yZXBsYWNlKC8oamF2YXNjcmlwdDp8IykuKiQvLCAnJyk7XG4gICAgICAgIGxvY2F0aW9uLnJlcGxhY2UoaHJlZiArICcjJyArIGZyYWdtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgcmVxdWlyZSB0aGF0IGBoYXNoYCBjb250YWlucyBhIGxlYWRpbmcgIy5cbiAgICAgICAgbG9jYXRpb24uaGFzaCA9ICcjJyArIGZyYWdtZW50O1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcblxuICAvLyBDcmVhdGUgdGhlIGRlZmF1bHQgQmFja2JvbmUuaGlzdG9yeS5cbiAgQmFja2JvbmUuaGlzdG9yeSA9IG5ldyBIaXN0b3J5O1xuXG4gIC8vIEhlbHBlcnNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb3JyZWN0bHkgc2V0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4gZm9yIHN1YmNsYXNzZXMuXG4gIC8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG4gIC8vIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZXh0ZW5kZWQuXG4gIHZhciBleHRlbmQgPSBmdW5jdGlvbihwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIHZhciBjaGlsZDtcblxuICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgICAvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yLlxuICAgIGlmIChwcm90b1Byb3BzICYmIF8uaGFzKHByb3RvUHJvcHMsICdjb25zdHJ1Y3RvcicpKSB7XG4gICAgICBjaGlsZCA9IHByb3RvUHJvcHMuY29uc3RydWN0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkID0gZnVuY3Rpb24oKXsgcmV0dXJuIHBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIH1cblxuICAgIC8vIEFkZCBzdGF0aWMgcHJvcGVydGllcyB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24sIGlmIHN1cHBsaWVkLlxuICAgIF8uZXh0ZW5kKGNoaWxkLCBwYXJlbnQsIHN0YXRpY1Byb3BzKTtcblxuICAgIC8vIFNldCB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGluaGVyaXQgZnJvbSBgcGFyZW50YCwgd2l0aG91dCBjYWxsaW5nXG4gICAgLy8gYHBhcmVudGAgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgdmFyIFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uKCl7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfTtcbiAgICBTdXJyb2dhdGUucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgU3Vycm9nYXRlO1xuXG4gICAgLy8gQWRkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChpbnN0YW5jZSBwcm9wZXJ0aWVzKSB0byB0aGUgc3ViY2xhc3MsXG4gICAgLy8gaWYgc3VwcGxpZWQuXG4gICAgaWYgKHByb3RvUHJvcHMpIF8uZXh0ZW5kKGNoaWxkLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG5cbiAgICAvLyBTZXQgYSBjb252ZW5pZW5jZSBwcm9wZXJ0eSBpbiBjYXNlIHRoZSBwYXJlbnQncyBwcm90b3R5cGUgaXMgbmVlZGVkXG4gICAgLy8gbGF0ZXIuXG4gICAgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTtcblxuICAgIHJldHVybiBjaGlsZDtcbiAgfTtcblxuICAvLyBTZXQgdXAgaW5oZXJpdGFuY2UgZm9yIHRoZSBtb2RlbCwgY29sbGVjdGlvbiwgcm91dGVyLCB2aWV3IGFuZCBoaXN0b3J5LlxuICBNb2RlbC5leHRlbmQgPSBDb2xsZWN0aW9uLmV4dGVuZCA9IFJvdXRlci5leHRlbmQgPSBWaWV3LmV4dGVuZCA9IEhpc3RvcnkuZXh0ZW5kID0gZXh0ZW5kO1xuXG4gIC8vIFRocm93IGFuIGVycm9yIHdoZW4gYSBVUkwgaXMgbmVlZGVkLCBhbmQgbm9uZSBpcyBzdXBwbGllZC5cbiAgdmFyIHVybEVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIFwidXJsXCIgcHJvcGVydHkgb3IgZnVuY3Rpb24gbXVzdCBiZSBzcGVjaWZpZWQnKTtcbiAgfTtcblxuICAvLyBXcmFwIGFuIG9wdGlvbmFsIGVycm9yIGNhbGxiYWNrIHdpdGggYSBmYWxsYmFjayBlcnJvciBldmVudC5cbiAgdmFyIHdyYXBFcnJvciA9IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICBvcHRpb25zLmVycm9yID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgaWYgKGVycm9yKSBlcnJvci5jYWxsKG9wdGlvbnMuY29udGV4dCwgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgbW9kZWwudHJpZ2dlcignZXJyb3InLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gQmFja2JvbmU7XG5cbn0pKTtcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiaW1wb3J0ICogYXMgYmFzZSBmcm9tICcuL2hhbmRsZWJhcnMvYmFzZSc7XG5cbi8vIEVhY2ggb2YgdGhlc2UgYXVnbWVudCB0aGUgSGFuZGxlYmFycyBvYmplY3QuIE5vIG5lZWQgdG8gc2V0dXAgaGVyZS5cbi8vIChUaGlzIGlzIGRvbmUgdG8gZWFzaWx5IHNoYXJlIGNvZGUgYmV0d2VlbiBjb21tb25qcyBhbmQgYnJvd3NlIGVudnMpXG5pbXBvcnQgU2FmZVN0cmluZyBmcm9tICcuL2hhbmRsZWJhcnMvc2FmZS1zdHJpbmcnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuL2hhbmRsZWJhcnMvZXhjZXB0aW9uJztcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gJy4vaGFuZGxlYmFycy91dGlscyc7XG5pbXBvcnQgKiBhcyBydW50aW1lIGZyb20gJy4vaGFuZGxlYmFycy9ydW50aW1lJztcblxuaW1wb3J0IG5vQ29uZmxpY3QgZnJvbSAnLi9oYW5kbGViYXJzL25vLWNvbmZsaWN0JztcblxuLy8gRm9yIGNvbXBhdGliaWxpdHkgYW5kIHVzYWdlIG91dHNpZGUgb2YgbW9kdWxlIHN5c3RlbXMsIG1ha2UgdGhlIEhhbmRsZWJhcnMgb2JqZWN0IGEgbmFtZXNwYWNlXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBoYiA9IG5ldyBiYXNlLkhhbmRsZWJhcnNFbnZpcm9ubWVudCgpO1xuXG4gIFV0aWxzLmV4dGVuZChoYiwgYmFzZSk7XG4gIGhiLlNhZmVTdHJpbmcgPSBTYWZlU3RyaW5nO1xuICBoYi5FeGNlcHRpb24gPSBFeGNlcHRpb247XG4gIGhiLlV0aWxzID0gVXRpbHM7XG4gIGhiLmVzY2FwZUV4cHJlc3Npb24gPSBVdGlscy5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIGhiLlZNID0gcnVudGltZTtcbiAgaGIudGVtcGxhdGUgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgcmV0dXJuIHJ1bnRpbWUudGVtcGxhdGUoc3BlYywgaGIpO1xuICB9O1xuXG4gIHJldHVybiBoYjtcbn1cblxubGV0IGluc3QgPSBjcmVhdGUoKTtcbmluc3QuY3JlYXRlID0gY3JlYXRlO1xuXG5ub0NvbmZsaWN0KGluc3QpO1xuXG5pbnN0WydkZWZhdWx0J10gPSBpbnN0O1xuXG5leHBvcnQgZGVmYXVsdCBpbnN0O1xuIiwiaW1wb3J0IHtjcmVhdGVGcmFtZSwgZXh0ZW5kLCB0b1N0cmluZ30gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vZXhjZXB0aW9uJztcbmltcG9ydCB7cmVnaXN0ZXJEZWZhdWx0SGVscGVyc30gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7cmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9yc30gZnJvbSAnLi9kZWNvcmF0b3JzJztcbmltcG9ydCBsb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICc0LjAuNSc7XG5leHBvcnQgY29uc3QgQ09NUElMRVJfUkVWSVNJT04gPSA3O1xuXG5leHBvcnQgY29uc3QgUkVWSVNJT05fQ0hBTkdFUyA9IHtcbiAgMTogJzw9IDEuMC5yYy4yJywgLy8gMS4wLnJjLjIgaXMgYWN0dWFsbHkgcmV2MiBidXQgZG9lc24ndCByZXBvcnQgaXRcbiAgMjogJz09IDEuMC4wLXJjLjMnLFxuICAzOiAnPT0gMS4wLjAtcmMuNCcsXG4gIDQ6ICc9PSAxLngueCcsXG4gIDU6ICc9PSAyLjAuMC1hbHBoYS54JyxcbiAgNjogJz49IDIuMC4wLWJldGEuMScsXG4gIDc6ICc+PSA0LjAuMCdcbn07XG5cbmNvbnN0IG9iamVjdFR5cGUgPSAnW29iamVjdCBPYmplY3RdJztcblxuZXhwb3J0IGZ1bmN0aW9uIEhhbmRsZWJhcnNFbnZpcm9ubWVudChoZWxwZXJzLCBwYXJ0aWFscywgZGVjb3JhdG9ycykge1xuICB0aGlzLmhlbHBlcnMgPSBoZWxwZXJzIHx8IHt9O1xuICB0aGlzLnBhcnRpYWxzID0gcGFydGlhbHMgfHwge307XG4gIHRoaXMuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnMgfHwge307XG5cbiAgcmVnaXN0ZXJEZWZhdWx0SGVscGVycyh0aGlzKTtcbiAgcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyh0aGlzKTtcbn1cblxuSGFuZGxlYmFyc0Vudmlyb25tZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEhhbmRsZWJhcnNFbnZpcm9ubWVudCxcblxuICBsb2dnZXI6IGxvZ2dlcixcbiAgbG9nOiBsb2dnZXIubG9nLFxuXG4gIHJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBpZiAoZm4pIHsgdGhyb3cgbmV3IEV4Y2VwdGlvbignQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBoZWxwZXJzJyk7IH1cbiAgICAgIGV4dGVuZCh0aGlzLmhlbHBlcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlbHBlcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5oZWxwZXJzW25hbWVdO1xuICB9LFxuXG4gIHJlZ2lzdGVyUGFydGlhbDogZnVuY3Rpb24obmFtZSwgcGFydGlhbCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBleHRlbmQodGhpcy5wYXJ0aWFscywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcGFydGlhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihgQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIHBhcnRpYWwgY2FsbGVkIFwiJHtuYW1lfVwiIGFzIHVuZGVmaW5lZGApO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJ0aWFsc1tuYW1lXSA9IHBhcnRpYWw7XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyUGFydGlhbDogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLnBhcnRpYWxzW25hbWVdO1xuICB9LFxuXG4gIHJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBpZiAoZm4pIHsgdGhyb3cgbmV3IEV4Y2VwdGlvbignQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBkZWNvcmF0b3JzJyk7IH1cbiAgICAgIGV4dGVuZCh0aGlzLmRlY29yYXRvcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY29yYXRvcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5kZWNvcmF0b3JzW25hbWVdO1xuICB9XG59O1xuXG5leHBvcnQgbGV0IGxvZyA9IGxvZ2dlci5sb2c7XG5cbmV4cG9ydCB7Y3JlYXRlRnJhbWUsIGxvZ2dlcn07XG4iLCJpbXBvcnQgcmVnaXN0ZXJJbmxpbmUgZnJvbSAnLi9kZWNvcmF0b3JzL2lubGluZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzKGluc3RhbmNlKSB7XG4gIHJlZ2lzdGVySW5saW5lKGluc3RhbmNlKTtcbn1cblxuIiwiaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJEZWNvcmF0b3IoJ2lubGluZScsIGZ1bmN0aW9uKGZuLCBwcm9wcywgY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgbGV0IHJldCA9IGZuO1xuICAgIGlmICghcHJvcHMucGFydGlhbHMpIHtcbiAgICAgIHByb3BzLnBhcnRpYWxzID0ge307XG4gICAgICByZXQgPSBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJ0aWFscyBzdGFjayBmcmFtZSBwcmlvciB0byBleGVjLlxuICAgICAgICBsZXQgb3JpZ2luYWwgPSBjb250YWluZXIucGFydGlhbHM7XG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IGV4dGVuZCh7fSwgb3JpZ2luYWwsIHByb3BzLnBhcnRpYWxzKTtcbiAgICAgICAgbGV0IHJldCA9IGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcmlnaW5hbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcHJvcHMucGFydGlhbHNbb3B0aW9ucy5hcmdzWzBdXSA9IG9wdGlvbnMuZm47XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiIsIlxuY29uc3QgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICdtZXNzYWdlJywgJ25hbWUnLCAnbnVtYmVyJywgJ3N0YWNrJ107XG5cbmZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlLCBub2RlKSB7XG4gIGxldCBsb2MgPSBub2RlICYmIG5vZGUubG9jLFxuICAgICAgbGluZSxcbiAgICAgIGNvbHVtbjtcbiAgaWYgKGxvYykge1xuICAgIGxpbmUgPSBsb2Muc3RhcnQubGluZTtcbiAgICBjb2x1bW4gPSBsb2Muc3RhcnQuY29sdW1uO1xuXG4gICAgbWVzc2FnZSArPSAnIC0gJyArIGxpbmUgKyAnOicgKyBjb2x1bW47XG4gIH1cblxuICBsZXQgdG1wID0gRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgLy8gVW5mb3J0dW5hdGVseSBlcnJvcnMgYXJlIG5vdCBlbnVtZXJhYmxlIGluIENocm9tZSAoYXQgbGVhc3QpLCBzbyBgZm9yIHByb3AgaW4gdG1wYCBkb2Vzbid0IHdvcmsuXG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGVycm9yUHJvcHMubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXNbZXJyb3JQcm9wc1tpZHhdXSA9IHRtcFtlcnJvclByb3BzW2lkeF1dO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXhjZXB0aW9uKTtcbiAgfVxuXG4gIGlmIChsb2MpIHtcbiAgICB0aGlzLmxpbmVOdW1iZXIgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICB9XG59XG5cbkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuZXhwb3J0IGRlZmF1bHQgRXhjZXB0aW9uO1xuIiwiaW1wb3J0IHJlZ2lzdGVyQmxvY2tIZWxwZXJNaXNzaW5nIGZyb20gJy4vaGVscGVycy9ibG9jay1oZWxwZXItbWlzc2luZyc7XG5pbXBvcnQgcmVnaXN0ZXJFYWNoIGZyb20gJy4vaGVscGVycy9lYWNoJztcbmltcG9ydCByZWdpc3RlckhlbHBlck1pc3NpbmcgZnJvbSAnLi9oZWxwZXJzL2hlbHBlci1taXNzaW5nJztcbmltcG9ydCByZWdpc3RlcklmIGZyb20gJy4vaGVscGVycy9pZic7XG5pbXBvcnQgcmVnaXN0ZXJMb2cgZnJvbSAnLi9oZWxwZXJzL2xvZyc7XG5pbXBvcnQgcmVnaXN0ZXJMb29rdXAgZnJvbSAnLi9oZWxwZXJzL2xvb2t1cCc7XG5pbXBvcnQgcmVnaXN0ZXJXaXRoIGZyb20gJy4vaGVscGVycy93aXRoJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnMoaW5zdGFuY2UpIHtcbiAgcmVnaXN0ZXJCbG9ja0hlbHBlck1pc3NpbmcoaW5zdGFuY2UpO1xuICByZWdpc3RlckVhY2goaW5zdGFuY2UpO1xuICByZWdpc3RlckhlbHBlck1pc3NpbmcoaW5zdGFuY2UpO1xuICByZWdpc3RlcklmKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJMb2coaW5zdGFuY2UpO1xuICByZWdpc3Rlckxvb2t1cChpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyV2l0aChpbnN0YW5jZSk7XG59XG4iLCJpbXBvcnQge2FwcGVuZENvbnRleHRQYXRoLCBjcmVhdGVGcmFtZSwgaXNBcnJheX0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignYmxvY2tIZWxwZXJNaXNzaW5nJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIGxldCBpbnZlcnNlID0gb3B0aW9ucy5pbnZlcnNlLFxuICAgICAgICBmbiA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAoY29udGV4dCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGZuKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoY29udGV4dCA9PT0gZmFsc2UgfHwgY29udGV4dCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoY29udGV4dCkpIHtcbiAgICAgIGlmIChjb250ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaWRzKSB7XG4gICAgICAgICAgb3B0aW9ucy5pZHMgPSBbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzLmVhY2goY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgICBsZXQgZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBhcHBlbmRDb250ZXh0UGF0aChvcHRpb25zLmRhdGEuY29udGV4dFBhdGgsIG9wdGlvbnMubmFtZSk7XG4gICAgICAgIG9wdGlvbnMgPSB7ZGF0YTogZGF0YX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHthcHBlbmRDb250ZXh0UGF0aCwgYmxvY2tQYXJhbXMsIGNyZWF0ZUZyYW1lLCBpc0FycmF5LCBpc0Z1bmN0aW9ufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL2V4Y2VwdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdlYWNoJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignTXVzdCBwYXNzIGl0ZXJhdG9yIHRvICNlYWNoJyk7XG4gICAgfVxuXG4gICAgbGV0IGZuID0gb3B0aW9ucy5mbixcbiAgICAgICAgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIHJldCA9ICcnLFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0UGF0aDtcblxuICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgIGNvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSkgKyAnLic7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dCkpIHsgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTsgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlY0l0ZXJhdGlvbihmaWVsZCwgaW5kZXgsIGxhc3QpIHtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRhdGEua2V5ID0gZmllbGQ7XG4gICAgICAgIGRhdGEuaW5kZXggPSBpbmRleDtcbiAgICAgICAgZGF0YS5maXJzdCA9IGluZGV4ID09PSAwO1xuICAgICAgICBkYXRhLmxhc3QgPSAhIWxhc3Q7XG5cbiAgICAgICAgaWYgKGNvbnRleHRQYXRoKSB7XG4gICAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGNvbnRleHRQYXRoICsgZmllbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0ID0gcmV0ICsgZm4oY29udGV4dFtmaWVsZF0sIHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgYmxvY2tQYXJhbXM6IGJsb2NrUGFyYW1zKFtjb250ZXh0W2ZpZWxkXSwgZmllbGRdLCBbY29udGV4dFBhdGggKyBmaWVsZCwgbnVsbF0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dCAmJiB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChpc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBjb250ZXh0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgIGlmIChpIGluIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGV4ZWNJdGVyYXRpb24oaSwgaSwgaSA9PT0gY29udGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwcmlvcktleTtcblxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIHJ1bm5pbmcgdGhlIGl0ZXJhdGlvbnMgb25lIHN0ZXAgb3V0IG9mIHN5bmMgc28gd2UgY2FuIGRldGVjdFxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgaXRlcmF0aW9uIHdpdGhvdXQgaGF2ZSB0byBzY2FuIHRoZSBvYmplY3QgdHdpY2UgYW5kIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYW4gaXRlcm1lZGlhdGUga2V5cyBhcnJheS5cbiAgICAgICAgICAgIGlmIChwcmlvcktleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGV4ZWNJdGVyYXRpb24ocHJpb3JLZXksIGkgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByaW9yS2V5ID0ga2V5O1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV4ZWNJdGVyYXRpb24ocHJpb3JLZXksIGkgLSAxLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICByZXQgPSBpbnZlcnNlKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuIiwiaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignaGVscGVyTWlzc2luZycsIGZ1bmN0aW9uKC8qIFthcmdzLCBdb3B0aW9ucyAqLykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBBIG1pc3NpbmcgZmllbGQgaW4gYSB7e2Zvb319IGNvbnN0cnVjdC5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvbWVvbmUgaXMgYWN0dWFsbHkgdHJ5aW5nIHRvIGNhbGwgc29tZXRoaW5nLCBibG93IHVwLlxuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignTWlzc2luZyBoZWxwZXI6IFwiJyArIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0ubmFtZSArICdcIicpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJpbXBvcnQge2lzRW1wdHksIGlzRnVuY3Rpb259IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2lmJywgZnVuY3Rpb24oY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihjb25kaXRpb25hbCkpIHsgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5jYWxsKHRoaXMpOyB9XG5cbiAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHJlbmRlciB0aGUgcG9zaXRpdmUgcGF0aCBpZiB0aGUgdmFsdWUgaXMgdHJ1dGh5IGFuZCBub3QgZW1wdHkuXG4gICAgLy8gVGhlIGBpbmNsdWRlWmVyb2Agb3B0aW9uIG1heSBiZSBzZXQgdG8gdHJlYXQgdGhlIGNvbmR0aW9uYWwgYXMgcHVyZWx5IG5vdCBlbXB0eSBiYXNlZCBvbiB0aGVcbiAgICAvLyBiZWhhdmlvciBvZiBpc0VtcHR5LiBFZmZlY3RpdmVseSB0aGlzIGRldGVybWluZXMgaWYgMCBpcyBoYW5kbGVkIGJ5IHRoZSBwb3NpdGl2ZSBwYXRoIG9yIG5lZ2F0aXZlLlxuICAgIGlmICgoIW9wdGlvbnMuaGFzaC5pbmNsdWRlWmVybyAmJiAhY29uZGl0aW9uYWwpIHx8IGlzRW1wdHkoY29uZGl0aW9uYWwpKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd1bmxlc3MnLCBmdW5jdGlvbihjb25kaXRpb25hbCwgb3B0aW9ucykge1xuICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzWydpZiddLmNhbGwodGhpcywgY29uZGl0aW9uYWwsIHtmbjogb3B0aW9ucy5pbnZlcnNlLCBpbnZlcnNlOiBvcHRpb25zLmZuLCBoYXNoOiBvcHRpb25zLmhhc2h9KTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9nJywgZnVuY3Rpb24oLyogbWVzc2FnZSwgb3B0aW9ucyAqLykge1xuICAgIGxldCBhcmdzID0gW3VuZGVmaW5lZF0sXG4gICAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgbGV0IGxldmVsID0gMTtcbiAgICBpZiAob3B0aW9ucy5oYXNoLmxldmVsICE9IG51bGwpIHtcbiAgICAgIGxldmVsID0gb3B0aW9ucy5oYXNoLmxldmVsO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuZGF0YS5sZXZlbCAhPSBudWxsKSB7XG4gICAgICBsZXZlbCA9IG9wdGlvbnMuZGF0YS5sZXZlbDtcbiAgICB9XG4gICAgYXJnc1swXSA9IGxldmVsO1xuXG4gICAgaW5zdGFuY2UubG9nKC4uLiBhcmdzKTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9va3VwJywgZnVuY3Rpb24ob2JqLCBmaWVsZCkge1xuICAgIHJldHVybiBvYmogJiYgb2JqW2ZpZWxkXTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge2FwcGVuZENvbnRleHRQYXRoLCBibG9ja1BhcmFtcywgY3JlYXRlRnJhbWUsIGlzRW1wdHksIGlzRnVuY3Rpb259IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3dpdGgnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dCkpIHsgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTsgfVxuXG4gICAgbGV0IGZuID0gb3B0aW9ucy5mbjtcblxuICAgIGlmICghaXNFbXB0eShjb250ZXh0KSkge1xuICAgICAgbGV0IGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihjb250ZXh0LCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhbY29udGV4dF0sIFtkYXRhICYmIGRhdGEuY29udGV4dFBhdGhdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7aW5kZXhPZn0gZnJvbSAnLi91dGlscyc7XG5cbmxldCBsb2dnZXIgPSB7XG4gIG1ldGhvZE1hcDogWydkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXSxcbiAgbGV2ZWw6ICdpbmZvJyxcblxuICAvLyBNYXBzIGEgZ2l2ZW4gbGV2ZWwgdmFsdWUgdG8gdGhlIGBtZXRob2RNYXBgIGluZGV4ZXMgYWJvdmUuXG4gIGxvb2t1cExldmVsOiBmdW5jdGlvbihsZXZlbCkge1xuICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgbGV2ZWxNYXAgPSBpbmRleE9mKGxvZ2dlci5tZXRob2RNYXAsIGxldmVsLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKGxldmVsTWFwID49IDApIHtcbiAgICAgICAgbGV2ZWwgPSBsZXZlbE1hcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsID0gcGFyc2VJbnQobGV2ZWwsIDEwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH0sXG5cbiAgLy8gQ2FuIGJlIG92ZXJyaWRkZW4gaW4gdGhlIGhvc3QgZW52aXJvbm1lbnRcbiAgbG9nOiBmdW5jdGlvbihsZXZlbCwgLi4ubWVzc2FnZSkge1xuICAgIGxldmVsID0gbG9nZ2VyLmxvb2t1cExldmVsKGxldmVsKTtcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9nZ2VyLmxvb2t1cExldmVsKGxvZ2dlci5sZXZlbCkgPD0gbGV2ZWwpIHtcbiAgICAgIGxldCBtZXRob2QgPSBsb2dnZXIubWV0aG9kTWFwW2xldmVsXTtcbiAgICAgIGlmICghY29uc29sZVttZXRob2RdKSB7ICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgIG1ldGhvZCA9ICdsb2cnO1xuICAgICAgfVxuICAgICAgY29uc29sZVttZXRob2RdKC4uLm1lc3NhZ2UpOyAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGxvZ2dlcjtcbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKEhhbmRsZWJhcnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbGV0IHJvb3QgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyxcbiAgICAgICRIYW5kbGViYXJzID0gcm9vdC5IYW5kbGViYXJzO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBIYW5kbGViYXJzLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAocm9vdC5IYW5kbGViYXJzID09PSBIYW5kbGViYXJzKSB7XG4gICAgICByb290LkhhbmRsZWJhcnMgPSAkSGFuZGxlYmFycztcbiAgICB9XG4gICAgcmV0dXJuIEhhbmRsZWJhcnM7XG4gIH07XG59XG4iLCJpbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9leGNlcHRpb24nO1xuaW1wb3J0IHsgQ09NUElMRVJfUkVWSVNJT04sIFJFVklTSU9OX0NIQU5HRVMsIGNyZWF0ZUZyYW1lIH0gZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmV2aXNpb24oY29tcGlsZXJJbmZvKSB7XG4gIGNvbnN0IGNvbXBpbGVyUmV2aXNpb24gPSBjb21waWxlckluZm8gJiYgY29tcGlsZXJJbmZvWzBdIHx8IDEsXG4gICAgICAgIGN1cnJlbnRSZXZpc2lvbiA9IENPTVBJTEVSX1JFVklTSU9OO1xuXG4gIGlmIChjb21waWxlclJldmlzaW9uICE9PSBjdXJyZW50UmV2aXNpb24pIHtcbiAgICBpZiAoY29tcGlsZXJSZXZpc2lvbiA8IGN1cnJlbnRSZXZpc2lvbikge1xuICAgICAgY29uc3QgcnVudGltZVZlcnNpb25zID0gUkVWSVNJT05fQ0hBTkdFU1tjdXJyZW50UmV2aXNpb25dLFxuICAgICAgICAgICAgY29tcGlsZXJWZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbY29tcGlsZXJSZXZpc2lvbl07XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhbiBvbGRlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgdXBkYXRlIHlvdXIgcHJlY29tcGlsZXIgdG8gYSBuZXdlciB2ZXJzaW9uICgnICsgcnVudGltZVZlcnNpb25zICsgJykgb3IgZG93bmdyYWRlIHlvdXIgcnVudGltZSB0byBhbiBvbGRlciB2ZXJzaW9uICgnICsgY29tcGlsZXJWZXJzaW9ucyArICcpLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2UgdGhlIGVtYmVkZGVkIHZlcnNpb24gaW5mbyBzaW5jZSB0aGUgcnVudGltZSBkb2Vzbid0IGtub3cgYWJvdXQgdGhpcyByZXZpc2lvbiB5ZXRcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGEgbmV3ZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHVwZGF0ZSB5b3VyIHJ1bnRpbWUgdG8gYSBuZXdlciB2ZXJzaW9uICgnICsgY29tcGlsZXJJbmZvWzFdICsgJykuJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZSh0ZW1wbGF0ZVNwZWMsIGVudikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIWVudikge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ05vIGVudmlyb25tZW50IHBhc3NlZCB0byB0ZW1wbGF0ZScpO1xuICB9XG4gIGlmICghdGVtcGxhdGVTcGVjIHx8ICF0ZW1wbGF0ZVNwZWMubWFpbikge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1Vua25vd24gdGVtcGxhdGUgb2JqZWN0OiAnICsgdHlwZW9mIHRlbXBsYXRlU3BlYyk7XG4gIH1cblxuICB0ZW1wbGF0ZVNwZWMubWFpbi5kZWNvcmF0b3IgPSB0ZW1wbGF0ZVNwZWMubWFpbl9kO1xuXG4gIC8vIE5vdGU6IFVzaW5nIGVudi5WTSByZWZlcmVuY2VzIHJhdGhlciB0aGFuIGxvY2FsIHZhciByZWZlcmVuY2VzIHRocm91Z2hvdXQgdGhpcyBzZWN0aW9uIHRvIGFsbG93XG4gIC8vIGZvciBleHRlcm5hbCB1c2VycyB0byBvdmVycmlkZSB0aGVzZSBhcyBwc3VlZG8tc3VwcG9ydGVkIEFQSXMuXG4gIGVudi5WTS5jaGVja1JldmlzaW9uKHRlbXBsYXRlU3BlYy5jb21waWxlcik7XG5cbiAgZnVuY3Rpb24gaW52b2tlUGFydGlhbFdyYXBwZXIocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICAgIGNvbnRleHQgPSBVdGlscy5leHRlbmQoe30sIGNvbnRleHQsIG9wdGlvbnMuaGFzaCk7XG4gICAgICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICAgICAgb3B0aW9ucy5pZHNbMF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnRpYWwgPSBlbnYuVk0ucmVzb2x2ZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcbiAgICBsZXQgcmVzdWx0ID0gZW52LlZNLmludm9rZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcblxuICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiBlbnYuY29tcGlsZSkge1xuICAgICAgb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdID0gZW52LmNvbXBpbGUocGFydGlhbCwgdGVtcGxhdGVTcGVjLmNvbXBpbGVyT3B0aW9ucywgZW52KTtcbiAgICAgIHJlc3VsdCA9IG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXShjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbmRlbnQpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gcmVzdWx0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWxpbmVzW2ldICYmIGkgKyAxID09PSBsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5lc1tpXSA9IG9wdGlvbnMuaW5kZW50ICsgbGluZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUaGUgcGFydGlhbCAnICsgb3B0aW9ucy5uYW1lICsgJyBjb3VsZCBub3QgYmUgY29tcGlsZWQgd2hlbiBydW5uaW5nIGluIHJ1bnRpbWUtb25seSBtb2RlJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gSnVzdCBhZGQgd2F0ZXJcbiAgbGV0IGNvbnRhaW5lciA9IHtcbiAgICBzdHJpY3Q6IGZ1bmN0aW9uKG9iaiwgbmFtZSkge1xuICAgICAgaWYgKCEobmFtZSBpbiBvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1wiJyArIG5hbWUgKyAnXCIgbm90IGRlZmluZWQgaW4gJyArIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqW25hbWVdO1xuICAgIH0sXG4gICAgbG9va3VwOiBmdW5jdGlvbihkZXB0aHMsIG5hbWUpIHtcbiAgICAgIGNvbnN0IGxlbiA9IGRlcHRocy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChkZXB0aHNbaV0gJiYgZGVwdGhzW2ldW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZGVwdGhzW2ldW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsYW1iZGE6IGZ1bmN0aW9uKGN1cnJlbnQsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY3VycmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnQuY2FsbChjb250ZXh0KSA6IGN1cnJlbnQ7XG4gICAgfSxcblxuICAgIGVzY2FwZUV4cHJlc3Npb246IFV0aWxzLmVzY2FwZUV4cHJlc3Npb24sXG4gICAgaW52b2tlUGFydGlhbDogaW52b2tlUGFydGlhbFdyYXBwZXIsXG5cbiAgICBmbjogZnVuY3Rpb24oaSkge1xuICAgICAgbGV0IHJldCA9IHRlbXBsYXRlU3BlY1tpXTtcbiAgICAgIHJldC5kZWNvcmF0b3IgPSB0ZW1wbGF0ZVNwZWNbaSArICdfZCddO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgcHJvZ3JhbXM6IFtdLFxuICAgIHByb2dyYW06IGZ1bmN0aW9uKGksIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgICAgIGxldCBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0sXG4gICAgICAgICAgZm4gPSB0aGlzLmZuKGkpO1xuICAgICAgaWYgKGRhdGEgfHwgZGVwdGhzIHx8IGJsb2NrUGFyYW1zIHx8IGRlY2xhcmVkQmxvY2tQYXJhbXMpIHtcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB3cmFwUHJvZ3JhbSh0aGlzLCBpLCBmbiwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gICAgICB9IGVsc2UgaWYgKCFwcm9ncmFtV3JhcHBlcikge1xuICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0gPSB3cmFwUHJvZ3JhbSh0aGlzLCBpLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvZ3JhbVdyYXBwZXI7XG4gICAgfSxcblxuICAgIGRhdGE6IGZ1bmN0aW9uKHZhbHVlLCBkZXB0aCkge1xuICAgICAgd2hpbGUgKHZhbHVlICYmIGRlcHRoLS0pIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5fcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKHBhcmFtLCBjb21tb24pIHtcbiAgICAgIGxldCBvYmogPSBwYXJhbSB8fCBjb21tb247XG5cbiAgICAgIGlmIChwYXJhbSAmJiBjb21tb24gJiYgKHBhcmFtICE9PSBjb21tb24pKSB7XG4gICAgICAgIG9iaiA9IFV0aWxzLmV4dGVuZCh7fSwgY29tbW9uLCBwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIG5vb3A6IGVudi5WTS5ub29wLFxuICAgIGNvbXBpbGVySW5mbzogdGVtcGxhdGVTcGVjLmNvbXBpbGVyXG4gIH07XG5cbiAgZnVuY3Rpb24gcmV0KGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuXG4gICAgcmV0Ll9zZXR1cChvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMucGFydGlhbCAmJiB0ZW1wbGF0ZVNwZWMudXNlRGF0YSkge1xuICAgICAgZGF0YSA9IGluaXREYXRhKGNvbnRleHQsIGRhdGEpO1xuICAgIH1cbiAgICBsZXQgZGVwdGhzLFxuICAgICAgICBibG9ja1BhcmFtcyA9IHRlbXBsYXRlU3BlYy51c2VCbG9ja1BhcmFtcyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzKSB7XG4gICAgICBpZiAob3B0aW9ucy5kZXB0aHMpIHtcbiAgICAgICAgZGVwdGhzID0gY29udGV4dCAhPT0gb3B0aW9ucy5kZXB0aHNbMF0gPyBbY29udGV4dF0uY29uY2F0KG9wdGlvbnMuZGVwdGhzKSA6IG9wdGlvbnMuZGVwdGhzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVwdGhzID0gW2NvbnRleHRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1haW4oY29udGV4dC8qLCBvcHRpb25zKi8pIHtcbiAgICAgIHJldHVybiAnJyArIHRlbXBsYXRlU3BlYy5tYWluKGNvbnRhaW5lciwgY29udGV4dCwgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscywgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gICAgfVxuICAgIG1haW4gPSBleGVjdXRlRGVjb3JhdG9ycyh0ZW1wbGF0ZVNwZWMubWFpbiwgbWFpbiwgY29udGFpbmVyLCBvcHRpb25zLmRlcHRocyB8fCBbXSwgZGF0YSwgYmxvY2tQYXJhbXMpO1xuICAgIHJldHVybiBtYWluKGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG4gIHJldC5pc1RvcCA9IHRydWU7XG5cbiAgcmV0Ll9zZXR1cCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMucGFydGlhbCkge1xuICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5oZWxwZXJzLCBlbnYuaGVscGVycyk7XG5cbiAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCkge1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5wYXJ0aWFscywgZW52LnBhcnRpYWxzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCB8fCB0ZW1wbGF0ZVNwZWMudXNlRGVjb3JhdG9ycykge1xuICAgICAgICBjb250YWluZXIuZGVjb3JhdG9ycyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLmRlY29yYXRvcnMsIGVudi5kZWNvcmF0b3JzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBvcHRpb25zLmhlbHBlcnM7XG4gICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcHRpb25zLnBhcnRpYWxzO1xuICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBvcHRpb25zLmRlY29yYXRvcnM7XG4gICAgfVxuICB9O1xuXG4gIHJldC5fY2hpbGQgPSBmdW5jdGlvbihpLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VCbG9ja1BhcmFtcyAmJiAhYmxvY2tQYXJhbXMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ211c3QgcGFzcyBibG9jayBwYXJhbXMnKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMgJiYgIWRlcHRocykge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignbXVzdCBwYXNzIHBhcmVudCBkZXB0aHMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcFByb2dyYW0oY29udGFpbmVyLCBpLCB0ZW1wbGF0ZVNwZWNbaV0sIGRhdGEsIDAsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICB9O1xuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcFByb2dyYW0oY29udGFpbmVyLCBpLCBmbiwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICBmdW5jdGlvbiBwcm9nKGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjdXJyZW50RGVwdGhzID0gZGVwdGhzO1xuICAgIGlmIChkZXB0aHMgJiYgY29udGV4dCAhPT0gZGVwdGhzWzBdKSB7XG4gICAgICBjdXJyZW50RGVwdGhzID0gW2NvbnRleHRdLmNvbmNhdChkZXB0aHMpO1xuICAgIH1cblxuICAgIHJldHVybiBmbihjb250YWluZXIsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsXG4gICAgICAgIG9wdGlvbnMuZGF0YSB8fCBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtcyAmJiBbb3B0aW9ucy5ibG9ja1BhcmFtc10uY29uY2F0KGJsb2NrUGFyYW1zKSxcbiAgICAgICAgY3VycmVudERlcHRocyk7XG4gIH1cblxuICBwcm9nID0gZXhlY3V0ZURlY29yYXRvcnMoZm4sIHByb2csIGNvbnRhaW5lciwgZGVwdGhzLCBkYXRhLCBibG9ja1BhcmFtcyk7XG5cbiAgcHJvZy5wcm9ncmFtID0gaTtcbiAgcHJvZy5kZXB0aCA9IGRlcHRocyA/IGRlcHRocy5sZW5ndGggOiAwO1xuICBwcm9nLmJsb2NrUGFyYW1zID0gZGVjbGFyZWRCbG9ja1BhcmFtcyB8fCAwO1xuICByZXR1cm4gcHJvZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQYXJ0aWFsKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgaWYgKCFwYXJ0aWFsKSB7XG4gICAgaWYgKG9wdGlvbnMubmFtZSA9PT0gJ0BwYXJ0aWFsLWJsb2NrJykge1xuICAgICAgcGFydGlhbCA9IG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdO1xuICAgIH1cbiAgfSBlbHNlIGlmICghcGFydGlhbC5jYWxsICYmICFvcHRpb25zLm5hbWUpIHtcbiAgICAvLyBUaGlzIGlzIGEgZHluYW1pYyBwYXJ0aWFsIHRoYXQgcmV0dXJuZWQgYSBzdHJpbmdcbiAgICBvcHRpb25zLm5hbWUgPSBwYXJ0aWFsO1xuICAgIHBhcnRpYWwgPSBvcHRpb25zLnBhcnRpYWxzW3BhcnRpYWxdO1xuICB9XG4gIHJldHVybiBwYXJ0aWFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMucGFydGlhbCA9IHRydWU7XG4gIGlmIChvcHRpb25zLmlkcykge1xuICAgIG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCA9IG9wdGlvbnMuaWRzWzBdIHx8IG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aDtcbiAgfVxuXG4gIGxldCBwYXJ0aWFsQmxvY2s7XG4gIGlmIChvcHRpb25zLmZuICYmIG9wdGlvbnMuZm4gIT09IG5vb3ApIHtcbiAgICBvcHRpb25zLmRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgIHBhcnRpYWxCbG9jayA9IG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddID0gb3B0aW9ucy5mbjtcblxuICAgIGlmIChwYXJ0aWFsQmxvY2sucGFydGlhbHMpIHtcbiAgICAgIG9wdGlvbnMucGFydGlhbHMgPSBVdGlscy5leHRlbmQoe30sIG9wdGlvbnMucGFydGlhbHMsIHBhcnRpYWxCbG9jay5wYXJ0aWFscyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCAmJiBwYXJ0aWFsQmxvY2spIHtcbiAgICBwYXJ0aWFsID0gcGFydGlhbEJsb2NrO1xuICB9XG5cbiAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RoZSBwYXJ0aWFsICcgKyBvcHRpb25zLm5hbWUgKyAnIGNvdWxkIG5vdCBiZSBmb3VuZCcpO1xuICB9IGVsc2UgaWYgKHBhcnRpYWwgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHJldHVybiBwYXJ0aWFsKGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkgeyByZXR1cm4gJyc7IH1cblxuZnVuY3Rpb24gaW5pdERhdGEoY29udGV4dCwgZGF0YSkge1xuICBpZiAoIWRhdGEgfHwgISgncm9vdCcgaW4gZGF0YSkpIHtcbiAgICBkYXRhID0gZGF0YSA/IGNyZWF0ZUZyYW1lKGRhdGEpIDoge307XG4gICAgZGF0YS5yb290ID0gY29udGV4dDtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZXhlY3V0ZURlY29yYXRvcnMoZm4sIHByb2csIGNvbnRhaW5lciwgZGVwdGhzLCBkYXRhLCBibG9ja1BhcmFtcykge1xuICBpZiAoZm4uZGVjb3JhdG9yKSB7XG4gICAgbGV0IHByb3BzID0ge307XG4gICAgcHJvZyA9IGZuLmRlY29yYXRvcihwcm9nLCBwcm9wcywgY29udGFpbmVyLCBkZXB0aHMgJiYgZGVwdGhzWzBdLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgICBVdGlscy5leHRlbmQocHJvZywgcHJvcHMpO1xuICB9XG4gIHJldHVybiBwcm9nO1xufVxuIiwiLy8gQnVpbGQgb3V0IG91ciBiYXNpYyBTYWZlU3RyaW5nIHR5cGVcbmZ1bmN0aW9uIFNhZmVTdHJpbmcoc3RyaW5nKSB7XG4gIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xufVxuXG5TYWZlU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IFNhZmVTdHJpbmcucHJvdG90eXBlLnRvSFRNTCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJycgKyB0aGlzLnN0cmluZztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNhZmVTdHJpbmc7XG4iLCJjb25zdCBlc2NhcGUgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmI3gyNzsnLFxuICAnYCc6ICcmI3g2MDsnLFxuICAnPSc6ICcmI3gzRDsnXG59O1xuXG5jb25zdCBiYWRDaGFycyA9IC9bJjw+XCInYD1dL2csXG4gICAgICBwb3NzaWJsZSA9IC9bJjw+XCInYD1dLztcblxuZnVuY3Rpb24gZXNjYXBlQ2hhcihjaHIpIHtcbiAgcmV0dXJuIGVzY2FwZVtjaHJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKG9iai8qICwgLi4uc291cmNlICovKSB7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQga2V5IGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbaV0sIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnQgbGV0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gU291cmNlZCBmcm9tIGxvZGFzaFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2xvZGFzaC9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuLyogZXNsaW50LWRpc2FibGUgZnVuYy1zdHlsZSAqL1xubGV0IGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufTtcbi8vIGZhbGxiYWNrIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpc0Z1bmN0aW9uKC94LykpIHtcbiAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfTtcbn1cbmV4cG9ydCB7aXNGdW5jdGlvbn07XG4vKiBlc2xpbnQtZW5hYmxlIGZ1bmMtc3R5bGUgKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpID8gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScgOiBmYWxzZTtcbn07XG5cbi8vIE9sZGVyIElFIHZlcnNpb25zIGRvIG5vdCBkaXJlY3RseSBzdXBwb3J0IGluZGV4T2Ygc28gd2UgbXVzdCBpbXBsZW1lbnQgb3VyIG93biwgc2FkbHkuXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRXhwcmVzc2lvbihzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgZXNjYXBlIFNhZmVTdHJpbmdzLCBzaW5jZSB0aGV5J3JlIGFscmVhZHkgc2FmZVxuICAgIGlmIChzdHJpbmcgJiYgc3RyaW5nLnRvSFRNTCkge1xuICAgICAgcmV0dXJuIHN0cmluZy50b0hUTUwoKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nICsgJyc7XG4gICAgfVxuXG4gICAgLy8gRm9yY2UgYSBzdHJpbmcgY29udmVyc2lvbiBhcyB0aGlzIHdpbGwgYmUgZG9uZSBieSB0aGUgYXBwZW5kIHJlZ2FyZGxlc3MgYW5kXG4gICAgLy8gdGhlIHJlZ2V4IHRlc3Qgd2lsbCBkbyB0aGlzIHRyYW5zcGFyZW50bHkgYmVoaW5kIHRoZSBzY2VuZXMsIGNhdXNpbmcgaXNzdWVzIGlmXG4gICAgLy8gYW4gb2JqZWN0J3MgdG8gc3RyaW5nIGhhcyBlc2NhcGVkIGNoYXJhY3RlcnMgaW4gaXQuXG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICBpZiAoIXBvc3NpYmxlLnRlc3Qoc3RyaW5nKSkgeyByZXR1cm4gc3RyaW5nOyB9XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShiYWRDaGFycywgZXNjYXBlQ2hhcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyYW1lKG9iamVjdCkge1xuICBsZXQgZnJhbWUgPSBleHRlbmQoe30sIG9iamVjdCk7XG4gIGZyYW1lLl9wYXJlbnQgPSBvYmplY3Q7XG4gIHJldHVybiBmcmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsb2NrUGFyYW1zKHBhcmFtcywgaWRzKSB7XG4gIHBhcmFtcy5wYXRoID0gaWRzO1xuICByZXR1cm4gcGFyYW1zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQ29udGV4dFBhdGgoY29udGV4dFBhdGgsIGlkKSB7XG4gIHJldHVybiAoY29udGV4dFBhdGggPyBjb250ZXh0UGF0aCArICcuJyA6ICcnKSArIGlkO1xufVxuIiwiLy8gQ3JlYXRlIGEgc2ltcGxlIHBhdGggYWxpYXMgdG8gYWxsb3cgYnJvd3NlcmlmeSB0byByZXNvbHZlXG4vLyB0aGUgcnVudGltZSBvbiBhIHN1cHBvcnRlZCBwYXRoLlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2pzL2hhbmRsZWJhcnMucnVudGltZScpWydkZWZhdWx0J107XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJoYW5kbGViYXJzL3J1bnRpbWVcIilbXCJkZWZhdWx0XCJdO1xuIiwiXG4vKipcbiAqIEBsaWNlbnNlIEhpZ2hjaGFydHMgSlMgdjQuMS45ICgyMDE1LTEwLTA3KVxuICpcbiAqIFN0YW5kYWxvbmUgSGlnaGNoYXJ0cyBGcmFtZXdvcmtcbiAqXG4gKiBMaWNlbnNlOiBNSVQgTGljZW5zZVxuICovXG5cblxuLypnbG9iYWwgSGlnaGNoYXJ0cyAqL1xudmFyIEhpZ2hjaGFydHNBZGFwdGVyID0gKGZ1bmN0aW9uICgpIHtcblxudmFyIFVOREVGSU5FRCxcblx0ZG9jID0gZG9jdW1lbnQsXG5cdGVtcHR5QXJyYXkgPSBbXSxcblx0dGltZXJzID0gW10sXG5cdGFuaW1TZXR0ZXJzID0ge30sXG5cdEZ4O1xuXG5NYXRoLmVhc2VJbk91dFNpbmUgPSBmdW5jdGlvbiAodCwgYiwgYywgZCkge1xuXHRyZXR1cm4gLWMgLyAyICogKE1hdGguY29zKE1hdGguUEkgKiB0IC8gZCkgLSAxKSArIGI7XG59O1xuXG5cblxuLyoqXG4gKiBFeHRlbmQgZ2l2ZW4gb2JqZWN0IHdpdGggY3VzdG9tIGV2ZW50c1xuICovXG5mdW5jdGlvbiBhdWdtZW50KG9iaikge1xuXHRmdW5jdGlvbiByZW1vdmVPbmVFdmVudChlbCwgdHlwZSwgZm4pIHtcblx0XHRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBJRVJlbW92ZU9uZUV2ZW50KGVsLCB0eXBlLCBmbikge1xuXHRcdGZuID0gZWwuSENQcm94aWVkTWV0aG9kc1tmbi50b1N0cmluZygpXTtcblx0XHRlbC5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgZm4pO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlQWxsRXZlbnRzKGVsLCB0eXBlKSB7XG5cdFx0dmFyIGV2ZW50cyA9IGVsLkhDRXZlbnRzLFxuXHRcdFx0cmVtb3ZlLFxuXHRcdFx0dHlwZXMsXG5cdFx0XHRsZW4sXG5cdFx0XHRuO1xuXG5cdFx0aWYgKGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdHJlbW92ZSA9IHJlbW92ZU9uZUV2ZW50O1xuXHRcdH0gZWxzZSBpZiAoZWwuYXR0YWNoRXZlbnQpIHtcblx0XHRcdHJlbW92ZSA9IElFUmVtb3ZlT25lRXZlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjsgLy8gYnJlYWsgb24gbm9uLURPTSBldmVudHNcblx0XHR9XG5cblxuXHRcdGlmICh0eXBlKSB7XG5cdFx0XHR0eXBlcyA9IHt9O1xuXHRcdFx0dHlwZXNbdHlwZV0gPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0eXBlcyA9IGV2ZW50cztcblx0XHR9XG5cblx0XHRmb3IgKG4gaW4gdHlwZXMpIHtcblx0XHRcdGlmIChldmVudHNbbl0pIHtcblx0XHRcdFx0bGVuID0gZXZlbnRzW25dLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGxlbi0tKSB7XG5cdFx0XHRcdFx0cmVtb3ZlKGVsLCBuLCBldmVudHNbbl1bbGVuXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIW9iai5IQ0V4dGVuZGVkKSB7XG5cdFx0SGlnaGNoYXJ0cy5leHRlbmQob2JqLCB7XG5cdFx0XHRIQ0V4dGVuZGVkOiB0cnVlLFxuXG5cdFx0XHRIQ0V2ZW50czoge30sXG5cblx0XHRcdGJpbmQ6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuXHRcdFx0XHR2YXIgZWwgPSB0aGlzLFxuXHRcdFx0XHRcdGV2ZW50cyA9IHRoaXMuSENFdmVudHMsXG5cdFx0XHRcdFx0d3JhcHBlZEZuO1xuXG5cdFx0XHRcdC8vIGhhbmRsZSBET00gZXZlbnRzIGluIG1vZGVybiBicm93c2Vyc1xuXHRcdFx0XHRpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZm4sIGZhbHNlKTtcblxuXHRcdFx0XHQvLyBoYW5kbGUgb2xkIElFIGltcGxlbWVudGF0aW9uXG5cdFx0XHRcdH0gZWxzZSBpZiAoZWwuYXR0YWNoRXZlbnQpIHtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR3cmFwcGVkRm4gPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0ZS50YXJnZXQgPSBlLnNyY0VsZW1lbnQgfHwgd2luZG93OyAvLyAjMjgyMFxuXHRcdFx0XHRcdFx0Zm4uY2FsbChlbCwgZSk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmICghZWwuSENQcm94aWVkTWV0aG9kcykge1xuXHRcdFx0XHRcdFx0ZWwuSENQcm94aWVkTWV0aG9kcyA9IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGxpbmsgd3JhcHBlZCBmbiB3aXRoIG9yaWdpbmFsIGZuLCBzbyB3ZSBjYW4gZ2V0IHRoaXMgaW4gcmVtb3ZlRXZlbnRcblx0XHRcdFx0XHRlbC5IQ1Byb3hpZWRNZXRob2RzW2ZuLnRvU3RyaW5nKCldID0gd3JhcHBlZEZuO1xuXG5cdFx0XHRcdFx0ZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIHdyYXBwZWRGbik7XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGlmIChldmVudHNbbmFtZV0gPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdGV2ZW50c1tuYW1lXSA9IFtdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZXZlbnRzW25hbWVdLnB1c2goZm4pO1xuXHRcdFx0fSxcblxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcblx0XHRcdFx0dmFyIGV2ZW50cyxcblx0XHRcdFx0XHRpbmRleDtcblxuXHRcdFx0XHRpZiAobmFtZSkge1xuXHRcdFx0XHRcdGV2ZW50cyA9IHRoaXMuSENFdmVudHNbbmFtZV0gfHwgW107XG5cdFx0XHRcdFx0aWYgKGZuKSB7XG5cdFx0XHRcdFx0XHRpbmRleCA9IEhpZ2hjaGFydHNBZGFwdGVyLmluQXJyYXkoZm4sIGV2ZW50cyk7XG5cdFx0XHRcdFx0XHRpZiAoaW5kZXggPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRldmVudHMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5IQ0V2ZW50c1tuYW1lXSA9IGV2ZW50cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlT25lRXZlbnQodGhpcywgbmFtZSwgZm4pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmF0dGFjaEV2ZW50KSB7XG5cdFx0XHRcdFx0XHRcdElFUmVtb3ZlT25lRXZlbnQodGhpcywgbmFtZSwgZm4pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVBbGxFdmVudHModGhpcywgbmFtZSk7XG5cdFx0XHRcdFx0XHR0aGlzLkhDRXZlbnRzW25hbWVdID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlbW92ZUFsbEV2ZW50cyh0aGlzKTtcblx0XHRcdFx0XHR0aGlzLkhDRXZlbnRzID0ge307XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG5cdFx0XHRcdHZhciBldmVudHMgPSB0aGlzLkhDRXZlbnRzW25hbWVdIHx8IFtdLFxuXHRcdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdFx0bGVuID0gZXZlbnRzLmxlbmd0aCxcblx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdHByZXZlbnREZWZhdWx0LFxuXHRcdFx0XHRcdGZuO1xuXG5cdFx0XHRcdC8vIEF0dGFjaCBhIHNpbXBsZSBwcmV2ZW50RGVmYXVsdCBmdW5jdGlvbiB0byBza2lwIGRlZmF1bHQgaGFuZGxlciBpZiBjYWxsZWRcblx0XHRcdFx0cHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0YXJncy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGZuID0gZXZlbnRzW2ldO1xuXG5cdFx0XHRcdFx0Ly8gYXJncyBpcyBuZXZlciBudWxsIGhlcmVcblx0XHRcdFx0XHRpZiAoYXJncy5zdG9wcGVkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YXJncy5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xuXHRcdFx0XHRcdGFyZ3MudGFyZ2V0ID0gdGFyZ2V0O1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHR5cGUgaXMgbm90IHNldCwgd2UncmUgcnVubmluZyBhIGN1c3RvbSBldmVudCAoIzIyOTcpLiBJZiBpdCBpcyBzZXQsXG5cdFx0XHRcdFx0Ly8gd2UncmUgcnVubmluZyBhIGJyb3dzZXIgZXZlbnQsIGFuZCBzZXR0aW5nIGl0IHdpbGwgY2F1c2UgZW4gZXJyb3IgaW5cblx0XHRcdFx0XHQvLyBJRTggKCMyNDY1KS5cblx0XHRcdFx0XHRpZiAoIWFyZ3MudHlwZSkge1xuXHRcdFx0XHRcdFx0YXJncy50eXBlID0gbmFtZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaGFuZGxlciByZXR1cm4gZmFsc2UsIHByZXZlbnQgdGhlIGRlZmF1bHQgaGFuZGxlciBmcm9tIGV4ZWN1dGluZ1xuXHRcdFx0XHRcdGlmIChmbi5jYWxsKHRoaXMsIGFyZ3MpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YXJncy5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIG9iajtcbn1cblxuXG5yZXR1cm4ge1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBhZGFwdGVyLiBUaGlzIGlzIHJ1biBvbmNlIGFzIEhpZ2hjaGFydHMgaXMgZmlyc3QgcnVuLlxuXHQgKi9cblx0aW5pdDogZnVuY3Rpb24gKHBhdGhBbmltKSB7XG5cblx0XHQvKipcblx0XHQgKiBDb21wYXRpYmlsaXR5IHNlY3Rpb24gdG8gYWRkIHN1cHBvcnQgZm9yIGxlZ2FjeSBJRS4gVGhpcyBjYW4gYmUgcmVtb3ZlZCBpZiBvbGQgSUUgXG5cdFx0ICogc3VwcG9ydCBpcyBub3QgbmVlZGVkLlxuXHRcdCAqL1xuXHRcdGlmICghZG9jLmRlZmF1bHRWaWV3KSB7XG5cdFx0XHR0aGlzLl9nZXRTdHlsZSA9IGZ1bmN0aW9uIChlbCwgcHJvcCkge1xuXHRcdFx0XHR2YXIgdmFsO1xuXHRcdFx0XHRpZiAoZWwuc3R5bGVbcHJvcF0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZWwuc3R5bGVbcHJvcF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHByb3AgPT09ICdvcGFjaXR5Jykge1xuXHRcdFx0XHRcdFx0cHJvcCA9ICdmaWx0ZXInO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvKmpzbGludCB1bnBhcmFtOiB0cnVlKi9cblx0XHRcdFx0XHR2YWwgPSBlbC5jdXJyZW50U3R5bGVbcHJvcC5yZXBsYWNlKC9cXC0oXFx3KS9nLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi50b1VwcGVyQ2FzZSgpOyB9KV07XG5cdFx0XHRcdFx0aWYgKHByb3AgPT09ICdmaWx0ZXInKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSB2YWwucmVwbGFjZShcblx0XHRcdFx0XHRcdFx0L2FscGhhXFwob3BhY2l0eT0oWzAtOV0rKVxcKS8sIFxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAoYSwgYikgeyBcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gYiAvIDEwMDsgXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8qanNsaW50IHVucGFyYW06IGZhbHNlKi9cblx0XHRcdFx0XHRyZXR1cm4gdmFsID09PSAnJyA/IDEgOiB2YWw7XG5cdFx0XHRcdH0gXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5hZGFwdGVyUnVuID0gZnVuY3Rpb24gKGVsZW0sIG1ldGhvZCkge1xuXHRcdFx0XHR2YXIgYWxpYXMgPSB7IHdpZHRoOiAnY2xpZW50V2lkdGgnLCBoZWlnaHQ6ICdjbGllbnRIZWlnaHQnIH1bbWV0aG9kXTtcblxuXHRcdFx0XHRpZiAoYWxpYXMpIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLnpvb20gPSAxO1xuXHRcdFx0XHRcdHJldHVybiBlbGVtW2FsaWFzXSAtIDIgKiBwYXJzZUludChIaWdoY2hhcnRzQWRhcHRlci5fZ2V0U3R5bGUoZWxlbSwgJ3BhZGRpbmcnKSwgMTApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcblx0XHRcdHRoaXMuZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGZuKSB7IC8vIGxlZ2FjeVxuXHRcdFx0XHR2YXIgaSA9IDAsIFxuXHRcdFx0XHRcdGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZm4uY2FsbChhcnJbaV0sIGFycltpXSwgaSwgYXJyKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG5cdFx0XHR0aGlzLmluQXJyYXkgPSBmdW5jdGlvbiAoaXRlbSwgYXJyKSB7XG5cdFx0XHRcdHZhciBsZW4sIFxuXHRcdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRcdGlmIChhcnIpIHtcblx0XHRcdFx0XHRsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChhcnJbaV0gPT09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoIUFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcblx0XHRcdHRoaXMuZ3JlcCA9IGZ1bmN0aW9uIChlbGVtZW50cywgY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIHJldCA9IFtdLFxuXHRcdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKCEhY2FsbGJhY2soZWxlbWVudHNbaV0sIGkpKSB7XG5cdFx0XHRcdFx0XHRyZXQucHVzaChlbGVtZW50c1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8tLS0gRW5kIGNvbXBhdGliaWxpdHkgc2VjdGlvbiAtLS1cblxuXG5cdFx0LyoqXG5cdFx0ICogU3RhcnQgb2YgYW5pbWF0aW9uIHNwZWNpZmljIGNvZGVcblx0XHQgKi9cblx0XHRGeCA9IGZ1bmN0aW9uIChlbGVtLCBvcHRpb25zLCBwcm9wKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0fTtcblx0XHRGeC5wcm90b3R5cGUgPSB7XG5cdFx0XHRcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgc3R5bGVzLFxuXHRcdFx0XHRcdHBhdGhzID0gdGhpcy5wYXRocyxcblx0XHRcdFx0XHRlbGVtID0gdGhpcy5lbGVtLFxuXHRcdFx0XHRcdGVsZW1lbGVtID0gZWxlbS5lbGVtZW50OyAvLyBpZiBkZXN0cm95ZWQsIGl0IGlzIG51bGxcblxuXHRcdFx0XHQvLyBBbmltYXRpb24gc2V0dGVyIGRlZmluZWQgZnJvbSBvdXRzaWRlXG5cdFx0XHRcdGlmIChhbmltU2V0dGVyc1t0aGlzLnByb3BdKSB7XG5cdFx0XHRcdFx0YW5pbVNldHRlcnNbdGhpcy5wcm9wXSh0aGlzKTtcblxuXHRcdFx0XHQvLyBBbmltYXRpbmcgYSBwYXRoIGRlZmluaXRpb24gb24gU1ZHRWxlbWVudFxuXHRcdFx0XHR9IGVsc2UgaWYgKHBhdGhzICYmIGVsZW1lbGVtKSB7XG5cdFx0XHRcdFx0ZWxlbS5hdHRyKCdkJywgcGF0aEFuaW0uc3RlcChwYXRoc1swXSwgcGF0aHNbMV0sIHRoaXMubm93LCB0aGlzLnRvRCkpO1xuXG5cdFx0XHRcdC8vIE90aGVyIGFuaW1hdGlvbnMgb24gU1ZHRWxlbWVudFxuXHRcdFx0XHR9IGVsc2UgaWYgKGVsZW0uYXR0cikge1xuXHRcdFx0XHRcdGlmIChlbGVtZWxlbSkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hdHRyKHRoaXMucHJvcCwgdGhpcy5ub3cpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIVE1MIHN0eWxlc1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlcyA9IHt9O1xuXHRcdFx0XHRcdHN0eWxlc1t0aGlzLnByb3BdID0gdGhpcy5ub3cgKyB0aGlzLnVuaXQ7XG5cdFx0XHRcdFx0SGlnaGNoYXJ0cy5jc3MoZWxlbSwgc3R5bGVzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zdGVwKSB7XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXHRcdFx0Y3VzdG9tOiBmdW5jdGlvbiAoZnJvbSwgdG8sIHVuaXQpIHtcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRcdHQgPSBmdW5jdGlvbiAoZ290b0VuZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNlbGYuc3RlcChnb3RvRW5kKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGk7XG5cblx0XHRcdFx0dGhpcy5zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblx0XHRcdFx0dGhpcy5zdGFydCA9IGZyb207XG5cdFx0XHRcdHRoaXMuZW5kID0gdG87XG5cdFx0XHRcdHRoaXMudW5pdCA9IHVuaXQ7XG5cdFx0XHRcdHRoaXMubm93ID0gdGhpcy5zdGFydDtcblx0XHRcdFx0dGhpcy5wb3MgPSB0aGlzLnN0YXRlID0gMDtcblxuXHRcdFx0XHR0LmVsZW0gPSB0aGlzLmVsZW07XG5cblx0XHRcdFx0aWYgKHQoKSAmJiB0aW1lcnMucHVzaCh0KSA9PT0gMSkge1xuXHRcdFx0XHRcdHQudGltZXJJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXRpbWVyc1tpXSgpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGltZXJzLnNwbGljZShpLS0sIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICghdGltZXJzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRjbGVhckludGVydmFsKHQudGltZXJJZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgMTMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0XG5cdFx0XHRzdGVwOiBmdW5jdGlvbiAoZ290b0VuZCkge1xuXHRcdFx0XHR2YXIgdCA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0XHRcdHJldCxcblx0XHRcdFx0XHRkb25lLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdFx0ZWxlbSA9IHRoaXMuZWxlbSxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGVsZW0uYXR0ciAmJiAhZWxlbS5lbGVtZW50KSB7IC8vICMyNjE2LCBlbGVtZW50IGluY2x1ZGluZyBmbGFnIGlzIGRlc3Ryb3llZFxuXHRcdFx0XHRcdHJldCA9IGZhbHNlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoZ290b0VuZCB8fCB0ID49IG9wdGlvbnMuZHVyYXRpb24gKyB0aGlzLnN0YXJ0VGltZSkge1xuXHRcdFx0XHRcdHRoaXMubm93ID0gdGhpcy5lbmQ7XG5cdFx0XHRcdFx0dGhpcy5wb3MgPSB0aGlzLnN0YXRlID0gMTtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zLmN1ckFuaW1bdGhpcy5wcm9wXSA9IHRydWU7XG5cblx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRmb3IgKGkgaW4gb3B0aW9ucy5jdXJBbmltKSB7XG5cdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5jdXJBbmltW2ldICE9PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdGRvbmUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZG9uZSkge1xuXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMuY29tcGxldGUpIHtcblx0XHRcdFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZS5jYWxsKGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXQgPSBmYWxzZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBuID0gdCAtIHRoaXMuc3RhcnRUaW1lO1xuXHRcdFx0XHRcdHRoaXMuc3RhdGUgPSBuIC8gb3B0aW9ucy5kdXJhdGlvbjtcblx0XHRcdFx0XHR0aGlzLnBvcyA9IG9wdGlvbnMuZWFzaW5nKG4sIDAsIDEsIG9wdGlvbnMuZHVyYXRpb24pO1xuXHRcdFx0XHRcdHRoaXMubm93ID0gdGhpcy5zdGFydCArICgodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIHRoaXMucG9zKTtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdHJldCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGFkYXB0ZXIgYW5pbWF0ZSBtZXRob2Rcblx0XHQgKi9cblx0XHR0aGlzLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWwsIHByb3AsIG9wdCkge1xuXHRcdFx0dmFyIHN0YXJ0LFxuXHRcdFx0XHR1bml0ID0gJycsXG5cdFx0XHRcdGVuZCxcblx0XHRcdFx0ZngsXG5cdFx0XHRcdGFyZ3MsXG5cdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFBYID0gJ3B4JztcblxuXHRcdFx0aWYgKHR5cGVvZiBvcHQgIT09ICdvYmplY3QnIHx8IG9wdCA9PT0gbnVsbCkge1xuXHRcdFx0XHRhcmdzID0gYXJndW1lbnRzO1xuXHRcdFx0XHRvcHQgPSB7XG5cdFx0XHRcdFx0ZHVyYXRpb246IGFyZ3NbMl0sXG5cdFx0XHRcdFx0ZWFzaW5nOiBhcmdzWzNdLFxuXHRcdFx0XHRcdGNvbXBsZXRlOiBhcmdzWzRdXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gJ251bWJlcicpIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0gNDAwO1xuXHRcdFx0fVxuXHRcdFx0b3B0LmVhc2luZyA9IE1hdGhbb3B0LmVhc2luZ10gfHwgTWF0aC5lYXNlSW5PdXRTaW5lO1xuXHRcdFx0b3B0LmN1ckFuaW0gPSBIaWdoY2hhcnRzLmV4dGVuZCh7fSwgcHJvcCk7XG5cdFx0XHRcblx0XHRcdGZvciAobmFtZSBpbiBwcm9wKSB7XG5cdFx0XHRcdGZ4ID0gbmV3IEZ4KGVsLCBvcHQsIG5hbWUpO1xuXHRcdFx0XHRlbmQgPSBudWxsO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG5hbWUgPT09ICdkJykge1xuXHRcdFx0XHRcdGZ4LnBhdGhzID0gcGF0aEFuaW0uaW5pdChcblx0XHRcdFx0XHRcdGVsLFxuXHRcdFx0XHRcdFx0ZWwuZCxcblx0XHRcdFx0XHRcdHByb3AuZFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0ZngudG9EID0gcHJvcC5kO1xuXHRcdFx0XHRcdHN0YXJ0ID0gMDtcblx0XHRcdFx0XHRlbmQgPSAxO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGVsLmF0dHIpIHtcblx0XHRcdFx0XHRzdGFydCA9IGVsLmF0dHIobmFtZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhcnQgPSBwYXJzZUZsb2F0KEhpZ2hjaGFydHNBZGFwdGVyLl9nZXRTdHlsZShlbCwgbmFtZSkpIHx8IDA7XG5cdFx0XHRcdFx0aWYgKG5hbWUgIT09ICdvcGFjaXR5Jykge1xuXHRcdFx0XHRcdFx0dW5pdCA9IFBYO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0aWYgKCFlbmQpIHtcblx0XHRcdFx0XHRlbmQgPSBwcm9wW25hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlbmQubWF0Y2ggJiYgZW5kLm1hdGNoKFBYKSkge1xuXHRcdFx0XHRcdGVuZCA9IGVuZC5yZXBsYWNlKC9weC9nLCAnJyk7IC8vICM0MzUxXG5cdFx0XHRcdH1cblx0XHRcdFx0ZnguY3VzdG9tKHN0YXJ0LCBlbmQsIHVuaXQpO1xuXHRcdFx0fVx0XG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogSW50ZXJuYWwgbWV0aG9kIHRvIHJldHVybiBDU1MgdmFsdWUgZm9yIGdpdmVuIGVsZW1lbnQgYW5kIHByb3BlcnR5XG5cdCAqL1xuXHRfZ2V0U3R5bGU6IGZ1bmN0aW9uIChlbCwgcHJvcCkge1xuXHRcdHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgdW5kZWZpbmVkKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGQgYW4gYW5pbWF0aW9uIHNldHRlciBmb3IgYSBzcGVjaWZpYyBwcm9wZXJ0eVxuXHQgKi9cblx0YWRkQW5pbVNldHRlcjogZnVuY3Rpb24gKHByb3AsIGZuKSB7XG5cdFx0YW5pbVNldHRlcnNbcHJvcF0gPSBmbjtcblx0fSxcblxuXHQvKipcblx0ICogRG93bmxvYWRzIGEgc2NyaXB0IGFuZCBleGVjdXRlcyBhIGNhbGxiYWNrIHdoZW4gZG9uZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHNjcmlwdExvY2F0aW9uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqL1xuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uIChzY3JpcHRMb2NhdGlvbiwgY2FsbGJhY2spIHtcblx0XHQvLyBXZSBjYW5ub3QgYXNzdW1lIHRoYXQgQXNzZXRzIGNsYXNzIGZyb20gbW9vdG9vbHMtbW9yZSBpcyBhdmFpbGFibGUgc28gaW5zdGVhZCBpbnNlcnQgYSBzY3JpcHQgdGFnIHRvIGRvd25sb2FkIHNjcmlwdC5cblx0XHR2YXIgaGVhZCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLFxuXHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG5cdFx0c2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0Jztcblx0XHRzY3JpcHQuc3JjID0gc2NyaXB0TG9jYXRpb247XG5cdFx0c2NyaXB0Lm9ubG9hZCA9IGNhbGxiYWNrO1xuXG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGluZGV4IG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksIG9yIC0xIGlmIG5vdCBmb3VuZFxuXHQgKi9cblx0aW5BcnJheTogZnVuY3Rpb24gKGl0ZW0sIGFycikge1xuXHRcdHJldHVybiBhcnIuaW5kZXhPZiA/IGFyci5pbmRleE9mKGl0ZW0pIDogZW1wdHlBcnJheS5pbmRleE9mLmNhbGwoYXJyLCBpdGVtKTtcblx0fSxcblxuXG5cdC8qKlxuXHQgKiBBIGRpcmVjdCBsaW5rIHRvIGFkYXB0ZXIgbWV0aG9kc1xuXHQgKi9cblx0YWRhcHRlclJ1bjogZnVuY3Rpb24gKGVsZW0sIG1ldGhvZCkge1xuXHRcdHJldHVybiBwYXJzZUludChIaWdoY2hhcnRzQWRhcHRlci5fZ2V0U3R5bGUoZWxlbSwgbWV0aG9kKSwgMTApO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBGaWx0ZXIgYW4gYXJyYXlcblx0ICovXG5cdGdyZXA6IGZ1bmN0aW9uIChlbGVtZW50cywgY2FsbGJhY2spIHtcblx0XHRyZXR1cm4gZW1wdHlBcnJheS5maWx0ZXIuY2FsbChlbGVtZW50cywgY2FsbGJhY2spO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBNYXAgYW4gYXJyYXlcblx0ICovXG5cdG1hcDogZnVuY3Rpb24gKGFyciwgZm4pIHtcblx0XHR2YXIgcmVzdWx0cyA9IFtdLCBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDtcblxuXHRcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHJlc3VsdHNbaV0gPSBmbi5jYWxsKGFycltpXSwgYXJyW2ldLCBpLCBhcnIpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGVsZW1lbnQncyBvZmZzZXQgcG9zaXRpb24sIGNvcnJlY3RlZCBieSBvdmVyZmxvdzphdXRvLiBMb29zZWx5IGJhc2VkIG9uIGpRdWVyeSdzIG9mZnNldCBtZXRob2QuXG5cdCAqL1xuXHRvZmZzZXQ6IGZ1bmN0aW9uIChlbCkge1xuXHRcdHZhciBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0Ym94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBib3gudG9wICArICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3ApICAtIChkb2NFbGVtLmNsaWVudFRvcCAgfHwgMCksXG5cdFx0XHRsZWZ0OiBib3gubGVmdCArICh3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxMZWZ0KSAtIChkb2NFbGVtLmNsaWVudExlZnQgfHwgMClcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcblx0ICovXG5cdGFkZEV2ZW50OiBmdW5jdGlvbiAoZWwsIHR5cGUsIGZuKSB7XG5cdFx0YXVnbWVudChlbCkuYmluZCh0eXBlLCBmbik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBldmVudCBhZGRlZCB3aXRoIGFkZEV2ZW50XG5cdCAqL1xuXHRyZW1vdmVFdmVudDogZnVuY3Rpb24gKGVsLCB0eXBlLCBmbikge1xuXHRcdGF1Z21lbnQoZWwpLnVuYmluZCh0eXBlLCBmbik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZpcmUgYW4gZXZlbnQgb24gYSBjdXN0b20gb2JqZWN0XG5cdCAqL1xuXHRmaXJlRXZlbnQ6IGZ1bmN0aW9uIChlbCwgdHlwZSwgZXZlbnRBcmd1bWVudHMsIGRlZmF1bHRGdW5jdGlvbikge1xuXHRcdHZhciBlO1xuXG5cdFx0aWYgKGRvYy5jcmVhdGVFdmVudCAmJiAoZWwuZGlzcGF0Y2hFdmVudCB8fCBlbC5maXJlRXZlbnQpKSB7XG5cdFx0XHRlID0gZG9jLmNyZWF0ZUV2ZW50KCdFdmVudHMnKTtcblx0XHRcdGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuXHRcdFx0ZS50YXJnZXQgPSBlbDtcblxuXHRcdFx0SGlnaGNoYXJ0cy5leHRlbmQoZSwgZXZlbnRBcmd1bWVudHMpO1xuXG5cdFx0XHRpZiAoZWwuZGlzcGF0Y2hFdmVudCkge1xuXHRcdFx0XHRlbC5kaXNwYXRjaEV2ZW50KGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWwuZmlyZUV2ZW50KHR5cGUsIGUpO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmIChlbC5IQ0V4dGVuZGVkID09PSB0cnVlKSB7XG5cdFx0XHRldmVudEFyZ3VtZW50cyA9IGV2ZW50QXJndW1lbnRzIHx8IHt9O1xuXHRcdFx0ZWwudHJpZ2dlcih0eXBlLCBldmVudEFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50QXJndW1lbnRzICYmIGV2ZW50QXJndW1lbnRzLmRlZmF1bHRQcmV2ZW50ZWQpIHtcblx0XHRcdGRlZmF1bHRGdW5jdGlvbiA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKGRlZmF1bHRGdW5jdGlvbikge1xuXHRcdFx0ZGVmYXVsdEZ1bmN0aW9uKGV2ZW50QXJndW1lbnRzKTtcblx0XHR9XG5cdH0sXG5cblx0d2FzaE1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0cmV0dXJuIGU7XG5cdH0sXG5cblxuXHQvKipcblx0ICogU3RvcCBydW5uaW5nIGFuaW1hdGlvblxuXHQgKi9cblx0c3RvcDogZnVuY3Rpb24gKGVsKSB7XG5cblx0XHR2YXIgaSA9IHRpbWVycy5sZW5ndGgsXG5cdFx0XHR0aW1lcjtcblxuXHRcdC8vIFJlbW92ZSB0aW1lcnMgcmVsYXRlZCB0byB0aGlzIGVsZW1lbnQgKCM0NTE5KVxuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdHRpbWVyID0gdGltZXJzW2ldO1xuXHRcdFx0aWYgKHRpbWVyLmVsZW0gPT09IGVsKSB7XG5cdFx0XHRcdHRpbWVycy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVdGlsaXR5IGZvciBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheS4gUGFyYW1ldGVycyBhcmUgcmV2ZXJzZWQgY29tcGFyZWQgdG8galF1ZXJ5LlxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0ICovXG5cdGVhY2g6IGZ1bmN0aW9uIChhcnIsIGZuKSB7IC8vIG1vZGVybiBicm93c2Vyc1xuXHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGFyciwgZm4pO1xuXHR9XG59O1xufSgpKTtcbjtcblxubW9kdWxlLmV4cG9ydHMgPSBIaWdoY2hhcnRzQWRhcHRlcjsiLCJcbnZhciBIaWdoY2hhcnRzQWRhcHRlciA9IHdpbmRvdy5IaWdoY2hhcnRzQWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvc3RhbmRhbG9uZS1mcmFtZXdvcmsnKTtcblxuLy8gPT1DbG9zdXJlQ29tcGlsZXI9PVxuLy8gQGNvbXBpbGF0aW9uX2xldmVsIFNJTVBMRV9PUFRJTUlaQVRJT05TXG5cbi8qKlxuICogQGxpY2Vuc2UgSGlnaGNoYXJ0cyBKUyB2NC4xLjkgKDIwMTUtMTAtMDcpXG4gKlxuICogKGMpIDIwMDktMjAxNCBUb3JzdGVpbiBIb25zaVxuICpcbiAqIExpY2Vuc2U6IHd3dy5oaWdoY2hhcnRzLmNvbS9saWNlbnNlXG4gKi9cblxuLy8gSlNMaW50IG9wdGlvbnM6XG4vKmdsb2JhbCBIaWdoY2hhcnRzLCBIaWdoY2hhcnRzQWRhcHRlciwgZG9jdW1lbnQsIHdpbmRvdywgbmF2aWdhdG9yLCBzZXRJbnRlcnZhbCwgY2xlYXJJbnRlcnZhbCwgY2xlYXJUaW1lb3V0LCBzZXRUaW1lb3V0LCBsb2NhdGlvbiwgalF1ZXJ5LCAkLCBjb25zb2xlLCBlYWNoLCBncmVwICovXG4vKmpzbGludCBhc3M6IHRydWUsIHNsb3BweTogdHJ1ZSwgZm9yaW46IHRydWUsIHBsdXNwbHVzOiB0cnVlLCBub21lbjogdHJ1ZSwgdmFyczogdHJ1ZSwgcmVnZXhwOiB0cnVlLCBuZXdjYXA6IHRydWUsIGJyb3dzZXI6IHRydWUsIGNvbnRpbnVlOiB0cnVlLCB3aGl0ZTogdHJ1ZSAqL1xuKGZ1bmN0aW9uICgpIHtcbi8vIGVuY2Fwc3VsYXRlZCB2YXJpYWJsZXNcbnZhciBVTkRFRklORUQsXG5cdGRvYyA9IGRvY3VtZW50LFxuXHR3aW4gPSB3aW5kb3csXG5cdG1hdGggPSBNYXRoLFxuXHRtYXRoUm91bmQgPSBtYXRoLnJvdW5kLFxuXHRtYXRoRmxvb3IgPSBtYXRoLmZsb29yLFxuXHRtYXRoQ2VpbCA9IG1hdGguY2VpbCxcblx0bWF0aE1heCA9IG1hdGgubWF4LFxuXHRtYXRoTWluID0gbWF0aC5taW4sXG5cdG1hdGhBYnMgPSBtYXRoLmFicyxcblx0bWF0aENvcyA9IG1hdGguY29zLFxuXHRtYXRoU2luID0gbWF0aC5zaW4sXG5cdG1hdGhQSSA9IG1hdGguUEksXG5cdGRlZzJyYWQgPSBtYXRoUEkgKiAyIC8gMzYwLFxuXG5cblx0Ly8gc29tZSB2YXJpYWJsZXNcblx0dXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcblx0aXNPcGVyYSA9IHdpbi5vcGVyYSxcblx0aXNNUyA9IC8obXNpZXx0cmlkZW50fGVkZ2UpL2kudGVzdCh1c2VyQWdlbnQpICYmICFpc09wZXJhLFxuXHRkb2NNb2RlOCA9IGRvYy5kb2N1bWVudE1vZGUgPT09IDgsXG5cdGlzV2ViS2l0ID0gIWlzTVMgJiYgL0FwcGxlV2ViS2l0Ly50ZXN0KHVzZXJBZ2VudCksXG5cdGlzRmlyZWZveCA9IC9GaXJlZm94Ly50ZXN0KHVzZXJBZ2VudCksXG5cdGlzVG91Y2hEZXZpY2UgPSAvKE1vYmlsZXxBbmRyb2lkfFdpbmRvd3MgUGhvbmUpLy50ZXN0KHVzZXJBZ2VudCksXG5cdFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdGhhc1NWRyA9ICEhZG9jLmNyZWF0ZUVsZW1lbnROUyAmJiAhIWRvYy5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCAnc3ZnJykuY3JlYXRlU1ZHUmVjdCxcblx0aGFzQmlkaUJ1ZyA9IGlzRmlyZWZveCAmJiBwYXJzZUludCh1c2VyQWdlbnQuc3BsaXQoJ0ZpcmVmb3gvJylbMV0sIDEwKSA8IDQsIC8vIGlzc3VlICMzOFxuXHR1c2VDYW5WRyA9ICFoYXNTVkcgJiYgIWlzTVMgJiYgISFkb2MuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCxcblx0UmVuZGVyZXIsXG5cdGhhc1RvdWNoLFxuXHRzeW1ib2xTaXplcyA9IHt9LFxuXHRpZENvdW50ZXIgPSAwLFxuXHRnYXJiYWdlQmluLFxuXHRkZWZhdWx0T3B0aW9ucyxcblx0ZGF0ZUZvcm1hdCwgLy8gZnVuY3Rpb25cblx0cGF0aEFuaW0sXG5cdHRpbWVVbml0cyxcblx0bm9vcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFVOREVGSU5FRDsgfSxcblx0Y2hhcnRzID0gW10sXG5cdGNoYXJ0Q291bnQgPSAwLFxuXHRQUk9EVUNUID0gJ0hpZ2hjaGFydHMnLFxuXHRWRVJTSU9OID0gJzQuMS45JyxcblxuXHQvLyBzb21lIGNvbnN0YW50cyBmb3IgZnJlcXVlbnRseSB1c2VkIHN0cmluZ3Ncblx0RElWID0gJ2RpdicsXG5cdEFCU09MVVRFID0gJ2Fic29sdXRlJyxcblx0UkVMQVRJVkUgPSAncmVsYXRpdmUnLFxuXHRISURERU4gPSAnaGlkZGVuJyxcblx0UFJFRklYID0gJ2hpZ2hjaGFydHMtJyxcblx0VklTSUJMRSA9ICd2aXNpYmxlJyxcblx0UFggPSAncHgnLFxuXHROT05FID0gJ25vbmUnLFxuXHRNID0gJ00nLFxuXHRMID0gJ0wnLFxuXHRudW1SZWdleCA9IC9eWzAtOV0rJC8sXG5cdE5PUk1BTF9TVEFURSA9ICcnLFxuXHRIT1ZFUl9TVEFURSA9ICdob3ZlcicsXG5cdFNFTEVDVF9TVEFURSA9ICdzZWxlY3QnLFxuXHRtYXJnaW5OYW1lcyA9IFsncGxvdFRvcCcsICdtYXJnaW5SaWdodCcsICdtYXJnaW5Cb3R0b20nLCAncGxvdExlZnQnXSxcblx0XG5cdC8vIE9iamVjdCBmb3IgZXh0ZW5kaW5nIEF4aXNcblx0QXhpc1Bsb3RMaW5lT3JCYW5kRXh0ZW5zaW9uLFxuXG5cdC8vIGNvbnN0YW50cyBmb3IgYXR0cmlidXRlc1xuXHRTVFJPS0VfV0lEVEggPSAnc3Ryb2tlLXdpZHRoJyxcblxuXHQvLyB0aW1lIG1ldGhvZHMsIGNoYW5nZWQgYmFzZWQgb24gd2hldGhlciBvciBub3QgVVRDIGlzIHVzZWRcblx0RGF0ZSwgIC8vIEFsbG93IHVzaW5nIGEgZGlmZmVyZW50IERhdGUgY2xhc3Ncblx0bWFrZVRpbWUsXG5cdHRpbWV6b25lT2Zmc2V0LFxuXHRnZXRUaW1lem9uZU9mZnNldCxcblx0Z2V0TWludXRlcyxcblx0Z2V0SG91cnMsXG5cdGdldERheSxcblx0Z2V0RGF0ZSxcblx0Z2V0TW9udGgsXG5cdGdldEZ1bGxZZWFyLFxuXHRzZXRNaWxsaXNlY29uZHMsXG5cdHNldFNlY29uZHMsXG5cdHNldE1pbnV0ZXMsXG5cdHNldEhvdXJzLFxuXHRzZXREYXRlLFxuXHRzZXRNb250aCxcblx0c2V0RnVsbFllYXIsXG5cblxuXHQvLyBsb29rdXAgb3ZlciB0aGUgdHlwZXMgYW5kIHRoZSBhc3NvY2lhdGVkIGNsYXNzZXNcblx0c2VyaWVzVHlwZXMgPSB7fSxcblx0SGlnaGNoYXJ0cztcblxuLy8gVGhlIEhpZ2hjaGFydHMgbmFtZXNwYWNlXG5IaWdoY2hhcnRzID0gd2luLkhpZ2hjaGFydHMgPSB3aW4uSGlnaGNoYXJ0cyA/IGVycm9yKDE2LCB0cnVlKSA6IHt9O1xuXG5IaWdoY2hhcnRzLnNlcmllc1R5cGVzID0gc2VyaWVzVHlwZXM7XG5cbi8qKlxuICogRXh0ZW5kIGFuIG9iamVjdCB3aXRoIHRoZSBtZW1iZXJzIG9mIGFub3RoZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gYWRkIHRvIHRoZSBmaXJzdCBvbmVcbiAqL1xudmFyIGV4dGVuZCA9IEhpZ2hjaGFydHMuZXh0ZW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcblx0dmFyIG47XG5cdGlmICghYSkge1xuXHRcdGEgPSB7fTtcblx0fVxuXHRmb3IgKG4gaW4gYikge1xuXHRcdGFbbl0gPSBiW25dO1xuXHR9XG5cdHJldHVybiBhO1xufTtcblx0XG4vKipcbiAqIERlZXAgbWVyZ2UgdHdvIG9yIG1vcmUgb2JqZWN0cyBhbmQgcmV0dXJuIGEgdGhpcmQgb2JqZWN0LiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXNcbiAqIHRydWUsIHRoZSBjb250ZW50cyBvZiB0aGUgc2Vjb25kIG9iamVjdCBpcyBjb3BpZWQgaW50byB0aGUgZmlyc3Qgb2JqZWN0LlxuICogUHJldmlvdXNseSB0aGlzIGZ1bmN0aW9uIHJlZGlyZWN0ZWQgdG8galF1ZXJ5LmV4dGVuZCh0cnVlKSwgYnV0IHRoaXMgaGFkIHR3byBsaW1pdGF0aW9ucy5cbiAqIEZpcnN0LCBpdCBkZWVwIG1lcmdlZCBhcnJheXMsIHdoaWNoIGxlYWQgdG8gd29ya2Fyb3VuZHMgaW4gSGlnaGNoYXJ0cy4gU2Vjb25kLFxuICogaXQgY29waWVkIHByb3BlcnRpZXMgZnJvbSBleHRlbmRlZCBwcm90b3R5cGVzLiBcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoKSB7XG5cdHZhciBpLFxuXHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0bGVuLFxuXHRcdHJldCA9IHt9LFxuXHRcdGRvQ29weSA9IGZ1bmN0aW9uIChjb3B5LCBvcmlnaW5hbCkge1xuXHRcdFx0dmFyIHZhbHVlLCBrZXk7XG5cblx0XHRcdC8vIEFuIG9iamVjdCBpcyByZXBsYWNpbmcgYSBwcmltaXRpdmVcblx0XHRcdGlmICh0eXBlb2YgY29weSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Y29weSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGtleSBpbiBvcmlnaW5hbCkge1xuXHRcdFx0XHRpZiAob3JpZ2luYWwuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gb3JpZ2luYWxba2V5XTtcblxuXHRcdFx0XHRcdC8vIENvcHkgdGhlIGNvbnRlbnRzIG9mIG9iamVjdHMsIGJ1dCBub3QgYXJyYXlzIG9yIERPTSBub2Rlc1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHRcdFx0XHRcdFx0a2V5ICE9PSAncmVuZGVyVG8nICYmIHR5cGVvZiB2YWx1ZS5ub2RlVHlwZSAhPT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRcdGNvcHlba2V5XSA9IGRvQ29weShjb3B5W2tleV0gfHwge30sIHZhbHVlKTtcblx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gUHJpbWl0aXZlcyBhbmQgYXJyYXlzIGFyZSBjb3BpZWQgb3ZlciBkaXJlY3RseVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb3B5W2tleV0gPSBvcmlnaW5hbFtrZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvcHk7XG5cdFx0fTtcblxuXHQvLyBJZiBmaXJzdCBhcmd1bWVudCBpcyB0cnVlLCBjb3B5IGludG8gdGhlIGV4aXN0aW5nIG9iamVjdC4gVXNlZCBpbiBzZXRPcHRpb25zLlxuXHRpZiAoYXJnc1swXSA9PT0gdHJ1ZSkge1xuXHRcdHJldCA9IGFyZ3NbMV07XG5cdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDIpO1xuXHR9XG5cblx0Ly8gRm9yIGVhY2ggYXJndW1lbnQsIGV4dGVuZCB0aGUgcmV0dXJuXG5cdGxlbiA9IGFyZ3MubGVuZ3RoO1xuXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRyZXQgPSBkb0NvcHkocmV0LCBhcmdzW2ldKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogU2hvcnRjdXQgZm9yIHBhcnNlSW50XG4gKiBAcGFyYW0ge09iamVjdH0gc1xuICogQHBhcmFtIHtOdW1iZXJ9IG1hZyBNYWduaXR1ZGVcbiAqL1xuZnVuY3Rpb24gcEludChzLCBtYWcpIHtcblx0cmV0dXJuIHBhcnNlSW50KHMsIG1hZyB8fCAxMCk7XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIHN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IHNcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcocykge1xuXHRyZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIENoZWNrIGZvciBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG5cdHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBDaGVjayBmb3IgbnVtYmVyXG4gKiBAcGFyYW0ge09iamVjdH0gblxuICovXG5mdW5jdGlvbiBpc051bWJlcihuKSB7XG5cdHJldHVybiB0eXBlb2YgbiA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGxvZzJsaW4obnVtKSB7XG5cdHJldHVybiBtYXRoLmxvZyhudW0pIC8gbWF0aC5MTjEwO1xufVxuZnVuY3Rpb24gbGluMmxvZyhudW0pIHtcblx0cmV0dXJuIG1hdGgucG93KDEwLCBudW0pO1xufVxuXG4vKipcbiAqIFJlbW92ZSBsYXN0IG9jY3VyZW5jZSBvZiBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtNaXhlZH0gaXRlbVxuICovXG5mdW5jdGlvbiBlcmFzZShhcnIsIGl0ZW0pIHtcblx0dmFyIGkgPSBhcnIubGVuZ3RoO1xuXHR3aGlsZSAoaS0tKSB7XG5cdFx0aWYgKGFycltpXSA9PT0gaXRlbSkge1xuXHRcdFx0YXJyLnNwbGljZShpLCAxKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXHQvL3JldHVybiBhcnI7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkLiBMaWtlIE1vb1Rvb2xzJyAkLmRlZmluZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cbmZ1bmN0aW9uIGRlZmluZWQob2JqKSB7XG5cdHJldHVybiBvYmogIT09IFVOREVGSU5FRCAmJiBvYmogIT09IG51bGw7XG59XG5cbi8qKlxuICogU2V0IG9yIGdldCBhbiBhdHRyaWJ1dGUgb3IgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMuIENhbid0IHVzZSBqUXVlcnkgYXR0ciBiZWNhdXNlXG4gKiBpdCBhdHRlbXB0cyB0byBzZXQgZXhwYW5kbyBwcm9wZXJ0aWVzIG9uIHRoZSBTVkcgZWxlbWVudCwgd2hpY2ggaXMgbm90IGFsbG93ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW0gVGhlIERPTSBlbGVtZW50IHRvIHJlY2VpdmUgdGhlIGF0dHJpYnV0ZShzKVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwcm9wIFRoZSBwcm9wZXJ0eSBvciBhbiBhYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIGlmIGEgc2luZ2xlIHByb3BlcnR5IGlzIHNldFxuICovXG5mdW5jdGlvbiBhdHRyKGVsZW0sIHByb3AsIHZhbHVlKSB7XG5cdHZhciBrZXksXG5cdFx0cmV0O1xuXG5cdC8vIGlmIHRoZSBwcm9wIGlzIGEgc3RyaW5nXG5cdGlmIChpc1N0cmluZyhwcm9wKSkge1xuXHRcdC8vIHNldCB0aGUgdmFsdWVcblx0XHRpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcblxuXHRcdC8vIGdldCB0aGUgdmFsdWVcblx0XHR9IGVsc2UgaWYgKGVsZW0gJiYgZWxlbS5nZXRBdHRyaWJ1dGUpIHsgLy8gZWxlbSBub3QgZGVmaW5lZCB3aGVuIHByaW50aW5nIHBpZSBkZW1vLi4uXG5cdFx0XHRyZXQgPSBlbGVtLmdldEF0dHJpYnV0ZShwcm9wKTtcblx0XHR9XG5cblx0Ly8gZWxzZSBpZiBwcm9wIGlzIGRlZmluZWQsIGl0IGlzIGEgaGFzaCBvZiBrZXkvdmFsdWUgcGFpcnNcblx0fSBlbHNlIGlmIChkZWZpbmVkKHByb3ApICYmIGlzT2JqZWN0KHByb3ApKSB7XG5cdFx0Zm9yIChrZXkgaW4gcHJvcCkge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoa2V5LCBwcm9wW2tleV0pO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmV0O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGFuIGFycmF5LCBhbmQgaWYgbm90LCBtYWtlIGl0IGludG8gYW4gYXJyYXkuIExpa2VcbiAqIE1vb1Rvb2xzJyAkLnNwbGF0LlxuICovXG5mdW5jdGlvbiBzcGxhdChvYmopIHtcblx0cmV0dXJuIGlzQXJyYXkob2JqKSA/IG9iaiA6IFtvYmpdO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB0aGF0IGlzIGRlZmluZWQuIExpa2UgTW9vVG9vbHMnICQucGljay5cbiAqL1xudmFyIHBpY2sgPSBIaWdoY2hhcnRzLnBpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdGksXG5cdFx0YXJnLFxuXHRcdGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRhcmcgPSBhcmdzW2ldO1xuXHRcdGlmIChhcmcgIT09IFVOREVGSU5FRCAmJiBhcmcgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiBhcmc7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIFNldCBDU1Mgb24gYSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXMgU3R5bGUgb2JqZWN0IHdpdGggY2FtZWwgY2FzZSBwcm9wZXJ0eSBuYW1lc1xuICovXG5mdW5jdGlvbiBjc3MoZWwsIHN0eWxlcykge1xuXHRpZiAoaXNNUyAmJiAhaGFzU1ZHKSB7IC8vICMyNjg2XG5cdFx0aWYgKHN0eWxlcyAmJiBzdHlsZXMub3BhY2l0eSAhPT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRzdHlsZXMuZmlsdGVyID0gJ2FscGhhKG9wYWNpdHk9JyArIChzdHlsZXMub3BhY2l0eSAqIDEwMCkgKyAnKSc7XG5cdFx0fVxuXHR9XG5cdGV4dGVuZChlbC5zdHlsZSwgc3R5bGVzKTtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBlbGVtZW50IHdpdGggYXR0cmlidXRlcyBhbmQgc3R5bGVzXG4gKiBAcGFyYW0ge09iamVjdH0gdGFnXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlic1xuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlc1xuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtIHtPYmplY3R9IG5vcGFkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBhdHRyaWJzLCBzdHlsZXMsIHBhcmVudCwgbm9wYWQpIHtcblx0dmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcblx0aWYgKGF0dHJpYnMpIHtcblx0XHRleHRlbmQoZWwsIGF0dHJpYnMpO1xuXHR9XG5cdGlmIChub3BhZCkge1xuXHRcdGNzcyhlbCwge3BhZGRpbmc6IDAsIGJvcmRlcjogTk9ORSwgbWFyZ2luOiAwfSk7XG5cdH1cblx0aWYgKHN0eWxlcykge1xuXHRcdGNzcyhlbCwgc3R5bGVzKTtcblx0fVxuXHRpZiAocGFyZW50KSB7XG5cdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcblx0fVxuXHRyZXR1cm4gZWw7XG59XG5cbi8qKlxuICogRXh0ZW5kIGEgcHJvdG90eXBlZCBjbGFzcyBieSBuZXcgbWVtYmVyc1xuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtIHtPYmplY3R9IG1lbWJlcnNcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kQ2xhc3MocGFyZW50LCBtZW1iZXJzKSB7XG5cdHZhciBvYmplY3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBVTkRFRklORUQ7IH07XG5cdG9iamVjdC5wcm90b3R5cGUgPSBuZXcgcGFyZW50KCk7XG5cdGV4dGVuZChvYmplY3QucHJvdG90eXBlLCBtZW1iZXJzKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBQYWQgYSBzdHJpbmcgdG8gYSBnaXZlbiBsZW5ndGggYnkgYWRkaW5nIDAgdG8gdGhlIGJlZ2lubmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICovXG5mdW5jdGlvbiBwYWQobnVtYmVyLCBsZW5ndGgpIHtcblx0Ly8gQ3JlYXRlIGFuIGFycmF5IG9mIHRoZSByZW1haW5pbmcgbGVuZ3RoICsxIGFuZCBqb2luIGl0IHdpdGggMCdzXG5cdHJldHVybiBuZXcgQXJyYXkoKGxlbmd0aCB8fCAyKSArIDEgLSBTdHJpbmcobnVtYmVyKS5sZW5ndGgpLmpvaW4oMCkgKyBudW1iZXI7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgbGVuZ3RoIGJhc2VkIG9uIGVpdGhlciB0aGUgaW50ZWdlciB2YWx1ZSwgb3IgYSBwZXJjZW50YWdlIG9mIGEgYmFzZS5cbiAqL1xuZnVuY3Rpb24gcmVsYXRpdmVMZW5ndGggKHZhbHVlLCBiYXNlKSB7XG5cdHJldHVybiAoLyUkLykudGVzdCh2YWx1ZSkgPyBiYXNlICogcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgOiBwYXJzZUZsb2F0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBXcmFwIGEgbWV0aG9kIHdpdGggZXh0ZW5kZWQgZnVuY3Rpb25hbGl0eSwgcHJlc2VydmluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIGNvbnRleHQgb2JqZWN0IHRoYXQgdGhlIG1ldGhvZCBiZWxvbmdzIHRvIFxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGV4dGVuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBBIHdyYXBwZXIgZnVuY3Rpb24gY2FsbGJhY2suIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzXG4gKiBhcyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24sIGV4Y2VwdCB0aGF0IHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBpcyB1bnNoaWZ0ZWQgYW5kIHBhc3NlZCBhcyB0aGUgZmlyc3QgXG4gKiBhcmd1bWVudC4gXG4gKi9cbnZhciB3cmFwID0gSGlnaGNoYXJ0cy53cmFwID0gZnVuY3Rpb24gKG9iaiwgbWV0aG9kLCBmdW5jKSB7XG5cdHZhciBwcm9jZWVkID0gb2JqW21ldGhvZF07XG5cdG9ialttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRhcmdzLnVuc2hpZnQocHJvY2VlZCk7XG5cdFx0cmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG5cdH07XG59O1xuXG5cbmZ1bmN0aW9uIGdldFRaT2Zmc2V0KHRpbWVzdGFtcCkge1xuXHRyZXR1cm4gKChnZXRUaW1lem9uZU9mZnNldCAmJiBnZXRUaW1lem9uZU9mZnNldCh0aW1lc3RhbXApKSB8fCB0aW1lem9uZU9mZnNldCB8fCAwKSAqIDYwMDAwO1xufVxuXG4vKipcbiAqIEJhc2VkIG9uIGh0dHA6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uc3RyZnRpbWUucGhwXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gKiBAcGFyYW0ge051bWJlcn0gdGltZXN0YW1wXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcGl0YWxpemVcbiAqL1xuZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQsIHRpbWVzdGFtcCwgY2FwaXRhbGl6ZSkge1xuXHRpZiAoIWRlZmluZWQodGltZXN0YW1wKSB8fCBpc05hTih0aW1lc3RhbXApKSB7XG5cdFx0cmV0dXJuIGRlZmF1bHRPcHRpb25zLmxhbmcuaW52YWxpZERhdGUgfHwgJyc7XG5cdH1cblx0Zm9ybWF0ID0gcGljayhmb3JtYXQsICclWS0lbS0lZCAlSDolTTolUycpO1xuXG5cdHZhciBkYXRlID0gbmV3IERhdGUodGltZXN0YW1wIC0gZ2V0VFpPZmZzZXQodGltZXN0YW1wKSksXG5cdFx0a2V5LCAvLyB1c2VkIGluIGZvciBjb25zdHVjdCBiZWxvd1xuXHRcdC8vIGdldCB0aGUgYmFzaWMgdGltZSB2YWx1ZXNcblx0XHRob3VycyA9IGRhdGVbZ2V0SG91cnNdKCksXG5cdFx0ZGF5ID0gZGF0ZVtnZXREYXldKCksXG5cdFx0ZGF5T2ZNb250aCA9IGRhdGVbZ2V0RGF0ZV0oKSxcblx0XHRtb250aCA9IGRhdGVbZ2V0TW9udGhdKCksXG5cdFx0ZnVsbFllYXIgPSBkYXRlW2dldEZ1bGxZZWFyXSgpLFxuXHRcdGxhbmcgPSBkZWZhdWx0T3B0aW9ucy5sYW5nLFxuXHRcdGxhbmdXZWVrZGF5cyA9IGxhbmcud2Vla2RheXMsXG5cblx0XHQvLyBMaXN0IGFsbCBmb3JtYXQga2V5cy4gQ3VzdG9tIGZvcm1hdHMgY2FuIGJlIGFkZGVkIGZyb20gdGhlIG91dHNpZGUuIFxuXHRcdHJlcGxhY2VtZW50cyA9IGV4dGVuZCh7XG5cblx0XHRcdC8vIERheVxuXHRcdFx0J2EnOiBsYW5nV2Vla2RheXNbZGF5XS5zdWJzdHIoMCwgMyksIC8vIFNob3J0IHdlZWtkYXksIGxpa2UgJ01vbidcblx0XHRcdCdBJzogbGFuZ1dlZWtkYXlzW2RheV0sIC8vIExvbmcgd2Vla2RheSwgbGlrZSAnTW9uZGF5J1xuXHRcdFx0J2QnOiBwYWQoZGF5T2ZNb250aCksIC8vIFR3byBkaWdpdCBkYXkgb2YgdGhlIG1vbnRoLCAwMSB0byAzMVxuXHRcdFx0J2UnOiBkYXlPZk1vbnRoLCAvLyBEYXkgb2YgdGhlIG1vbnRoLCAxIHRocm91Z2ggMzFcblx0XHRcdCd3JzogZGF5LFxuXG5cdFx0XHQvLyBXZWVrIChub25lIGltcGxlbWVudGVkKVxuXHRcdFx0Ly8nVyc6IHdlZWtOdW1iZXIoKSxcblxuXHRcdFx0Ly8gTW9udGhcblx0XHRcdCdiJzogbGFuZy5zaG9ydE1vbnRoc1ttb250aF0sIC8vIFNob3J0IG1vbnRoLCBsaWtlICdKYW4nXG5cdFx0XHQnQic6IGxhbmcubW9udGhzW21vbnRoXSwgLy8gTG9uZyBtb250aCwgbGlrZSAnSmFudWFyeSdcblx0XHRcdCdtJzogcGFkKG1vbnRoICsgMSksIC8vIFR3byBkaWdpdCBtb250aCBudW1iZXIsIDAxIHRocm91Z2ggMTJcblxuXHRcdFx0Ly8gWWVhclxuXHRcdFx0J3knOiBmdWxsWWVhci50b1N0cmluZygpLnN1YnN0cigyLCAyKSwgLy8gVHdvIGRpZ2l0cyB5ZWFyLCBsaWtlIDA5IGZvciAyMDA5XG5cdFx0XHQnWSc6IGZ1bGxZZWFyLCAvLyBGb3VyIGRpZ2l0cyB5ZWFyLCBsaWtlIDIwMDlcblxuXHRcdFx0Ly8gVGltZVxuXHRcdFx0J0gnOiBwYWQoaG91cnMpLCAvLyBUd28gZGlnaXRzIGhvdXJzIGluIDI0aCBmb3JtYXQsIDAwIHRocm91Z2ggMjNcblx0XHRcdCdrJzogaG91cnMsIC8vIEhvdXJzIGluIDI0aCBmb3JtYXQsIDAgdGhyb3VnaCAyM1xuXHRcdFx0J0knOiBwYWQoKGhvdXJzICUgMTIpIHx8IDEyKSwgLy8gVHdvIGRpZ2l0cyBob3VycyBpbiAxMmggZm9ybWF0LCAwMCB0aHJvdWdoIDExXG5cdFx0XHQnbCc6IChob3VycyAlIDEyKSB8fCAxMiwgLy8gSG91cnMgaW4gMTJoIGZvcm1hdCwgMSB0aHJvdWdoIDEyXG5cdFx0XHQnTSc6IHBhZChkYXRlW2dldE1pbnV0ZXNdKCkpLCAvLyBUd28gZGlnaXRzIG1pbnV0ZXMsIDAwIHRocm91Z2ggNTlcblx0XHRcdCdwJzogaG91cnMgPCAxMiA/ICdBTScgOiAnUE0nLCAvLyBVcHBlciBjYXNlIEFNIG9yIFBNXG5cdFx0XHQnUCc6IGhvdXJzIDwgMTIgPyAnYW0nIDogJ3BtJywgLy8gTG93ZXIgY2FzZSBBTSBvciBQTVxuXHRcdFx0J1MnOiBwYWQoZGF0ZS5nZXRTZWNvbmRzKCkpLCAvLyBUd28gZGlnaXRzIHNlY29uZHMsIDAwIHRocm91Z2ggIDU5XG5cdFx0XHQnTCc6IHBhZChtYXRoUm91bmQodGltZXN0YW1wICUgMTAwMCksIDMpIC8vIE1pbGxpc2Vjb25kcyAobmFtaW5nIGZyb20gUnVieSlcblx0XHR9LCBIaWdoY2hhcnRzLmRhdGVGb3JtYXRzKTtcblxuXG5cdC8vIGRvIHRoZSByZXBsYWNlc1xuXHRmb3IgKGtleSBpbiByZXBsYWNlbWVudHMpIHtcblx0XHR3aGlsZSAoZm9ybWF0LmluZGV4T2YoJyUnICsga2V5KSAhPT0gLTEpIHsgLy8gcmVnZXggd291bGQgZG8gaXQgaW4gb25lIGxpbmUsIGJ1dCB0aGlzIGlzIGZhc3RlclxuXHRcdFx0Zm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyUnICsga2V5LCB0eXBlb2YgcmVwbGFjZW1lbnRzW2tleV0gPT09ICdmdW5jdGlvbicgPyByZXBsYWNlbWVudHNba2V5XSh0aW1lc3RhbXApIDogcmVwbGFjZW1lbnRzW2tleV0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIE9wdGlvbmFsbHkgY2FwaXRhbGl6ZSB0aGUgc3RyaW5nIGFuZCByZXR1cm5cblx0cmV0dXJuIGNhcGl0YWxpemUgPyBmb3JtYXQuc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBmb3JtYXQuc3Vic3RyKDEpIDogZm9ybWF0O1xufTtcblxuLyoqIFxuICogRm9ybWF0IGEgc2luZ2xlIHZhcmlhYmxlLiBTaW1pbGFyIHRvIHNwcmludGYsIHdpdGhvdXQgdGhlICUgcHJlZml4LlxuICovXG5mdW5jdGlvbiBmb3JtYXRTaW5nbGUoZm9ybWF0LCB2YWwpIHtcblx0dmFyIGZsb2F0UmVnZXggPSAvZiQvLFxuXHRcdGRlY1JlZ2V4ID0gL1xcLihbMC05XSkvLFxuXHRcdGxhbmcgPSBkZWZhdWx0T3B0aW9ucy5sYW5nLFxuXHRcdGRlY2ltYWxzO1xuXG5cdGlmIChmbG9hdFJlZ2V4LnRlc3QoZm9ybWF0KSkgeyAvLyBmbG9hdFxuXHRcdGRlY2ltYWxzID0gZm9ybWF0Lm1hdGNoKGRlY1JlZ2V4KTtcblx0XHRkZWNpbWFscyA9IGRlY2ltYWxzID8gZGVjaW1hbHNbMV0gOiAtMTtcblx0XHRpZiAodmFsICE9PSBudWxsKSB7XG5cdFx0XHR2YWwgPSBIaWdoY2hhcnRzLm51bWJlckZvcm1hdChcblx0XHRcdFx0dmFsLFxuXHRcdFx0XHRkZWNpbWFscyxcblx0XHRcdFx0bGFuZy5kZWNpbWFsUG9pbnQsXG5cdFx0XHRcdGZvcm1hdC5pbmRleE9mKCcsJykgPiAtMSA/IGxhbmcudGhvdXNhbmRzU2VwIDogJydcblx0XHRcdCk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IGRhdGVGb3JtYXQoZm9ybWF0LCB2YWwpO1xuXHR9XG5cdHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgc3RyaW5nIGFjY29yZGluZyB0byBhIHN1YnNldCBvZiB0aGUgcnVsZXMgb2YgUHl0aG9uJ3MgU3RyaW5nLmZvcm1hdCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdChzdHIsIGN0eCkge1xuXHR2YXIgc3BsaXR0ZXIgPSAneycsXG5cdFx0aXNJbnNpZGUgPSBmYWxzZSxcblx0XHRzZWdtZW50LFxuXHRcdHZhbHVlQW5kRm9ybWF0LFxuXHRcdHBhdGgsXG5cdFx0aSxcblx0XHRsZW4sXG5cdFx0cmV0ID0gW10sXG5cdFx0dmFsLFxuXHRcdGluZGV4O1xuXHRcblx0d2hpbGUgKChpbmRleCA9IHN0ci5pbmRleE9mKHNwbGl0dGVyKSkgIT09IC0xKSB7XG5cdFx0XG5cdFx0c2VnbWVudCA9IHN0ci5zbGljZSgwLCBpbmRleCk7XG5cdFx0aWYgKGlzSW5zaWRlKSB7IC8vIHdlJ3JlIG9uIHRoZSBjbG9zaW5nIGJyYWNrZXQgbG9va2luZyBiYWNrXG5cdFx0XHRcblx0XHRcdHZhbHVlQW5kRm9ybWF0ID0gc2VnbWVudC5zcGxpdCgnOicpO1xuXHRcdFx0cGF0aCA9IHZhbHVlQW5kRm9ybWF0LnNoaWZ0KCkuc3BsaXQoJy4nKTsgLy8gZ2V0IGZpcnN0IGFuZCBsZWF2ZSBmb3JtYXRcblx0XHRcdGxlbiA9IHBhdGgubGVuZ3RoO1xuXHRcdFx0dmFsID0gY3R4O1xuXG5cdFx0XHQvLyBBc3NpZ24gZGVlcGVyIHBhdGhzXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dmFsID0gdmFsW3BhdGhbaV1dO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JtYXQgdGhlIHJlcGxhY2VtZW50XG5cdFx0XHRpZiAodmFsdWVBbmRGb3JtYXQubGVuZ3RoKSB7XG5cdFx0XHRcdHZhbCA9IGZvcm1hdFNpbmdsZSh2YWx1ZUFuZEZvcm1hdC5qb2luKCc6JyksIHZhbCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1c2ggdGhlIHJlc3VsdCBhbmQgYWR2YW5jZSB0aGUgY3Vyc29yXG5cdFx0XHRyZXQucHVzaCh2YWwpO1xuXHRcdFx0XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldC5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0XG5cdFx0fVxuXHRcdHN0ciA9IHN0ci5zbGljZShpbmRleCArIDEpOyAvLyB0aGUgcmVzdFxuXHRcdGlzSW5zaWRlID0gIWlzSW5zaWRlOyAvLyB0b2dnbGVcblx0XHRzcGxpdHRlciA9IGlzSW5zaWRlID8gJ30nIDogJ3snOyAvLyBub3cgbG9vayBmb3IgbmV4dCBtYXRjaGluZyBicmFja2V0XG5cdH1cblx0cmV0LnB1c2goc3RyKTtcblx0cmV0dXJuIHJldC5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1hZ25pdHVkZSBvZiBhIG51bWJlclxuICovXG5mdW5jdGlvbiBnZXRNYWduaXR1ZGUobnVtKSB7XG5cdHJldHVybiBtYXRoLnBvdygxMCwgbWF0aEZsb29yKG1hdGgubG9nKG51bSkgLyBtYXRoLkxOMTApKTtcbn1cblxuLyoqXG4gKiBUYWtlIGFuIGludGVydmFsIGFuZCBub3JtYWxpemUgaXQgdG8gbXVsdGlwbGVzIG9mIDEsIDIsIDIuNSBhbmQgNVxuICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsXG4gKiBAcGFyYW0ge0FycmF5fSBtdWx0aXBsZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYWduaXR1ZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRpY2tJbnRlcnZhbChpbnRlcnZhbCwgbXVsdGlwbGVzLCBtYWduaXR1ZGUsIGFsbG93RGVjaW1hbHMsIHByZXZlbnRFeGNlZWQpIHtcblx0dmFyIG5vcm1hbGl6ZWQsIFxuXHRcdGksXG5cdFx0cmV0SW50ZXJ2YWwgPSBpbnRlcnZhbDtcblxuXHQvLyByb3VuZCB0byBhIHRlbmZvbGQgb2YgMSwgMiwgMi41IG9yIDVcblx0bWFnbml0dWRlID0gcGljayhtYWduaXR1ZGUsIDEpO1xuXHRub3JtYWxpemVkID0gaW50ZXJ2YWwgLyBtYWduaXR1ZGU7XG5cblx0Ly8gbXVsdGlwbGVzIGZvciBhIGxpbmVhciBzY2FsZVxuXHRpZiAoIW11bHRpcGxlcykge1xuXHRcdG11bHRpcGxlcyA9IFsxLCAyLCAyLjUsIDUsIDEwXTtcblxuXHRcdC8vIHRoZSBhbGxvd0RlY2ltYWxzIG9wdGlvblxuXHRcdGlmIChhbGxvd0RlY2ltYWxzID09PSBmYWxzZSkge1xuXHRcdFx0aWYgKG1hZ25pdHVkZSA9PT0gMSkge1xuXHRcdFx0XHRtdWx0aXBsZXMgPSBbMSwgMiwgNSwgMTBdO1xuXHRcdFx0fSBlbHNlIGlmIChtYWduaXR1ZGUgPD0gMC4xKSB7XG5cdFx0XHRcdG11bHRpcGxlcyA9IFsxIC8gbWFnbml0dWRlXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBub3JtYWxpemUgdGhlIGludGVydmFsIHRvIHRoZSBuZWFyZXN0IG11bHRpcGxlXG5cdGZvciAoaSA9IDA7IGkgPCBtdWx0aXBsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRyZXRJbnRlcnZhbCA9IG11bHRpcGxlc1tpXTtcblx0XHRpZiAoKHByZXZlbnRFeGNlZWQgJiYgcmV0SW50ZXJ2YWwgKiBtYWduaXR1ZGUgPj0gaW50ZXJ2YWwpIHx8IC8vIG9ubHkgYWxsb3cgdGljayBhbW91bnRzIHNtYWxsZXIgdGhhbiBuYXR1cmFsXG5cdFx0XHQoIXByZXZlbnRFeGNlZWQgJiYgKG5vcm1hbGl6ZWQgPD0gKG11bHRpcGxlc1tpXSArIChtdWx0aXBsZXNbaSArIDFdIHx8IG11bHRpcGxlc1tpXSkpIC8gMikpKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBtdWx0aXBseSBiYWNrIHRvIHRoZSBjb3JyZWN0IG1hZ25pdHVkZVxuXHRyZXRJbnRlcnZhbCAqPSBtYWduaXR1ZGU7XG5cdFxuXHRyZXR1cm4gcmV0SW50ZXJ2YWw7XG59XG5cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0aGF0IHNvcnRzIGFuIG9iamVjdCBhcnJheSBhbmQga2VlcGluZyB0aGUgb3JkZXIgb2YgZXF1YWwgaXRlbXMuXG4gKiBFQ01BIHNjcmlwdCBzdGFuZGFyZCBkb2VzIG5vdCBzcGVjaWZ5IHRoZSBiZWhhdmlvdXIgd2hlbiBpdGVtcyBhcmUgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHN0YWJsZVNvcnQoYXJyLCBzb3J0RnVuY3Rpb24pIHtcblx0dmFyIGxlbmd0aCA9IGFyci5sZW5ndGgsXG5cdFx0c29ydFZhbHVlLFxuXHRcdGk7XG5cblx0Ly8gQWRkIGluZGV4IHRvIGVhY2ggaXRlbVxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRhcnJbaV0uc3NfaSA9IGk7IC8vIHN0YWJsZSBzb3J0IGluZGV4XG5cdH1cblxuXHRhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdHNvcnRWYWx1ZSA9IHNvcnRGdW5jdGlvbihhLCBiKTtcblx0XHRyZXR1cm4gc29ydFZhbHVlID09PSAwID8gYS5zc19pIC0gYi5zc19pIDogc29ydFZhbHVlO1xuXHR9KTtcblxuXHQvLyBSZW1vdmUgaW5kZXggZnJvbSBpdGVtc1xuXHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRkZWxldGUgYXJyW2ldLnNzX2k7IC8vIHN0YWJsZSBzb3J0IGluZGV4XG5cdH1cbn1cblxuLyoqXG4gKiBOb24tcmVjdXJzaXZlIG1ldGhvZCB0byBmaW5kIHRoZSBsb3dlc3QgbWVtYmVyIG9mIGFuIGFycmF5LiBNYXRoLm1pbiByYWlzZXMgYSBtYXhpbXVtXG4gKiBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWQgZXJyb3IgaW4gQ2hyb21lIHdoZW4gdHJ5aW5nIHRvIGFwcGx5IG1vcmUgdGhhbiAxNTAuMDAwIHBvaW50cy4gVGhpc1xuICogbWV0aG9kIGlzIHNsaWdodGx5IHNsb3dlciwgYnV0IHNhZmUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWluKGRhdGEpIHtcblx0dmFyIGkgPSBkYXRhLmxlbmd0aCxcblx0XHRtaW4gPSBkYXRhWzBdO1xuXG5cdHdoaWxlIChpLS0pIHtcblx0XHRpZiAoZGF0YVtpXSA8IG1pbikge1xuXHRcdFx0bWluID0gZGF0YVtpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1pbjtcbn1cblxuLyoqXG4gKiBOb24tcmVjdXJzaXZlIG1ldGhvZCB0byBmaW5kIHRoZSBsb3dlc3QgbWVtYmVyIG9mIGFuIGFycmF5LiBNYXRoLm1pbiByYWlzZXMgYSBtYXhpbXVtXG4gKiBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWQgZXJyb3IgaW4gQ2hyb21lIHdoZW4gdHJ5aW5nIHRvIGFwcGx5IG1vcmUgdGhhbiAxNTAuMDAwIHBvaW50cy4gVGhpc1xuICogbWV0aG9kIGlzIHNsaWdodGx5IHNsb3dlciwgYnV0IHNhZmUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWF4KGRhdGEpIHtcblx0dmFyIGkgPSBkYXRhLmxlbmd0aCxcblx0XHRtYXggPSBkYXRhWzBdO1xuXG5cdHdoaWxlIChpLS0pIHtcblx0XHRpZiAoZGF0YVtpXSA+IG1heCkge1xuXHRcdFx0bWF4ID0gZGF0YVtpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1heDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0aGF0IGRlc3Ryb3lzIGFueSBTVkdFbGVtZW50IG9yIFZNTEVsZW1lbnQgdGhhdCBhcmUgcHJvcGVydGllcyBvbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICogSXQgbG9vcHMgYWxsIHByb3BlcnRpZXMgYW5kIGludm9rZXMgZGVzdHJveSBpZiB0aGVyZSBpcyBhIGRlc3Ryb3kgbWV0aG9kLiBUaGUgcHJvcGVydHkgaXNcbiAqIHRoZW4gZGVsZXRlJ2VkLlxuICogQHBhcmFtIHtPYmplY3R9IFRoZSBvYmplY3QgdG8gZGVzdHJveSBwcm9wZXJ0aWVzIG9uXG4gKiBAcGFyYW0ge09iamVjdH0gRXhjZXB0aW9uLCBkbyBub3QgZGVzdHJveSB0aGlzIHByb3BlcnR5LCBvbmx5IGRlbGV0ZSBpdC5cbiAqL1xuZnVuY3Rpb24gZGVzdHJveU9iamVjdFByb3BlcnRpZXMob2JqLCBleGNlcHQpIHtcblx0dmFyIG47XG5cdGZvciAobiBpbiBvYmopIHtcblx0XHQvLyBJZiB0aGUgb2JqZWN0IGlzIG5vbi1udWxsIGFuZCBkZXN0cm95IGlzIGRlZmluZWRcblx0XHRpZiAob2JqW25dICYmIG9ialtuXSAhPT0gZXhjZXB0ICYmIG9ialtuXS5kZXN0cm95KSB7XG5cdFx0XHQvLyBJbnZva2UgdGhlIGRlc3Ryb3lcblx0XHRcdG9ialtuXS5kZXN0cm95KCk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVsZXRlIHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBvYmplY3QuXG5cdFx0ZGVsZXRlIG9ialtuXTtcblx0fVxufVxuXG5cbi8qKlxuICogRGlzY2FyZCBhbiBlbGVtZW50IGJ5IG1vdmluZyBpdCB0byB0aGUgYmluIGFuZCBkZWxldGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBUaGUgSFRNTCBub2RlIHRvIGRpc2NhcmRcbiAqL1xuZnVuY3Rpb24gZGlzY2FyZEVsZW1lbnQoZWxlbWVudCkge1xuXHQvLyBjcmVhdGUgYSBnYXJiYWdlIGJpbiBlbGVtZW50LCBub3QgcGFydCBvZiB0aGUgRE9NXG5cdGlmICghZ2FyYmFnZUJpbikge1xuXHRcdGdhcmJhZ2VCaW4gPSBjcmVhdGVFbGVtZW50KERJVik7XG5cdH1cblxuXHQvLyBtb3ZlIHRoZSBub2RlIGFuZCBlbXB0eSBiaW5cblx0aWYgKGVsZW1lbnQpIHtcblx0XHRnYXJiYWdlQmluLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXHR9XG5cdGdhcmJhZ2VCaW4uaW5uZXJIVE1MID0gJyc7XG59XG5cbi8qKlxuICogUHJvdmlkZSBlcnJvciBtZXNzYWdlcyBmb3IgZGVidWdnaW5nLCB3aXRoIGxpbmtzIHRvIG9ubGluZSBleHBsYW5hdGlvbiBcbiAqL1xuZnVuY3Rpb24gZXJyb3IgKGNvZGUsIHN0b3ApIHtcblx0dmFyIG1zZyA9ICdIaWdoY2hhcnRzIGVycm9yICMnICsgY29kZSArICc6IHd3dy5oaWdoY2hhcnRzLmNvbS9lcnJvcnMvJyArIGNvZGU7XG5cdGlmIChzdG9wKSB7XG5cdFx0dGhyb3cgbXNnO1xuXHR9XG5cdC8vIGVsc2UgLi4uXG5cdGlmICh3aW4uY29uc29sZSkge1xuXHRcdGNvbnNvbGUubG9nKG1zZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBGaXggSlMgcm91bmQgb2ZmIGZsb2F0IGVycm9yc1xuICogQHBhcmFtIHtOdW1iZXJ9IG51bVxuICovXG5mdW5jdGlvbiBjb3JyZWN0RmxvYXQobnVtLCBwcmVjKSB7XG5cdHJldHVybiBwYXJzZUZsb2F0KFxuXHRcdG51bS50b1ByZWNpc2lvbihwcmVjIHx8IDE0KVxuXHQpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgZ2xvYmFsIGFuaW1hdGlvbiB0byBlaXRoZXIgYSBnaXZlbiB2YWx1ZSwgb3IgZmFsbCBiYWNrIHRvIHRoZVxuICogZ2l2ZW4gY2hhcnQncyBhbmltYXRpb24gb3B0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gYW5pbWF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gY2hhcnRcbiAqL1xuZnVuY3Rpb24gc2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgY2hhcnQpIHtcblx0Y2hhcnQucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uID0gcGljayhhbmltYXRpb24sIGNoYXJ0LmFuaW1hdGlvbik7XG59XG5cbi8qKlxuICogVGhlIHRpbWUgdW5pdCBsb29rdXBcbiAqL1xudGltZVVuaXRzID0ge1xuXHRtaWxsaXNlY29uZDogMSxcblx0c2Vjb25kOiAxMDAwLFxuXHRtaW51dGU6IDYwMDAwLFxuXHRob3VyOiAzNjAwMDAwLFxuXHRkYXk6IDI0ICogMzYwMDAwMCxcblx0d2VlazogNyAqIDI0ICogMzYwMDAwMCxcblx0bW9udGg6IDI4ICogMjQgKiAzNjAwMDAwLFxuXHR5ZWFyOiAzNjQgKiAyNCAqIDM2MDAwMDBcbn07XG5cblxuLyoqXG4gKiBGb3JtYXQgYSBudW1iZXIgYW5kIHJldHVybiBhIHN0cmluZyBiYXNlZCBvbiBpbnB1dCBzZXR0aW5nc1xuICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBUaGUgaW5wdXQgbnVtYmVyIHRvIGZvcm1hdFxuICogQHBhcmFtIHtOdW1iZXJ9IGRlY2ltYWxzIFRoZSBhbW91bnQgb2YgZGVjaW1hbHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZWNQb2ludCBUaGUgZGVjaW1hbCBwb2ludCwgZGVmYXVsdHMgdG8gdGhlIG9uZSBnaXZlbiBpbiB0aGUgbGFuZyBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdGhvdXNhbmRzU2VwIFRoZSB0aG91c2FuZHMgc2VwYXJhdG9yLCBkZWZhdWx0cyB0byB0aGUgb25lIGdpdmVuIGluIHRoZSBsYW5nIG9wdGlvbnNcbiAqL1xuSGlnaGNoYXJ0cy5udW1iZXJGb3JtYXQgPSBmdW5jdGlvbiAobnVtYmVyLCBkZWNpbWFscywgZGVjUG9pbnQsIHRob3VzYW5kc1NlcCkge1xuXHR2YXIgbGFuZyA9IGRlZmF1bHRPcHRpb25zLmxhbmcsXG5cdFx0Ly8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQvdGVjaGJsb2cvYXJ0aWNsZS9qYXZhc2NyaXB0X2VxdWl2YWxlbnRfZm9yX3BocHNfbnVtYmVyX2Zvcm1hdC9cblx0XHRuID0gK251bWJlciB8fCAwLFxuXHRcdGMgPSBkZWNpbWFscyA9PT0gLTEgP1xuXHRcdFx0bWF0aE1pbigobi50b1N0cmluZygpLnNwbGl0KCcuJylbMV0gfHwgJycpLmxlbmd0aCwgMjApIDogLy8gUHJlc2VydmUgZGVjaW1hbHMuIE5vdCBodWdlIG51bWJlcnMgKCMzNzkzKS5cblx0XHRcdChpc05hTihkZWNpbWFscyA9IG1hdGhBYnMoZGVjaW1hbHMpKSA/IDIgOiBkZWNpbWFscyksXG5cdFx0ZCA9IGRlY1BvaW50ID09PSB1bmRlZmluZWQgPyBsYW5nLmRlY2ltYWxQb2ludCA6IGRlY1BvaW50LFxuXHRcdHQgPSB0aG91c2FuZHNTZXAgPT09IHVuZGVmaW5lZCA/IGxhbmcudGhvdXNhbmRzU2VwIDogdGhvdXNhbmRzU2VwLFxuXHRcdHMgPSBuIDwgMCA/IFwiLVwiIDogXCJcIixcblx0XHRpID0gU3RyaW5nKHBJbnQobiA9IG1hdGhBYnMobikudG9GaXhlZChjKSkpLFxuXHRcdGogPSBpLmxlbmd0aCA+IDMgPyBpLmxlbmd0aCAlIDMgOiAwO1xuXG5cdHJldHVybiAocyArIChqID8gaS5zdWJzdHIoMCwgaikgKyB0IDogXCJcIikgKyBpLnN1YnN0cihqKS5yZXBsYWNlKC8oXFxkezN9KSg/PVxcZCkvZywgXCIkMVwiICsgdCkgK1xuXHRcdFx0KGMgPyBkICsgbWF0aEFicyhuIC0gaSkudG9GaXhlZChjKS5zbGljZSgyKSA6IFwiXCIpKTtcbn07XG4vKipcbiAqIFBhdGggaW50ZXJwb2xhdGlvbiBhbGdvcml0aG0gdXNlZCBhY3Jvc3MgYWRhcHRlcnNcbiAqL1xucGF0aEFuaW0gPSB7XG5cdC8qKlxuXHQgKiBQcmVwYXJlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIHNvIHRoYXQgdGhlIHBhdGggY2FuIGJlIGFuaW1hdGVkIG9uZSB0byBvbmVcblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uIChlbGVtLCBmcm9tRCwgdG9EKSB7XG5cdFx0ZnJvbUQgPSBmcm9tRCB8fCAnJztcblx0XHR2YXIgc2hpZnQgPSBlbGVtLnNoaWZ0LFxuXHRcdFx0YmV6aWVyID0gZnJvbUQuaW5kZXhPZignQycpID4gLTEsXG5cdFx0XHRudW1QYXJhbXMgPSBiZXppZXIgPyA3IDogMyxcblx0XHRcdGVuZExlbmd0aCxcblx0XHRcdHNsaWNlLFxuXHRcdFx0aSxcblx0XHRcdHN0YXJ0ID0gZnJvbUQuc3BsaXQoJyAnKSxcblx0XHRcdGVuZCA9IFtdLmNvbmNhdCh0b0QpLCAvLyBjb3B5XG5cdFx0XHRzdGFydEJhc2VMaW5lLFxuXHRcdFx0ZW5kQmFzZUxpbmUsXG5cdFx0XHRzaXhpZnkgPSBmdW5jdGlvbiAoYXJyKSB7IC8vIGluIHNwbGluZXMgbWFrZSBtb3ZlIHBvaW50cyBoYXZlIHNpeCBwYXJhbWV0ZXJzIGxpa2UgYmV6aWVyIGN1cnZlc1xuXHRcdFx0XHRpID0gYXJyLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdGlmIChhcnJbaV0gPT09IE0pIHtcblx0XHRcdFx0XHRcdGFyci5zcGxpY2UoaSArIDEsIDAsIGFycltpICsgMV0sIGFycltpICsgMl0sIGFycltpICsgMV0sIGFycltpICsgMl0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmIChiZXppZXIpIHtcblx0XHRcdHNpeGlmeShzdGFydCk7XG5cdFx0XHRzaXhpZnkoZW5kKTtcblx0XHR9XG5cblx0XHQvLyBwdWxsIG91dCB0aGUgYmFzZSBsaW5lcyBiZWZvcmUgcGFkZGluZ1xuXHRcdGlmIChlbGVtLmlzQXJlYSkge1xuXHRcdFx0c3RhcnRCYXNlTGluZSA9IHN0YXJ0LnNwbGljZShzdGFydC5sZW5ndGggLSA2LCA2KTtcblx0XHRcdGVuZEJhc2VMaW5lID0gZW5kLnNwbGljZShlbmQubGVuZ3RoIC0gNiwgNik7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgc2hpZnRpbmcgcG9pbnRzLCBwcmVwZW5kIGEgZHVtbXkgcG9pbnQgdG8gdGhlIGVuZCBwYXRoXG5cdFx0aWYgKHNoaWZ0IDw9IGVuZC5sZW5ndGggLyBudW1QYXJhbXMgJiYgc3RhcnQubGVuZ3RoID09PSBlbmQubGVuZ3RoKSB7XG5cdFx0XHR3aGlsZSAoc2hpZnQtLSkge1xuXHRcdFx0XHRlbmQgPSBbXS5jb25jYXQoZW5kKS5zcGxpY2UoMCwgbnVtUGFyYW1zKS5jb25jYXQoZW5kKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxlbS5zaGlmdCA9IDA7IC8vIHJlc2V0IGZvciBmb2xsb3dpbmcgYW5pbWF0aW9uc1xuXG5cdFx0Ly8gY29weSBhbmQgYXBwZW5kIGxhc3QgcG9pbnQgdW50aWwgdGhlIGxlbmd0aCBtYXRjaGVzIHRoZSBlbmQgbGVuZ3RoXG5cdFx0aWYgKHN0YXJ0Lmxlbmd0aCkge1xuXHRcdFx0ZW5kTGVuZ3RoID0gZW5kLmxlbmd0aDtcblx0XHRcdHdoaWxlIChzdGFydC5sZW5ndGggPCBlbmRMZW5ndGgpIHtcblxuXHRcdFx0XHQvL2JlemllciAmJiBzaXhpZnkoc3RhcnQpO1xuXHRcdFx0XHRzbGljZSA9IFtdLmNvbmNhdChzdGFydCkuc3BsaWNlKHN0YXJ0Lmxlbmd0aCAtIG51bVBhcmFtcywgbnVtUGFyYW1zKTtcblx0XHRcdFx0aWYgKGJlemllcikgeyAvLyBkaXNhYmxlIGZpcnN0IGNvbnRyb2wgcG9pbnRcblx0XHRcdFx0XHRzbGljZVtudW1QYXJhbXMgLSA2XSA9IHNsaWNlW251bVBhcmFtcyAtIDJdO1xuXHRcdFx0XHRcdHNsaWNlW251bVBhcmFtcyAtIDVdID0gc2xpY2VbbnVtUGFyYW1zIC0gMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhcnQgPSBzdGFydC5jb25jYXQoc2xpY2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChzdGFydEJhc2VMaW5lKSB7IC8vIGFwcGVuZCB0aGUgYmFzZSBsaW5lcyBmb3IgYXJlYXNcblx0XHRcdHN0YXJ0ID0gc3RhcnQuY29uY2F0KHN0YXJ0QmFzZUxpbmUpO1xuXHRcdFx0ZW5kID0gZW5kLmNvbmNhdChlbmRCYXNlTGluZSk7XG5cdFx0fVxuXHRcdHJldHVybiBbc3RhcnQsIGVuZF07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEludGVycG9sYXRlIGVhY2ggdmFsdWUgb2YgdGhlIHBhdGggYW5kIHJldHVybiB0aGUgYXJyYXlcblx0ICovXG5cdHN0ZXA6IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwb3MsIGNvbXBsZXRlKSB7XG5cdFx0dmFyIHJldCA9IFtdLFxuXHRcdFx0aSA9IHN0YXJ0Lmxlbmd0aCxcblx0XHRcdHN0YXJ0VmFsO1xuXG5cdFx0aWYgKHBvcyA9PT0gMSkgeyAvLyBsYW5kIG9uIHRoZSBmaW5hbCBwYXRoIHdpdGhvdXQgYWRqdXN0bWVudCBwb2ludHMgYXBwZW5kZWQgaW4gdGhlIGVuZHNcblx0XHRcdHJldCA9IGNvbXBsZXRlO1xuXG5cdFx0fSBlbHNlIGlmIChpID09PSBlbmQubGVuZ3RoICYmIHBvcyA8IDEpIHtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0c3RhcnRWYWwgPSBwYXJzZUZsb2F0KHN0YXJ0W2ldKTtcblx0XHRcdFx0cmV0W2ldID1cblx0XHRcdFx0XHRpc05hTihzdGFydFZhbCkgPyAvLyBhIGxldHRlciBpbnN0cnVjdGlvbiBsaWtlIE0gb3IgTFxuXHRcdFx0XHRcdFx0c3RhcnRbaV0gOlxuXHRcdFx0XHRcdFx0cG9zICogKHBhcnNlRmxvYXQoZW5kW2ldIC0gc3RhcnRWYWwpKSArIHN0YXJ0VmFsO1xuXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgLy8gaWYgYW5pbWF0aW9uIGlzIGZpbmlzaGVkIG9yIGxlbmd0aCBub3QgbWF0Y2hpbmcsIGxhbmQgb24gcmlnaHQgdmFsdWVcblx0XHRcdHJldCA9IGVuZDtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fVxufTtcblxuKGZ1bmN0aW9uICgkKSB7XG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCBIaWdoY2hhcnRzQWRhcHRlciBmb3IgalF1ZXJ5XG5cdCAqL1xuXHR3aW4uSGlnaGNoYXJ0c0FkYXB0ZXIgPSB3aW4uSGlnaGNoYXJ0c0FkYXB0ZXIgfHwgKCQgJiYge1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgdGhlIGFkYXB0ZXIgYnkgYXBwbHlpbmcgc29tZSBleHRlbnNpb25zIHRvIGpRdWVyeVxuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChwYXRoQW5pbSkge1xuXHRcdFx0XG5cdFx0XHQvLyBleHRlbmQgdGhlIGFuaW1hdGUgZnVuY3Rpb24gdG8gYWxsb3cgU1ZHIGFuaW1hdGlvbnNcblx0XHRcdHZhciBGeCA9ICQuZng7XG5cdFx0XHRcblx0XHRcdC8qanNsaW50IHVucGFyYW06IHRydWUqLy8qIGFsbG93IHVudXNlZCBwYXJhbSB4IGluIHRoaXMgZnVuY3Rpb24gKi9cblx0XHRcdCQuZXh0ZW5kKCQuZWFzaW5nLCB7XG5cdFx0XHRcdGVhc2VPdXRRdWFkOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xuXHRcdFx0XHRcdHJldHVybiAtYyAqICh0IC89IGQpICogKHQgLSAyKSArIGI7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0Lypqc2xpbnQgdW5wYXJhbTogZmFsc2UqL1xuXHRcdFxuXHRcdFx0Ly8gZXh0ZW5kIHNvbWUgbWV0aG9kcyB0byBjaGVjayBmb3IgZWxlbS5hdHRyLCB3aGljaCBtZWFucyBpdCBpcyBhIEhpZ2hjaGFydHMgU1ZHIG9iamVjdFxuXHRcdFx0JC5lYWNoKFsnY3VyJywgJ19kZWZhdWx0JywgJ3dpZHRoJywgJ2hlaWdodCcsICdvcGFjaXR5J10sIGZ1bmN0aW9uIChpLCBmbikge1xuXHRcdFx0XHR2YXIgb2JqID0gRnguc3RlcCxcblx0XHRcdFx0XHRiYXNlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHQvLyBIYW5kbGUgZGlmZmVyZW50IHBhcmVudCBvYmplY3RzXG5cdFx0XHRcdGlmIChmbiA9PT0gJ2N1cicpIHtcblx0XHRcdFx0XHRvYmogPSBGeC5wcm90b3R5cGU7IC8vICdjdXInLCB0aGUgZ2V0dGVyLCByZWxhdGVzIHRvIEZ4LnByb3RvdHlwZVxuXHRcdFx0XHRcblx0XHRcdFx0fSBlbHNlIGlmIChmbiA9PT0gJ19kZWZhdWx0JyAmJiAkLlR3ZWVuKSB7IC8vIGpRdWVyeSAxLjggbW9kZWxcblx0XHRcdFx0XHRvYmogPSAkLlR3ZWVuLnByb3BIb29rc1tmbl07XG5cdFx0XHRcdFx0Zm4gPSAnc2V0Jztcblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHQvLyBPdmVyd3JpdGUgdGhlIG1ldGhvZFxuXHRcdFx0XHRiYXNlID0gb2JqW2ZuXTtcblx0XHRcdFx0aWYgKGJhc2UpIHsgLy8gc3RlcC53aWR0aCBhbmQgc3RlcC5oZWlnaHQgZG9uJ3QgZXhpc3QgaW4galF1ZXJ5IDwgMS43XG5cdFx0XG5cdFx0XHRcdFx0Ly8gY3JlYXRlIHRoZSBleHRlbmRlZCBmdW5jdGlvbiByZXBsYWNlbWVudFxuXHRcdFx0XHRcdG9ialtmbl0gPSBmdW5jdGlvbiAoZngpIHtcblxuXHRcdFx0XHRcdFx0dmFyIGVsZW07XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIEZ4LnByb3RvdHlwZS5jdXIgZG9lcyBub3QgdXNlIGZ4IGFyZ3VtZW50XG5cdFx0XHRcdFx0XHRmeCA9IGkgPyBmeCA6IHRoaXM7XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHJ1biBhbmltYXRpb25zIG9uIHRleHR1YWwgcHJvcGVydGllcyBsaWtlIGFsaWduICgjMTgyMSlcblx0XHRcdFx0XHRcdGlmIChmeC5wcm9wID09PSAnYWxpZ24nKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0XHRcdC8vIHNob3J0Y3V0XG5cdFx0XHRcdFx0XHRlbGVtID0gZnguZWxlbTtcblx0XHRcblx0XHRcdFx0XHRcdC8vIEZ4LnByb3RvdHlwZS5jdXIgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZS4gVGhlIG90aGVyIG9uZXMgYXJlIHNldHRlcnNcblx0XHRcdFx0XHRcdC8vIGFuZCByZXR1cm5pbmcgYSB2YWx1ZSBoYXMgbm8gZWZmZWN0LlxuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uYXR0ciA/IC8vIGlzIFNWRyBlbGVtZW50IHdyYXBwZXJcblx0XHRcdFx0XHRcdFx0ZWxlbS5hdHRyKGZ4LnByb3AsIGZuID09PSAnY3VyJyA/IFVOREVGSU5FRCA6IGZ4Lm5vdykgOiAvLyBhcHBseSB0aGUgU1ZHIHdyYXBwZXIncyBtZXRob2Rcblx0XHRcdFx0XHRcdFx0YmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyB1c2UgalF1ZXJ5J3MgYnVpbHQtaW4gbWV0aG9kXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgb3BhY2l0eSBnZXR0ZXIsIG5lZWRlZCBmb3IgZmFkaW5nIG9wYWNpdHkgd2l0aCBJRTkgYW5kIGpRdWVyeSAxLjEwK1xuXHRcdFx0d3JhcCgkLmNzc0hvb2tzLm9wYWNpdHksICdnZXQnLCBmdW5jdGlvbiAocHJvY2VlZCwgZWxlbSwgY29tcHV0ZWQpIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uYXR0ciA/IChlbGVtLm9wYWNpdHkgfHwgMCkgOiBwcm9jZWVkLmNhbGwodGhpcywgZWxlbSwgY29tcHV0ZWQpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIERlZmluZSB0aGUgc2V0dGVyIGZ1bmN0aW9uIGZvciBkIChwYXRoIGRlZmluaXRpb25zKVxuXHRcdFx0dGhpcy5hZGRBbmltU2V0dGVyKCdkJywgZnVuY3Rpb24gKGZ4KSB7XG5cdFx0XHRcdHZhciBlbGVtID0gZnguZWxlbSxcblx0XHRcdFx0XHRlbmRzO1xuXHRcdFxuXHRcdFx0XHQvLyBOb3JtYWxseSBzdGFydCBhbmQgZW5kIHNob3VsZCBiZSBzZXQgaW4gc3RhdGUgPT0gMCwgYnV0IHNvbWV0aW1lcyxcblx0XHRcdFx0Ly8gZm9yIHJlYXNvbnMgdW5rbm93biwgdGhpcyBkb2Vzbid0IGhhcHBlbi4gUGVyaGFwcyBzdGF0ZSA9PSAwIGlzIHNraXBwZWRcblx0XHRcdFx0Ly8gaW4gdGhlc2UgY2FzZXNcblx0XHRcdFx0aWYgKCFmeC5zdGFydGVkKSB7XG5cdFx0XHRcdFx0ZW5kcyA9IHBhdGhBbmltLmluaXQoZWxlbSwgZWxlbS5kLCBlbGVtLnRvRCk7XG5cdFx0XHRcdFx0Znguc3RhcnQgPSBlbmRzWzBdO1xuXHRcdFx0XHRcdGZ4LmVuZCA9IGVuZHNbMV07XG5cdFx0XHRcdFx0Znguc3RhcnRlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0Ly8gSW50ZXJwb2xhdGUgZWFjaCB2YWx1ZSBvZiB0aGUgcGF0aFxuXHRcdFx0XHRlbGVtLmF0dHIoJ2QnLCBwYXRoQW5pbS5zdGVwKGZ4LnN0YXJ0LCBmeC5lbmQsIGZ4LnBvcywgZWxlbS50b0QpKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFV0aWxpdHkgZm9yIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5LiBQYXJhbWV0ZXJzIGFyZSByZXZlcnNlZCBjb21wYXJlZCB0byBqUXVlcnkuXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBhcnJcblx0XHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMuZWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID9cblx0XHRcdFx0ZnVuY3Rpb24gKGFyciwgZm4pIHsgLy8gbW9kZXJuIGJyb3dzZXJzXG5cdFx0XHRcdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYXJyLCBmbik7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH0gOiBcblx0XHRcdFx0ZnVuY3Rpb24gKGFyciwgZm4pIHsgLy8gbGVnYWN5XG5cdFx0XHRcdFx0dmFyIGksIFxuXHRcdFx0XHRcdFx0bGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChmbi5jYWxsKGFycltpXSwgYXJyW2ldLCBpLCBhcnIpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUmVnaXN0ZXIgSGlnaGNoYXJ0cyBhcyBhIHBsdWdpbiBpbiB0aGUgcmVzcGVjdGl2ZSBmcmFtZXdvcmtcblx0XHRcdCAqL1xuXHRcdFx0JC5mbi5oaWdoY2hhcnRzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgY29uc3RyID0gJ0NoYXJ0JywgLy8gZGVmYXVsdCBjb25zdHJ1Y3RvclxuXHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0b3B0aW9ucyxcblx0XHRcdFx0XHRyZXQsXG5cdFx0XHRcdFx0Y2hhcnQ7XG5cblx0XHRcdFx0aWYgKHRoaXNbMF0pIHtcblxuXHRcdFx0XHRcdGlmIChpc1N0cmluZyhhcmdzWzBdKSkge1xuXHRcdFx0XHRcdFx0Y29uc3RyID0gYXJnc1swXTtcblx0XHRcdFx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKTsgXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9wdGlvbnMgPSBhcmdzWzBdO1xuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBjaGFydFxuXHRcdFx0XHRcdGlmIChvcHRpb25zICE9PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRcdC8qanNsaW50IHVudXNlZDpmYWxzZSovXG5cdFx0XHRcdFx0XHRvcHRpb25zLmNoYXJ0ID0gb3B0aW9ucy5jaGFydCB8fCB7fTtcblx0XHRcdFx0XHRcdG9wdGlvbnMuY2hhcnQucmVuZGVyVG8gPSB0aGlzWzBdO1xuXHRcdFx0XHRcdFx0Y2hhcnQgPSBuZXcgSGlnaGNoYXJ0c1tjb25zdHJdKG9wdGlvbnMsIGFyZ3NbMV0pO1xuXHRcdFx0XHRcdFx0cmV0ID0gdGhpcztcblx0XHRcdFx0XHRcdC8qanNsaW50IHVudXNlZDp0cnVlKi9cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBXaGVuIGNhbGxlZCB3aXRob3V0IHBhcmFtZXRlcnMgb3Igd2l0aCB0aGUgcmV0dXJuIGFyZ3VtZW50LCBnZXQgYSBwcmVkZWZpbmVkIGNoYXJ0XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMgPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0cmV0ID0gY2hhcnRzW2F0dHIodGhpc1swXSwgJ2RhdGEtaGlnaGNoYXJ0cy1jaGFydCcpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9O1xuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhbiBhbmltYXRpb24gc2V0dGVyIGZvciBhIHNwZWNpZmljIHByb3BlcnR5XG5cdFx0ICovXG5cdFx0YWRkQW5pbVNldHRlcjogZnVuY3Rpb24gKHByb3AsIHNldHRlcikge1xuXHRcdFx0Ly8galF1ZXJ5IDEuOCBzdHlsZVxuXHRcdFx0aWYgKCQuVHdlZW4pIHtcblx0XHRcdFx0JC5Ud2Vlbi5wcm9wSG9va3NbcHJvcF0gPSB7XG5cdFx0XHRcdFx0c2V0OiBzZXR0ZXJcblx0XHRcdFx0fTtcblx0XHRcdC8vIHByZSAxLjhcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQuZnguc3RlcFtwcm9wXSA9IHNldHRlcjtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIERvd25sb2FkcyBhIHNjcmlwdCBhbmQgZXhlY3V0ZXMgYSBjYWxsYmFjayB3aGVuIGRvbmUuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHNjcmlwdExvY2F0aW9uXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0XHQgKi9cblx0XHRnZXRTY3JpcHQ6ICQuZ2V0U2NyaXB0LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiB0aGUgaW5kZXggb2YgYW4gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTEgaWYgbm90IGZvdW5kXG5cdFx0ICovXG5cdFx0aW5BcnJheTogJC5pbkFycmF5LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEEgZGlyZWN0IGxpbmsgdG8galF1ZXJ5IG1ldGhvZHMuIE1vb1Rvb2xzIGFuZCBQcm90b3R5cGUgYWRhcHRlcnMgbXVzdCBiZSBpbXBsZW1lbnRlZCBmb3IgZWFjaCBjYXNlIG9mIG1ldGhvZC5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWxlbSBUaGUgSFRNTCBlbGVtZW50XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBXaGljaCBtZXRob2QgdG8gcnVuIG9uIHRoZSB3cmFwcGVkIGVsZW1lbnRcblx0XHQgKi9cblx0XHRhZGFwdGVyUnVuOiBmdW5jdGlvbiAoZWxlbSwgbWV0aG9kKSB7XG5cdFx0XHRyZXR1cm4gJChlbGVtKVttZXRob2RdKCk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogRmlsdGVyIGFuIGFycmF5XG5cdFx0ICovXG5cdFx0Z3JlcDogJC5ncmVwLFxuXHRcblx0XHQvKipcblx0XHQgKiBNYXAgYW4gYXJyYXlcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBhcnJcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHRcdCAqL1xuXHRcdG1hcDogZnVuY3Rpb24gKGFyciwgZm4pIHtcblx0XHRcdC8vcmV0dXJuIGpRdWVyeS5tYXAoYXJyLCBmbik7XG5cdFx0XHR2YXIgcmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmVzdWx0c1tpXSA9IGZuLmNhbGwoYXJyW2ldLCBhcnJbaV0sIGksIGFycik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSB0b3AgbGVmdCBvZiB0aGUgcGFnZVxuXHRcdCAqL1xuXHRcdG9mZnNldDogZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRyZXR1cm4gJChlbCkub2Zmc2V0KCk7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVsIEEgSFRNTCBlbGVtZW50IG9yIGN1c3RvbSBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHR5cGVcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZXZlbnQgaGFuZGxlclxuXHRcdCAqL1xuXHRcdGFkZEV2ZW50OiBmdW5jdGlvbiAoZWwsIGV2ZW50LCBmbikge1xuXHRcdFx0JChlbCkuYmluZChldmVudCwgZm4pO1xuXHRcdH0sXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBldmVudCBhZGRlZCB3aXRoIGFkZEV2ZW50XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVsIFRoZSBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIFRoZSBldmVudCB0eXBlLiBMZWF2ZSBibGFuayB0byByZW1vdmUgYWxsIGV2ZW50cy5cblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBmdW5jdGlvbiB0byByZW1vdmVcblx0XHQgKi9cblx0XHRyZW1vdmVFdmVudDogZnVuY3Rpb24gKGVsLCBldmVudFR5cGUsIGhhbmRsZXIpIHtcblx0XHRcdC8vIHdvcmthcm91bmQgZm9yIGpRdWVyeSBpc3N1ZSB3aXRoIHVuYmluZGluZyBjdXN0b20gZXZlbnRzOlxuXHRcdFx0Ly8gaHR0cDovL2ZvcnVtLmpRdWVyeS5jb20vdG9waWMvamF2YXNjcmlwdC1lcnJvci13aGVuLXVuYmluZGluZy1hLWN1c3RvbS1ldmVudC11c2luZy1qUXVlcnktMS00LTJcblx0XHRcdHZhciBmdW5jID0gZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIgPyAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgOiAnZGV0YWNoRXZlbnQnO1xuXHRcdFx0aWYgKGRvY1tmdW5jXSAmJiBlbCAmJiAhZWxbZnVuY10pIHtcblx0XHRcdFx0ZWxbZnVuY10gPSBmdW5jdGlvbiAoKSB7fTtcblx0XHRcdH1cblx0XG5cdFx0XHQkKGVsKS51bmJpbmQoZXZlbnRUeXBlLCBoYW5kbGVyKTtcblx0XHR9LFxuXHRcblx0XHQvKipcblx0XHQgKiBGaXJlIGFuIGV2ZW50IG9uIGEgY3VzdG9tIG9iamVjdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlbFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50QXJndW1lbnRzXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdEZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0ZmlyZUV2ZW50OiBmdW5jdGlvbiAoZWwsIHR5cGUsIGV2ZW50QXJndW1lbnRzLCBkZWZhdWx0RnVuY3Rpb24pIHtcblx0XHRcdHZhciBldmVudCA9ICQuRXZlbnQodHlwZSksXG5cdFx0XHRcdGRldGFjaGVkVHlwZSA9ICdkZXRhY2hlZCcgKyB0eXBlLFxuXHRcdFx0XHRkZWZhdWx0UHJldmVudGVkO1xuXHRcblx0XHRcdC8vIFJlbW92ZSB3YXJuaW5ncyBpbiBDaHJvbWUgd2hlbiBhY2Nlc3NpbmcgcmV0dXJuVmFsdWUgKCMyNzkwKSwgbGF5ZXJYIGFuZCBsYXllclkuIEFsdGhvdWdoIEhpZ2hjaGFydHNcblx0XHRcdC8vIG5ldmVyIHVzZXMgdGhlc2UgcHJvcGVydGllcywgQ2hyb21lIGluY2x1ZGVzIHRoZW0gaW4gdGhlIGRlZmF1bHQgY2xpY2sgZXZlbnQgYW5kXG5cdFx0XHQvLyByYWlzZXMgdGhlIHdhcm5pbmcgd2hlbiB0aGV5IGFyZSBjb3BpZWQgb3ZlciBpbiB0aGUgZXh0ZW5kIHN0YXRlbWVudCBiZWxvdy5cblx0XHRcdC8vXG5cdFx0XHQvLyBUbyBhdm9pZCBwcm9ibGVtcyBpbiBJRSAoc2VlICMxMDEwKSB3aGVyZSB3ZSBjYW5ub3QgZGVsZXRlIHRoZSBwcm9wZXJ0aWVzIGFuZCBhdm9pZFxuXHRcdFx0Ly8gdGVzdGluZyBpZiB0aGV5IGFyZSB0aGVyZSAod2FybmluZyBpbiBjaHJvbWUpIHRoZSBvbmx5IG9wdGlvbiBpcyB0byB0ZXN0IGlmIHJ1bm5pbmcgSUUuXG5cdFx0XHRpZiAoIWlzTVMgJiYgZXZlbnRBcmd1bWVudHMpIHtcblx0XHRcdFx0ZGVsZXRlIGV2ZW50QXJndW1lbnRzLmxheWVyWDtcblx0XHRcdFx0ZGVsZXRlIGV2ZW50QXJndW1lbnRzLmxheWVyWTtcblx0XHRcdFx0ZGVsZXRlIGV2ZW50QXJndW1lbnRzLnJldHVyblZhbHVlO1xuXHRcdFx0fVxuXHRcblx0XHRcdGV4dGVuZChldmVudCwgZXZlbnRBcmd1bWVudHMpO1xuXHRcblx0XHRcdC8vIFByZXZlbnQgalF1ZXJ5IGZyb20gdHJpZ2dlcmluZyB0aGUgb2JqZWN0IG1ldGhvZCB0aGF0IGlzIG5hbWVkIHRoZVxuXHRcdFx0Ly8gc2FtZSBhcyB0aGUgZXZlbnQuIEZvciBleGFtcGxlLCBpZiB0aGUgZXZlbnQgaXMgJ3NlbGVjdCcsIGpRdWVyeVxuXHRcdFx0Ly8gYXR0ZW1wdHMgY2FsbGluZyBlbC5zZWxlY3QgYW5kIGl0IGdvZXMgaW50byBhIGxvb3AuXG5cdFx0XHRpZiAoZWxbdHlwZV0pIHtcblx0XHRcdFx0ZWxbZGV0YWNoZWRUeXBlXSA9IGVsW3R5cGVdO1xuXHRcdFx0XHRlbFt0eXBlXSA9IG51bGw7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gV3JhcCBwcmV2ZW50RGVmYXVsdCBhbmQgc3RvcFByb3BhZ2F0aW9uIGluIHRyeS9jYXRjaCBibG9ja3MgaW5cblx0XHRcdC8vIG9yZGVyIHRvIHByZXZlbnQgSlMgZXJyb3JzIHdoZW4gY2FuY2VsbGluZyBldmVudHMgb24gbm9uLURPTVxuXHRcdFx0Ly8gb2JqZWN0cy4gIzYxNS5cblx0XHRcdC8qanNsaW50IHVucGFyYW06IHRydWUqL1xuXHRcdFx0JC5lYWNoKFsncHJldmVudERlZmF1bHQnLCAnc3RvcFByb3BhZ2F0aW9uJ10sIGZ1bmN0aW9uIChpLCBmbikge1xuXHRcdFx0XHR2YXIgYmFzZSA9IGV2ZW50W2ZuXTtcblx0XHRcdFx0ZXZlbnRbZm5dID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRiYXNlLmNhbGwoZXZlbnQpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdGlmIChmbiA9PT0gJ3ByZXZlbnREZWZhdWx0Jykge1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHRcdC8qanNsaW50IHVucGFyYW06IGZhbHNlKi9cblx0XG5cdFx0XHQvLyB0cmlnZ2VyIGl0XG5cdFx0XHQkKGVsKS50cmlnZ2VyKGV2ZW50KTtcblx0XG5cdFx0XHQvLyBhdHRhY2ggdGhlIG1ldGhvZFxuXHRcdFx0aWYgKGVsW2RldGFjaGVkVHlwZV0pIHtcblx0XHRcdFx0ZWxbdHlwZV0gPSBlbFtkZXRhY2hlZFR5cGVdO1xuXHRcdFx0XHRlbFtkZXRhY2hlZFR5cGVdID0gbnVsbDtcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoZGVmYXVsdEZ1bmN0aW9uICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiAhZGVmYXVsdFByZXZlbnRlZCkge1xuXHRcdFx0XHRkZWZhdWx0RnVuY3Rpb24oZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRXh0ZW5zaW9uIG1ldGhvZCBuZWVkZWQgZm9yIE1vb1Rvb2xzXG5cdFx0ICovXG5cdFx0d2FzaE1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgcmV0ID0gZS5vcmlnaW5hbEV2ZW50IHx8IGU7XG5cdFx0XHRcblx0XHRcdC8vIGNvbXB1dGVkIGJ5IGpRdWVyeSwgbmVlZGVkIGJ5IElFOFxuXHRcdFx0aWYgKHJldC5wYWdlWCA9PT0gVU5ERUZJTkVEKSB7IC8vICMxMjM2XG5cdFx0XHRcdHJldC5wYWdlWCA9IGUucGFnZVg7XG5cdFx0XHRcdHJldC5wYWdlWSA9IGUucGFnZVk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSxcblx0XG5cdFx0LyoqXG5cdFx0ICogQW5pbWF0ZSBhIEhUTUwgZWxlbWVudCBvciBTVkcgZWxlbWVudCB3cmFwcGVyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVsXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGpRdWVyeS1saWtlIGFuaW1hdGlvbiBvcHRpb25zOiBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFja1xuXHRcdCAqL1xuXHRcdGFuaW1hdGU6IGZ1bmN0aW9uIChlbCwgcGFyYW1zLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgJGVsID0gJChlbCk7XG5cdFx0XHRpZiAoIWVsLnN0eWxlKSB7XG5cdFx0XHRcdGVsLnN0eWxlID0ge307IC8vICMxODgxXG5cdFx0XHR9XG5cdFx0XHRpZiAocGFyYW1zLmQpIHtcblx0XHRcdFx0ZWwudG9EID0gcGFyYW1zLmQ7IC8vIGtlZXAgdGhlIGFycmF5IGZvcm0gZm9yIHBhdGhzLCB1c2VkIGluICQuZnguc3RlcC5kXG5cdFx0XHRcdHBhcmFtcy5kID0gMTsgLy8gYmVjYXVzZSBpbiBqUXVlcnksIGFuaW1hdGluZyB0byBhbiBhcnJheSBoYXMgYSBkaWZmZXJlbnQgbWVhbmluZ1xuXHRcdFx0fVxuXHRcblx0XHRcdCRlbC5zdG9wKCk7XG5cdFx0XHRpZiAocGFyYW1zLm9wYWNpdHkgIT09IFVOREVGSU5FRCAmJiBlbC5hdHRyKSB7XG5cdFx0XHRcdHBhcmFtcy5vcGFjaXR5ICs9ICdweCc7IC8vIGZvcmNlIGpRdWVyeSB0byB1c2Ugc2FtZSBsb2dpYyBhcyB3aWR0aCBhbmQgaGVpZ2h0ICgjMjE2MSlcblx0XHRcdH1cblx0XHRcdGVsLmhhc0FuaW0gPSAxOyAvLyAjMzM0MlxuXHRcdFx0JGVsLmFuaW1hdGUocGFyYW1zLCBvcHRpb25zKTtcblx0XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBTdG9wIHJ1bm5pbmcgYW5pbWF0aW9uXG5cdFx0ICovXG5cdFx0c3RvcDogZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRpZiAoZWwuaGFzQW5pbSkgeyAvLyAjMzM0MiwgbWVtb3J5IGxlYWsgb24gY2FsbGluZyAkKGVsKSBmcm9tIGRlc3Ryb3lcblx0XHRcdFx0JChlbCkuc3RvcCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KHdpbi5qUXVlcnkpKTtcblxuXG4vLyBjaGVjayBmb3IgYSBjdXN0b20gSGlnaGNoYXJ0c0FkYXB0ZXIgZGVmaW5lZCBwcmlvciB0byB0aGlzIGZpbGVcbnZhciBnbG9iYWxBZGFwdGVyID0gd2luLkhpZ2hjaGFydHNBZGFwdGVyLFxuXHRhZGFwdGVyID0gZ2xvYmFsQWRhcHRlciB8fCB7fTtcblx0XG4vLyBJbml0aWFsaXplIHRoZSBhZGFwdGVyXG5pZiAoZ2xvYmFsQWRhcHRlcikge1xuXHRnbG9iYWxBZGFwdGVyLmluaXQuY2FsbChnbG9iYWxBZGFwdGVyLCBwYXRoQW5pbSk7XG59XG5cblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMuIElmIHRoZSBIaWdoY2hhcnRzQWRhcHRlciBpcyBub3QgZGVmaW5lZCwgYWRhcHRlciBpcyBhbiBlbXB0eSBvYmplY3Rcbi8vIGFuZCBhbGwgdGhlIHV0aWxpdHkgZnVuY3Rpb25zIHdpbGwgYmUgbnVsbC4gSW4gdGhhdCBjYXNlIHRoZXkgYXJlIHBvcHVsYXRlZCBieSB0aGVcbi8vIGRlZmF1bHQgYWRhcHRlcnMgYmVsb3cuXG52YXIgYWRhcHRlclJ1biA9IGFkYXB0ZXIuYWRhcHRlclJ1bixcblx0Z2V0U2NyaXB0ID0gYWRhcHRlci5nZXRTY3JpcHQsXG5cdGluQXJyYXkgPSBhZGFwdGVyLmluQXJyYXksXG5cdGVhY2ggPSBIaWdoY2hhcnRzLmVhY2ggPSBhZGFwdGVyLmVhY2gsXG5cdGdyZXAgPSBhZGFwdGVyLmdyZXAsXG5cdG9mZnNldCA9IGFkYXB0ZXIub2Zmc2V0LFxuXHRtYXAgPSBhZGFwdGVyLm1hcCxcblx0YWRkRXZlbnQgPSBhZGFwdGVyLmFkZEV2ZW50LFxuXHRyZW1vdmVFdmVudCA9IGFkYXB0ZXIucmVtb3ZlRXZlbnQsXG5cdGZpcmVFdmVudCA9IGFkYXB0ZXIuZmlyZUV2ZW50LFxuXHR3YXNoTW91c2VFdmVudCA9IGFkYXB0ZXIud2FzaE1vdXNlRXZlbnQsXG5cdGFuaW1hdGUgPSBhZGFwdGVyLmFuaW1hdGUsXG5cdHN0b3AgPSBhZGFwdGVyLnN0b3A7XG5cblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBIYW5kbGUgdGhlIG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5kZWZhdWx0T3B0aW9ucyA9IHtcblx0Y29sb3JzOiBbJyM3Y2I1ZWMnLCAnIzQzNDM0OCcsICcjOTBlZDdkJywgJyNmN2EzNWMnLCBcblx0XHQgICAgJyM4MDg1ZTknLCAnI2YxNWM4MCcsICcjZTRkMzU0JywgJyMyYjkwOGYnLCAnI2Y0NWI1YicsICcjOTFlOGUxJ10sXG5cdHN5bWJvbHM6IFsnY2lyY2xlJywgJ2RpYW1vbmQnLCAnc3F1YXJlJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlLWRvd24nXSxcblx0bGFuZzoge1xuXHRcdGxvYWRpbmc6ICdMb2FkaW5nLi4uJyxcblx0XHRtb250aHM6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5Jyxcblx0XHRcdFx0J0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuXHRcdHNob3J0TW9udGhzOiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG5cdFx0d2Vla2RheXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcblx0XHQvLyBpbnZhbGlkRGF0ZTogJycsXG5cdFx0ZGVjaW1hbFBvaW50OiAnLicsXG5cdFx0bnVtZXJpY1N5bWJvbHM6IFsnaycsICdNJywgJ0cnLCAnVCcsICdQJywgJ0UnXSwgLy8gU0kgcHJlZml4ZXMgdXNlZCBpbiBheGlzIGxhYmVsc1xuXHRcdHJlc2V0Wm9vbTogJ1Jlc2V0IHpvb20nLFxuXHRcdHJlc2V0Wm9vbVRpdGxlOiAnUmVzZXQgem9vbSBsZXZlbCAxOjEnLFxuXHRcdHRob3VzYW5kc1NlcDogJyAnXG5cdH0sXG5cdGdsb2JhbDoge1xuXHRcdHVzZVVUQzogdHJ1ZSxcblx0XHQvL3RpbWV6b25lT2Zmc2V0OiAwLFxuXHRcdGNhbnZhc1Rvb2xzVVJMOiAnaHR0cDovL2NvZGUuaGlnaGNoYXJ0cy5jb20vNC4xLjkvbW9kdWxlcy9jYW52YXMtdG9vbHMuanMnLFxuXHRcdFZNTFJhZGlhbEdyYWRpZW50VVJMOiAnaHR0cDovL2NvZGUuaGlnaGNoYXJ0cy5jb20vNC4xLjkvZ2Z4L3ZtbC1yYWRpYWwtZ3JhZGllbnQucG5nJ1xuXHR9LFxuXHRjaGFydDoge1xuXHRcdC8vYW5pbWF0aW9uOiB0cnVlLFxuXHRcdC8vYWxpZ25UaWNrczogZmFsc2UsXG5cdFx0Ly9yZWZsb3c6IHRydWUsXG5cdFx0Ly9jbGFzc05hbWU6IG51bGwsXG5cdFx0Ly9ldmVudHM6IHsgbG9hZCwgc2VsZWN0aW9uIH0sXG5cdFx0Ly9tYXJnaW46IFtudWxsXSxcblx0XHQvL21hcmdpblRvcDogbnVsbCxcblx0XHQvL21hcmdpblJpZ2h0OiBudWxsLFxuXHRcdC8vbWFyZ2luQm90dG9tOiBudWxsLFxuXHRcdC8vbWFyZ2luTGVmdDogbnVsbCxcblx0XHRib3JkZXJDb2xvcjogJyM0NTcyQTcnLFxuXHRcdC8vYm9yZGVyV2lkdGg6IDAsXG5cdFx0Ym9yZGVyUmFkaXVzOiAwLFxuXHRcdGRlZmF1bHRTZXJpZXNUeXBlOiAnbGluZScsXG5cdFx0aWdub3JlSGlkZGVuU2VyaWVzOiB0cnVlLFxuXHRcdC8vaW52ZXJ0ZWQ6IGZhbHNlLFxuXHRcdC8vc2hhZG93OiBmYWxzZSxcblx0XHRzcGFjaW5nOiBbMTAsIDEwLCAxNSwgMTBdLFxuXHRcdC8vc3BhY2luZ1RvcDogMTAsXG5cdFx0Ly9zcGFjaW5nUmlnaHQ6IDEwLFxuXHRcdC8vc3BhY2luZ0JvdHRvbTogMTUsXG5cdFx0Ly9zcGFjaW5nTGVmdDogMTAsXG5cdFx0Ly9zdHlsZToge1xuXHRcdC8vXHRmb250RmFtaWx5OiAnXCJMdWNpZGEgR3JhbmRlXCIsIFwiTHVjaWRhIFNhbnMgVW5pY29kZVwiLCBWZXJkYW5hLCBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJywgLy8gZGVmYXVsdCBmb250XG5cdFx0Ly9cdGZvbnRTaXplOiAnMTJweCdcblx0XHQvL30sXG5cdFx0YmFja2dyb3VuZENvbG9yOiAnI0ZGRkZGRicsXG5cdFx0Ly9wbG90QmFja2dyb3VuZENvbG9yOiBudWxsLFxuXHRcdHBsb3RCb3JkZXJDb2xvcjogJyNDMEMwQzAnLFxuXHRcdC8vcGxvdEJvcmRlcldpZHRoOiAwLFxuXHRcdC8vcGxvdFNoYWRvdzogZmFsc2UsXG5cdFx0Ly96b29tVHlwZTogJydcblx0XHRyZXNldFpvb21CdXR0b246IHtcblx0XHRcdHRoZW1lOiB7XG5cdFx0XHRcdHpJbmRleDogMjBcblx0XHRcdH0sXG5cdFx0XHRwb3NpdGlvbjoge1xuXHRcdFx0XHRhbGlnbjogJ3JpZ2h0Jyxcblx0XHRcdFx0eDogLTEwLFxuXHRcdFx0XHQvL3ZlcnRpY2FsQWxpZ246ICd0b3AnLFxuXHRcdFx0XHR5OiAxMFxuXHRcdFx0fVxuXHRcdFx0Ly8gcmVsYXRpdmVUbzogJ3Bsb3QnXG5cdFx0fVxuXHR9LFxuXHR0aXRsZToge1xuXHRcdHRleHQ6ICdDaGFydCB0aXRsZScsXG5cdFx0YWxpZ246ICdjZW50ZXInLFxuXHRcdC8vIGZsb2F0aW5nOiBmYWxzZSxcblx0XHRtYXJnaW46IDE1LFxuXHRcdC8vIHg6IDAsXG5cdFx0Ly8gdmVydGljYWxBbGlnbjogJ3RvcCcsXG5cdFx0Ly8geTogbnVsbCxcblx0XHRzdHlsZToge1xuXHRcdFx0Y29sb3I6ICcjMzMzMzMzJyxcblx0XHRcdGZvbnRTaXplOiAnMThweCdcblx0XHR9XG5cblx0fSxcblx0c3VidGl0bGU6IHtcblx0XHR0ZXh0OiAnJyxcblx0XHRhbGlnbjogJ2NlbnRlcicsXG5cdFx0Ly8gZmxvYXRpbmc6IGZhbHNlXG5cdFx0Ly8geDogMCxcblx0XHQvLyB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcblx0XHQvLyB5OiBudWxsLFxuXHRcdHN0eWxlOiB7XG5cdFx0XHRjb2xvcjogJyM1NTU1NTUnXG5cdFx0fVxuXHR9LFxuXG5cdHBsb3RPcHRpb25zOiB7XG5cdFx0bGluZTogeyAvLyBiYXNlIHNlcmllcyBvcHRpb25zXG5cdFx0XHRhbGxvd1BvaW50U2VsZWN0OiBmYWxzZSxcblx0XHRcdHNob3dDaGVja2JveDogZmFsc2UsXG5cdFx0XHRhbmltYXRpb246IHtcblx0XHRcdFx0ZHVyYXRpb246IDEwMDBcblx0XHRcdH0sXG5cdFx0XHQvL2Nvbm5lY3ROdWxsczogZmFsc2UsXG5cdFx0XHQvL2N1cnNvcjogJ2RlZmF1bHQnLFxuXHRcdFx0Ly9jbGlwOiB0cnVlLFxuXHRcdFx0Ly9kYXNoU3R5bGU6IG51bGwsXG5cdFx0XHQvL2VuYWJsZU1vdXNlVHJhY2tpbmc6IHRydWUsXG5cdFx0XHRldmVudHM6IHt9LFxuXHRcdFx0Ly9sZWdlbmRJbmRleDogMCxcblx0XHRcdC8vbGluZWNhcDogJ3JvdW5kJyxcblx0XHRcdGxpbmVXaWR0aDogMixcblx0XHRcdC8vc2hhZG93OiBmYWxzZSxcblx0XHRcdC8vIHN0YWNraW5nOiBudWxsLFxuXHRcdFx0bWFya2VyOiB7XG5cdFx0XHRcdC8vZW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0Ly9zeW1ib2w6IG51bGwsXG5cdFx0XHRcdGxpbmVXaWR0aDogMCxcblx0XHRcdFx0cmFkaXVzOiA0LFxuXHRcdFx0XHRsaW5lQ29sb3I6ICcjRkZGRkZGJyxcblx0XHRcdFx0Ly9maWxsQ29sb3I6IG51bGwsXG5cdFx0XHRcdHN0YXRlczogeyAvLyBzdGF0ZXMgZm9yIGEgc2luZ2xlIHBvaW50XG5cdFx0XHRcdFx0aG92ZXI6IHtcblx0XHRcdFx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRcdFx0XHRsaW5lV2lkdGhQbHVzOiAxLFxuXHRcdFx0XHRcdFx0cmFkaXVzUGx1czogMlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c2VsZWN0OiB7XG5cdFx0XHRcdFx0XHRmaWxsQ29sb3I6ICcjRkZGRkZGJyxcblx0XHRcdFx0XHRcdGxpbmVDb2xvcjogJyMwMDAwMDAnLFxuXHRcdFx0XHRcdFx0bGluZVdpZHRoOiAyXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cG9pbnQ6IHtcblx0XHRcdFx0ZXZlbnRzOiB7fVxuXHRcdFx0fSxcblx0XHRcdGRhdGFMYWJlbHM6IHtcblx0XHRcdFx0YWxpZ246ICdjZW50ZXInLFxuXHRcdFx0XHQvLyBkZWZlcjogdHJ1ZSxcblx0XHRcdFx0Ly8gZW5hYmxlZDogZmFsc2UsXG5cdFx0XHRcdGZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnkgPT09IG51bGwgPyAnJyA6IEhpZ2hjaGFydHMubnVtYmVyRm9ybWF0KHRoaXMueSwgLTEpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdGNvbG9yOiAnY29udHJhc3QnLFxuXHRcdFx0XHRcdGZvbnRTaXplOiAnMTFweCcsXG5cdFx0XHRcdFx0Zm9udFdlaWdodDogJ2JvbGQnLFxuXHRcdFx0XHRcdHRleHRTaGFkb3c6ICcwIDAgNnB4IGNvbnRyYXN0LCAwIDAgM3B4IGNvbnRyYXN0J1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR2ZXJ0aWNhbEFsaWduOiAnYm90dG9tJywgLy8gYWJvdmUgc2luZ3VsYXIgcG9pbnRcblx0XHRcdFx0eDogMCxcblx0XHRcdFx0eTogMCxcblx0XHRcdFx0Ly8gYmFja2dyb3VuZENvbG9yOiB1bmRlZmluZWQsXG5cdFx0XHRcdC8vIGJvcmRlckNvbG9yOiB1bmRlZmluZWQsXG5cdFx0XHRcdC8vIGJvcmRlclJhZGl1czogdW5kZWZpbmVkLFxuXHRcdFx0XHQvLyBib3JkZXJXaWR0aDogdW5kZWZpbmVkLFxuXHRcdFx0XHRwYWRkaW5nOiA1XG5cdFx0XHRcdC8vIHNoYWRvdzogZmFsc2Vcblx0XHRcdH0sXG5cdFx0XHRjcm9wVGhyZXNob2xkOiAzMDAsIC8vIGRyYXcgcG9pbnRzIG91dHNpZGUgdGhlIHBsb3QgYXJlYSB3aGVuIHRoZSBudW1iZXIgb2YgcG9pbnRzIGlzIGxlc3MgdGhhbiB0aGlzXG5cdFx0XHRwb2ludFJhbmdlOiAwLFxuXHRcdFx0Ly9wb2ludFN0YXJ0OiAwLFxuXHRcdFx0Ly9wb2ludEludGVydmFsOiAxLFxuXHRcdFx0Ly9zaG93SW5MZWdlbmQ6IG51bGwsIC8vIGF1dG86IHRydWUgZm9yIHN0YW5kYWxvbmUgc2VyaWVzLCBmYWxzZSBmb3IgbGlua2VkIHNlcmllc1xuXHRcdFx0c29mdFRocmVzaG9sZDogdHJ1ZSxcblx0XHRcdHN0YXRlczogeyAvLyBzdGF0ZXMgZm9yIHRoZSBlbnRpcmUgc2VyaWVzXG5cdFx0XHRcdGhvdmVyOiB7XG5cdFx0XHRcdFx0Ly9lbmFibGVkOiBmYWxzZSxcblx0XHRcdFx0XHRsaW5lV2lkdGhQbHVzOiAxLFxuXHRcdFx0XHRcdG1hcmtlcjoge1xuXHRcdFx0XHRcdFx0Ly8gbGluZVdpZHRoOiBiYXNlICsgMSxcblx0XHRcdFx0XHRcdC8vIHJhZGl1czogYmFzZSArIDFcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGhhbG86IHtcblx0XHRcdFx0XHRcdHNpemU6IDEwLFxuXHRcdFx0XHRcdFx0b3BhY2l0eTogMC4yNVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0OiB7XG5cdFx0XHRcdFx0bWFya2VyOiB7fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c3RpY2t5VHJhY2tpbmc6IHRydWUsXG5cdFx0XHQvL3Rvb2x0aXA6IHtcblx0XHRcdFx0Ly9wb2ludEZvcm1hdDogJzxzcGFuIHN0eWxlPVwiY29sb3I6e3BvaW50LmNvbG9yfVwiPlxcdTI1Q0Y8L3NwYW4+IHtzZXJpZXMubmFtZX06IDxiPntwb2ludC55fTwvYj4nXG5cdFx0XHRcdC8vdmFsdWVEZWNpbWFsczogbnVsbCxcblx0XHRcdFx0Ly94RGF0ZUZvcm1hdDogJyVBLCAlYiAlZSwgJVknLFxuXHRcdFx0XHQvL3ZhbHVlUHJlZml4OiAnJyxcblx0XHRcdFx0Ly95U3VmZml4OiAnJ1x0XHRcdFx0XG5cdFx0XHQvL31cblx0XHRcdHR1cmJvVGhyZXNob2xkOiAxMDAwXG5cdFx0XHQvLyB6SW5kZXg6IG51bGxcblx0XHR9XG5cdH0sXG5cdGxhYmVsczoge1xuXHRcdC8vaXRlbXM6IFtdLFxuXHRcdHN0eWxlOiB7XG5cdFx0XHQvL2ZvbnQ6IGRlZmF1bHRGb250LFxuXHRcdFx0cG9zaXRpb246IEFCU09MVVRFLFxuXHRcdFx0Y29sb3I6ICcjM0U1NzZGJ1xuXHRcdH1cblx0fSxcblx0bGVnZW5kOiB7XG5cdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRhbGlnbjogJ2NlbnRlcicsXG5cdFx0Ly9mbG9hdGluZzogZmFsc2UsXG5cdFx0bGF5b3V0OiAnaG9yaXpvbnRhbCcsXG5cdFx0bGFiZWxGb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLm5hbWU7XG5cdFx0fSxcblx0XHQvL2JvcmRlcldpZHRoOiAwLFxuXHRcdGJvcmRlckNvbG9yOiAnIzkwOTA5MCcsXG5cdFx0Ym9yZGVyUmFkaXVzOiAwLFxuXHRcdG5hdmlnYXRpb246IHtcblx0XHRcdC8vIGFuaW1hdGlvbjogdHJ1ZSxcblx0XHRcdGFjdGl2ZUNvbG9yOiAnIzI3NGI2ZCcsXG5cdFx0XHQvLyBhcnJvd1NpemU6IDEyXG5cdFx0XHRpbmFjdGl2ZUNvbG9yOiAnI0NDQydcblx0XHRcdC8vIHN0eWxlOiB7fSAvLyB0ZXh0IHN0eWxlc1xuXHRcdH0sXG5cdFx0Ly8gbWFyZ2luOiAyMCxcblx0XHQvLyByZXZlcnNlZDogZmFsc2UsXG5cdFx0c2hhZG93OiBmYWxzZSxcblx0XHQvLyBiYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG5cdFx0LypzdHlsZToge1xuXHRcdFx0cGFkZGluZzogJzVweCdcblx0XHR9LCovXG5cdFx0aXRlbVN0eWxlOiB7XHRcdFx0XG5cdFx0XHRjb2xvcjogJyMzMzMzMzMnLFxuXHRcdFx0Zm9udFNpemU6ICcxMnB4Jyxcblx0XHRcdGZvbnRXZWlnaHQ6ICdib2xkJ1xuXHRcdH0sXG5cdFx0aXRlbUhvdmVyU3R5bGU6IHtcblx0XHRcdC8vY3Vyc29yOiAncG9pbnRlcicsIHJlbW92ZWQgYXMgb2YgIzYwMVxuXHRcdFx0Y29sb3I6ICcjMDAwJ1xuXHRcdH0sXG5cdFx0aXRlbUhpZGRlblN0eWxlOiB7XG5cdFx0XHRjb2xvcjogJyNDQ0MnXG5cdFx0fSxcblx0XHRpdGVtQ2hlY2tib3hTdHlsZToge1xuXHRcdFx0cG9zaXRpb246IEFCU09MVVRFLFxuXHRcdFx0d2lkdGg6ICcxM3B4JywgLy8gZm9yIElFIHByZWNpc2lvblxuXHRcdFx0aGVpZ2h0OiAnMTNweCdcblx0XHR9LFxuXHRcdC8vIGl0ZW1XaWR0aDogdW5kZWZpbmVkLFxuXHRcdC8vIHN5bWJvbFJhZGl1czogMCxcblx0XHQvLyBzeW1ib2xXaWR0aDogMTYsXG5cdFx0c3ltYm9sUGFkZGluZzogNSxcblx0XHR2ZXJ0aWNhbEFsaWduOiAnYm90dG9tJyxcblx0XHQvLyB3aWR0aDogdW5kZWZpbmVkLFxuXHRcdHg6IDAsXG5cdFx0eTogMCxcblx0XHR0aXRsZToge1xuXHRcdFx0Ly90ZXh0OiBudWxsLFxuXHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0Zm9udFdlaWdodDogJ2JvbGQnXG5cdFx0XHR9XG5cdFx0fVx0XHRcdFxuXHR9LFxuXG5cdGxvYWRpbmc6IHtcblx0XHQvLyBoaWRlRHVyYXRpb246IDEwMCxcblx0XHRsYWJlbFN0eWxlOiB7XG5cdFx0XHRmb250V2VpZ2h0OiAnYm9sZCcsXG5cdFx0XHRwb3NpdGlvbjogUkVMQVRJVkUsXG5cdFx0XHR0b3A6ICc0NSUnXG5cdFx0fSxcblx0XHQvLyBzaG93RHVyYXRpb246IDAsXG5cdFx0c3R5bGU6IHtcblx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcblx0XHRcdG9wYWNpdHk6IDAuNSxcblx0XHRcdHRleHRBbGlnbjogJ2NlbnRlcidcblx0XHR9XG5cdH0sXG5cblx0dG9vbHRpcDoge1xuXHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0YW5pbWF0aW9uOiBoYXNTVkcsXG5cdFx0Ly9jcm9zc2hhaXJzOiBudWxsLFxuXHRcdGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjQ5LCAyNDksIDI0OSwgLjg1KScsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdFx0Ym9yZGVyUmFkaXVzOiAzLFxuXHRcdGRhdGVUaW1lTGFiZWxGb3JtYXRzOiB7IFxuXHRcdFx0bWlsbGlzZWNvbmQ6ICclQSwgJWIgJWUsICVIOiVNOiVTLiVMJyxcblx0XHRcdHNlY29uZDogJyVBLCAlYiAlZSwgJUg6JU06JVMnLFxuXHRcdFx0bWludXRlOiAnJUEsICViICVlLCAlSDolTScsXG5cdFx0XHRob3VyOiAnJUEsICViICVlLCAlSDolTScsXG5cdFx0XHRkYXk6ICclQSwgJWIgJWUsICVZJyxcblx0XHRcdHdlZWs6ICdXZWVrIGZyb20gJUEsICViICVlLCAlWScsXG5cdFx0XHRtb250aDogJyVCICVZJyxcblx0XHRcdHllYXI6ICclWSdcblx0XHR9LFxuXHRcdGZvb3RlckZvcm1hdDogJycsXG5cdFx0Ly9mb3JtYXR0ZXI6IGRlZmF1bHRGb3JtYXR0ZXIsXG5cdFx0aGVhZGVyRm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDEwcHhcIj57cG9pbnQua2V5fTwvc3Bhbj48YnIvPicsXG5cdFx0cG9pbnRGb3JtYXQ6ICc8c3BhbiBzdHlsZT1cImNvbG9yOntwb2ludC5jb2xvcn1cIj5cXHUyNUNGPC9zcGFuPiB7c2VyaWVzLm5hbWV9OiA8Yj57cG9pbnQueX08L2I+PGJyLz4nLFxuXHRcdHNoYWRvdzogdHJ1ZSxcblx0XHQvL3NoYXBlOiAnY2FsbG91dCcsXG5cdFx0Ly9zaGFyZWQ6IGZhbHNlLFxuXHRcdHNuYXA6IGlzVG91Y2hEZXZpY2UgPyAyNSA6IDEwLFxuXHRcdHN0eWxlOiB7XG5cdFx0XHRjb2xvcjogJyMzMzMzMzMnLFxuXHRcdFx0Y3Vyc29yOiAnZGVmYXVsdCcsXG5cdFx0XHRmb250U2l6ZTogJzEycHgnLFxuXHRcdFx0cGFkZGluZzogJzhweCcsXG5cdFx0XHRwb2ludGVyRXZlbnRzOiAnbm9uZScsIC8vICMxNjg2IGh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD1wb2ludGVyLWV2ZW50c1xuXHRcdFx0d2hpdGVTcGFjZTogJ25vd3JhcCdcblx0XHR9XG5cdFx0Ly94RGF0ZUZvcm1hdDogJyVBLCAlYiAlZSwgJVknLFxuXHRcdC8vdmFsdWVEZWNpbWFsczogbnVsbCxcblx0XHQvL3ZhbHVlUHJlZml4OiAnJyxcblx0XHQvL3ZhbHVlU3VmZml4OiAnJ1xuXHR9LFxuXG5cdGNyZWRpdHM6IHtcblx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdHRleHQ6ICdIaWdoY2hhcnRzLmNvbScsXG5cdFx0aHJlZjogJ2h0dHA6Ly93d3cuaGlnaGNoYXJ0cy5jb20nLFxuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRhbGlnbjogJ3JpZ2h0Jyxcblx0XHRcdHg6IC0xMCxcblx0XHRcdHZlcnRpY2FsQWxpZ246ICdib3R0b20nLFxuXHRcdFx0eTogLTVcblx0XHR9LFxuXHRcdHN0eWxlOiB7XG5cdFx0XHRjdXJzb3I6ICdwb2ludGVyJyxcblx0XHRcdGNvbG9yOiAnIzkwOTA5MCcsXG5cdFx0XHRmb250U2l6ZTogJzlweCdcblx0XHR9XG5cdH1cbn07XG5cblxuXG5cbi8vIFNlcmllcyBkZWZhdWx0c1xudmFyIGRlZmF1bHRQbG90T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zLnBsb3RPcHRpb25zLFxuXHRkZWZhdWx0U2VyaWVzT3B0aW9ucyA9IGRlZmF1bHRQbG90T3B0aW9ucy5saW5lO1xuXG4vLyBzZXQgdGhlIGRlZmF1bHQgdGltZSBtZXRob2RzXG5zZXRUaW1lTWV0aG9kcygpO1xuXG5cblxuLyoqXG4gKiBTZXQgdGhlIHRpbWUgbWV0aG9kcyBnbG9iYWxseSBiYXNlZCBvbiB0aGUgdXNlVVRDIG9wdGlvbi4gVGltZSBtZXRob2QgY2FuIGJlIGVpdGhlclxuICogbG9jYWwgdGltZSBvciBVVEMgKGRlZmF1bHQpLlxuICovXG5mdW5jdGlvbiBzZXRUaW1lTWV0aG9kcygpIHtcblx0dmFyIGdsb2JhbE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucy5nbG9iYWwsXG5cdFx0dXNlVVRDID0gZ2xvYmFsT3B0aW9ucy51c2VVVEMsXG5cdFx0R0VUID0gdXNlVVRDID8gJ2dldFVUQycgOiAnZ2V0Jyxcblx0XHRTRVQgPSB1c2VVVEMgPyAnc2V0VVRDJyA6ICdzZXQnO1xuXG5cblx0RGF0ZSA9IGdsb2JhbE9wdGlvbnMuRGF0ZSB8fCB3aW5kb3cuRGF0ZTtcblx0dGltZXpvbmVPZmZzZXQgPSB1c2VVVEMgJiYgZ2xvYmFsT3B0aW9ucy50aW1lem9uZU9mZnNldDtcblx0Z2V0VGltZXpvbmVPZmZzZXQgPSB1c2VVVEMgJiYgZ2xvYmFsT3B0aW9ucy5nZXRUaW1lem9uZU9mZnNldDtcblx0bWFrZVRpbWUgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG5cdFx0dmFyIGQ7XG5cdFx0aWYgKHVzZVVUQykge1xuXHRcdFx0ZCA9IERhdGUuVVRDLmFwcGx5KDAsIGFyZ3VtZW50cyk7XG5cdFx0XHRkICs9IGdldFRaT2Zmc2V0KGQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkID0gbmV3IERhdGUoXG5cdFx0XHRcdHllYXIsXG5cdFx0XHRcdG1vbnRoLFxuXHRcdFx0XHRwaWNrKGRhdGUsIDEpLFxuXHRcdFx0XHRwaWNrKGhvdXJzLCAwKSxcblx0XHRcdFx0cGljayhtaW51dGVzLCAwKSxcblx0XHRcdFx0cGljayhzZWNvbmRzLCAwKVxuXHRcdFx0KS5nZXRUaW1lKCk7XG5cdFx0fVxuXHRcdHJldHVybiBkO1xuXHR9O1xuXHRnZXRNaW51dGVzID0gICAgICBHRVQgKyAnTWludXRlcyc7XG5cdGdldEhvdXJzID0gICAgICAgIEdFVCArICdIb3Vycyc7XG5cdGdldERheSA9ICAgICAgICAgIEdFVCArICdEYXknO1xuXHRnZXREYXRlID0gICAgICAgICBHRVQgKyAnRGF0ZSc7XG5cdGdldE1vbnRoID0gICAgICAgIEdFVCArICdNb250aCc7XG5cdGdldEZ1bGxZZWFyID0gICAgIEdFVCArICdGdWxsWWVhcic7XG5cdHNldE1pbGxpc2Vjb25kcyA9IFNFVCArICdNaWxsaXNlY29uZHMnO1xuXHRzZXRTZWNvbmRzID0gICAgICBTRVQgKyAnU2Vjb25kcyc7XG5cdHNldE1pbnV0ZXMgPSAgICAgIFNFVCArICdNaW51dGVzJztcblx0c2V0SG91cnMgPSAgICAgICAgU0VUICsgJ0hvdXJzJztcblx0c2V0RGF0ZSA9ICAgICAgICAgU0VUICsgJ0RhdGUnO1xuXHRzZXRNb250aCA9ICAgICAgICBTRVQgKyAnTW9udGgnO1xuXHRzZXRGdWxsWWVhciA9ICAgICBTRVQgKyAnRnVsbFllYXInO1xuXG59XG5cbi8qKlxuICogTWVyZ2UgdGhlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIGN1c3RvbSBvcHRpb25zIGFuZCByZXR1cm4gdGhlIG5ldyBvcHRpb25zIHN0cnVjdHVyZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG5ldyBjdXN0b20gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcblx0XG5cdC8vIENvcHkgaW4gdGhlIGRlZmF1bHQgb3B0aW9uc1xuXHRkZWZhdWx0T3B0aW9ucyA9IG1lcmdlKHRydWUsIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblx0XG5cdC8vIEFwcGx5IFVUQ1xuXHRzZXRUaW1lTWV0aG9kcygpO1xuXG5cdHJldHVybiBkZWZhdWx0T3B0aW9ucztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHVwZGF0ZWQgZGVmYXVsdCBvcHRpb25zLiBVbnRpbCAzLjAuNywgbWVyZWx5IGV4cG9zaW5nIGRlZmF1bHRPcHRpb25zIGZvciBvdXRzaWRlIG1vZHVsZXNcbiAqIHdhc24ndCBlbm91Z2ggYmVjYXVzZSB0aGUgc2V0T3B0aW9ucyBtZXRob2QgY3JlYXRlZCBhIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG5cdHJldHVybiBkZWZhdWx0T3B0aW9ucztcbn1cblxuXG4vKipcbiAqIEhhbmRsZSBjb2xvciBvcGVyYXRpb25zLiBUaGUgb2JqZWN0IG1ldGhvZHMgYXJlIGNoYWluYWJsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgaW5wdXQgY29sb3IgaW4gZWl0aGVyIHJiZ2Egb3IgaGV4IGZvcm1hdFxuICovXG52YXIgcmdiYVJlZ0V4ID0gL3JnYmFcXChcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldPyg/OlxcLlswLTldKyk/KVxccypcXCkvLFxuXHRoZXhSZWdFeCA9IC8jKFthLWZBLUYwLTldezJ9KShbYS1mQS1GMC05XXsyfSkoW2EtZkEtRjAtOV17Mn0pLyxcblx0cmdiUmVnRXggPSAvcmdiXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccypcXCkvO1xuXG52YXIgQ29sb3IgPSBmdW5jdGlvbiAoaW5wdXQpIHtcblx0Ly8gZGVjbGFyZSB2YXJpYWJsZXNcblx0dmFyIHJnYmEgPSBbXSwgcmVzdWx0LCBzdG9wcztcblxuXHQvKipcblx0ICogUGFyc2UgdGhlIGlucHV0IGNvbG9yIHRvIHJnYmEgYXJyYXlcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0XG5cdCAqL1xuXHRmdW5jdGlvbiBpbml0KGlucHV0KSB7XG5cblx0XHQvLyBHcmFkaWVudHNcblx0XHRpZiAoaW5wdXQgJiYgaW5wdXQuc3RvcHMpIHtcblx0XHRcdHN0b3BzID0gbWFwKGlucHV0LnN0b3BzLCBmdW5jdGlvbiAoc3RvcCkge1xuXHRcdFx0XHRyZXR1cm4gQ29sb3Ioc3RvcFsxXSk7XG5cdFx0XHR9KTtcblxuXHRcdC8vIFNvbGlkIGNvbG9yc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyByZ2JhXG5cdFx0XHRyZXN1bHQgPSByZ2JhUmVnRXguZXhlYyhpbnB1dCk7XG5cdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdHJnYmEgPSBbcEludChyZXN1bHRbMV0pLCBwSW50KHJlc3VsdFsyXSksIHBJbnQocmVzdWx0WzNdKSwgcGFyc2VGbG9hdChyZXN1bHRbNF0sIDEwKV07XG5cdFx0XHR9IGVsc2UgeyBcblx0XHRcdFx0Ly8gaGV4XG5cdFx0XHRcdHJlc3VsdCA9IGhleFJlZ0V4LmV4ZWMoaW5wdXQpO1xuXHRcdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0cmdiYSA9IFtwSW50KHJlc3VsdFsxXSwgMTYpLCBwSW50KHJlc3VsdFsyXSwgMTYpLCBwSW50KHJlc3VsdFszXSwgMTYpLCAxXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyByZ2Jcblx0XHRcdFx0XHRyZXN1bHQgPSByZ2JSZWdFeC5leGVjKGlucHV0KTtcblx0XHRcdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRyZ2JhID0gW3BJbnQocmVzdWx0WzFdKSwgcEludChyZXN1bHRbMl0pLCBwSW50KHJlc3VsdFszXSksIDFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cdFx0XG5cblx0fVxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBjb2xvciBhIHNwZWNpZmllZCBmb3JtYXRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0KGZvcm1hdCkge1xuXHRcdHZhciByZXQ7XG5cblx0XHRpZiAoc3RvcHMpIHtcblx0XHRcdHJldCA9IG1lcmdlKGlucHV0KTtcblx0XHRcdHJldC5zdG9wcyA9IFtdLmNvbmNhdChyZXQuc3RvcHMpO1xuXHRcdFx0ZWFjaChzdG9wcywgZnVuY3Rpb24gKHN0b3AsIGkpIHtcblx0XHRcdFx0cmV0LnN0b3BzW2ldID0gW3JldC5zdG9wc1tpXVswXSwgc3RvcC5nZXQoZm9ybWF0KV07XG5cdFx0XHR9KTtcblxuXHRcdC8vIGl0J3MgTmFOIGlmIGdyYWRpZW50IGNvbG9ycyBvbiBhIGNvbHVtbiBjaGFydFxuXHRcdH0gZWxzZSBpZiAocmdiYSAmJiAhaXNOYU4ocmdiYVswXSkpIHtcblx0XHRcdGlmIChmb3JtYXQgPT09ICdyZ2InKSB7XG5cdFx0XHRcdHJldCA9ICdyZ2IoJyArIHJnYmFbMF0gKyAnLCcgKyByZ2JhWzFdICsgJywnICsgcmdiYVsyXSArICcpJztcblx0XHRcdH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnYScpIHtcblx0XHRcdFx0cmV0ID0gcmdiYVszXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldCA9ICdyZ2JhKCcgKyByZ2JhLmpvaW4oJywnKSArICcpJztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0ID0gaW5wdXQ7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXHQvKipcblx0ICogQnJpZ2h0ZW4gdGhlIGNvbG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYVxuXHQgKi9cblx0ZnVuY3Rpb24gYnJpZ2h0ZW4oYWxwaGEpIHtcblx0XHRpZiAoc3RvcHMpIHtcblx0XHRcdGVhY2goc3RvcHMsIGZ1bmN0aW9uIChzdG9wKSB7XG5cdFx0XHRcdHN0b3AuYnJpZ2h0ZW4oYWxwaGEpO1xuXHRcdFx0fSk7XG5cdFx0XG5cdFx0fSBlbHNlIGlmIChpc051bWJlcihhbHBoYSkgJiYgYWxwaGEgIT09IDApIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0XHRyZ2JhW2ldICs9IHBJbnQoYWxwaGEgKiAyNTUpO1xuXG5cdFx0XHRcdGlmIChyZ2JhW2ldIDwgMCkge1xuXHRcdFx0XHRcdHJnYmFbaV0gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZ2JhW2ldID4gMjU1KSB7XG5cdFx0XHRcdFx0cmdiYVtpXSA9IDI1NTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0ICogU2V0IHRoZSBjb2xvcidzIG9wYWNpdHkgdG8gYSBnaXZlbiBhbHBoYSB2YWx1ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYWxwaGFcblx0ICovXG5cdGZ1bmN0aW9uIHNldE9wYWNpdHkoYWxwaGEpIHtcblx0XHRyZ2JhWzNdID0gYWxwaGE7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvLyBpbml0aWFsaXplOiBwYXJzZSB0aGUgaW5wdXRcblx0aW5pdChpbnB1dCk7XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cmV0dXJuIHtcblx0XHRnZXQ6IGdldCxcblx0XHRicmlnaHRlbjogYnJpZ2h0ZW4sXG5cdFx0cmdiYTogcmdiYSxcblx0XHRzZXRPcGFjaXR5OiBzZXRPcGFjaXR5LFxuXHRcdHJhdzogaW5wdXRcblx0fTtcbn07XG5cblxuLyoqXG4gKiBBIHdyYXBwZXIgb2JqZWN0IGZvciBTVkcgZWxlbWVudHNcbiAqL1xuZnVuY3Rpb24gU1ZHRWxlbWVudCgpIHt9XG5cblNWR0VsZW1lbnQucHJvdG90eXBlID0ge1xuXHRcblx0Ly8gRGVmYXVsdCBiYXNlIGZvciBhbmltYXRpb25cblx0b3BhY2l0eTogMSxcblx0Ly8gRm9yIGxhYmVscywgdGhlc2UgQ1NTIHByb3BlcnRpZXMgYXJlIGFwcGxpZWQgdG8gdGhlIDx0ZXh0PiBub2RlIGRpcmVjdGx5XG5cdHRleHRQcm9wczogWydmb250U2l6ZScsICdmb250V2VpZ2h0JywgJ2ZvbnRGYW1pbHknLCAnZm9udFN0eWxlJywgJ2NvbG9yJywgXG5cdFx0J2xpbmVIZWlnaHQnLCAnd2lkdGgnLCAndGV4dERlY29yYXRpb24nLCAndGV4dE92ZXJmbG93JywgJ3RleHRTaGFkb3cnXSxcblx0XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBTVkcgcmVuZGVyZXJcblx0ICogQHBhcmFtIHtPYmplY3R9IHJlbmRlcmVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxuXHQgKi9cblx0aW5pdDogZnVuY3Rpb24gKHJlbmRlcmVyLCBub2RlTmFtZSkge1xuXHRcdHZhciB3cmFwcGVyID0gdGhpcztcblx0XHR3cmFwcGVyLmVsZW1lbnQgPSBub2RlTmFtZSA9PT0gJ3NwYW4nID9cblx0XHRcdGNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpIDpcblx0XHRcdGRvYy5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBub2RlTmFtZSk7XG5cdFx0d3JhcHBlci5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIEFuaW1hdGUgYSBnaXZlbiBhdHRyaWJ1dGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucyBUaGUgc2FtZSBvcHRpb25zIGFzIGluIGpRdWVyeSBhbmltYXRpb25cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGxldGUgRnVuY3Rpb24gdG8gcGVyZm9ybSBhdCB0aGUgZW5kIG9mIGFuaW1hdGlvblxuXHQgKi9cblx0YW5pbWF0ZTogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucywgY29tcGxldGUpIHtcblx0XHR2YXIgYW5pbU9wdGlvbnMgPSBwaWNrKG9wdGlvbnMsIHRoaXMucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uLCB0cnVlKTtcblx0XHRzdG9wKHRoaXMpOyAvLyBzdG9wIHJlZ2FyZGxlc3Mgb2YgYW5pbWF0aW9uIGFjdHVhbGx5IHJ1bm5pbmcsIG9yIHJldmVydGluZyB0byAuYXR0ciAoIzYwNylcblx0XHRpZiAoYW5pbU9wdGlvbnMpIHtcblx0XHRcdGFuaW1PcHRpb25zID0gbWVyZ2UoYW5pbU9wdGlvbnMsIHt9KTsgLy8jMjYyNVxuXHRcdFx0aWYgKGNvbXBsZXRlKSB7IC8vIGFsbG93cyB1c2luZyBhIGNhbGxiYWNrIHdpdGggdGhlIGdsb2JhbCBhbmltYXRpb24gd2l0aG91dCBvdmVyd3JpdGluZyBpdFxuXHRcdFx0XHRhbmltT3B0aW9ucy5jb21wbGV0ZSA9IGNvbXBsZXRlO1xuXHRcdFx0fVxuXHRcdFx0YW5pbWF0ZSh0aGlzLCBwYXJhbXMsIGFuaW1PcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hdHRyKHBhcmFtcywgbnVsbCwgY29tcGxldGUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogQnVpbGQgYW4gU1ZHIGdyYWRpZW50IG91dCBvZiBhIGNvbW1vbiBKYXZhU2NyaXB0IGNvbmZpZ3VyYXRpb24gb2JqZWN0XG5cdCAqL1xuXHRjb2xvckdyYWRpZW50OiBmdW5jdGlvbiAoY29sb3IsIHByb3AsIGVsZW0pIHtcblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuXHRcdFx0Y29sb3JPYmplY3QsXG5cdFx0XHRncmFkTmFtZSxcblx0XHRcdGdyYWRBdHRyLFxuXHRcdFx0cmFkQXR0cixcblx0XHRcdGdyYWRpZW50cyxcblx0XHRcdGdyYWRpZW50T2JqZWN0LFxuXHRcdFx0c3RvcHMsXG5cdFx0XHRzdG9wQ29sb3IsXG5cdFx0XHRzdG9wT3BhY2l0eSxcblx0XHRcdHJhZGlhbFJlZmVyZW5jZSxcblx0XHRcdG4sXG5cdFx0XHRpZCxcblx0XHRcdGtleSA9IFtdO1xuXG5cdFx0Ly8gQXBwbHkgbGluZWFyIG9yIHJhZGlhbCBncmFkaWVudHNcblx0XHRpZiAoY29sb3IubGluZWFyR3JhZGllbnQpIHtcblx0XHRcdGdyYWROYW1lID0gJ2xpbmVhckdyYWRpZW50Jztcblx0XHR9IGVsc2UgaWYgKGNvbG9yLnJhZGlhbEdyYWRpZW50KSB7XG5cdFx0XHRncmFkTmFtZSA9ICdyYWRpYWxHcmFkaWVudCc7XG5cdFx0fVxuXG5cdFx0aWYgKGdyYWROYW1lKSB7XG5cdFx0XHRncmFkQXR0ciA9IGNvbG9yW2dyYWROYW1lXTtcblx0XHRcdGdyYWRpZW50cyA9IHJlbmRlcmVyLmdyYWRpZW50cztcblx0XHRcdHN0b3BzID0gY29sb3Iuc3RvcHM7XG5cdFx0XHRyYWRpYWxSZWZlcmVuY2UgPSBlbGVtLnJhZGlhbFJlZmVyZW5jZTtcblxuXHRcdFx0Ly8gS2VlcCA8IDIuMiBrb21wYXRpYmlsaXR5XG5cdFx0XHRpZiAoaXNBcnJheShncmFkQXR0cikpIHtcblx0XHRcdFx0Y29sb3JbZ3JhZE5hbWVdID0gZ3JhZEF0dHIgPSB7XG5cdFx0XHRcdFx0eDE6IGdyYWRBdHRyWzBdLFxuXHRcdFx0XHRcdHkxOiBncmFkQXR0clsxXSxcblx0XHRcdFx0XHR4MjogZ3JhZEF0dHJbMl0sXG5cdFx0XHRcdFx0eTI6IGdyYWRBdHRyWzNdLFxuXHRcdFx0XHRcdGdyYWRpZW50VW5pdHM6ICd1c2VyU3BhY2VPblVzZSdcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29ycmVjdCB0aGUgcmFkaWFsIGdyYWRpZW50IGZvciB0aGUgcmFkaWFsIHJlZmVyZW5jZSBzeXN0ZW1cblx0XHRcdGlmIChncmFkTmFtZSA9PT0gJ3JhZGlhbEdyYWRpZW50JyAmJiByYWRpYWxSZWZlcmVuY2UgJiYgIWRlZmluZWQoZ3JhZEF0dHIuZ3JhZGllbnRVbml0cykpIHtcblx0XHRcdFx0cmFkQXR0ciA9IGdyYWRBdHRyOyAvLyBTYXZlIHRoZSByYWRpYWwgYXR0cmlidXRlcyBmb3IgdXBkYXRpbmdcblx0XHRcdFx0Z3JhZEF0dHIgPSBtZXJnZShncmFkQXR0ciwgXG5cdFx0XHRcdFx0cmVuZGVyZXIuZ2V0UmFkaWFsQXR0cihyYWRpYWxSZWZlcmVuY2UsIHJhZEF0dHIpLFxuXHRcdFx0XHRcdHsgZ3JhZGllbnRVbml0czogJ3VzZXJTcGFjZU9uVXNlJyB9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1aWxkIHRoZSB1bmlxdWUga2V5IHRvIGRldGVjdCB3aGV0aGVyIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgKCMxMjgyKVxuXHRcdFx0Zm9yIChuIGluIGdyYWRBdHRyKSB7XG5cdFx0XHRcdGlmIChuICE9PSAnaWQnKSB7XG5cdFx0XHRcdFx0a2V5LnB1c2gobiwgZ3JhZEF0dHJbbl0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKG4gaW4gc3RvcHMpIHtcblx0XHRcdFx0a2V5LnB1c2goc3RvcHNbbl0pO1xuXHRcdFx0fVxuXHRcdFx0a2V5ID0ga2V5LmpvaW4oJywnKTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBncmFkaWVudCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBjb25maWcgb2JqZWN0IGlzIGNyZWF0ZWQgd2l0aGluIHRoaXMgcmVuZGVyZXJcblx0XHRcdGlmIChncmFkaWVudHNba2V5XSkge1xuXHRcdFx0XHRpZCA9IGdyYWRpZW50c1trZXldLmF0dHIoJ2lkJyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBpZCBhbmQgY3JlYXRlIHRoZSBlbGVtZW50XG5cdFx0XHRcdGdyYWRBdHRyLmlkID0gaWQgPSBQUkVGSVggKyBpZENvdW50ZXIrKztcblx0XHRcdFx0Z3JhZGllbnRzW2tleV0gPSBncmFkaWVudE9iamVjdCA9IHJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoZ3JhZE5hbWUpXG5cdFx0XHRcdFx0LmF0dHIoZ3JhZEF0dHIpXG5cdFx0XHRcdFx0LmFkZChyZW5kZXJlci5kZWZzKTtcblxuXHRcdFx0XHRncmFkaWVudE9iamVjdC5yYWRBdHRyID0gcmFkQXR0cjtcblxuXHRcdFx0XHQvLyBUaGUgZ3JhZGllbnQgbmVlZHMgdG8ga2VlcCBhIGxpc3Qgb2Ygc3RvcHMgdG8gYmUgYWJsZSB0byBkZXN0cm95IHRoZW1cblx0XHRcdFx0Z3JhZGllbnRPYmplY3Quc3RvcHMgPSBbXTtcblx0XHRcdFx0ZWFjaChzdG9wcywgZnVuY3Rpb24gKHN0b3ApIHtcblx0XHRcdFx0XHR2YXIgc3RvcE9iamVjdDtcblx0XHRcdFx0XHRpZiAoc3RvcFsxXS5pbmRleE9mKCdyZ2JhJykgPT09IDApIHtcblx0XHRcdFx0XHRcdGNvbG9yT2JqZWN0ID0gQ29sb3Ioc3RvcFsxXSk7XG5cdFx0XHRcdFx0XHRzdG9wQ29sb3IgPSBjb2xvck9iamVjdC5nZXQoJ3JnYicpO1xuXHRcdFx0XHRcdFx0c3RvcE9wYWNpdHkgPSBjb2xvck9iamVjdC5nZXQoJ2EnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RvcENvbG9yID0gc3RvcFsxXTtcblx0XHRcdFx0XHRcdHN0b3BPcGFjaXR5ID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3RvcE9iamVjdCA9IHJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ3N0b3AnKS5hdHRyKHtcblx0XHRcdFx0XHRcdG9mZnNldDogc3RvcFswXSxcblx0XHRcdFx0XHRcdCdzdG9wLWNvbG9yJzogc3RvcENvbG9yLFxuXHRcdFx0XHRcdFx0J3N0b3Atb3BhY2l0eSc6IHN0b3BPcGFjaXR5XG5cdFx0XHRcdFx0fSkuYWRkKGdyYWRpZW50T2JqZWN0KTtcblxuXHRcdFx0XHRcdC8vIEFkZCB0aGUgc3RvcCBlbGVtZW50IHRvIHRoZSBncmFkaWVudFxuXHRcdFx0XHRcdGdyYWRpZW50T2JqZWN0LnN0b3BzLnB1c2goc3RvcE9iamVjdCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgZ3JhZGllbnQgb2JqZWN0XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZShwcm9wLCAndXJsKCcgKyByZW5kZXJlci51cmwgKyAnIycgKyBpZCArICcpJyk7XG5cdFx0XHRlbGVtLmdyYWRpZW50ID0ga2V5O1xuXHRcdH0gXG5cdH0sXG5cblx0LyoqXG5cdCAqIEFwcGx5IGEgcG9seWZpbGwgdG8gdGhlIHRleHQtc3Ryb2tlIENTUyBwcm9wZXJ0eSwgYnkgY29weWluZyB0aGUgdGV4dCBlbGVtZW50XG5cdCAqIGFuZCBhcHBseSBzdHJva2VzIHRvIHRoZSBjb3B5LlxuXHQgKlxuXHQgKiBDb250cmFzdCBjaGVja3MgYXQgaHR0cDovL2pzZmlkZGxlLm5ldC9oaWdoY2hhcnRzLzQzc29lOW0xLzIvXG5cdCAqXG5cdCAqIGRvY3M6IHVwZGF0ZSBkZWZhdWx0LCBkb2N1bWVudCB0aGUgcG9seWZpbGwgYW5kIHRoZSBsaW1pdGF0aW9ucyBvbiBoZXggY29sb3JzIGFuZCBwaXhlbCB2YWx1ZXMsIGRvY3VtZW50IGNvbnRyYXN0IHBzZXVkby1jb2xvclxuXHQgKi9cblx0YXBwbHlUZXh0U2hhZG93OiBmdW5jdGlvbiAodGV4dFNoYWRvdykge1xuXHRcdHZhciBlbGVtID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0dHNwYW5zLFxuXHRcdFx0aGFzQ29udHJhc3QgPSB0ZXh0U2hhZG93LmluZGV4T2YoJ2NvbnRyYXN0JykgIT09IC0xLFxuXHRcdFx0c3R5bGVzID0ge30sXG5cdFx0XHRmb3JFeHBvcnQgPSB0aGlzLnJlbmRlcmVyLmZvckV4cG9ydCxcblx0XHRcdC8vIElFMTAgYW5kIElFMTEgcmVwb3J0IHRleHRTaGFkb3cgaW4gZWxlbS5zdHlsZSBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHdvcmsuIENoZWNrXG5cdFx0XHQvLyB0aGlzIGFnYWluIHdpdGggbmV3IElFIHJlbGVhc2UuIEluIGV4cG9ydHMsIHRoZSByZW5kZXJpbmcgaXMgcGFzc2VkIHRvIFBoYW50b21KUy4gXG5cdFx0XHRzdXBwb3J0cyA9IGZvckV4cG9ydCB8fCAoZWxlbS5zdHlsZS50ZXh0U2hhZG93ICE9PSBVTkRFRklORUQgJiYgIWlzTVMpO1xuXG5cdFx0Ly8gV2hlbiB0aGUgdGV4dCBzaGFkb3cgaXMgc2V0IHRvIGNvbnRyYXN0LCB1c2UgZGFyayBzdHJva2UgZm9yIGxpZ2h0IHRleHQgYW5kIHZpY2UgdmVyc2Fcblx0XHRpZiAoaGFzQ29udHJhc3QpIHtcblx0XHRcdHN0eWxlcy50ZXh0U2hhZG93ID0gdGV4dFNoYWRvdyA9IHRleHRTaGFkb3cucmVwbGFjZSgvY29udHJhc3QvZywgdGhpcy5yZW5kZXJlci5nZXRDb250cmFzdChlbGVtLnN0eWxlLmZpbGwpKTtcblx0XHR9XG5cblx0XHQvLyBTYWZhcmkgd2l0aCByZXRpbmEgZGlzcGxheXMgYXMgd2VsbCBhcyBQaGFudG9tSlMgYnVnICgjMzk3NCkuIEZpcmVmb3ggZG9lcyBub3QgdG9sZXJhdGUgdGhpcyxcblx0XHQvLyBpdCByZW1vdmVzIHRoZSB0ZXh0IHNoYWRvd3MuXG5cdFx0aWYgKGlzV2ViS2l0IHx8IGZvckV4cG9ydCkge1xuXHRcdFx0c3R5bGVzLnRleHRSZW5kZXJpbmcgPSAnZ2VvbWV0cmljUHJlY2lzaW9uJztcblx0XHR9XG5cblx0XHQvKiBTZWxlY3RpdmUgc2lkZS1ieS1zaWRlIHRlc3RpbmcgaW4gc3VwcG9ydGVkIGJyb3dzZXIgKGh0dHA6Ly9qc2ZpZGRsZS5uZXQvaGlnaGNoYXJ0cy83M0wxcHRyaC8pXG5cdFx0aWYgKGVsZW0udGV4dENvbnRlbnQuaW5kZXhPZignMi4nKSA9PT0gMCkge1xuXHRcdFx0ZWxlbS5zdHlsZVsndGV4dC1zaGFkb3cnXSA9ICdub25lJztcblx0XHRcdHN1cHBvcnRzID0gZmFsc2U7XG5cdFx0fVxuXHRcdC8vICovXG5cblx0XHQvLyBObyByZWFzb24gdG8gcG9seWZpbGwsIHdlJ3ZlIGdvdCBuYXRpdmUgc3VwcG9ydFxuXHRcdGlmIChzdXBwb3J0cykge1xuXHRcdFx0dGhpcy5jc3Moc3R5bGVzKTsgLy8gQXBwbHkgYWx0ZXJlZCB0ZXh0U2hhZG93IG9yIHRleHRSZW5kZXJpbmcgd29ya2Fyb3VuZFxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuZmFrZVRTID0gdHJ1ZTsgLy8gRmFrZSB0ZXh0IHNoYWRvd1xuXG5cdFx0XHQvLyBJbiBvcmRlciB0byBnZXQgdGhlIHJpZ2h0IHkgcG9zaXRpb24gb2YgdGhlIGNsb25lcywgXG5cdFx0XHQvLyBjb3B5IG92ZXIgdGhlIHkgc2V0dGVyXG5cdFx0XHR0aGlzLnlTZXR0ZXIgPSB0aGlzLnhTZXR0ZXI7XG5cblx0XHRcdHRzcGFucyA9IFtdLnNsaWNlLmNhbGwoZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSgndHNwYW4nKSk7XG5cdFx0XHRlYWNoKHRleHRTaGFkb3cuc3BsaXQoL1xccz8sXFxzPy9nKSwgZnVuY3Rpb24gKHRleHRTaGFkb3cpIHtcblx0XHRcdFx0dmFyIGZpcnN0Q2hpbGQgPSBlbGVtLmZpcnN0Q2hpbGQsXG5cdFx0XHRcdFx0Y29sb3IsXG5cdFx0XHRcdFx0c3Ryb2tlV2lkdGg7XG5cdFx0XHRcdFxuXHRcdFx0XHR0ZXh0U2hhZG93ID0gdGV4dFNoYWRvdy5zcGxpdCgnICcpO1xuXHRcdFx0XHRjb2xvciA9IHRleHRTaGFkb3dbdGV4dFNoYWRvdy5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHQvLyBBcHByb3hpbWF0ZWx5IHR1bmUgdGhlIHNldHRpbmdzIHRvIHRoZSB0ZXh0LXNoYWRvdyBiZWhhdmlvdXJcblx0XHRcdFx0c3Ryb2tlV2lkdGggPSB0ZXh0U2hhZG93W3RleHRTaGFkb3cubGVuZ3RoIC0gMl07XG5cblx0XHRcdFx0aWYgKHN0cm9rZVdpZHRoKSB7XG5cdFx0XHRcdFx0ZWFjaCh0c3BhbnMsIGZ1bmN0aW9uICh0c3BhbiwgeSkge1xuXHRcdFx0XHRcdFx0dmFyIGNsb25lO1xuXG5cdFx0XHRcdFx0XHQvLyBMZXQgdGhlIGZpcnN0IGxpbmUgc3RhcnQgYXQgdGhlIGNvcnJlY3QgWCBwb3NpdGlvblxuXHRcdFx0XHRcdFx0aWYgKHkgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0dHNwYW4uc2V0QXR0cmlidXRlKCd4JywgZWxlbS5nZXRBdHRyaWJ1dGUoJ3gnKSk7XG5cdFx0XHRcdFx0XHRcdHkgPSBlbGVtLmdldEF0dHJpYnV0ZSgneScpO1xuXHRcdFx0XHRcdFx0XHR0c3Bhbi5zZXRBdHRyaWJ1dGUoJ3knLCB5IHx8IDApO1xuXHRcdFx0XHRcdFx0XHRpZiAoeSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCd5JywgMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBjbG9uZSBhbmQgYXBwbHkgc2hhZG93IHByb3BlcnRpZXNcblx0XHRcdFx0XHRcdGNsb25lID0gdHNwYW4uY2xvbmVOb2RlKDEpO1xuXHRcdFx0XHRcdFx0YXR0cihjbG9uZSwge1xuXHRcdFx0XHRcdFx0XHQnY2xhc3MnOiBQUkVGSVggKyAndGV4dC1zaGFkb3cnLFxuXHRcdFx0XHRcdFx0XHQnZmlsbCc6IGNvbG9yLFxuXHRcdFx0XHRcdFx0XHQnc3Ryb2tlJzogY29sb3IsXG5cdFx0XHRcdFx0XHRcdCdzdHJva2Utb3BhY2l0eSc6IDEgLyBtYXRoTWF4KHBJbnQoc3Ryb2tlV2lkdGgpLCAzKSxcblx0XHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoLFxuXHRcdFx0XHRcdFx0XHQnc3Ryb2tlLWxpbmVqb2luJzogJ3JvdW5kJ1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRlbGVtLmluc2VydEJlZm9yZShjbG9uZSwgZmlyc3RDaGlsZCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IG9yIGdldCBhIGdpdmVuIGF0dHJpYnV0ZVxuXHQgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGhhc2hcblx0ICogQHBhcmFtIHtNaXhlZHxVbmRlZmluZWR9IHZhbFxuXHQgKi9cblx0YXR0cjogZnVuY3Rpb24gKGhhc2gsIHZhbCwgY29tcGxldGUpIHtcblx0XHR2YXIga2V5LFxuXHRcdFx0dmFsdWUsXG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0aGFzU2V0U3ltYm9sU2l6ZSxcblx0XHRcdHJldCA9IHRoaXMsXG5cdFx0XHRza2lwQXR0cjtcblxuXHRcdC8vIHNpbmdsZSBrZXktdmFsdWUgcGFpclxuXHRcdGlmICh0eXBlb2YgaGFzaCA9PT0gJ3N0cmluZycgJiYgdmFsICE9PSBVTkRFRklORUQpIHtcblx0XHRcdGtleSA9IGhhc2g7XG5cdFx0XHRoYXNoID0ge307XG5cdFx0XHRoYXNoW2tleV0gPSB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gdXNlZCBhcyBhIGdldHRlcjogZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIHNlY29uZCBpcyB1bmRlZmluZWRcblx0XHRpZiAodHlwZW9mIGhhc2ggPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXQgPSAodGhpc1toYXNoICsgJ0dldHRlciddIHx8IHRoaXMuX2RlZmF1bHRHZXR0ZXIpLmNhbGwodGhpcywgaGFzaCwgZWxlbWVudCk7XG5cdFx0XG5cdFx0Ly8gc2V0dGVyXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Zm9yIChrZXkgaW4gaGFzaCkge1xuXHRcdFx0XHR2YWx1ZSA9IGhhc2hba2V5XTtcblx0XHRcdFx0c2tpcEF0dHIgPSBmYWxzZTtcblxuXG5cblx0XHRcdFx0aWYgKHRoaXMuc3ltYm9sTmFtZSAmJiAvXih4fHl8d2lkdGh8aGVpZ2h0fHJ8c3RhcnR8ZW5kfGlubmVyUnxhbmNob3JYfGFuY2hvclkpLy50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHRpZiAoIWhhc1NldFN5bWJvbFNpemUpIHtcblx0XHRcdFx0XHRcdHRoaXMuc3ltYm9sQXR0cihoYXNoKTtcblx0XHRcdFx0XHRcdGhhc1NldFN5bWJvbFNpemUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRza2lwQXR0ciA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5yb3RhdGlvbiAmJiAoa2V5ID09PSAneCcgfHwga2V5ID09PSAneScpKSB7XG5cdFx0XHRcdFx0dGhpcy5kb1RyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmICghc2tpcEF0dHIpIHtcblx0XHRcdFx0XHQodGhpc1trZXkgKyAnU2V0dGVyJ10gfHwgdGhpcy5fZGVmYXVsdFNldHRlcikuY2FsbCh0aGlzLCB2YWx1ZSwga2V5LCBlbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExldCB0aGUgc2hhZG93IGZvbGxvdyB0aGUgbWFpbiBlbGVtZW50XG5cdFx0XHRcdGlmICh0aGlzLnNoYWRvd3MgJiYgL14od2lkdGh8aGVpZ2h0fHZpc2liaWxpdHl8eHx5fGR8dHJhbnNmb3JtfGN4fGN5fHIpJC8udGVzdChrZXkpKSB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGVTaGFkb3dzKGtleSwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0cmFuc2Zvcm0uIERvIHRoaXMgb3V0c2lkZSB0aGUgbG9vcCB0byBwcmV2ZW50IHJlZHVuZGFudCB1cGRhdGluZyBmb3IgYmF0Y2ggc2V0dGluZ1xuXHRcdFx0Ly8gb2YgYXR0cmlidXRlcy5cblx0XHRcdGlmICh0aGlzLmRvVHJhbnNmb3JtKSB7XG5cdFx0XHRcdHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0XHRcdHRoaXMuZG9UcmFuc2Zvcm0gPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIEluIGFjY29yZGFuY2Ugd2l0aCBhbmltYXRlLCBydW4gYSBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdGlmIChjb21wbGV0ZSkge1xuXHRcdFx0Y29tcGxldGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdHVwZGF0ZVNoYWRvd3M6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0dmFyIHNoYWRvd3MgPSB0aGlzLnNoYWRvd3MsXG5cdFx0XHRpID0gc2hhZG93cy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0c2hhZG93c1tpXS5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdGtleSxcblx0XHRcdFx0a2V5ID09PSAnaGVpZ2h0JyA/XG5cdFx0XHRcdFx0bWF0aE1heCh2YWx1ZSAtIChzaGFkb3dzW2ldLmN1dEhlaWdodCB8fCAwKSwgMCkgOlxuXHRcdFx0XHRcdGtleSA9PT0gJ2QnID8gdGhpcy5kIDogdmFsdWVcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGQgYSBjbGFzcyBuYW1lIHRvIGFuIGVsZW1lbnRcblx0ICovXG5cdGFkZENsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRjdXJyZW50Q2xhc3NOYW1lID0gYXR0cihlbGVtZW50LCAnY2xhc3MnKSB8fCAnJztcblxuXHRcdGlmIChjdXJyZW50Q2xhc3NOYW1lLmluZGV4T2YoY2xhc3NOYW1lKSA9PT0gLTEpIHtcblx0XHRcdGF0dHIoZWxlbWVudCwgJ2NsYXNzJywgY3VycmVudENsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHQvKiBoYXNDbGFzcyBhbmQgcmVtb3ZlQ2xhc3MgYXJlIG5vdCAoeWV0KSBuZWVkZWRcblx0aGFzQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcblx0XHRyZXR1cm4gYXR0cih0aGlzLmVsZW1lbnQsICdjbGFzcycpLmluZGV4T2YoY2xhc3NOYW1lKSAhPT0gLTE7XG5cdH0sXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG5cdFx0YXR0cih0aGlzLmVsZW1lbnQsICdjbGFzcycsIGF0dHIodGhpcy5lbGVtZW50LCAnY2xhc3MnKS5yZXBsYWNlKGNsYXNzTmFtZSwgJycpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0Ki9cblxuXHQvKipcblx0ICogSWYgb25lIG9mIHRoZSBzeW1ib2wgc2l6ZSBhZmZlY3RpbmcgcGFyYW1ldGVycyBhcmUgY2hhbmdlZCxcblx0ICogY2hlY2sgYWxsIHRoZSBvdGhlcnMgb25seSBvbmNlIGZvciBlYWNoIGNhbGwgdG8gYW4gZWxlbWVudCdzXG5cdCAqIC5hdHRyKCkgbWV0aG9kXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoXG5cdCAqL1xuXHRzeW1ib2xBdHRyOiBmdW5jdGlvbiAoaGFzaCkge1xuXHRcdHZhciB3cmFwcGVyID0gdGhpcztcblxuXHRcdGVhY2goWyd4JywgJ3knLCAncicsICdzdGFydCcsICdlbmQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2lubmVyUicsICdhbmNob3JYJywgJ2FuY2hvclknXSwgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0d3JhcHBlcltrZXldID0gcGljayhoYXNoW2tleV0sIHdyYXBwZXJba2V5XSk7XG5cdFx0fSk7XG5cblx0XHR3cmFwcGVyLmF0dHIoe1xuXHRcdFx0ZDogd3JhcHBlci5yZW5kZXJlci5zeW1ib2xzW3dyYXBwZXIuc3ltYm9sTmFtZV0oXG5cdFx0XHRcdHdyYXBwZXIueCxcblx0XHRcdFx0d3JhcHBlci55LFxuXHRcdFx0XHR3cmFwcGVyLndpZHRoLFxuXHRcdFx0XHR3cmFwcGVyLmhlaWdodCxcblx0XHRcdFx0d3JhcHBlclxuXHRcdFx0KVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBcHBseSBhIGNsaXBwaW5nIHBhdGggdG8gdGhpcyBvYmplY3Rcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlkXG5cdCAqL1xuXHRjbGlwOiBmdW5jdGlvbiAoY2xpcFJlY3QpIHtcblx0XHRyZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwUmVjdCA/ICd1cmwoJyArIHRoaXMucmVuZGVyZXIudXJsICsgJyMnICsgY2xpcFJlY3QuaWQgKyAnKScgOiBOT05FKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2FsY3VsYXRlIHRoZSBjb29yZGluYXRlcyBuZWVkZWQgZm9yIGRyYXdpbmcgYSByZWN0YW5nbGUgY3Jpc3BseSBhbmQgcmV0dXJuIHRoZVxuXHQgKiBjYWxjdWxhdGVkIGF0dHJpYnV0ZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0cm9rZVdpZHRoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdCAqL1xuXHRjcmlzcDogZnVuY3Rpb24gKHJlY3QpIHtcblxuXHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdGtleSxcblx0XHRcdGF0dHJpYnMgPSB7fSxcblx0XHRcdG5vcm1hbGl6ZXIsXG5cdFx0XHRzdHJva2VXaWR0aCA9IHJlY3Quc3Ryb2tlV2lkdGggfHwgd3JhcHBlci5zdHJva2VXaWR0aCB8fCAwO1xuXG5cdFx0bm9ybWFsaXplciA9IG1hdGhSb3VuZChzdHJva2VXaWR0aCkgJSAyIC8gMjsgLy8gbWF0aFJvdW5kIGJlY2F1c2Ugc3Ryb2tlV2lkdGggY2FuIHNvbWV0aW1lcyBoYXZlIHJvdW5kb2ZmIGVycm9yc1xuXG5cdFx0Ly8gbm9ybWFsaXplIGZvciBjcmlzcCBlZGdlc1xuXHRcdHJlY3QueCA9IG1hdGhGbG9vcihyZWN0LnggfHwgd3JhcHBlci54IHx8IDApICsgbm9ybWFsaXplcjtcblx0XHRyZWN0LnkgPSBtYXRoRmxvb3IocmVjdC55IHx8IHdyYXBwZXIueSB8fCAwKSArIG5vcm1hbGl6ZXI7XG5cdFx0cmVjdC53aWR0aCA9IG1hdGhGbG9vcigocmVjdC53aWR0aCB8fCB3cmFwcGVyLndpZHRoIHx8IDApIC0gMiAqIG5vcm1hbGl6ZXIpO1xuXHRcdHJlY3QuaGVpZ2h0ID0gbWF0aEZsb29yKChyZWN0LmhlaWdodCB8fCB3cmFwcGVyLmhlaWdodCB8fCAwKSAtIDIgKiBub3JtYWxpemVyKTtcblx0XHRyZWN0LnN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG5cblx0XHRmb3IgKGtleSBpbiByZWN0KSB7XG5cdFx0XHRpZiAod3JhcHBlcltrZXldICE9PSByZWN0W2tleV0pIHsgLy8gb25seSBzZXQgYXR0cmlidXRlIGlmIGNoYW5nZWRcblx0XHRcdFx0d3JhcHBlcltrZXldID0gYXR0cmlic1trZXldID0gcmVjdFtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBhdHRyaWJzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgc3R5bGVzIGZvciB0aGUgZWxlbWVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG5cdCAqL1xuXHRjc3M6IGZ1bmN0aW9uIChzdHlsZXMpIHtcblx0XHR2YXIgZWxlbVdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0b2xkU3R5bGVzID0gZWxlbVdyYXBwZXIuc3R5bGVzLFxuXHRcdFx0bmV3U3R5bGVzID0ge30sXG5cdFx0XHRlbGVtID0gZWxlbVdyYXBwZXIuZWxlbWVudCxcblx0XHRcdHRleHRXaWR0aCxcblx0XHRcdG4sXG5cdFx0XHRzZXJpYWxpemVkQ3NzID0gJycsXG5cdFx0XHRoeXBoZW5hdGUsXG5cdFx0XHRoYXNOZXcgPSAhb2xkU3R5bGVzO1xuXG5cdFx0Ly8gY29udmVydCBsZWdhY3lcblx0XHRpZiAoc3R5bGVzICYmIHN0eWxlcy5jb2xvcikge1xuXHRcdFx0c3R5bGVzLmZpbGwgPSBzdHlsZXMuY29sb3I7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyIG91dCBleGlzdGluZyBzdHlsZXMgdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2UgKCMyNjQwKVxuXHRcdGlmIChvbGRTdHlsZXMpIHtcblx0XHRcdGZvciAobiBpbiBzdHlsZXMpIHtcblx0XHRcdFx0aWYgKHN0eWxlc1tuXSAhPT0gb2xkU3R5bGVzW25dKSB7XG5cdFx0XHRcdFx0bmV3U3R5bGVzW25dID0gc3R5bGVzW25dO1xuXHRcdFx0XHRcdGhhc05ldyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGhhc05ldykge1xuXHRcdFx0dGV4dFdpZHRoID0gZWxlbVdyYXBwZXIudGV4dFdpZHRoID0gXG5cdFx0XHRcdChzdHlsZXMgJiYgc3R5bGVzLndpZHRoICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHQnICYmIHBJbnQoc3R5bGVzLndpZHRoKSkgfHwgXG5cdFx0XHRcdGVsZW1XcmFwcGVyLnRleHRXaWR0aDsgLy8gIzM1MDFcblxuXHRcdFx0Ly8gTWVyZ2UgdGhlIG5ldyBzdHlsZXMgd2l0aCB0aGUgb2xkIG9uZXNcblx0XHRcdGlmIChvbGRTdHlsZXMpIHtcblx0XHRcdFx0c3R5bGVzID0gZXh0ZW5kKFxuXHRcdFx0XHRcdG9sZFN0eWxlcyxcblx0XHRcdFx0XHRuZXdTdHlsZXNcblx0XHRcdFx0KTtcblx0XHRcdH1cdFx0XG5cblx0XHRcdC8vIHN0b3JlIG9iamVjdFxuXHRcdFx0ZWxlbVdyYXBwZXIuc3R5bGVzID0gc3R5bGVzO1xuXG5cdFx0XHRpZiAodGV4dFdpZHRoICYmICh1c2VDYW5WRyB8fCAoIWhhc1NWRyAmJiBlbGVtV3JhcHBlci5yZW5kZXJlci5mb3JFeHBvcnQpKSkge1xuXHRcdFx0XHRkZWxldGUgc3R5bGVzLndpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXJpYWxpemUgYW5kIHNldCBzdHlsZSBhdHRyaWJ1dGVcblx0XHRcdGlmIChpc01TICYmICFoYXNTVkcpIHtcblx0XHRcdFx0Y3NzKGVsZW1XcmFwcGVyLmVsZW1lbnQsIHN0eWxlcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvKmpzbGludCB1bnBhcmFtOiB0cnVlKi9cblx0XHRcdFx0aHlwaGVuYXRlID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuICctJyArIGIudG9Mb3dlckNhc2UoKTsgfTtcblx0XHRcdFx0Lypqc2xpbnQgdW5wYXJhbTogZmFsc2UqL1xuXHRcdFx0XHRmb3IgKG4gaW4gc3R5bGVzKSB7XG5cdFx0XHRcdFx0c2VyaWFsaXplZENzcyArPSBuLnJlcGxhY2UoLyhbQS1aXSkvZywgaHlwaGVuYXRlKSArICc6JyArIHN0eWxlc1tuXSArICc7Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRhdHRyKGVsZW0sICdzdHlsZScsIHNlcmlhbGl6ZWRDc3MpOyAvLyAjMTg4MVxuXHRcdFx0fVxuXG5cblx0XHRcdC8vIHJlLWJ1aWxkIHRleHRcblx0XHRcdGlmICh0ZXh0V2lkdGggJiYgZWxlbVdyYXBwZXIuYWRkZWQpIHtcblx0XHRcdFx0ZWxlbVdyYXBwZXIucmVuZGVyZXIuYnVpbGRUZXh0KGVsZW1XcmFwcGVyKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVdyYXBwZXI7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZCBhbiBldmVudCBsaXN0ZW5lclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcblx0ICovXG5cdG9uOiBmdW5jdGlvbiAoZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG5cdFx0dmFyIHN2Z0VsZW1lbnQgPSB0aGlzLFxuXHRcdFx0ZWxlbWVudCA9IHN2Z0VsZW1lbnQuZWxlbWVudDtcblx0XHRcblx0XHQvLyB0b3VjaFxuXHRcdGlmIChoYXNUb3VjaCAmJiBldmVudFR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdGVsZW1lbnQub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcdFx0XHRcblx0XHRcdFx0c3ZnRWxlbWVudC50b3VjaEV2ZW50RmlyZWQgPSBEYXRlLm5vdygpO1x0XHRcdFx0XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0aGFuZGxlci5jYWxsKGVsZW1lbnQsIGUpO1xuXHRcdFx0fTtcblx0XHRcdGVsZW1lbnQub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdGlmICh1c2VyQWdlbnQuaW5kZXhPZignQW5kcm9pZCcpID09PSAtMSB8fCBEYXRlLm5vdygpIC0gKHN2Z0VsZW1lbnQudG91Y2hFdmVudEZpcmVkIHx8IDApID4gMTEwMCkgeyAvLyAjMjI2OVxuXHRcdFx0XHRcdGhhbmRsZXIuY2FsbChlbGVtZW50LCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcdFx0XHRcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gc2ltcGxlc3QgcG9zc2libGUgZXZlbnQgbW9kZWwgZm9yIGludGVybmFsIHVzZVxuXHRcdFx0ZWxlbWVudFsnb24nICsgZXZlbnRUeXBlXSA9IGhhbmRsZXI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG5lZWRlZCB0byBkcmF3IGEgY29uc2lzdGVudCByYWRpYWwgZ3JhZGllbnQgYWNyb3NzXG5cdCAqIHBpZSBzbGljZXMgcmVnYXJkbGVzcyBvZiBwb3NpdGlvbmluZyBpbnNpZGUgdGhlIGNoYXJ0LiBUaGUgZm9ybWF0IGlzXG5cdCAqIFtjZW50ZXJYLCBjZW50ZXJZLCBkaWFtZXRlcl0gaW4gcGl4ZWxzLlxuXHQgKi9cblx0c2V0UmFkaWFsUmVmZXJlbmNlOiBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcblx0XHR2YXIgZXhpc3RpbmdHcmFkaWVudCA9IHRoaXMucmVuZGVyZXIuZ3JhZGllbnRzW3RoaXMuZWxlbWVudC5ncmFkaWVudF07XG5cblx0XHR0aGlzLmVsZW1lbnQucmFkaWFsUmVmZXJlbmNlID0gY29vcmRpbmF0ZXM7XG5cdFx0XG5cdFx0Ly8gT24gcmVkcmF3aW5nIG9iamVjdHMgd2l0aCBhbiBleGlzdGluZyBncmFkaWVudCwgdGhlIGdyYWRpZW50IG5lZWRzXG5cdFx0Ly8gdG8gYmUgcmVwb3NpdGlvbmVkICgjMzgwMSlcblx0XHRpZiAoZXhpc3RpbmdHcmFkaWVudCAmJiBleGlzdGluZ0dyYWRpZW50LnJhZEF0dHIpIHtcblx0XHRcdGV4aXN0aW5nR3JhZGllbnQuYW5pbWF0ZShcblx0XHRcdFx0dGhpcy5yZW5kZXJlci5nZXRSYWRpYWxBdHRyKFxuXHRcdFx0XHRcdGNvb3JkaW5hdGVzLCBcblx0XHRcdFx0XHRleGlzdGluZ0dyYWRpZW50LnJhZEF0dHJcblx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogTW92ZSBhbiBvYmplY3QgYW5kIGl0cyBjaGlsZHJlbiBieSB4IGFuZCB5IHZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKi9cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmF0dHIoe1xuXHRcdFx0dHJhbnNsYXRlWDogeCxcblx0XHRcdHRyYW5zbGF0ZVk6IHlcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogSW52ZXJ0IGEgZ3JvdXAsIHJvdGF0ZSBhbmQgZmxpcFxuXHQgKi9cblx0aW52ZXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzO1xuXHRcdHdyYXBwZXIuaW52ZXJ0ZWQgPSB0cnVlO1xuXHRcdHdyYXBwZXIudXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0cmV0dXJuIHdyYXBwZXI7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFByaXZhdGUgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBiYXNlZCBvbiBpbnRlcm5hbFxuXHQgKiBwcm9wZXJ0aWVzXG5cdCAqL1xuXHR1cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHR0cmFuc2xhdGVYID0gd3JhcHBlci50cmFuc2xhdGVYIHx8IDAsXG5cdFx0XHR0cmFuc2xhdGVZID0gd3JhcHBlci50cmFuc2xhdGVZIHx8IDAsXG5cdFx0XHRzY2FsZVggPSB3cmFwcGVyLnNjYWxlWCxcblx0XHRcdHNjYWxlWSA9IHdyYXBwZXIuc2NhbGVZLFxuXHRcdFx0aW52ZXJ0ZWQgPSB3cmFwcGVyLmludmVydGVkLFxuXHRcdFx0cm90YXRpb24gPSB3cmFwcGVyLnJvdGF0aW9uLFxuXHRcdFx0ZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdHRyYW5zZm9ybTtcblxuXHRcdC8vIGZsaXBwaW5nIGFmZmVjdHMgdHJhbnNsYXRlIGFzIGFkanVzdG1lbnQgZm9yIGZsaXBwaW5nIGFyb3VuZCB0aGUgZ3JvdXAncyBheGlzXG5cdFx0aWYgKGludmVydGVkKSB7XG5cdFx0XHR0cmFuc2xhdGVYICs9IHdyYXBwZXIuYXR0cignd2lkdGgnKTtcblx0XHRcdHRyYW5zbGF0ZVkgKz0gd3JhcHBlci5hdHRyKCdoZWlnaHQnKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0cmFuc2xhdGUuIE5lYXJseSBhbGwgdHJhbnNmb3JtZWQgZWxlbWVudHMgaGF2ZSB0cmFuc2xhdGlvbiwgc28gaW5zdGVhZFxuXHRcdC8vIG9mIGNoZWNraW5nIGZvciB0cmFuc2xhdGUgPSAwLCBkbyBpdCBhbHdheXMgKCMxNzY3LCAjMTg0NikuXG5cdFx0dHJhbnNmb3JtID0gWyd0cmFuc2xhdGUoJyArIHRyYW5zbGF0ZVggKyAnLCcgKyB0cmFuc2xhdGVZICsgJyknXTtcblxuXHRcdC8vIGFwcGx5IHJvdGF0aW9uXG5cdFx0aWYgKGludmVydGVkKSB7XG5cdFx0XHR0cmFuc2Zvcm0ucHVzaCgncm90YXRlKDkwKSBzY2FsZSgtMSwxKScpO1xuXHRcdH0gZWxzZSBpZiAocm90YXRpb24pIHsgLy8gdGV4dCByb3RhdGlvblxuXHRcdFx0dHJhbnNmb3JtLnB1c2goJ3JvdGF0ZSgnICsgcm90YXRpb24gKyAnICcgKyAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3gnKSB8fCAwKSArICcgJyArIChlbGVtZW50LmdldEF0dHJpYnV0ZSgneScpIHx8IDApICsgJyknKTtcblx0XHRcdFxuXHRcdFx0Ly8gRGVsZXRlIGJCb3ggbWVtbyB3aGVuIHRoZSByb3RhdGlvbiBjaGFuZ2VzXG5cdFx0XHQvL2RlbGV0ZSB3cmFwcGVyLmJCb3g7XG5cdFx0fVxuXG5cdFx0Ly8gYXBwbHkgc2NhbGVcblx0XHRpZiAoZGVmaW5lZChzY2FsZVgpIHx8IGRlZmluZWQoc2NhbGVZKSkge1xuXHRcdFx0dHJhbnNmb3JtLnB1c2goJ3NjYWxlKCcgKyBwaWNrKHNjYWxlWCwgMSkgKyAnICcgKyBwaWNrKHNjYWxlWSwgMSkgKyAnKScpO1xuXHRcdH1cblxuXHRcdGlmICh0cmFuc2Zvcm0ubGVuZ3RoKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgdHJhbnNmb3JtLmpvaW4oJyAnKSk7XG5cdFx0fVxuXHR9LFxuXHQvKipcblx0ICogQnJpbmcgdGhlIGVsZW1lbnQgdG8gdGhlIGZyb250XG5cdCAqL1xuXHR0b0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0ZWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cblx0LyoqXG5cdCAqIEJyZWFrIGRvd24gYWxpZ25tZW50IG9wdGlvbnMgbGlrZSBhbGlnbiwgdmVydGljYWxBbGlnbiwgeCBhbmQgeVxuXHQgKiB0byB4IGFuZCB5IHJlbGF0aXZlIHRvIHRoZSBjaGFydC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGFsaWduT3B0aW9uc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFsaWduQnlUcmFuc2xhdGVcblx0ICogQHBhcmFtIHtTdHJpbmdbT2JqZWN0fSBib3ggVGhlIGJveCB0byBhbGlnbiB0bywgbmVlZHMgYSB3aWR0aCBhbmQgaGVpZ2h0LiBXaGVuIHRoZVxuXHQgKlx0XHRib3ggaXMgYSBzdHJpbmcsIGl0IHJlZmVycyB0byBhbiBvYmplY3QgaW4gdGhlIFJlbmRlcmVyLiBGb3IgZXhhbXBsZSwgd2hlblxuXHQgKlx0XHRib3ggaXMgJ3NwYWNpbmdCb3gnLCBpdCByZWZlcnMgdG8gUmVuZGVyZXIuc3BhY2luZ0JveCB3aGljaCBob2xkcyB3aWR0aCwgaGVpZ2h0XG5cdCAqXHRcdHggYW5kIHkgcHJvcGVydGllcy5cblx0ICpcblx0ICovXG5cdGFsaWduOiBmdW5jdGlvbiAoYWxpZ25PcHRpb25zLCBhbGlnbkJ5VHJhbnNsYXRlLCBib3gpIHtcblx0XHR2YXIgYWxpZ24sXG5cdFx0XHR2QWxpZ24sXG5cdFx0XHR4LFxuXHRcdFx0eSxcblx0XHRcdGF0dHJpYnMgPSB7fSxcblx0XHRcdGFsaWduVG8sXG5cdFx0XHRyZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG5cdFx0XHRhbGlnbmVkT2JqZWN0cyA9IHJlbmRlcmVyLmFsaWduZWRPYmplY3RzO1xuXG5cdFx0Ly8gRmlyc3QgY2FsbCBvbiBpbnN0YW5jaWF0ZVxuXHRcdGlmIChhbGlnbk9wdGlvbnMpIHtcblx0XHRcdHRoaXMuYWxpZ25PcHRpb25zID0gYWxpZ25PcHRpb25zO1xuXHRcdFx0dGhpcy5hbGlnbkJ5VHJhbnNsYXRlID0gYWxpZ25CeVRyYW5zbGF0ZTtcblx0XHRcdGlmICghYm94IHx8IGlzU3RyaW5nKGJveCkpIHsgLy8gYm94ZXMgb3RoZXIgdGhhbiByZW5kZXJlciBoYW5kbGUgdGhpcyBpbnRlcm5hbGx5XG5cdFx0XHRcdHRoaXMuYWxpZ25UbyA9IGFsaWduVG8gPSBib3ggfHwgJ3JlbmRlcmVyJztcblx0XHRcdFx0ZXJhc2UoYWxpZ25lZE9iamVjdHMsIHRoaXMpOyAvLyBwcmV2ZW50IGR1cGxpY2F0ZXMsIGxpa2UgbGVnZW5kR3JvdXAgYWZ0ZXIgcmVzaXplXG5cdFx0XHRcdGFsaWduZWRPYmplY3RzLnB1c2godGhpcyk7XG5cdFx0XHRcdGJveCA9IG51bGw7IC8vIHJlYXNzaWduIGl0IGJlbG93XG5cdFx0XHR9XG5cblx0XHQvLyBXaGVuIGNhbGxlZCBvbiByZXNpemUsIG5vIGFyZ3VtZW50cyBhcmUgc3VwcGxpZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0YWxpZ25PcHRpb25zID0gdGhpcy5hbGlnbk9wdGlvbnM7XG5cdFx0XHRhbGlnbkJ5VHJhbnNsYXRlID0gdGhpcy5hbGlnbkJ5VHJhbnNsYXRlO1xuXHRcdFx0YWxpZ25UbyA9IHRoaXMuYWxpZ25Ubztcblx0XHR9XG5cblx0XHRib3ggPSBwaWNrKGJveCwgcmVuZGVyZXJbYWxpZ25Ub10sIHJlbmRlcmVyKTtcblxuXHRcdC8vIEFzc2lnbiB2YXJpYWJsZXNcblx0XHRhbGlnbiA9IGFsaWduT3B0aW9ucy5hbGlnbjtcblx0XHR2QWxpZ24gPSBhbGlnbk9wdGlvbnMudmVydGljYWxBbGlnbjtcblx0XHR4ID0gKGJveC54IHx8IDApICsgKGFsaWduT3B0aW9ucy54IHx8IDApOyAvLyBkZWZhdWx0OiBsZWZ0IGFsaWduXG5cdFx0eSA9IChib3gueSB8fCAwKSArIChhbGlnbk9wdGlvbnMueSB8fCAwKTsgLy8gZGVmYXVsdDogdG9wIGFsaWduXG5cblx0XHQvLyBBbGlnblxuXHRcdGlmIChhbGlnbiA9PT0gJ3JpZ2h0JyB8fCBhbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHggKz0gKGJveC53aWR0aCAtIChhbGlnbk9wdGlvbnMud2lkdGggfHwgMCkpIC9cblx0XHRcdFx0XHR7IHJpZ2h0OiAxLCBjZW50ZXI6IDIgfVthbGlnbl07XG5cdFx0fVxuXHRcdGF0dHJpYnNbYWxpZ25CeVRyYW5zbGF0ZSA/ICd0cmFuc2xhdGVYJyA6ICd4J10gPSBtYXRoUm91bmQoeCk7XG5cblxuXHRcdC8vIFZlcnRpY2FsIGFsaWduXG5cdFx0aWYgKHZBbGlnbiA9PT0gJ2JvdHRvbScgfHwgdkFsaWduID09PSAnbWlkZGxlJykge1xuXHRcdFx0eSArPSAoYm94LmhlaWdodCAtIChhbGlnbk9wdGlvbnMuaGVpZ2h0IHx8IDApKSAvXG5cdFx0XHRcdFx0KHsgYm90dG9tOiAxLCBtaWRkbGU6IDIgfVt2QWxpZ25dIHx8IDEpO1xuXG5cdFx0fVxuXHRcdGF0dHJpYnNbYWxpZ25CeVRyYW5zbGF0ZSA/ICd0cmFuc2xhdGVZJyA6ICd5J10gPSBtYXRoUm91bmQoeSk7XG5cblx0XHQvLyBBbmltYXRlIG9ubHkgaWYgYWxyZWFkeSBwbGFjZWRcblx0XHR0aGlzW3RoaXMucGxhY2VkID8gJ2FuaW1hdGUnIDogJ2F0dHInXShhdHRyaWJzKTtcblx0XHR0aGlzLnBsYWNlZCA9IHRydWU7XG5cdFx0dGhpcy5hbGlnbkF0dHIgPSBhdHRyaWJzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgYm91bmRpbmcgYm94ICh3aWR0aCwgaGVpZ2h0LCB4IGFuZCB5KSBmb3IgdGhlIGVsZW1lbnRcblx0ICovXG5cdGdldEJCb3g6IGZ1bmN0aW9uIChyZWxvYWQpIHtcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRiQm94LC8vID0gd3JhcHBlci5iQm94LFxuXHRcdFx0cmVuZGVyZXIgPSB3cmFwcGVyLnJlbmRlcmVyLFxuXHRcdFx0d2lkdGgsXG5cdFx0XHRoZWlnaHQsXG5cdFx0XHRyb3RhdGlvbiA9IHdyYXBwZXIucm90YXRpb24sXG5cdFx0XHRlbGVtZW50ID0gd3JhcHBlci5lbGVtZW50LFxuXHRcdFx0c3R5bGVzID0gd3JhcHBlci5zdHlsZXMsXG5cdFx0XHRyYWQgPSByb3RhdGlvbiAqIGRlZzJyYWQsXG5cdFx0XHR0ZXh0U3RyID0gd3JhcHBlci50ZXh0U3RyLFxuXHRcdFx0dGV4dFNoYWRvdyxcblx0XHRcdGVsZW1TdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG5cdFx0XHR0b2dnbGVUZXh0U2hhZG93U2hpbSxcblx0XHRcdGNhY2hlS2V5O1xuXG5cdFx0aWYgKHRleHRTdHIgIT09IFVOREVGSU5FRCkge1xuXG5cdFx0XHQvLyBQcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IGJvdW5kaW5nIGJveFxuXHRcdFx0Y2FjaGVLZXkgPSBbJycsIHJvdGF0aW9uIHx8IDAsIHN0eWxlcyAmJiBzdHlsZXMuZm9udFNpemUsIGVsZW1lbnQuc3R5bGUud2lkdGhdLmpvaW4oJywnKTtcblxuXHRcdFx0Ly8gU2luY2UgbnVtYmVycyBhcmUgbW9ub3NwYWNlZCwgYW5kIG51bWVyaWNhbCBsYWJlbHMgYXBwZWFyIGEgbG90IGluIGEgY2hhcnQsXG5cdFx0XHQvLyB3ZSBhc3N1bWUgdGhhdCBhIGxhYmVsIG9mIG4gY2hhcmFjdGVycyBoYXMgdGhlIHNhbWUgYm91bmRpbmcgYm94IGFzIG90aGVycyBcblx0XHRcdC8vIG9mIHRoZSBzYW1lIGxlbmd0aC5cblx0XHRcdGlmICh0ZXh0U3RyID09PSAnJyB8fCBudW1SZWdleC50ZXN0KHRleHRTdHIpKSB7XG5cdFx0XHRcdGNhY2hlS2V5ID0gJ251bTonICsgdGV4dFN0ci50b1N0cmluZygpLmxlbmd0aCArIGNhY2hlS2V5O1xuXG5cdFx0XHQvLyBDYWNoaW5nIGFsbCBzdHJpbmdzIHJlZHVjZXMgcmVuZGVyaW5nIHRpbWUgYnkgNC01JS5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhY2hlS2V5ID0gdGV4dFN0ciArIGNhY2hlS2V5O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjYWNoZUtleSAmJiAhcmVsb2FkKSB7XG5cdFx0XHRiQm94ID0gcmVuZGVyZXIuY2FjaGVbY2FjaGVLZXldO1xuXHRcdH1cblxuXHRcdC8vIE5vIGNhY2hlIGZvdW5kXG5cdFx0aWYgKCFiQm94KSB7XG5cblx0XHRcdC8vIFNWRyBlbGVtZW50c1xuXHRcdFx0aWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTlMgfHwgcmVuZGVyZXIuZm9yRXhwb3J0KSB7XG5cdFx0XHRcdHRyeSB7IC8vIEZhaWxzIGluIEZpcmVmb3ggaWYgdGhlIGNvbnRhaW5lciBoYXMgZGlzcGxheTogbm9uZS5cblxuXHRcdFx0XHRcdC8vIFdoZW4gdGhlIHRleHQgc2hhZG93IHNoaW0gaXMgdXNlZCwgd2UgbmVlZCB0byBoaWRlIHRoZSBmYWtlIHNoYWRvd3Ncblx0XHRcdFx0XHQvLyB0byBnZXQgdGhlIGNvcnJlY3QgYm91bmRpbmcgYm94ICgjMzg3Milcblx0XHRcdFx0XHR0b2dnbGVUZXh0U2hhZG93U2hpbSA9IHRoaXMuZmFrZVRTICYmIGZ1bmN0aW9uIChkaXNwbGF5KSB7XG5cdFx0XHRcdFx0XHRlYWNoKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLicgKyBQUkVGSVggKyAndGV4dC1zaGFkb3cnKSwgZnVuY3Rpb24gKHRzcGFuKSB7XG5cdFx0XHRcdFx0XHRcdHRzcGFuLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIFdvcmthcm91bmQgZm9yICMzODQyLCBGaXJlZm94IHJlcG9ydGluZyB3cm9uZyBib3VuZGluZyBib3ggZm9yIHNoYWRvd3Ncblx0XHRcdFx0XHRpZiAoaXNGaXJlZm94ICYmIGVsZW1TdHlsZS50ZXh0U2hhZG93KSB7XG5cdFx0XHRcdFx0XHR0ZXh0U2hhZG93ID0gZWxlbVN0eWxlLnRleHRTaGFkb3c7XG5cdFx0XHRcdFx0XHRlbGVtU3R5bGUudGV4dFNoYWRvdyA9ICcnO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodG9nZ2xlVGV4dFNoYWRvd1NoaW0pIHtcblx0XHRcdFx0XHRcdHRvZ2dsZVRleHRTaGFkb3dTaGltKE5PTkUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJCb3ggPSBlbGVtZW50LmdldEJCb3ggP1xuXHRcdFx0XHRcdFx0Ly8gU1ZHOiB1c2UgZXh0ZW5kIGJlY2F1c2UgSUU5IGlzIG5vdCBhbGxvd2VkIHRvIGNoYW5nZSB3aWR0aCBhbmQgaGVpZ2h0IGluIGNhc2Vcblx0XHRcdFx0XHRcdC8vIG9mIHJvdGF0aW9uIChiZWxvdylcblx0XHRcdFx0XHRcdGV4dGVuZCh7fSwgZWxlbWVudC5nZXRCQm94KCkpIDpcblx0XHRcdFx0XHRcdC8vIENhbnZhcyByZW5kZXJlciBhbmQgbGVnYWN5IElFIGluIGV4cG9ydCBtb2RlXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Ly8gIzM4NDJcblx0XHRcdFx0XHRpZiAodGV4dFNoYWRvdykge1xuXHRcdFx0XHRcdFx0ZWxlbVN0eWxlLnRleHRTaGFkb3cgPSB0ZXh0U2hhZG93O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodG9nZ2xlVGV4dFNoYWRvd1NoaW0pIHtcblx0XHRcdFx0XHRcdHRvZ2dsZVRleHRTaGFkb3dTaGltKCcnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGJCb3ggaXMgbm90IHNldCwgdGhlIHRyeS1jYXRjaCBibG9jayBhYm92ZSBmYWlsZWQuIFRoZSBvdGhlciBjb25kaXRpb25cblx0XHRcdFx0Ly8gaXMgZm9yIE9wZXJhIHRoYXQgcmV0dXJucyBhIHdpZHRoIG9mIC1JbmZpbml0eSBvbiBoaWRkZW4gZWxlbWVudHMuXG5cdFx0XHRcdGlmICghYkJveCB8fCBiQm94LndpZHRoIDwgMCkge1xuXHRcdFx0XHRcdGJCb3ggPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdC8vIFZNTCBSZW5kZXJlciBvciB1c2VIVE1MIHdpdGhpbiBTVkdcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YkJveCA9IHdyYXBwZXIuaHRtbEdldEJCb3goKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcnVlIFNWRyBlbGVtZW50cyBhcyB3ZWxsIGFzIEhUTUwgZWxlbWVudHMgaW4gbW9kZXJuIGJyb3dzZXJzIHVzaW5nIHRoZSAudXNlSFRNTCBvcHRpb25cblx0XHRcdC8vIG5lZWQgdG8gY29tcGVuc2F0ZWQgZm9yIHJvdGF0aW9uXG5cdFx0XHRpZiAocmVuZGVyZXIuaXNTVkcpIHtcblx0XHRcdFx0d2lkdGggPSBiQm94LndpZHRoO1xuXHRcdFx0XHRoZWlnaHQgPSBiQm94LmhlaWdodDtcblxuXHRcdFx0XHQvLyBXb3JrYXJvdW5kIGZvciB3cm9uZyBib3VuZGluZyBib3ggaW4gSUU5IGFuZCBJRTEwICgjMTEwMSwgIzE1MDUsICMxNjY5LCAjMjU2OClcblx0XHRcdFx0aWYgKGlzTVMgJiYgc3R5bGVzICYmIHN0eWxlcy5mb250U2l6ZSA9PT0gJzExcHgnICYmIGhlaWdodC50b1ByZWNpc2lvbigzKSA9PT0gJzE2LjknKSB7XG5cdFx0XHRcdFx0YkJveC5oZWlnaHQgPSBoZWlnaHQgPSAxNDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkanVzdCBmb3Igcm90YXRlZCB0ZXh0XG5cdFx0XHRcdGlmIChyb3RhdGlvbikge1xuXHRcdFx0XHRcdGJCb3gud2lkdGggPSBtYXRoQWJzKGhlaWdodCAqIG1hdGhTaW4ocmFkKSkgKyBtYXRoQWJzKHdpZHRoICogbWF0aENvcyhyYWQpKTtcblx0XHRcdFx0XHRiQm94LmhlaWdodCA9IG1hdGhBYnMoaGVpZ2h0ICogbWF0aENvcyhyYWQpKSArIG1hdGhBYnMod2lkdGggKiBtYXRoU2luKHJhZCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhY2hlIGl0XG5cdFx0XHRpZiAoY2FjaGVLZXkpIHtcblx0XHRcdFx0cmVuZGVyZXIuY2FjaGVbY2FjaGVLZXldID0gYkJveDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGJCb3g7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNob3cgdGhlIGVsZW1lbnRcblx0ICovXG5cdHNob3c6IGZ1bmN0aW9uIChpbmhlcml0KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXR0cih7IHZpc2liaWxpdHk6IGluaGVyaXQgPyAnaW5oZXJpdCcgOiBWSVNJQkxFIH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIaWRlIHRoZSBlbGVtZW50XG5cdCAqL1xuXHRoaWRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXR0cih7IHZpc2liaWxpdHk6IEhJRERFTiB9KTtcblx0fSxcblxuXHRmYWRlT3V0OiBmdW5jdGlvbiAoZHVyYXRpb24pIHtcblx0XHR2YXIgZWxlbVdyYXBwZXIgPSB0aGlzO1xuXHRcdGVsZW1XcmFwcGVyLmFuaW1hdGUoe1xuXHRcdFx0b3BhY2l0eTogMFxuXHRcdH0sIHtcblx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbiB8fCAxNTAsXG5cdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRlbGVtV3JhcHBlci5hdHRyKHsgeTogLTk5OTkgfSk7IC8vICMzMDg4LCBhc3N1bWluZyB3ZSdyZSBvbmx5IHVzaW5nIHRoaXMgZm9yIHRvb2x0aXBzXG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZCB0aGUgZWxlbWVudFxuXHQgKiBAcGFyYW0ge09iamVjdHxVbmRlZmluZWR9IHBhcmVudCBDYW4gYmUgYW4gZWxlbWVudCwgYW4gZWxlbWVudCB3cmFwcGVyIG9yIHVuZGVmaW5lZFxuXHQgKlx0dG8gYXBwZW5kIHRoZSBlbGVtZW50IHRvIHRoZSByZW5kZXJlci5ib3guXG5cdCAqL1xuXHRhZGQ6IGZ1bmN0aW9uIChwYXJlbnQpIHtcblxuXHRcdHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0aW5zZXJ0ZWQ7XG5cblx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHR0aGlzLnBhcmVudEdyb3VwID0gcGFyZW50O1xuXHRcdH1cblxuXHRcdC8vIG1hcmsgYXMgaW52ZXJ0ZWRcblx0XHR0aGlzLnBhcmVudEludmVydGVkID0gcGFyZW50ICYmIHBhcmVudC5pbnZlcnRlZDtcblxuXHRcdC8vIGJ1aWxkIGZvcm1hdHRlZCB0ZXh0XG5cdFx0aWYgKHRoaXMudGV4dFN0ciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZW5kZXJlci5idWlsZFRleHQodGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFyayBhcyBhZGRlZFxuXHRcdHRoaXMuYWRkZWQgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgd2UncmUgYWRkaW5nIHRvIHJlbmRlcmVyIHJvb3QsIG9yIG90aGVyIGVsZW1lbnRzIGluIHRoZSBncm91cCBcblx0XHQvLyBoYXZlIGEgeiBpbmRleCwgd2UgbmVlZCB0byBoYW5kbGUgaXRcblx0XHRpZiAoIXBhcmVudCB8fCBwYXJlbnQuaGFuZGxlWiB8fCB0aGlzLnpJbmRleCkge1xuXHRcdFx0aW5zZXJ0ZWQgPSB0aGlzLnpJbmRleFNldHRlcigpO1xuXHRcdH1cblxuXHRcdC8vIElmIHpJbmRleCBpcyBub3QgaGFuZGxlZCwgYXBwZW5kIGF0IHRoZSBlbmRcblx0XHRpZiAoIWluc2VydGVkKSB7XG5cdFx0XHQocGFyZW50ID8gcGFyZW50LmVsZW1lbnQgOiByZW5kZXJlci5ib3gpLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXHRcdH1cblxuXHRcdC8vIGZpcmUgYW4gZXZlbnQgZm9yIGludGVybmFsIGhvb2tzXG5cdFx0aWYgKHRoaXMub25BZGQpIHtcblx0XHRcdHRoaXMub25BZGQoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhIGNoaWxkIGVpdGhlciBieSByZW1vdmVDaGlsZCBvciBtb3ZlIHRvIGdhcmJhZ2VCaW4uXG5cdCAqIElzc3VlIDQ5MDsgaW4gVk1MIHJlbW92ZUNoaWxkIHJlc3VsdHMgaW4gT3JwaGFuZWQgbm9kZXMgYWNjb3JkaW5nIHRvIHNJRXZlLCBkaXNjYXJkRWxlbWVudCBkb2VzIG5vdC5cblx0ICovXG5cdHNhZmVSZW1vdmVDaGlsZDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHR2YXIgcGFyZW50Tm9kZSA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRpZiAocGFyZW50Tm9kZSkge1xuXHRcdFx0cGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3Ryb3kgdGhlIGVsZW1lbnQgYW5kIGVsZW1lbnQgd3JhcHBlclxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQgfHwge30sXG5cdFx0XHRzaGFkb3dzID0gd3JhcHBlci5zaGFkb3dzLFxuXHRcdFx0cGFyZW50VG9DbGVhbiA9IHdyYXBwZXIucmVuZGVyZXIuaXNTVkcgJiYgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ1NQQU4nICYmIHdyYXBwZXIucGFyZW50R3JvdXAsXG5cdFx0XHRncmFuZFBhcmVudCxcblx0XHRcdGtleSxcblx0XHRcdGk7XG5cblx0XHQvLyByZW1vdmUgZXZlbnRzXG5cdFx0ZWxlbWVudC5vbmNsaWNrID0gZWxlbWVudC5vbm1vdXNlb3V0ID0gZWxlbWVudC5vbm1vdXNlb3ZlciA9IGVsZW1lbnQub25tb3VzZW1vdmUgPSBlbGVtZW50LnBvaW50ID0gbnVsbDtcblx0XHRzdG9wKHdyYXBwZXIpOyAvLyBzdG9wIHJ1bm5pbmcgYW5pbWF0aW9uc1xuXG5cdFx0aWYgKHdyYXBwZXIuY2xpcFBhdGgpIHtcblx0XHRcdHdyYXBwZXIuY2xpcFBhdGggPSB3cmFwcGVyLmNsaXBQYXRoLmRlc3Ryb3koKTtcblx0XHR9XG5cblx0XHQvLyBEZXN0cm95IHN0b3BzIGluIGNhc2UgdGhpcyBpcyBhIGdyYWRpZW50IG9iamVjdFxuXHRcdGlmICh3cmFwcGVyLnN0b3BzKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgd3JhcHBlci5zdG9wcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR3cmFwcGVyLnN0b3BzW2ldID0gd3JhcHBlci5zdG9wc1tpXS5kZXN0cm95KCk7XG5cdFx0XHR9XG5cdFx0XHR3cmFwcGVyLnN0b3BzID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyByZW1vdmUgZWxlbWVudFxuXHRcdHdyYXBwZXIuc2FmZVJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuXG5cdFx0Ly8gZGVzdHJveSBzaGFkb3dzXG5cdFx0aWYgKHNoYWRvd3MpIHtcblx0XHRcdGVhY2goc2hhZG93cywgZnVuY3Rpb24gKHNoYWRvdykge1xuXHRcdFx0XHR3cmFwcGVyLnNhZmVSZW1vdmVDaGlsZChzaGFkb3cpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gSW4gY2FzZSBvZiB1c2VIVE1MLCBjbGVhbiB1cCBlbXB0eSBjb250YWluZXJzIGVtdWxhdGluZyBTVkcgZ3JvdXBzICgjMTk2MCwgIzIzOTMsICMyNjk3KS5cblx0XHR3aGlsZSAocGFyZW50VG9DbGVhbiAmJiBwYXJlbnRUb0NsZWFuLmRpdiAmJiBwYXJlbnRUb0NsZWFuLmRpdi5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Z3JhbmRQYXJlbnQgPSBwYXJlbnRUb0NsZWFuLnBhcmVudEdyb3VwO1xuXHRcdFx0d3JhcHBlci5zYWZlUmVtb3ZlQ2hpbGQocGFyZW50VG9DbGVhbi5kaXYpO1xuXHRcdFx0ZGVsZXRlIHBhcmVudFRvQ2xlYW4uZGl2O1xuXHRcdFx0cGFyZW50VG9DbGVhbiA9IGdyYW5kUGFyZW50O1xuXHRcdH1cblxuXHRcdC8vIHJlbW92ZSBmcm9tIGFsaWduT2JqZWN0c1xuXHRcdGlmICh3cmFwcGVyLmFsaWduVG8pIHtcblx0XHRcdGVyYXNlKHdyYXBwZXIucmVuZGVyZXIuYWxpZ25lZE9iamVjdHMsIHdyYXBwZXIpO1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHdyYXBwZXIpIHtcblx0XHRcdGRlbGV0ZSB3cmFwcGVyW2tleV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZCBhIHNoYWRvdyB0byB0aGUgZWxlbWVudC4gTXVzdCBiZSBkb25lIGFmdGVyIHRoZSBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBET01cblx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gc2hhZG93T3B0aW9uc1xuXHQgKi9cblx0c2hhZG93OiBmdW5jdGlvbiAoc2hhZG93T3B0aW9ucywgZ3JvdXAsIGN1dE9mZikge1xuXHRcdHZhciBzaGFkb3dzID0gW10sXG5cdFx0XHRpLFxuXHRcdFx0c2hhZG93LFxuXHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdHN0cm9rZVdpZHRoLFxuXHRcdFx0c2hhZG93V2lkdGgsXG5cdFx0XHRzaGFkb3dFbGVtZW50T3BhY2l0eSxcblxuXHRcdFx0Ly8gY29tcGVuc2F0ZSBmb3IgaW52ZXJ0ZWQgcGxvdCBhcmVhXG5cdFx0XHR0cmFuc2Zvcm07XG5cblxuXHRcdGlmIChzaGFkb3dPcHRpb25zKSB7XG5cdFx0XHRzaGFkb3dXaWR0aCA9IHBpY2soc2hhZG93T3B0aW9ucy53aWR0aCwgMyk7XG5cdFx0XHRzaGFkb3dFbGVtZW50T3BhY2l0eSA9IChzaGFkb3dPcHRpb25zLm9wYWNpdHkgfHwgMC4xNSkgLyBzaGFkb3dXaWR0aDtcblx0XHRcdHRyYW5zZm9ybSA9IHRoaXMucGFyZW50SW52ZXJ0ZWQgP1xuXHRcdFx0XHQnKC0xLC0xKScgOlxuXHRcdFx0XHQnKCcgKyBwaWNrKHNoYWRvd09wdGlvbnMub2Zmc2V0WCwgMSkgKyAnLCAnICsgcGljayhzaGFkb3dPcHRpb25zLm9mZnNldFksIDEpICsgJyknO1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8PSBzaGFkb3dXaWR0aDsgaSsrKSB7XG5cdFx0XHRcdHNoYWRvdyA9IGVsZW1lbnQuY2xvbmVOb2RlKDApO1xuXHRcdFx0XHRzdHJva2VXaWR0aCA9IChzaGFkb3dXaWR0aCAqIDIpICsgMSAtICgyICogaSk7XG5cdFx0XHRcdGF0dHIoc2hhZG93LCB7XG5cdFx0XHRcdFx0J2lzU2hhZG93JzogJ3RydWUnLFxuXHRcdFx0XHRcdCdzdHJva2UnOiBzaGFkb3dPcHRpb25zLmNvbG9yIHx8ICdibGFjaycsXG5cdFx0XHRcdFx0J3N0cm9rZS1vcGFjaXR5Jzogc2hhZG93RWxlbWVudE9wYWNpdHkgKiBpLFxuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBzdHJva2VXaWR0aCxcblx0XHRcdFx0XHQndHJhbnNmb3JtJzogJ3RyYW5zbGF0ZScgKyB0cmFuc2Zvcm0sXG5cdFx0XHRcdFx0J2ZpbGwnOiBOT05FXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoY3V0T2ZmKSB7XG5cdFx0XHRcdFx0YXR0cihzaGFkb3csICdoZWlnaHQnLCBtYXRoTWF4KGF0dHIoc2hhZG93LCAnaGVpZ2h0JykgLSBzdHJva2VXaWR0aCwgMCkpO1xuXHRcdFx0XHRcdHNoYWRvdy5jdXRIZWlnaHQgPSBzdHJva2VXaWR0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChncm91cCkge1xuXHRcdFx0XHRcdGdyb3VwLmVsZW1lbnQuYXBwZW5kQ2hpbGQoc2hhZG93KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNoYWRvdywgZWxlbWVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzaGFkb3dzLnB1c2goc2hhZG93KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zaGFkb3dzID0gc2hhZG93cztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR4R2V0dGVyOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0aWYgKHRoaXMuZWxlbWVudC5ub2RlTmFtZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdGtleSA9IHsgeDogJ2N4JywgeTogJ2N5JyB9W2tleV0gfHwga2V5O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fZGVmYXVsdEdldHRlcihrZXkpO1xuXHR9LFxuXG5cdC8qKiBcblx0ICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvciBwc2V1ZG8gYXR0cmlidXRlLCB1c2VkIG1haW5seVxuXHQgKiBmb3IgYW5pbWF0aW9uLlxuXHQgKi9cblx0X2RlZmF1bHRHZXR0ZXI6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgcmV0ID0gcGljayh0aGlzW2tleV0sIHRoaXMuZWxlbWVudCA/IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoa2V5KSA6IG51bGwsIDApO1xuXG5cdFx0aWYgKC9eW1xcLTAtOVxcLl0rJC8udGVzdChyZXQpKSB7IC8vIGlzIG51bWVyaWNhbFxuXHRcdFx0cmV0ID0gcGFyc2VGbG9hdChyZXQpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cblx0ZFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRpZiAodmFsdWUgJiYgdmFsdWUuam9pbikgeyAvLyBqb2luIHBhdGhcblx0XHRcdHZhbHVlID0gdmFsdWUuam9pbignICcpO1xuXHRcdH1cblx0XHRpZiAoLyhOYU58IHsyfXxeJCkvLnRlc3QodmFsdWUpKSB7XG5cdFx0XHR2YWx1ZSA9ICdNIDAgMCc7XG5cdFx0fVxuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuXG5cdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdH0sXG5cdGRhc2hzdHlsZVNldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dmFyIGk7XG5cdFx0dmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0dmFsdWUgPSB2YWx1ZVxuXHRcdFx0XHQucmVwbGFjZSgnc2hvcnRkYXNoZG90ZG90JywgJzMsMSwxLDEsMSwxLCcpXG5cdFx0XHRcdC5yZXBsYWNlKCdzaG9ydGRhc2hkb3QnLCAnMywxLDEsMScpXG5cdFx0XHRcdC5yZXBsYWNlKCdzaG9ydGRvdCcsICcxLDEsJylcblx0XHRcdFx0LnJlcGxhY2UoJ3Nob3J0ZGFzaCcsICczLDEsJylcblx0XHRcdFx0LnJlcGxhY2UoJ2xvbmdkYXNoJywgJzgsMywnKVxuXHRcdFx0XHQucmVwbGFjZSgvZG90L2csICcxLDMsJylcblx0XHRcdFx0LnJlcGxhY2UoJ2Rhc2gnLCAnNCwzLCcpXG5cdFx0XHRcdC5yZXBsYWNlKC8sJC8sICcnKVxuXHRcdFx0XHQuc3BsaXQoJywnKTsgLy8gZW5kaW5nIGNvbW1hXG5cblx0XHRcdGkgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHZhbHVlW2ldID0gcEludCh2YWx1ZVtpXSkgKiB0aGlzWydzdHJva2Utd2lkdGgnXTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gdmFsdWUuam9pbignLCcpXG5cdFx0XHRcdC5yZXBsYWNlKCdOYU4nLCAnbm9uZScpOyAvLyAjMzIyNlxuXHRcdFx0dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIHZhbHVlKTtcblx0XHR9XG5cdH0sXG5cdGFsaWduU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCd0ZXh0LWFuY2hvcicsIHsgbGVmdDogJ3N0YXJ0JywgY2VudGVyOiAnbWlkZGxlJywgcmlnaHQ6ICdlbmQnIH1bdmFsdWVdKTtcblx0fSxcblx0b3BhY2l0eVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHR0aGlzW2tleV0gPSB2YWx1ZTtcblx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcblx0fSxcblx0dGl0bGVTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHZhciB0aXRsZU5vZGUgPSB0aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RpdGxlJylbMF07XG5cdFx0aWYgKCF0aXRsZU5vZGUpIHtcblx0XHRcdHRpdGxlTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCAndGl0bGUnKTtcblx0XHRcdHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aXRsZU5vZGUpO1xuXHRcdH1cblx0XHR0aXRsZU5vZGUuYXBwZW5kQ2hpbGQoXG5cdFx0XHRkb2MuY3JlYXRlVGV4dE5vZGUoXG5cdFx0XHRcdChTdHJpbmcocGljayh2YWx1ZSksICcnKSkucmVwbGFjZSgvPFtePl0qPi9nLCAnJykgLy8gIzMyNzYsICMzODk1XG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblx0dGV4dFNldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlICE9PSB0aGlzLnRleHRTdHIpIHtcblx0XHRcdC8vIERlbGV0ZSBiQm94IG1lbW8gd2hlbiB0aGUgdGV4dCBjaGFuZ2VzXG5cdFx0XHRkZWxldGUgdGhpcy5iQm94O1xuXHRcdFxuXHRcdFx0dGhpcy50ZXh0U3RyID0gdmFsdWU7XG5cdFx0XHRpZiAodGhpcy5hZGRlZCkge1xuXHRcdFx0XHR0aGlzLnJlbmRlcmVyLmJ1aWxkVGV4dCh0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGZpbGxTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUpIHtcblx0XHRcdHRoaXMuY29sb3JHcmFkaWVudCh2YWx1ZSwga2V5LCBlbGVtZW50KTtcblx0XHR9XG5cdH0sXG5cdHZpc2liaWxpdHlTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0Ly8gSUU5LTExIGRvZXNuJ3QgaGFuZGxlIHZpc2liaWx0eTppbmhlcml0IHdlbGwsIHNvIHdlIHJlbW92ZSB0aGUgYXR0cmlidXRlIGluc3RlYWQgKCMyODgxLCAjMzkwOSlcblx0XHRpZiAodmFsdWUgPT09ICdpbmhlcml0Jykge1xuXHRcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG5cdFx0fVxuXHR9LFxuXHR6SW5kZXhTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcixcblx0XHRcdHBhcmVudEdyb3VwID0gdGhpcy5wYXJlbnRHcm91cCxcblx0XHRcdHBhcmVudFdyYXBwZXIgPSBwYXJlbnRHcm91cCB8fCByZW5kZXJlcixcblx0XHRcdHBhcmVudE5vZGUgPSBwYXJlbnRXcmFwcGVyLmVsZW1lbnQgfHwgcmVuZGVyZXIuYm94LFxuXHRcdFx0Y2hpbGROb2Rlcyxcblx0XHRcdG90aGVyRWxlbWVudCxcblx0XHRcdG90aGVyWkluZGV4LFxuXHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdGluc2VydGVkLFxuXHRcdFx0cnVuID0gdGhpcy5hZGRlZCxcblx0XHRcdGk7XG5cdFx0XG5cdFx0aWYgKGRlZmluZWQodmFsdWUpKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTsgLy8gU28gd2UgY2FuIHJlYWQgaXQgZm9yIG90aGVyIGVsZW1lbnRzIGluIHRoZSBncm91cFxuXHRcdFx0dmFsdWUgPSArdmFsdWU7XG5cdFx0XHRpZiAodGhpc1trZXldID09PSB2YWx1ZSkgeyAvLyBPbmx5IHVwZGF0ZSB3aGVuIG5lZWRlZCAoIzM4NjUpXG5cdFx0XHRcdHJ1biA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0Ly8gSW5zZXJ0IGFjY29yZGluZyB0byB0aGlzIGFuZCBvdGhlciBlbGVtZW50cycgekluZGV4LiBCZWZvcmUgLmFkZCgpIGlzIGNhbGxlZCxcblx0XHQvLyBub3RoaW5nIGlzIGRvbmUuIFRoZW4gb24gYWRkLCBvciBieSBsYXRlciBjYWxscyB0byB6SW5kZXhTZXR0ZXIsIHRoZSBub2RlXG5cdFx0Ly8gaXMgcGxhY2VkIG9uIHRoZSByaWdodCBwbGFjZSBpbiB0aGUgRE9NLlxuXHRcdGlmIChydW4pIHtcblx0XHRcdHZhbHVlID0gdGhpcy56SW5kZXg7XG5cblx0XHRcdGlmICh2YWx1ZSAmJiBwYXJlbnRHcm91cCkge1xuXHRcdFx0XHRwYXJlbnRHcm91cC5oYW5kbGVaID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGNoaWxkTm9kZXMgPSBwYXJlbnROb2RlLmNoaWxkTm9kZXM7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGggJiYgIWluc2VydGVkOyBpKyspIHtcblx0XHRcdFx0b3RoZXJFbGVtZW50ID0gY2hpbGROb2Rlc1tpXTtcblx0XHRcdFx0b3RoZXJaSW5kZXggPSBhdHRyKG90aGVyRWxlbWVudCwgJ3pJbmRleCcpO1xuXHRcdFx0XHRpZiAob3RoZXJFbGVtZW50ICE9PSBlbGVtZW50ICYmIChcblx0XHRcdFx0XHRcdC8vIEluc2VydCBiZWZvcmUgdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCBhIGhpZ2hlciB6SW5kZXhcblx0XHRcdFx0XHRcdHBJbnQob3RoZXJaSW5kZXgpID4gdmFsdWUgfHxcblx0XHRcdFx0XHRcdC8vIElmIG5vIHpJbmRleCBnaXZlbiwgaW5zZXJ0IGJlZm9yZSB0aGUgZmlyc3QgZWxlbWVudCB3aXRoIGEgekluZGV4XG5cdFx0XHRcdFx0XHQoIWRlZmluZWQodmFsdWUpICYmIGRlZmluZWQob3RoZXJaSW5kZXgpKVxuXG5cdFx0XHRcdFx0XHQpKSB7XG5cdFx0XHRcdFx0cGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgb3RoZXJFbGVtZW50KTtcblx0XHRcdFx0XHRpbnNlcnRlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghaW5zZXJ0ZWQpIHtcblx0XHRcdFx0cGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGluc2VydGVkO1xuXHR9LFxuXHRfZGVmYXVsdFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcblx0fVxufTtcblxuLy8gU29tZSBzaGFyZWQgc2V0dGVycyBhbmQgZ2V0dGVyc1xuU1ZHRWxlbWVudC5wcm90b3R5cGUueUdldHRlciA9IFNWR0VsZW1lbnQucHJvdG90eXBlLnhHZXR0ZXI7XG5TVkdFbGVtZW50LnByb3RvdHlwZS50cmFuc2xhdGVYU2V0dGVyID0gU1ZHRWxlbWVudC5wcm90b3R5cGUudHJhbnNsYXRlWVNldHRlciA9IFxuXHRcdFNWR0VsZW1lbnQucHJvdG90eXBlLnJvdGF0aW9uU2V0dGVyID0gU1ZHRWxlbWVudC5wcm90b3R5cGUudmVydGljYWxBbGlnblNldHRlciA9IFxuXHRcdFNWR0VsZW1lbnQucHJvdG90eXBlLnNjYWxlWFNldHRlciA9IFNWR0VsZW1lbnQucHJvdG90eXBlLnNjYWxlWVNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdHRoaXNba2V5XSA9IHZhbHVlO1xuXHR0aGlzLmRvVHJhbnNmb3JtID0gdHJ1ZTtcbn07XG5cbi8vIFdlYktpdCBhbmQgQmF0aWsgaGF2ZSBwcm9ibGVtcyB3aXRoIGEgc3Ryb2tlLXdpZHRoIG9mIHplcm8sIHNvIGluIHRoaXMgY2FzZSB3ZSByZW1vdmUgdGhlIFxuLy8gc3Ryb2tlIGF0dHJpYnV0ZSBhbHRvZ2V0aGVyLiAjMTI3MCwgIzEzNjksICMzMDY1LCAjMzA3Mi5cblNWR0VsZW1lbnQucHJvdG90eXBlWydzdHJva2Utd2lkdGhTZXR0ZXInXSA9IFNWR0VsZW1lbnQucHJvdG90eXBlLnN0cm9rZVNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdHRoaXNba2V5XSA9IHZhbHVlO1xuXHQvLyBPbmx5IGFwcGx5IHRoZSBzdHJva2UgYXR0cmlidXRlIGlmIHRoZSBzdHJva2Ugd2lkdGggaXMgZGVmaW5lZCBhbmQgbGFyZ2VyIHRoYW4gMFxuXHRpZiAodGhpcy5zdHJva2UgJiYgdGhpc1snc3Ryb2tlLXdpZHRoJ10pIHtcblx0XHR0aGlzLnN0cm9rZVdpZHRoID0gdGhpc1snc3Ryb2tlLXdpZHRoJ107XG5cdFx0U1ZHRWxlbWVudC5wcm90b3R5cGUuZmlsbFNldHRlci5jYWxsKHRoaXMsIHRoaXMuc3Ryb2tlLCAnc3Ryb2tlJywgZWxlbWVudCk7IC8vIHVzZSBwcm90b3R5cGUgYXMgaW5zdGFuY2UgbWF5IGJlIG92ZXJyaWRkZW5cblx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgdGhpc1snc3Ryb2tlLXdpZHRoJ10pO1xuXHRcdHRoaXMuaGFzU3Ryb2tlID0gdHJ1ZTtcblx0fSBlbHNlIGlmIChrZXkgPT09ICdzdHJva2Utd2lkdGgnICYmIHZhbHVlID09PSAwICYmIHRoaXMuaGFzU3Ryb2tlKSB7XG5cdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZScpO1xuXHRcdHRoaXMuaGFzU3Ryb2tlID0gZmFsc2U7XG5cdH1cbn07XG5cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBTVkcgcmVuZGVyZXJcbiAqL1xudmFyIFNWR1JlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5TVkdSZW5kZXJlci5wcm90b3R5cGUgPSB7XG5cdEVsZW1lbnQ6IFNWR0VsZW1lbnQsXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIFNWR1JlbmRlcmVyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0ICogQHBhcmFtIHtCb29sZWFufSBmb3JFeHBvcnRcblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uIChjb250YWluZXIsIHdpZHRoLCBoZWlnaHQsIHN0eWxlLCBmb3JFeHBvcnQsIGFsbG93SFRNTCkge1xuXHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRsb2MgPSBsb2NhdGlvbixcblx0XHRcdGJveFdyYXBwZXIsXG5cdFx0XHRlbGVtZW50LFxuXHRcdFx0ZGVzYztcblxuXHRcdGJveFdyYXBwZXIgPSByZW5kZXJlci5jcmVhdGVFbGVtZW50KCdzdmcnKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHR2ZXJzaW9uOiAnMS4xJ1xuXHRcdFx0fSlcblx0XHRcdC5jc3ModGhpcy5nZXRTdHlsZShzdHlsZSkpO1xuXHRcdGVsZW1lbnQgPSBib3hXcmFwcGVyLmVsZW1lbnQ7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG5cdFx0Ly8gRm9yIGJyb3dzZXJzIG90aGVyIHRoYW4gSUUsIGFkZCB0aGUgbmFtZXNwYWNlIGF0dHJpYnV0ZSAoIzE5NzgpXG5cdFx0aWYgKGNvbnRhaW5lci5pbm5lckhUTUwuaW5kZXhPZigneG1sbnMnKSA9PT0gLTEpIHtcblx0XHRcdGF0dHIoZWxlbWVudCwgJ3htbG5zJywgU1ZHX05TKTtcblx0XHR9XG5cblx0XHQvLyBvYmplY3QgcHJvcGVydGllc1xuXHRcdHJlbmRlcmVyLmlzU1ZHID0gdHJ1ZTtcblx0XHRyZW5kZXJlci5ib3ggPSBlbGVtZW50O1xuXHRcdHJlbmRlcmVyLmJveFdyYXBwZXIgPSBib3hXcmFwcGVyO1xuXHRcdHJlbmRlcmVyLmFsaWduZWRPYmplY3RzID0gW107XG5cblx0XHQvLyBQYWdlIHVybCB1c2VkIGZvciBpbnRlcm5hbCByZWZlcmVuY2VzLiAjMjQsICM2NzIsICMxMDcwXG5cdFx0cmVuZGVyZXIudXJsID0gKGlzRmlyZWZveCB8fCBpc1dlYktpdCkgJiYgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdiYXNlJykubGVuZ3RoID9cblx0XHRcdGxvYy5ocmVmXG5cdFx0XHRcdC5yZXBsYWNlKC8jLio/JC8sICcnKSAvLyByZW1vdmUgdGhlIGhhc2hcblx0XHRcdFx0LnJlcGxhY2UoLyhbXFwoJ1xcKV0pL2csICdcXFxcJDEnKSAvLyBlc2NhcGUgcGFyYW50aGVzZXMgYW5kIHF1b3Rlc1xuXHRcdFx0XHQucmVwbGFjZSgvIC9nLCAnJTIwJykgOiAvLyByZXBsYWNlIHNwYWNlcyAobmVlZGVkIGZvciBTYWZhcmkgb25seSlcblx0XHRcdCcnO1xuXG5cdFx0Ly8gQWRkIGRlc2NyaXB0aW9uXG5cdFx0ZGVzYyA9IHRoaXMuY3JlYXRlRWxlbWVudCgnZGVzYycpLmFkZCgpO1xuXHRcdGRlc2MuZWxlbWVudC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoJ0NyZWF0ZWQgd2l0aCAnICsgUFJPRFVDVCArICcgJyArIFZFUlNJT04pKTtcblxuXG5cdFx0cmVuZGVyZXIuZGVmcyA9IHRoaXMuY3JlYXRlRWxlbWVudCgnZGVmcycpLmFkZCgpO1xuXHRcdHJlbmRlcmVyLmFsbG93SFRNTCA9IGFsbG93SFRNTDtcblx0XHRyZW5kZXJlci5mb3JFeHBvcnQgPSBmb3JFeHBvcnQ7XG5cdFx0cmVuZGVyZXIuZ3JhZGllbnRzID0ge307IC8vIE9iamVjdCB3aGVyZSBncmFkaWVudCBTdmdFbGVtZW50cyBhcmUgc3RvcmVkXG5cdFx0cmVuZGVyZXIuY2FjaGUgPSB7fTsgLy8gQ2FjaGUgZm9yIG51bWVyaWNhbCBib3VuZGluZyBib3hlc1xuXG5cdFx0cmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCBmYWxzZSk7XG5cblxuXG5cdFx0Ly8gSXNzdWUgMTEwIHdvcmthcm91bmQ6XG5cdFx0Ly8gSW4gRmlyZWZveCwgaWYgYSBkaXYgaXMgcG9zaXRpb25lZCBieSBwZXJjZW50YWdlLCBpdHMgcGl4ZWwgcG9zaXRpb24gbWF5IGxhbmRcblx0XHQvLyBiZXR3ZWVuIHBpeGVscy4gVGhlIGNvbnRhaW5lciBpdHNlbGYgZG9lc24ndCBkaXNwbGF5IHRoaXMsIGJ1dCBhbiBTVkcgZWxlbWVudFxuXHRcdC8vIGluc2lkZSB0aGlzIGNvbnRhaW5lciB3aWxsIGJlIGRyYXduIGF0IHN1YnBpeGVsIHByZWNpc2lvbi4gSW4gb3JkZXIgdG8gZHJhd1xuXHRcdC8vIHNoYXJwIGxpbmVzLCB0aGlzIG11c3QgYmUgY29tcGVuc2F0ZWQgZm9yLiBUaGlzIGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluc2lkZVxuXHRcdC8vIGlmcmFtZXMgdGhvdWdoIChsaWtlIGluIGpzRmlkZGxlKS5cblx0XHR2YXIgc3ViUGl4ZWxGaXgsIHJlY3Q7XG5cdFx0aWYgKGlzRmlyZWZveCAmJiBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG5cdFx0XHRyZW5kZXJlci5zdWJQaXhlbEZpeCA9IHN1YlBpeGVsRml4ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjc3MoY29udGFpbmVyLCB7IGxlZnQ6IDAsIHRvcDogMCB9KTtcblx0XHRcdFx0cmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0Y3NzKGNvbnRhaW5lciwge1xuXHRcdFx0XHRcdGxlZnQ6IChtYXRoQ2VpbChyZWN0LmxlZnQpIC0gcmVjdC5sZWZ0KSArIFBYLFxuXHRcdFx0XHRcdHRvcDogKG1hdGhDZWlsKHJlY3QudG9wKSAtIHJlY3QudG9wKSArIFBYXG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gcnVuIHRoZSBmaXggbm93XG5cdFx0XHRzdWJQaXhlbEZpeCgpO1xuXG5cdFx0XHQvLyBydW4gaXQgb24gcmVzaXplXG5cdFx0XHRhZGRFdmVudCh3aW4sICdyZXNpemUnLCBzdWJQaXhlbEZpeCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0XHRyZXR1cm4gKHRoaXMuc3R5bGUgPSBleHRlbmQoe1xuXHRcdFx0Zm9udEZhbWlseTogJ1wiTHVjaWRhIEdyYW5kZVwiLCBcIkx1Y2lkYSBTYW5zIFVuaWNvZGVcIiwgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZicsIC8vIGRlZmF1bHQgZm9udFxuXHRcdFx0Zm9udFNpemU6ICcxMnB4J1xuXHRcdH0sIHN0eWxlKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERldGVjdCB3aGV0aGVyIHRoZSByZW5kZXJlciBpcyBoaWRkZW4uIFRoaXMgaGFwcGVucyB3aGVuIG9uZSBvZiB0aGUgcGFyZW50IGVsZW1lbnRzXG5cdCAqIGhhcyBkaXNwbGF5OiBub25lLiAjNjA4LlxuXHQgKi9cblx0aXNIaWRkZW46IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuYm94V3JhcHBlci5nZXRCQm94KCkud2lkdGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3Ryb3lzIHRoZSByZW5kZXJlciBhbmQgaXRzIGFsbG9jYXRlZCBtZW1iZXJzLlxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRyZW5kZXJlckRlZnMgPSByZW5kZXJlci5kZWZzO1xuXHRcdHJlbmRlcmVyLmJveCA9IG51bGw7XG5cdFx0cmVuZGVyZXIuYm94V3JhcHBlciA9IHJlbmRlcmVyLmJveFdyYXBwZXIuZGVzdHJveSgpO1xuXG5cdFx0Ly8gQ2FsbCBkZXN0cm95IG9uIGFsbCBncmFkaWVudCBlbGVtZW50c1xuXHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHJlbmRlcmVyLmdyYWRpZW50cyB8fCB7fSk7XG5cdFx0cmVuZGVyZXIuZ3JhZGllbnRzID0gbnVsbDtcblxuXHRcdC8vIERlZnMgYXJlIG51bGwgaW4gVk1MUmVuZGVyZXJcblx0XHQvLyBPdGhlcndpc2UsIGRlc3Ryb3kgdGhlbSBoZXJlLlxuXHRcdGlmIChyZW5kZXJlckRlZnMpIHtcblx0XHRcdHJlbmRlcmVyLmRlZnMgPSByZW5kZXJlckRlZnMuZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBzdWIgcGl4ZWwgZml4IGhhbmRsZXJcblx0XHQvLyBXZSBuZWVkIHRvIGNoZWNrIHRoYXQgdGhlcmUgaXMgYSBoYW5kbGVyLCBvdGhlcndpc2UgYWxsIGZ1bmN0aW9ucyB0aGF0IGFyZSByZWdpc3RlcmVkIGZvciBldmVudCAncmVzaXplJyBhcmUgcmVtb3ZlZFxuXHRcdC8vIFNlZSBpc3N1ZSAjOTgyXG5cdFx0aWYgKHJlbmRlcmVyLnN1YlBpeGVsRml4KSB7XG5cdFx0XHRyZW1vdmVFdmVudCh3aW4sICdyZXNpemUnLCByZW5kZXJlci5zdWJQaXhlbEZpeCk7XG5cdFx0fVxuXG5cdFx0cmVuZGVyZXIuYWxpZ25lZE9iamVjdHMgPSBudWxsO1xuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIHdyYXBwZXIgZm9yIGFuIFNWRyBlbGVtZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlTmFtZVxuXHQgKi9cblx0Y3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG5cdFx0dmFyIHdyYXBwZXIgPSBuZXcgdGhpcy5FbGVtZW50KCk7XG5cdFx0d3JhcHBlci5pbml0KHRoaXMsIG5vZGVOYW1lKTtcblx0XHRyZXR1cm4gd3JhcHBlcjtcblx0fSxcblxuXHQvKipcblx0ICogRHVtbXkgZnVuY3Rpb24gZm9yIHVzZSBpbiBjYW52YXMgcmVuZGVyZXJcblx0ICovXG5cdGRyYXc6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdC8qKlxuXHQgKiBHZXQgY29udmVydGVkIHJhZGlhbCBncmFkaWVudCBhdHRyaWJ1dGVzXG5cdCAqL1xuXHRnZXRSYWRpYWxBdHRyOiBmdW5jdGlvbiAocmFkaWFsUmVmZXJlbmNlLCBncmFkQXR0cikge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjeDogKHJhZGlhbFJlZmVyZW5jZVswXSAtIHJhZGlhbFJlZmVyZW5jZVsyXSAvIDIpICsgZ3JhZEF0dHIuY3ggKiByYWRpYWxSZWZlcmVuY2VbMl0sXG5cdFx0XHRjeTogKHJhZGlhbFJlZmVyZW5jZVsxXSAtIHJhZGlhbFJlZmVyZW5jZVsyXSAvIDIpICsgZ3JhZEF0dHIuY3kgKiByYWRpYWxSZWZlcmVuY2VbMl0sXG5cdFx0XHRyOiBncmFkQXR0ci5yICogcmFkaWFsUmVmZXJlbmNlWzJdXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogUGFyc2UgYSBzaW1wbGUgSFRNTCBzdHJpbmcgaW50byBTVkcgdHNwYW5zXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0ZXh0Tm9kZSBUaGUgcGFyZW50IHRleHQgU1ZHIG5vZGVcblx0ICovXG5cdGJ1aWxkVGV4dDogZnVuY3Rpb24gKHdyYXBwZXIpIHtcblx0XHR2YXIgdGV4dE5vZGUgPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHRyZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRmb3JFeHBvcnQgPSByZW5kZXJlci5mb3JFeHBvcnQsXG5cdFx0XHR0ZXh0U3RyID0gcGljayh3cmFwcGVyLnRleHRTdHIsICcnKS50b1N0cmluZygpLFxuXHRcdFx0aGFzTWFya3VwID0gdGV4dFN0ci5pbmRleE9mKCc8JykgIT09IC0xLFxuXHRcdFx0bGluZXMsXG5cdFx0XHRjaGlsZE5vZGVzID0gdGV4dE5vZGUuY2hpbGROb2Rlcyxcblx0XHRcdHN0eWxlUmVnZXgsXG5cdFx0XHRocmVmUmVnZXgsXG5cdFx0XHRwYXJlbnRYID0gYXR0cih0ZXh0Tm9kZSwgJ3gnKSxcblx0XHRcdHRleHRTdHlsZXMgPSB3cmFwcGVyLnN0eWxlcyxcblx0XHRcdHdpZHRoID0gd3JhcHBlci50ZXh0V2lkdGgsXG5cdFx0XHR0ZXh0TGluZUhlaWdodCA9IHRleHRTdHlsZXMgJiYgdGV4dFN0eWxlcy5saW5lSGVpZ2h0LFxuXHRcdFx0dGV4dFNoYWRvdyA9IHRleHRTdHlsZXMgJiYgdGV4dFN0eWxlcy50ZXh0U2hhZG93LFxuXHRcdFx0ZWxsaXBzaXMgPSB0ZXh0U3R5bGVzICYmIHRleHRTdHlsZXMudGV4dE92ZXJmbG93ID09PSAnZWxsaXBzaXMnLFxuXHRcdFx0aSA9IGNoaWxkTm9kZXMubGVuZ3RoLFxuXHRcdFx0dGVtcFBhcmVudCA9IHdpZHRoICYmICF3cmFwcGVyLmFkZGVkICYmIHRoaXMuYm94LFxuXHRcdFx0Z2V0TGluZUhlaWdodCA9IGZ1bmN0aW9uICh0c3Bhbikge1xuXHRcdFx0XHRyZXR1cm4gdGV4dExpbmVIZWlnaHQgPyBcblx0XHRcdFx0XHRwSW50KHRleHRMaW5lSGVpZ2h0KSA6XG5cdFx0XHRcdFx0cmVuZGVyZXIuZm9udE1ldHJpY3MoXG5cdFx0XHRcdFx0XHQvKHB4fGVtKSQvLnRlc3QodHNwYW4gJiYgdHNwYW4uc3R5bGUuZm9udFNpemUpID9cblx0XHRcdFx0XHRcdFx0dHNwYW4uc3R5bGUuZm9udFNpemUgOlxuXHRcdFx0XHRcdFx0XHQoKHRleHRTdHlsZXMgJiYgdGV4dFN0eWxlcy5mb250U2l6ZSkgfHwgcmVuZGVyZXIuc3R5bGUuZm9udFNpemUgfHwgMTIpLFxuXHRcdFx0XHRcdFx0dHNwYW5cblx0XHRcdFx0XHQpLmg7XG5cdFx0XHR9LFxuXHRcdFx0dW5lc2NhcGVBbmdsZUJyYWNrZXRzID0gZnVuY3Rpb24gKGlucHV0U3RyKSB7XG5cdFx0XHRcdHJldHVybiBpbnB1dFN0ci5yZXBsYWNlKC8mbHQ7L2csICc8JykucmVwbGFjZSgvJmd0Oy9nLCAnPicpO1xuXHRcdFx0fTtcblxuXHRcdC8vLyByZW1vdmUgb2xkIHRleHRcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHR0ZXh0Tm9kZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2ldKTtcblx0XHR9XG5cblx0XHQvLyBTa2lwIHRzcGFucywgYWRkIHRleHQgZGlyZWN0bHkgdG8gdGV4dCBub2RlLiBUaGUgZm9yY2VUU3BhbiBpcyBhIGhvb2sgXG5cdFx0Ly8gdXNlZCBpbiB0ZXh0IG91dGxpbmUgaGFjay5cblx0XHRpZiAoIWhhc01hcmt1cCAmJiAhdGV4dFNoYWRvdyAmJiAhZWxsaXBzaXMgJiYgdGV4dFN0ci5pbmRleE9mKCcgJykgPT09IC0xKSB7XG5cdFx0XHR0ZXh0Tm9kZS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUodW5lc2NhcGVBbmdsZUJyYWNrZXRzKHRleHRTdHIpKSk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHQvLyBDb21wbGV4IHN0cmluZ3MsIGFkZCBtb3JlIGxvZ2ljXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0c3R5bGVSZWdleCA9IC88LipzdHlsZT1cIihbXlwiXSspXCIuKj4vO1xuXHRcdFx0aHJlZlJlZ2V4ID0gLzwuKmhyZWY9XCIoaHR0cFteXCJdKylcIi4qPi87XG5cblx0XHRcdGlmICh0ZW1wUGFyZW50KSB7XG5cdFx0XHRcdHRlbXBQYXJlbnQuYXBwZW5kQ2hpbGQodGV4dE5vZGUpOyAvLyBhdHRhY2ggaXQgdG8gdGhlIERPTSB0byByZWFkIG9mZnNldCB3aWR0aFxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaGFzTWFya3VwKSB7XG5cdFx0XHRcdGxpbmVzID0gdGV4dFN0clxuXHRcdFx0XHRcdC5yZXBsYWNlKC88KGJ8c3Ryb25nKT4vZywgJzxzcGFuIHN0eWxlPVwiZm9udC13ZWlnaHQ6Ym9sZFwiPicpXG5cdFx0XHRcdFx0LnJlcGxhY2UoLzwoaXxlbSk+L2csICc8c3BhbiBzdHlsZT1cImZvbnQtc3R5bGU6aXRhbGljXCI+Jylcblx0XHRcdFx0XHQucmVwbGFjZSgvPGEvZywgJzxzcGFuJylcblx0XHRcdFx0XHQucmVwbGFjZSgvPFxcLyhifHN0cm9uZ3xpfGVtfGEpPi9nLCAnPC9zcGFuPicpXG5cdFx0XHRcdFx0LnNwbGl0KC88YnIuKj8+L2cpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsaW5lcyA9IFt0ZXh0U3RyXTtcblx0XHRcdH1cblxuXG5cdFx0XHQvLyByZW1vdmUgZW1wdHkgbGluZSBhdCBlbmRcblx0XHRcdGlmIChsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSA9PT0gJycpIHtcblx0XHRcdFx0bGluZXMucG9wKCk7XG5cdFx0XHR9XG5cblx0XHRcdFxuXHRcdFx0Ly8gYnVpbGQgdGhlIGxpbmVzXG5cdFx0XHRlYWNoKGxpbmVzLCBmdW5jdGlvbiAobGluZSwgbGluZU5vKSB7XG5cdFx0XHRcdHZhciBzcGFucywgc3Bhbk5vID0gMDtcblxuXHRcdFx0XHRsaW5lID0gbGluZS5yZXBsYWNlKC88c3Bhbi9nLCAnfHx8PHNwYW4nKS5yZXBsYWNlKC88XFwvc3Bhbj4vZywgJzwvc3Bhbj58fHwnKTtcblx0XHRcdFx0c3BhbnMgPSBsaW5lLnNwbGl0KCd8fHwnKTtcblxuXHRcdFx0XHRlYWNoKHNwYW5zLCBmdW5jdGlvbiAoc3Bhbikge1xuXHRcdFx0XHRcdGlmIChzcGFuICE9PSAnJyB8fCBzcGFucy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRcdHZhciBhdHRyaWJ1dGVzID0ge30sXG5cdFx0XHRcdFx0XHRcdHRzcGFuID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsICd0c3BhbicpLFxuXHRcdFx0XHRcdFx0XHRzcGFuU3R5bGU7IC8vICMzOTBcblx0XHRcdFx0XHRcdGlmIChzdHlsZVJlZ2V4LnRlc3Qoc3BhbikpIHtcblx0XHRcdFx0XHRcdFx0c3BhblN0eWxlID0gc3Bhbi5tYXRjaChzdHlsZVJlZ2V4KVsxXS5yZXBsYWNlKC8oO3wgfF4pY29sb3IoWyA6XSkvLCAnJDFmaWxsJDInKTtcblx0XHRcdFx0XHRcdFx0YXR0cih0c3BhbiwgJ3N0eWxlJywgc3BhblN0eWxlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChocmVmUmVnZXgudGVzdChzcGFuKSAmJiAhZm9yRXhwb3J0KSB7IC8vIE5vdCBmb3IgZXhwb3J0IC0gIzE1Mjlcblx0XHRcdFx0XHRcdFx0YXR0cih0c3BhbiwgJ29uY2xpY2snLCAnbG9jYXRpb24uaHJlZj1cXFwiJyArIHNwYW4ubWF0Y2goaHJlZlJlZ2V4KVsxXSArICdcXFwiJyk7XG5cdFx0XHRcdFx0XHRcdGNzcyh0c3BhbiwgeyBjdXJzb3I6ICdwb2ludGVyJyB9KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3BhbiA9IHVuZXNjYXBlQW5nbGVCcmFja2V0cyhzcGFuLnJlcGxhY2UoLzwoLnxcXG4pKj8+L2csICcnKSB8fCAnICcpO1xuXG5cdFx0XHRcdFx0XHQvLyBOZXN0ZWQgdGFncyBhcmVuJ3Qgc3VwcG9ydGVkLCBhbmQgY2F1c2UgY3Jhc2ggaW4gU2FmYXJpICgjMTU5Nilcblx0XHRcdFx0XHRcdGlmIChzcGFuICE9PSAnICcpIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBhZGQgdGhlIHRleHQgbm9kZVxuXHRcdFx0XHRcdFx0XHR0c3Bhbi5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoc3BhbikpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghc3Bhbk5vKSB7IC8vIGZpcnN0IHNwYW4gaW4gYSBsaW5lLCBhbGlnbiBpdCB0byB0aGUgbGVmdFxuXHRcdFx0XHRcdFx0XHRcdGlmIChsaW5lTm8gJiYgcGFyZW50WCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YXR0cmlidXRlcy54ID0gcGFyZW50WDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0YXR0cmlidXRlcy5keCA9IDA7IC8vICMxNlxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gYWRkIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0YXR0cih0c3BhbiwgYXR0cmlidXRlcyk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXBwZW5kIGl0XG5cdFx0XHRcdFx0XHRcdHRleHROb2RlLmFwcGVuZENoaWxkKHRzcGFuKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBmaXJzdCBzcGFuIG9uIHN1YnNlcXVlbnQgbGluZSwgYWRkIHRoZSBsaW5lIGhlaWdodFxuXHRcdFx0XHRcdFx0XHRpZiAoIXNwYW5ObyAmJiBsaW5lTm8pIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIGFsbG93IGdldHRpbmcgdGhlIHJpZ2h0IG9mZnNldCBoZWlnaHQgaW4gZXhwb3J0aW5nIGluIElFXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFoYXNTVkcgJiYgZm9yRXhwb3J0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjc3ModHNwYW4sIHsgZGlzcGxheTogJ2Jsb2NrJyB9KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTZXQgdGhlIGxpbmUgaGVpZ2h0IGJhc2VkIG9uIHRoZSBmb250IHNpemUgb2YgZWl0aGVyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhlIHRleHQgZWxlbWVudCBvciB0aGUgdHNwYW4gZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdGF0dHIoXG5cdFx0XHRcdFx0XHRcdFx0XHR0c3Bhbixcblx0XHRcdFx0XHRcdFx0XHRcdCdkeScsXG5cdFx0XHRcdFx0XHRcdFx0XHRnZXRMaW5lSGVpZ2h0KHRzcGFuKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKmlmICh3aWR0aCkge1xuXHRcdFx0XHRcdFx0XHRcdHJlbmRlcmVyLmJyZWFrVGV4dCh3cmFwcGVyLCB3aWR0aCk7XG5cdFx0XHRcdFx0XHRcdH0qL1xuXG5cdFx0XHRcdFx0XHRcdC8vIENoZWNrIHdpZHRoIGFuZCBhcHBseSBzb2Z0IGJyZWFrcyBvciBlbGxpcHNpc1xuXHRcdFx0XHRcdFx0XHRpZiAod2lkdGgpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgd29yZHMgPSBzcGFuLnJlcGxhY2UoLyhbXlxcXl0pLS9nLCAnJDEtICcpLnNwbGl0KCcgJyksIC8vICMxMjczXG5cdFx0XHRcdFx0XHRcdFx0XHRoYXNXaGl0ZVNwYWNlID0gc3BhbnMubGVuZ3RoID4gMSB8fCBsaW5lTm8gfHwgKHdvcmRzLmxlbmd0aCA+IDEgJiYgdGV4dFN0eWxlcy53aGl0ZVNwYWNlICE9PSAnbm93cmFwJyksXG5cdFx0XHRcdFx0XHRcdFx0XHR0b29Mb25nLFxuXHRcdFx0XHRcdFx0XHRcdFx0d2FzVG9vTG9uZyxcblx0XHRcdFx0XHRcdFx0XHRcdGFjdHVhbFdpZHRoLFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdCA9IFtdLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZHkgPSBnZXRMaW5lSGVpZ2h0KHRzcGFuKSxcblx0XHRcdFx0XHRcdFx0XHRcdHNvZnRMaW5lTm8gPSAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0cm90YXRpb24gPSB3cmFwcGVyLnJvdGF0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdFx0d29yZFN0ciA9IHNwYW4sIC8vIGZvciBlbGxpcHNpc1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3Vyc29yID0gd29yZFN0ci5sZW5ndGgsIC8vIGJpbmFyeSBzZWFyY2ggY3Vyc29yXG5cdFx0XHRcdFx0XHRcdFx0XHRiQm94O1xuXG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKChoYXNXaGl0ZVNwYWNlIHx8IGVsbGlwc2lzKSAmJiAod29yZHMubGVuZ3RoIHx8IHJlc3QubGVuZ3RoKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0d3JhcHBlci5yb3RhdGlvbiA9IDA7IC8vIGRpc2NhcmQgcm90YXRpb24gd2hlbiBjb21wdXRpbmcgYm94XG5cdFx0XHRcdFx0XHRcdFx0XHRiQm94ID0gd3JhcHBlci5nZXRCQm94KHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YWN0dWFsV2lkdGggPSBiQm94LndpZHRoO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBPbGQgSUUgY2Fubm90IG1lYXN1cmUgdGhlIGFjdHVhbFdpZHRoIGZvciBTVkcgZWxlbWVudHMgKCMyMzE0KVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFoYXNTVkcgJiYgcmVuZGVyZXIuZm9yRXhwb3J0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFjdHVhbFdpZHRoID0gcmVuZGVyZXIubWVhc3VyZVNwYW5XaWR0aCh0c3Bhbi5maXJzdENoaWxkLmRhdGEsIHdyYXBwZXIuc3R5bGVzKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0dG9vTG9uZyA9IGFjdHVhbFdpZHRoID4gd2lkdGg7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBlbGxpcHNpcywgZG8gYSBiaW5hcnkgc2VhcmNoIGZvciB0aGUgY29ycmVjdCBzdHJpbmcgbGVuZ3RoXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAod2FzVG9vTG9uZyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHdhc1Rvb0xvbmcgPSB0b29Mb25nOyAvLyBGaXJzdCB0aW1lXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZWxsaXBzaXMgJiYgd2FzVG9vTG9uZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjdXJzb3IgLz0gMjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAod29yZFN0ciA9PT0gJycgfHwgKCF0b29Mb25nICYmIGN1cnNvciA8IDAuNSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3b3JkcyA9IFtdOyAvLyBBbGwgb2ssIGJyZWFrIG91dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICh0b29Mb25nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3YXNUb29Mb25nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0d29yZFN0ciA9IHNwYW4uc3Vic3RyaW5nKDAsIHdvcmRTdHIubGVuZ3RoICsgKHRvb0xvbmcgPyAtMSA6IDEpICogbWF0aENlaWwoY3Vyc29yKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0d29yZHMgPSBbd29yZFN0ciArICh3aWR0aCA+IDMgPyAnXFx1MjAyNicgOiAnJyldO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRzcGFuLnJlbW92ZUNoaWxkKHRzcGFuLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIExvb3BpbmcgZG93biwgdGhpcyBpcyB0aGUgZmlyc3Qgd29yZCBzZXF1ZW5jZSB0aGF0IGlzIG5vdCB0b28gbG9uZyxcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHNvIHdlIGNhbiBtb3ZlIG9uIHRvIGJ1aWxkIHRoZSBuZXh0IGxpbmUuXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCF0b29Mb25nIHx8IHdvcmRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR3b3JkcyA9IHJlc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3QgPSBbXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAod29yZHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c29mdExpbmVObysrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRzcGFuID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsICd0c3BhbicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGF0dHIodHNwYW4sIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGR5OiBkeSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHg6IHBhcmVudFhcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoc3BhblN0eWxlKSB7IC8vICMzOTBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGF0dHIodHNwYW4sICdzdHlsZScsIHNwYW5TdHlsZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRleHROb2RlLmFwcGVuZENoaWxkKHRzcGFuKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoYWN0dWFsV2lkdGggPiB3aWR0aCkgeyAvLyBhIHNpbmdsZSB3b3JkIGlzIHByZXNzaW5nIGl0IG91dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoID0gYWN0dWFsV2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7IC8vIGFwcGVuZCB0byBleGlzdGluZyBsaW5lIHRzcGFuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRzcGFuLnJlbW92ZUNoaWxkKHRzcGFuLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXN0LnVuc2hpZnQod29yZHMucG9wKCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHdvcmRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0c3Bhbi5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUod29yZHMuam9pbignICcpLnJlcGxhY2UoLy0gL2csICctJykpKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHdhc1Rvb0xvbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdyYXBwZXIuYXR0cigndGl0bGUnLCB3cmFwcGVyLnRleHRTdHIpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3cmFwcGVyLnJvdGF0aW9uID0gcm90YXRpb247XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRzcGFuTm8rKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAodGVtcFBhcmVudCkge1xuXHRcdFx0XHR0ZW1wUGFyZW50LnJlbW92ZUNoaWxkKHRleHROb2RlKTsgLy8gYXR0YWNoIGl0IHRvIHRoZSBET00gdG8gcmVhZCBvZmZzZXQgd2lkdGhcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgdGhlIHRleHQgc2hhZG93XG5cdFx0XHRpZiAodGV4dFNoYWRvdyAmJiB3cmFwcGVyLmFwcGx5VGV4dFNoYWRvdykge1xuXHRcdFx0XHR3cmFwcGVyLmFwcGx5VGV4dFNoYWRvdyh0ZXh0U2hhZG93KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0XG5cblx0Lypcblx0YnJlYWtUZXh0OiBmdW5jdGlvbiAod3JhcHBlciwgd2lkdGgpIHtcblx0XHR2YXIgYkJveCA9IHdyYXBwZXIuZ2V0QkJveCgpLFxuXHRcdFx0bm9kZSA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdHRleHRMZW5ndGggPSBub2RlLnRleHRDb250ZW50Lmxlbmd0aCxcblx0XHRcdHBvcyA9IG1hdGhSb3VuZCh3aWR0aCAqIHRleHRMZW5ndGggLyBiQm94LndpZHRoKSwgLy8gdHJ5IHRoaXMgcG9zaXRpb24gZmlyc3QsIGJhc2VkIG9uIGF2ZXJhZ2UgY2hhcmFjdGVyIHdpZHRoXG5cdFx0XHRpbmNyZW1lbnQgPSAwLFxuXHRcdFx0ZmluYWxQb3M7XG5cblx0XHRpZiAoYkJveC53aWR0aCA+IHdpZHRoKSB7XG5cdFx0XHR3aGlsZSAoZmluYWxQb3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0ZXh0TGVuZ3RoID0gbm9kZS5nZXRTdWJTdHJpbmdMZW5ndGgoMCwgcG9zKTtcblxuXHRcdFx0XHRpZiAodGV4dExlbmd0aCA8PSB3aWR0aCkge1xuXHRcdFx0XHRcdGlmIChpbmNyZW1lbnQgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRmaW5hbFBvcyA9IHBvcztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aW5jcmVtZW50ID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGluY3JlbWVudCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0ZmluYWxQb3MgPSBwb3MgLSAxO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpbmNyZW1lbnQgPSAtMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zICs9IGluY3JlbWVudDtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc29sZS5sb2coZmluYWxQb3MsIG5vZGUuZ2V0U3ViU3RyaW5nTGVuZ3RoKDAsIGZpbmFsUG9zKSlcblx0fSxcblx0Ki9cblxuXHQvKiogXG5cdCAqIFJldHVybnMgd2hpdGUgZm9yIGRhcmsgY29sb3JzIGFuZCBibGFjayBmb3IgYnJpZ2h0IGNvbG9yc1xuXHQgKi9cblx0Z2V0Q29udHJhc3Q6IGZ1bmN0aW9uIChjb2xvcikge1xuXHRcdGNvbG9yID0gQ29sb3IoY29sb3IpLnJnYmE7XG5cdFx0cmV0dXJuIGNvbG9yWzBdICsgY29sb3JbMV0gKyBjb2xvclsyXSA+IDM4NCA/ICcjMDAwMDAwJyA6ICcjRkZGRkZGJztcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgYnV0dG9uIHdpdGggcHJlc2V0IHN0YXRlc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuXHQgKiBAcGFyYW0ge09iamVjdH0gbm9ybWFsU3RhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGhvdmVyU3RhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHByZXNzZWRTdGF0ZVxuXHQgKi9cblx0YnV0dG9uOiBmdW5jdGlvbiAodGV4dCwgeCwgeSwgY2FsbGJhY2ssIG5vcm1hbFN0YXRlLCBob3ZlclN0YXRlLCBwcmVzc2VkU3RhdGUsIGRpc2FibGVkU3RhdGUsIHNoYXBlKSB7XG5cdFx0dmFyIGxhYmVsID0gdGhpcy5sYWJlbCh0ZXh0LCB4LCB5LCBzaGFwZSwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgJ2J1dHRvbicpLFxuXHRcdFx0Y3VyU3RhdGUgPSAwLFxuXHRcdFx0c3RhdGVPcHRpb25zLFxuXHRcdFx0c3RhdGVTdHlsZSxcblx0XHRcdG5vcm1hbFN0eWxlLFxuXHRcdFx0aG92ZXJTdHlsZSxcblx0XHRcdHByZXNzZWRTdHlsZSxcblx0XHRcdGRpc2FibGVkU3R5bGUsXG5cdFx0XHR2ZXJ0aWNhbEdyYWRpZW50ID0geyB4MTogMCwgeTE6IDAsIHgyOiAwLCB5MjogMSB9O1xuXG5cdFx0Ly8gTm9ybWFsIHN0YXRlIC0gcHJlcGFyZSB0aGUgYXR0cmlidXRlc1xuXHRcdG5vcm1hbFN0YXRlID0gbWVyZ2Uoe1xuXHRcdFx0J3N0cm9rZS13aWR0aCc6IDEsXG5cdFx0XHRzdHJva2U6ICcjQ0NDQ0NDJyxcblx0XHRcdGZpbGw6IHtcblx0XHRcdFx0bGluZWFyR3JhZGllbnQ6IHZlcnRpY2FsR3JhZGllbnQsXG5cdFx0XHRcdHN0b3BzOiBbXG5cdFx0XHRcdFx0WzAsICcjRkVGRUZFJ10sXG5cdFx0XHRcdFx0WzEsICcjRjZGNkY2J11cblx0XHRcdFx0XVxuXHRcdFx0fSxcblx0XHRcdHI6IDIsXG5cdFx0XHRwYWRkaW5nOiA1LFxuXHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0Y29sb3I6ICdibGFjaydcblx0XHRcdH1cblx0XHR9LCBub3JtYWxTdGF0ZSk7XG5cdFx0bm9ybWFsU3R5bGUgPSBub3JtYWxTdGF0ZS5zdHlsZTtcblx0XHRkZWxldGUgbm9ybWFsU3RhdGUuc3R5bGU7XG5cblx0XHQvLyBIb3ZlciBzdGF0ZVxuXHRcdGhvdmVyU3RhdGUgPSBtZXJnZShub3JtYWxTdGF0ZSwge1xuXHRcdFx0c3Ryb2tlOiAnIzY4QScsXG5cdFx0XHRmaWxsOiB7XG5cdFx0XHRcdGxpbmVhckdyYWRpZW50OiB2ZXJ0aWNhbEdyYWRpZW50LFxuXHRcdFx0XHRzdG9wczogW1xuXHRcdFx0XHRcdFswLCAnI0ZGRiddLFxuXHRcdFx0XHRcdFsxLCAnI0FDRiddXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHR9LCBob3ZlclN0YXRlKTtcblx0XHRob3ZlclN0eWxlID0gaG92ZXJTdGF0ZS5zdHlsZTtcblx0XHRkZWxldGUgaG92ZXJTdGF0ZS5zdHlsZTtcblxuXHRcdC8vIFByZXNzZWQgc3RhdGVcblx0XHRwcmVzc2VkU3RhdGUgPSBtZXJnZShub3JtYWxTdGF0ZSwge1xuXHRcdFx0c3Ryb2tlOiAnIzY4QScsXG5cdFx0XHRmaWxsOiB7XG5cdFx0XHRcdGxpbmVhckdyYWRpZW50OiB2ZXJ0aWNhbEdyYWRpZW50LFxuXHRcdFx0XHRzdG9wczogW1xuXHRcdFx0XHRcdFswLCAnIzlCRCddLFxuXHRcdFx0XHRcdFsxLCAnI0NERiddXG5cdFx0XHRcdF1cblx0XHRcdH1cblx0XHR9LCBwcmVzc2VkU3RhdGUpO1xuXHRcdHByZXNzZWRTdHlsZSA9IHByZXNzZWRTdGF0ZS5zdHlsZTtcblx0XHRkZWxldGUgcHJlc3NlZFN0YXRlLnN0eWxlO1xuXG5cdFx0Ly8gRGlzYWJsZWQgc3RhdGVcblx0XHRkaXNhYmxlZFN0YXRlID0gbWVyZ2Uobm9ybWFsU3RhdGUsIHtcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdGNvbG9yOiAnI0NDQydcblx0XHRcdH1cblx0XHR9LCBkaXNhYmxlZFN0YXRlKTtcblx0XHRkaXNhYmxlZFN0eWxlID0gZGlzYWJsZWRTdGF0ZS5zdHlsZTtcblx0XHRkZWxldGUgZGlzYWJsZWRTdGF0ZS5zdHlsZTtcblxuXHRcdC8vIEFkZCB0aGUgZXZlbnRzLiBJRTkgYW5kIElFMTAgbmVlZCBtb3VzZW92ZXIgYW5kIG1vdXNlb3V0IHRvIGZ1bmNpdG9uICgjNjY3KS5cblx0XHRhZGRFdmVudChsYWJlbC5lbGVtZW50LCBpc01TID8gJ21vdXNlb3ZlcicgOiAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChjdXJTdGF0ZSAhPT0gMykge1xuXHRcdFx0XHRsYWJlbC5hdHRyKGhvdmVyU3RhdGUpXG5cdFx0XHRcdFx0LmNzcyhob3ZlclN0eWxlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRhZGRFdmVudChsYWJlbC5lbGVtZW50LCBpc01TID8gJ21vdXNlb3V0JyA6ICdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGN1clN0YXRlICE9PSAzKSB7XG5cdFx0XHRcdHN0YXRlT3B0aW9ucyA9IFtub3JtYWxTdGF0ZSwgaG92ZXJTdGF0ZSwgcHJlc3NlZFN0YXRlXVtjdXJTdGF0ZV07XG5cdFx0XHRcdHN0YXRlU3R5bGUgPSBbbm9ybWFsU3R5bGUsIGhvdmVyU3R5bGUsIHByZXNzZWRTdHlsZV1bY3VyU3RhdGVdO1xuXHRcdFx0XHRsYWJlbC5hdHRyKHN0YXRlT3B0aW9ucylcblx0XHRcdFx0XHQuY3NzKHN0YXRlU3R5bGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0bGFiZWwuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcblx0XHRcdGxhYmVsLnN0YXRlID0gY3VyU3RhdGUgPSBzdGF0ZTtcblx0XHRcdGlmICghc3RhdGUpIHtcblx0XHRcdFx0bGFiZWwuYXR0cihub3JtYWxTdGF0ZSlcblx0XHRcdFx0XHQuY3NzKG5vcm1hbFN0eWxlKTtcblx0XHRcdH0gZWxzZSBpZiAoc3RhdGUgPT09IDIpIHtcblx0XHRcdFx0bGFiZWwuYXR0cihwcmVzc2VkU3RhdGUpXG5cdFx0XHRcdFx0LmNzcyhwcmVzc2VkU3R5bGUpO1xuXHRcdFx0fSBlbHNlIGlmIChzdGF0ZSA9PT0gMykge1xuXHRcdFx0XHRsYWJlbC5hdHRyKGRpc2FibGVkU3RhdGUpXG5cdFx0XHRcdFx0LmNzcyhkaXNhYmxlZFN0eWxlKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmV0dXJuIGxhYmVsXG5cdFx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYgKGN1clN0YXRlICE9PSAzKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbChsYWJlbCwgZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQuYXR0cihub3JtYWxTdGF0ZSlcblx0XHRcdC5jc3MoZXh0ZW5kKHsgY3Vyc29yOiAnZGVmYXVsdCcgfSwgbm9ybWFsU3R5bGUpKTtcblx0fSxcblxuXHQvKipcblx0ICogTWFrZSBhIHN0cmFpZ2h0IGxpbmUgY3Jpc3BlciBieSBub3Qgc3BpbGxpbmcgb3V0IHRvIG5laWdoYm91ciBwaXhlbHNcblx0ICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHQgKi9cblx0Y3Jpc3BMaW5lOiBmdW5jdGlvbiAocG9pbnRzLCB3aWR0aCkge1xuXHRcdC8vIHBvaW50cyBmb3JtYXQ6IFtNLCAwLCAwLCBMLCAxMDAsIDBdXG5cdFx0Ly8gbm9ybWFsaXplIHRvIGEgY3Jpc3AgbGluZVxuXHRcdGlmIChwb2ludHNbMV0gPT09IHBvaW50c1s0XSkge1xuXHRcdFx0Ly8gU3Vic3RyYWN0IGR1ZSB0byAjMTEyOS4gTm93IGJvdHRvbSBhbmQgbGVmdCBheGlzIGdyaWRsaW5lcyBiZWhhdmUgdGhlIHNhbWUuXG5cdFx0XHRwb2ludHNbMV0gPSBwb2ludHNbNF0gPSBtYXRoUm91bmQocG9pbnRzWzFdKSAtICh3aWR0aCAlIDIgLyAyKTtcblx0XHR9XG5cdFx0aWYgKHBvaW50c1syXSA9PT0gcG9pbnRzWzVdKSB7XG5cdFx0XHRwb2ludHNbMl0gPSBwb2ludHNbNV0gPSBtYXRoUm91bmQocG9pbnRzWzJdKSArICh3aWR0aCAlIDIgLyAyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50cztcblx0fSxcblxuXG5cdC8qKlxuXHQgKiBEcmF3IGEgcGF0aFxuXHQgKiBAcGFyYW0ge0FycmF5fSBwYXRoIEFuIFNWRyBwYXRoIGluIGFycmF5IGZvcm1cblx0ICovXG5cdHBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0dmFyIGF0dHIgPSB7XG5cdFx0XHRmaWxsOiBOT05FXG5cdFx0fTtcblx0XHRpZiAoaXNBcnJheShwYXRoKSkge1xuXHRcdFx0YXR0ci5kID0gcGF0aDtcblx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0KHBhdGgpKSB7IC8vIGF0dHJpYnV0ZXNcblx0XHRcdGV4dGVuZChhdHRyLCBwYXRoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlRWxlbWVudCgncGF0aCcpLmF0dHIoYXR0cik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXcgYW5kIHJldHVybiBhbiBTVkcgY2lyY2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByIFRoZSByYWRpdXNcblx0ICovXG5cdGNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHIpIHtcblx0XHR2YXIgYXR0ciA9IGlzT2JqZWN0KHgpID9cblx0XHRcdHggOlxuXHRcdFx0e1xuXHRcdFx0XHR4OiB4LFxuXHRcdFx0XHR5OiB5LFxuXHRcdFx0XHRyOiByXG5cdFx0XHR9LFxuXHRcdFx0d3JhcHBlciA9IHRoaXMuY3JlYXRlRWxlbWVudCgnY2lyY2xlJyk7XG5cblx0XHR3cmFwcGVyLnhTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2N4JywgdmFsdWUpO1xuXHRcdH07XG5cdFx0d3JhcHBlci55U2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdjeScsIHZhbHVlKTtcblx0XHR9O1xuXHRcdHJldHVybiB3cmFwcGVyLmF0dHIoYXR0cik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXcgYW5kIHJldHVybiBhbiBhcmNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByIFJhZGl1c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5uZXJSIElubmVyIHJhZGl1cyBsaWtlIHVzZWQgaW4gZG9udXQgY2hhcnRzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBTdGFydGluZyBhbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZGluZyBhbmdsZVxuXHQgKi9cblx0YXJjOiBmdW5jdGlvbiAoeCwgeSwgciwgaW5uZXJSLCBzdGFydCwgZW5kKSB7XG5cdFx0dmFyIGFyYztcblxuXHRcdGlmIChpc09iamVjdCh4KSkge1xuXHRcdFx0eSA9IHgueTtcblx0XHRcdHIgPSB4LnI7XG5cdFx0XHRpbm5lclIgPSB4LmlubmVyUjtcblx0XHRcdHN0YXJ0ID0geC5zdGFydDtcblx0XHRcdGVuZCA9IHguZW5kO1xuXHRcdFx0eCA9IHgueDtcblx0XHR9XG5cblx0XHQvLyBBcmNzIGFyZSBkZWZpbmVkIGFzIHN5bWJvbHMgZm9yIHRoZSBhYmlsaXR5IHRvIHNldFxuXHRcdC8vIGF0dHJpYnV0ZXMgaW4gYXR0ciBhbmQgYW5pbWF0ZVxuXHRcdGFyYyA9IHRoaXMuc3ltYm9sKCdhcmMnLCB4IHx8IDAsIHkgfHwgMCwgciB8fCAwLCByIHx8IDAsIHtcblx0XHRcdGlubmVyUjogaW5uZXJSIHx8IDAsXG5cdFx0XHRzdGFydDogc3RhcnQgfHwgMCxcblx0XHRcdGVuZDogZW5kIHx8IDBcblx0XHR9KTtcblx0XHRhcmMuciA9IHI7IC8vICM5NTlcblx0XHRyZXR1cm4gYXJjO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3IGFuZCByZXR1cm4gYSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggTGVmdCBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUb3AgcG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIgQm9yZGVyIGNvcm5lciByYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0cm9rZVdpZHRoIEEgc3Ryb2tlIHdpZHRoIGNhbiBiZSBzdXBwbGllZCB0byBhbGxvdyBjcmlzcCBkcmF3aW5nXG5cdCAqL1xuXHRyZWN0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgciwgc3Ryb2tlV2lkdGgpIHtcblxuXHRcdHIgPSBpc09iamVjdCh4KSA/IHguciA6IHI7XG5cblx0XHR2YXIgd3JhcHBlciA9IHRoaXMuY3JlYXRlRWxlbWVudCgncmVjdCcpLFxuXHRcdFx0YXR0cmlicyA9IGlzT2JqZWN0KHgpID8geCA6IHggPT09IFVOREVGSU5FRCA/IHt9IDoge1xuXHRcdFx0XHR4OiB4LFxuXHRcdFx0XHR5OiB5LFxuXHRcdFx0XHR3aWR0aDogbWF0aE1heCh3aWR0aCwgMCksXG5cdFx0XHRcdGhlaWdodDogbWF0aE1heChoZWlnaHQsIDApXG5cdFx0XHR9O1xuXG5cdFx0aWYgKHN0cm9rZVdpZHRoICE9PSBVTkRFRklORUQpIHtcblx0XHRcdGF0dHJpYnMuc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcblx0XHRcdGF0dHJpYnMgPSB3cmFwcGVyLmNyaXNwKGF0dHJpYnMpO1xuXHRcdH1cblxuXHRcdGlmIChyKSB7XG5cdFx0XHRhdHRyaWJzLnIgPSByO1xuXHRcdH1cblxuXHRcdHdyYXBwZXIuclNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0YXR0cih0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0cng6IHZhbHVlLFxuXHRcdFx0XHRyeTogdmFsdWVcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIHdyYXBwZXIuYXR0cihhdHRyaWJzKTtcblx0fSxcblxuXHQvKipcblx0ICogUmVzaXplIHRoZSBib3ggYW5kIHJlLWFsaWduIGFsbCBhbGlnbmVkIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB3aWR0aFxuXHQgKiBAcGFyYW0ge09iamVjdH0gaGVpZ2h0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYW5pbWF0ZVxuXHQgKlxuXHQgKi9cblx0c2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGFuaW1hdGUpIHtcblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLFxuXHRcdFx0YWxpZ25lZE9iamVjdHMgPSByZW5kZXJlci5hbGlnbmVkT2JqZWN0cyxcblx0XHRcdGkgPSBhbGlnbmVkT2JqZWN0cy5sZW5ndGg7XG5cblx0XHRyZW5kZXJlci53aWR0aCA9IHdpZHRoO1xuXHRcdHJlbmRlcmVyLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdHJlbmRlcmVyLmJveFdyYXBwZXJbcGljayhhbmltYXRlLCB0cnVlKSA/ICdhbmltYXRlJyA6ICdhdHRyJ10oe1xuXHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHRcblx0XHR9KTtcblxuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGFsaWduZWRPYmplY3RzW2ldLmFsaWduKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBncm91cFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZ3JvdXAgd2lsbCBiZSBnaXZlbiBhIGNsYXNzIG5hbWUgb2YgJ2hpZ2hjaGFydHMte25hbWV9Jy5cblx0ICpcdCBUaGlzIGNhbiBiZSB1c2VkIGZvciBzdHlsaW5nIGFuZCBzY3JpcHRpbmcuXG5cdCAqL1xuXHRnOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHZhciBlbGVtID0gdGhpcy5jcmVhdGVFbGVtZW50KCdnJyk7XG5cdFx0cmV0dXJuIGRlZmluZWQobmFtZSkgPyBlbGVtLmF0dHIoeyAnY2xhc3MnOiBQUkVGSVggKyBuYW1lIH0pIDogZWxlbTtcblx0fSxcblxuXHQvKipcblx0ICogRGlzcGxheSBhbiBpbWFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdCAqL1xuXHRpbWFnZTogZnVuY3Rpb24gKHNyYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHZhciBhdHRyaWJzID0ge1xuXHRcdFx0XHRwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBOT05FXG5cdFx0XHR9LFxuXHRcdFx0ZWxlbVdyYXBwZXI7XG5cblx0XHQvLyBvcHRpb25hbCBwcm9wZXJ0aWVzXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRleHRlbmQoYXR0cmlicywge1xuXHRcdFx0XHR4OiB4LFxuXHRcdFx0XHR5OiB5LFxuXHRcdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRlbGVtV3JhcHBlciA9IHRoaXMuY3JlYXRlRWxlbWVudCgnaW1hZ2UnKS5hdHRyKGF0dHJpYnMpO1xuXG5cdFx0Ly8gc2V0IHRoZSBocmVmIGluIHRoZSB4bGluayBuYW1lc3BhY2Vcblx0XHRpZiAoZWxlbVdyYXBwZXIuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUykge1xuXHRcdFx0ZWxlbVdyYXBwZXIuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG5cdFx0XHRcdCdocmVmJywgc3JjKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gY291bGQgYmUgZXhwb3J0aW5nIGluIElFXG5cdFx0XHQvLyB1c2luZyBocmVmIHRocm93cyBcIm5vdCBzdXBwb3J0ZWRcIiBpbiBpZTcgYW5kIHVuZGVyLCByZXF1cmllcyByZWdleCBzaGltIHRvIGZpeCBsYXRlclxuXHRcdFx0ZWxlbVdyYXBwZXIuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hjLXN2Zy1ocmVmJywgc3JjKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1XcmFwcGVyO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3IGEgc3ltYm9sIG91dCBvZiBwcmUtZGVmaW5lZCBzaGFwZSBwYXRocyBmcm9tIHRoZSBuYW1lc3BhY2UgJ3N5bWJvbCcgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB4XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB5XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByYWRpdXNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICovXG5cdHN5bWJvbDogZnVuY3Rpb24gKHN5bWJvbCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuXG5cdFx0dmFyIG9iaixcblxuXHRcdFx0Ly8gZ2V0IHRoZSBzeW1ib2wgZGVmaW5pdGlvbiBmdW5jdGlvblxuXHRcdFx0c3ltYm9sRm4gPSB0aGlzLnN5bWJvbHNbc3ltYm9sXSxcblxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlcmUncyBhIHBhdGggZGVmaW5lZCBmb3IgdGhpcyBzeW1ib2xcblx0XHRcdHBhdGggPSBzeW1ib2xGbiAmJiBzeW1ib2xGbihcblx0XHRcdFx0bWF0aFJvdW5kKHgpLFxuXHRcdFx0XHRtYXRoUm91bmQoeSksXG5cdFx0XHRcdHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQsXG5cdFx0XHRcdG9wdGlvbnNcblx0XHRcdCksXG5cblx0XHRcdGltYWdlRWxlbWVudCxcblx0XHRcdGltYWdlUmVnZXggPSAvXnVybFxcKCguKj8pXFwpJC8sXG5cdFx0XHRpbWFnZVNyYyxcblx0XHRcdGltYWdlU2l6ZSxcblx0XHRcdGNlbnRlckltYWdlO1xuXG5cdFx0aWYgKHBhdGgpIHtcblxuXHRcdFx0b2JqID0gdGhpcy5wYXRoKHBhdGgpO1xuXHRcdFx0Ly8gZXhwYW5kbyBwcm9wZXJ0aWVzIGZvciB1c2UgaW4gYW5pbWF0ZSBhbmQgYXR0clxuXHRcdFx0ZXh0ZW5kKG9iaiwge1xuXHRcdFx0XHRzeW1ib2xOYW1lOiBzeW1ib2wsXG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHksXG5cdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBoZWlnaHRcblx0XHRcdH0pO1xuXHRcdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdFx0ZXh0ZW5kKG9iaiwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cblxuXHRcdC8vIGltYWdlIHN5bWJvbHNcblx0XHR9IGVsc2UgaWYgKGltYWdlUmVnZXgudGVzdChzeW1ib2wpKSB7XG5cblx0XHRcdC8vIE9uIGltYWdlIGxvYWQsIHNldCB0aGUgc2l6ZSBhbmQgcG9zaXRpb25cblx0XHRcdGNlbnRlckltYWdlID0gZnVuY3Rpb24gKGltZywgc2l6ZSkge1xuXHRcdFx0XHRpZiAoaW1nLmVsZW1lbnQpIHsgLy8gaXQgbWF5IGJlIGRlc3Ryb3llZCBpbiB0aGUgbWVhbnRpbWUgKCMxMzkwKVxuXHRcdFx0XHRcdGltZy5hdHRyKHtcblx0XHRcdFx0XHRcdHdpZHRoOiBzaXplWzBdLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBzaXplWzFdXG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRpZiAoIWltZy5hbGlnbkJ5VHJhbnNsYXRlKSB7IC8vICMxODVcblx0XHRcdFx0XHRcdGltZy50cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdG1hdGhSb3VuZCgod2lkdGggLSBzaXplWzBdKSAvIDIpLCAvLyAjMTM3OFxuXHRcdFx0XHRcdFx0XHRtYXRoUm91bmQoKGhlaWdodCAtIHNpemVbMV0pIC8gMilcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRpbWFnZVNyYyA9IHN5bWJvbC5tYXRjaChpbWFnZVJlZ2V4KVsxXTtcblx0XHRcdGltYWdlU2l6ZSA9IHN5bWJvbFNpemVzW2ltYWdlU3JjXSB8fCAob3B0aW9ucyAmJiBvcHRpb25zLndpZHRoICYmIG9wdGlvbnMuaGVpZ2h0ICYmIFtvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodF0pO1xuXG5cdFx0XHQvLyBJcmVhdGUgdGhlIGltYWdlIHN5bmNocm9ub3VzbHksIGFkZCBhdHRyaWJzIGFzeW5jXG5cdFx0XHRvYmogPSB0aGlzLmltYWdlKGltYWdlU3JjKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHR5OiB5XG5cdFx0XHRcdH0pO1xuXHRcdFx0b2JqLmlzSW1nID0gdHJ1ZTtcblxuXHRcdFx0aWYgKGltYWdlU2l6ZSkge1xuXHRcdFx0XHRjZW50ZXJJbWFnZShvYmosIGltYWdlU2l6ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJbml0aWFsaXplIGltYWdlIHRvIGJlIDAgc2l6ZSBzbyBleHBvcnQgd2lsbCBzdGlsbCBmdW5jdGlvbiBpZiB0aGVyZSdzIG5vIGNhY2hlZCBzaXplcy5cblx0XHRcdFx0b2JqLmF0dHIoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSBhIGR1bW15IEphdmFTY3JpcHQgaW1hZ2UgdG8gZ2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0LiBEdWUgdG8gYSBidWcgaW4gSUUgPCA4LFxuXHRcdFx0XHQvLyB0aGUgY3JlYXRlZCBlbGVtZW50IG11c3QgYmUgYXNzaWduZWQgdG8gYSB2YXJpYWJsZSBpbiBvcmRlciB0byBsb2FkICgjMjkyKS5cblx0XHRcdFx0aW1hZ2VFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgnaW1nJywge1xuXHRcdFx0XHRcdG9ubG9hZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgZm9yIFNWR3Mgb24gSUUxMSwgdGhlIHdpZHRoIGlzIG5vdCBhY2Nlc3NpYmxlIHVudGlsIHRoZSBpbWFnZSBpcyBcblx0XHRcdFx0XHRcdC8vIHBhcnQgb2YgdGhlIERPTSAoIzI4NTQpLlxuXHRcdFx0XHRcdFx0aWYgKHRoaXMud2lkdGggPT09IDApIHsgXG5cdFx0XHRcdFx0XHRcdGNzcyh0aGlzLCB7XG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb246IEFCU09MVVRFLFxuXHRcdFx0XHRcdFx0XHRcdHRvcDogJy05OTllbSdcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIENlbnRlciB0aGUgaW1hZ2Vcblx0XHRcdFx0XHRcdGNlbnRlckltYWdlKG9iaiwgc3ltYm9sU2l6ZXNbaW1hZ2VTcmNdID0gW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSk7XG5cblx0XHRcdFx0XHRcdC8vIENsZWFuIHVwIGFmdGVyICMyODU0IHdvcmthcm91bmQuXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHNyYzogaW1hZ2VTcmNcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvKipcblx0ICogQW4gZXh0ZW5kYWJsZSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyBmb3IgZGVmaW5pbmcgc3ltYm9sIHBhdGhzLlxuXHQgKi9cblx0c3ltYm9sczoge1xuXHRcdCdjaXJjbGUnOiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuXHRcdFx0dmFyIGNwdyA9IDAuMTY2ICogdztcblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdE0sIHggKyB3IC8gMiwgeSxcblx0XHRcdFx0J0MnLCB4ICsgdyArIGNwdywgeSwgeCArIHcgKyBjcHcsIHkgKyBoLCB4ICsgdyAvIDIsIHkgKyBoLFxuXHRcdFx0XHQnQycsIHggLSBjcHcsIHkgKyBoLCB4IC0gY3B3LCB5LCB4ICsgdyAvIDIsIHksXG5cdFx0XHRcdCdaJ1xuXHRcdFx0XTtcblx0XHR9LFxuXG5cdFx0J3NxdWFyZSc6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRNLCB4LCB5LFxuXHRcdFx0XHRMLCB4ICsgdywgeSxcblx0XHRcdFx0eCArIHcsIHkgKyBoLFxuXHRcdFx0XHR4LCB5ICsgaCxcblx0XHRcdFx0J1onXG5cdFx0XHRdO1xuXHRcdH0sXG5cblx0XHQndHJpYW5nbGUnOiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0TSwgeCArIHcgLyAyLCB5LFxuXHRcdFx0XHRMLCB4ICsgdywgeSArIGgsXG5cdFx0XHRcdHgsIHkgKyBoLFxuXHRcdFx0XHQnWidcblx0XHRcdF07XG5cdFx0fSxcblxuXHRcdCd0cmlhbmdsZS1kb3duJzogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdE0sIHgsIHksXG5cdFx0XHRcdEwsIHggKyB3LCB5LFxuXHRcdFx0XHR4ICsgdyAvIDIsIHkgKyBoLFxuXHRcdFx0XHQnWidcblx0XHRcdF07XG5cdFx0fSxcblx0XHQnZGlhbW9uZCc6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRNLCB4ICsgdyAvIDIsIHksXG5cdFx0XHRcdEwsIHggKyB3LCB5ICsgaCAvIDIsXG5cdFx0XHRcdHggKyB3IC8gMiwgeSArIGgsXG5cdFx0XHRcdHgsIHkgKyBoIC8gMixcblx0XHRcdFx0J1onXG5cdFx0XHRdO1xuXHRcdH0sXG5cdFx0J2FyYyc6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSBvcHRpb25zLnN0YXJ0LFxuXHRcdFx0XHRyYWRpdXMgPSBvcHRpb25zLnIgfHwgdyB8fCBoLFxuXHRcdFx0XHRlbmQgPSBvcHRpb25zLmVuZCAtIDAuMDAxLCAvLyB0byBwcmV2ZW50IGNvcyBhbmQgc2luIG9mIHN0YXJ0IGFuZCBlbmQgZnJvbSBiZWNvbWluZyBlcXVhbCBvbiAzNjAgYXJjcyAocmVsYXRlZDogIzE1NjEpXG5cdFx0XHRcdGlubmVyUmFkaXVzID0gb3B0aW9ucy5pbm5lclIsXG5cdFx0XHRcdG9wZW4gPSBvcHRpb25zLm9wZW4sXG5cdFx0XHRcdGNvc1N0YXJ0ID0gbWF0aENvcyhzdGFydCksXG5cdFx0XHRcdHNpblN0YXJ0ID0gbWF0aFNpbihzdGFydCksXG5cdFx0XHRcdGNvc0VuZCA9IG1hdGhDb3MoZW5kKSxcblx0XHRcdFx0c2luRW5kID0gbWF0aFNpbihlbmQpLFxuXHRcdFx0XHRsb25nQXJjID0gb3B0aW9ucy5lbmQgLSBzdGFydCA8IG1hdGhQSSA/IDAgOiAxO1xuXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRNLFxuXHRcdFx0XHR4ICsgcmFkaXVzICogY29zU3RhcnQsXG5cdFx0XHRcdHkgKyByYWRpdXMgKiBzaW5TdGFydCxcblx0XHRcdFx0J0EnLCAvLyBhcmNUb1xuXHRcdFx0XHRyYWRpdXMsIC8vIHggcmFkaXVzXG5cdFx0XHRcdHJhZGl1cywgLy8geSByYWRpdXNcblx0XHRcdFx0MCwgLy8gc2xhbnRpbmdcblx0XHRcdFx0bG9uZ0FyYywgLy8gbG9uZyBvciBzaG9ydCBhcmNcblx0XHRcdFx0MSwgLy8gY2xvY2t3aXNlXG5cdFx0XHRcdHggKyByYWRpdXMgKiBjb3NFbmQsXG5cdFx0XHRcdHkgKyByYWRpdXMgKiBzaW5FbmQsXG5cdFx0XHRcdG9wZW4gPyBNIDogTCxcblx0XHRcdFx0eCArIGlubmVyUmFkaXVzICogY29zRW5kLFxuXHRcdFx0XHR5ICsgaW5uZXJSYWRpdXMgKiBzaW5FbmQsXG5cdFx0XHRcdCdBJywgLy8gYXJjVG9cblx0XHRcdFx0aW5uZXJSYWRpdXMsIC8vIHggcmFkaXVzXG5cdFx0XHRcdGlubmVyUmFkaXVzLCAvLyB5IHJhZGl1c1xuXHRcdFx0XHQwLCAvLyBzbGFudGluZ1xuXHRcdFx0XHRsb25nQXJjLCAvLyBsb25nIG9yIHNob3J0IGFyY1xuXHRcdFx0XHQwLCAvLyBjbG9ja3dpc2Vcblx0XHRcdFx0eCArIGlubmVyUmFkaXVzICogY29zU3RhcnQsXG5cdFx0XHRcdHkgKyBpbm5lclJhZGl1cyAqIHNpblN0YXJ0LFxuXG5cdFx0XHRcdG9wZW4gPyAnJyA6ICdaJyAvLyBjbG9zZVxuXHRcdFx0XTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsbG91dCBzaGFwZSB1c2VkIGZvciBkZWZhdWx0IHRvb2x0aXBzLCBhbHNvIHVzZWQgZm9yIHJvdW5kZWQgcmVjdGFuZ2xlcyBpbiBWTUxcblx0XHQgKi9cblx0XHRjYWxsb3V0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIGFycm93TGVuZ3RoID0gNixcblx0XHRcdFx0aGFsZkRpc3RhbmNlID0gNixcblx0XHRcdFx0ciA9IG1hdGhNaW4oKG9wdGlvbnMgJiYgb3B0aW9ucy5yKSB8fCAwLCB3LCBoKSxcblx0XHRcdFx0c2FmZURpc3RhbmNlID0gciArIGhhbGZEaXN0YW5jZSxcblx0XHRcdFx0YW5jaG9yWCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbmNob3JYLFxuXHRcdFx0XHRhbmNob3JZID0gb3B0aW9ucyAmJiBvcHRpb25zLmFuY2hvclksXG5cdFx0XHRcdHBhdGg7XG5cblx0XHRcdHBhdGggPSBbXG5cdFx0XHRcdCdNJywgeCArIHIsIHksIFxuXHRcdFx0XHQnTCcsIHggKyB3IC0gciwgeSwgLy8gdG9wIHNpZGVcblx0XHRcdFx0J0MnLCB4ICsgdywgeSwgeCArIHcsIHksIHggKyB3LCB5ICsgciwgLy8gdG9wLXJpZ2h0IGNvcm5lclxuXHRcdFx0XHQnTCcsIHggKyB3LCB5ICsgaCAtIHIsIC8vIHJpZ2h0IHNpZGVcblx0XHRcdFx0J0MnLCB4ICsgdywgeSArIGgsIHggKyB3LCB5ICsgaCwgeCArIHcgLSByLCB5ICsgaCwgLy8gYm90dG9tLXJpZ2h0IGNvcm5lclxuXHRcdFx0XHQnTCcsIHggKyByLCB5ICsgaCwgLy8gYm90dG9tIHNpZGVcblx0XHRcdFx0J0MnLCB4LCB5ICsgaCwgeCwgeSArIGgsIHgsIHkgKyBoIC0gciwgLy8gYm90dG9tLWxlZnQgY29ybmVyXG5cdFx0XHRcdCdMJywgeCwgeSArIHIsIC8vIGxlZnQgc2lkZVxuXHRcdFx0XHQnQycsIHgsIHksIHgsIHksIHggKyByLCB5IC8vIHRvcC1yaWdodCBjb3JuZXJcblx0XHRcdF07XG5cdFx0XHRcblx0XHRcdGlmIChhbmNob3JYICYmIGFuY2hvclggPiB3ICYmIGFuY2hvclkgPiB5ICsgc2FmZURpc3RhbmNlICYmIGFuY2hvclkgPCB5ICsgaCAtIHNhZmVEaXN0YW5jZSkgeyAvLyByZXBsYWNlIHJpZ2h0IHNpZGVcblx0XHRcdFx0cGF0aC5zcGxpY2UoMTMsIDMsXG5cdFx0XHRcdFx0J0wnLCB4ICsgdywgYW5jaG9yWSAtIGhhbGZEaXN0YW5jZSwgXG5cdFx0XHRcdFx0eCArIHcgKyBhcnJvd0xlbmd0aCwgYW5jaG9yWSxcblx0XHRcdFx0XHR4ICsgdywgYW5jaG9yWSArIGhhbGZEaXN0YW5jZSxcblx0XHRcdFx0XHR4ICsgdywgeSArIGggLSByXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2UgaWYgKGFuY2hvclggJiYgYW5jaG9yWCA8IDAgJiYgYW5jaG9yWSA+IHkgKyBzYWZlRGlzdGFuY2UgJiYgYW5jaG9yWSA8IHkgKyBoIC0gc2FmZURpc3RhbmNlKSB7IC8vIHJlcGxhY2UgbGVmdCBzaWRlXG5cdFx0XHRcdHBhdGguc3BsaWNlKDMzLCAzLCBcblx0XHRcdFx0XHQnTCcsIHgsIGFuY2hvclkgKyBoYWxmRGlzdGFuY2UsIFxuXHRcdFx0XHRcdHggLSBhcnJvd0xlbmd0aCwgYW5jaG9yWSxcblx0XHRcdFx0XHR4LCBhbmNob3JZIC0gaGFsZkRpc3RhbmNlLFxuXHRcdFx0XHRcdHgsIHkgKyByXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2UgaWYgKGFuY2hvclkgJiYgYW5jaG9yWSA+IGggJiYgYW5jaG9yWCA+IHggKyBzYWZlRGlzdGFuY2UgJiYgYW5jaG9yWCA8IHggKyB3IC0gc2FmZURpc3RhbmNlKSB7IC8vIHJlcGxhY2UgYm90dG9tXG5cdFx0XHRcdHBhdGguc3BsaWNlKDIzLCAzLFxuXHRcdFx0XHRcdCdMJywgYW5jaG9yWCArIGhhbGZEaXN0YW5jZSwgeSArIGgsXG5cdFx0XHRcdFx0YW5jaG9yWCwgeSArIGggKyBhcnJvd0xlbmd0aCxcblx0XHRcdFx0XHRhbmNob3JYIC0gaGFsZkRpc3RhbmNlLCB5ICsgaCxcblx0XHRcdFx0XHR4ICsgciwgeSArIGhcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSBpZiAoYW5jaG9yWSAmJiBhbmNob3JZIDwgMCAmJiBhbmNob3JYID4geCArIHNhZmVEaXN0YW5jZSAmJiBhbmNob3JYIDwgeCArIHcgLSBzYWZlRGlzdGFuY2UpIHsgLy8gcmVwbGFjZSB0b3Bcblx0XHRcdFx0cGF0aC5zcGxpY2UoMywgMyxcblx0XHRcdFx0XHQnTCcsIGFuY2hvclggLSBoYWxmRGlzdGFuY2UsIHksXG5cdFx0XHRcdFx0YW5jaG9yWCwgeSAtIGFycm93TGVuZ3RoLFxuXHRcdFx0XHRcdGFuY2hvclggKyBoYWxmRGlzdGFuY2UsIHksXG5cdFx0XHRcdFx0dyAtIHIsIHlcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXRoO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogRGVmaW5lIGEgY2xpcHBpbmcgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuXHQgKi9cblx0Y2xpcFJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dmFyIHdyYXBwZXIsXG5cdFx0XHRpZCA9IFBSRUZJWCArIGlkQ291bnRlcisrLFxuXG5cdFx0XHRjbGlwUGF0aCA9IHRoaXMuY3JlYXRlRWxlbWVudCgnY2xpcFBhdGgnKS5hdHRyKHtcblx0XHRcdFx0aWQ6IGlkXG5cdFx0XHR9KS5hZGQodGhpcy5kZWZzKTtcblxuXHRcdHdyYXBwZXIgPSB0aGlzLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgMCkuYWRkKGNsaXBQYXRoKTtcblx0XHR3cmFwcGVyLmlkID0gaWQ7XG5cdFx0d3JhcHBlci5jbGlwUGF0aCA9IGNsaXBQYXRoO1xuXHRcdHdyYXBwZXIuY291bnQgPSAwO1xuXG5cdFx0cmV0dXJuIHdyYXBwZXI7XG5cdH0sXG5cblxuXHRcblxuXG5cdC8qKlxuXHQgKiBBZGQgdGV4dCB0byB0aGUgU1ZHIG9iamVjdFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IExlZnQgcG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVG9wIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlSFRNTCBVc2UgSFRNTCB0byByZW5kZXIgdGhlIHRleHRcblx0ICovXG5cdHRleHQ6IGZ1bmN0aW9uIChzdHIsIHgsIHksIHVzZUhUTUwpIHtcblxuXHRcdC8vIGRlY2xhcmUgdmFyaWFibGVzXG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdGZha2VTVkcgPSB1c2VDYW5WRyB8fCAoIWhhc1NWRyAmJiByZW5kZXJlci5mb3JFeHBvcnQpLFxuXHRcdFx0d3JhcHBlcixcblx0XHRcdGF0dHIgPSB7fTtcblxuXHRcdGlmICh1c2VIVE1MICYmIChyZW5kZXJlci5hbGxvd0hUTUwgfHwgIXJlbmRlcmVyLmZvckV4cG9ydCkpIHtcblx0XHRcdHJldHVybiByZW5kZXJlci5odG1sKHN0ciwgeCwgeSk7XG5cdFx0fVxuXG5cdFx0YXR0ci54ID0gTWF0aC5yb3VuZCh4IHx8IDApOyAvLyBYIGlzIGFsd2F5cyBuZWVkZWQgZm9yIGxpbmUtd3JhcCBsb2dpY1xuXHRcdGlmICh5KSB7XG5cdFx0XHRhdHRyLnkgPSBNYXRoLnJvdW5kKHkpO1xuXHRcdH1cblx0XHRpZiAoc3RyIHx8IHN0ciA9PT0gMCkge1xuXHRcdFx0YXR0ci50ZXh0ID0gc3RyO1xuXHRcdH1cblxuXHRcdHdyYXBwZXIgPSByZW5kZXJlci5jcmVhdGVFbGVtZW50KCd0ZXh0Jylcblx0XHRcdC5hdHRyKGF0dHIpO1xuXG5cdFx0Ly8gUHJldmVudCB3cmFwcGluZyBmcm9tIGNyZWF0aW5nIGZhbHNlIG9mZnNldFdpZHRocyBpbiBleHBvcnQgaW4gbGVnYWN5IElFICgjMTA3OSwgIzEwNjMpXG5cdFx0aWYgKGZha2VTVkcpIHtcblx0XHRcdHdyYXBwZXIuY3NzKHtcblx0XHRcdFx0cG9zaXRpb246IEFCU09MVVRFXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIXVzZUhUTUwpIHtcblx0XHRcdHdyYXBwZXIueFNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHRcdHZhciB0c3BhbnMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0c3BhbicpLFxuXHRcdFx0XHRcdHRzcGFuLFxuXHRcdFx0XHRcdHBhcmVudFZhbCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGtleSksXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHRzcGFucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHRzcGFuID0gdHNwYW5zW2ldO1xuXHRcdFx0XHRcdC8vIElmIHRoZSB4IHZhbHVlcyBhcmUgZXF1YWwsIHRoZSB0c3BhbiByZXByZXNlbnRzIGEgbGluZWJyZWFrXG5cdFx0XHRcdFx0aWYgKHRzcGFuLmdldEF0dHJpYnV0ZShrZXkpID09PSBwYXJlbnRWYWwpIHtcblx0XHRcdFx0XHRcdHRzcGFuLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gd3JhcHBlcjtcblx0fSxcblxuXHQvKipcblx0ICogVXRpbGl0eSB0byByZXR1cm4gdGhlIGJhc2VsaW5lIG9mZnNldCBhbmQgdG90YWwgbGluZSBoZWlnaHQgZnJvbSB0aGUgZm9udCBzaXplXG5cdCAqL1xuXHRmb250TWV0cmljczogZnVuY3Rpb24gKGZvbnRTaXplLCBlbGVtKSB7XG5cdFx0dmFyIGxpbmVIZWlnaHQsXG5cdFx0XHRiYXNlbGluZSxcblx0XHRcdHN0eWxlO1xuXG5cdFx0Zm9udFNpemUgPSBmb250U2l6ZSB8fCB0aGlzLnN0eWxlLmZvbnRTaXplO1xuXHRcdGlmICghZm9udFNpemUgJiYgZWxlbSAmJiB3aW4uZ2V0Q29tcHV0ZWRTdHlsZSkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uZWxlbWVudCB8fCBlbGVtOyAvLyBTVkdFbGVtZW50XG5cdFx0XHRzdHlsZSA9IHdpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW0sIFwiXCIpO1xuXHRcdFx0Zm9udFNpemUgPSBzdHlsZSAmJiBzdHlsZS5mb250U2l6ZTsgLy8gIzQzMDksIHRoZSBzdHlsZSBkb2Vzbid0IGV4aXN0IGluc2lkZSBhIGhpZGRlbiBpZnJhbWUgaW4gRmlyZWZveFxuXHRcdH1cblx0XHRmb250U2l6ZSA9IC9weC8udGVzdChmb250U2l6ZSkgPyBwSW50KGZvbnRTaXplKSA6IC9lbS8udGVzdChmb250U2l6ZSkgPyBwYXJzZUZsb2F0KGZvbnRTaXplKSAqIDEyIDogMTI7XG5cblx0XHQvLyBFbXBpcmljYWwgdmFsdWVzIGZvdW5kIGJ5IGNvbXBhcmluZyBmb250IHNpemUgYW5kIGJvdW5kaW5nIGJveCBoZWlnaHQuXG5cdFx0Ly8gQXBwbGllcyB0byB0aGUgZGVmYXVsdCBmb250IGZhbWlseS4gaHR0cDovL2pzZmlkZGxlLm5ldC9oaWdoY2hhcnRzLzd4dm43L1xuXHRcdGxpbmVIZWlnaHQgPSBmb250U2l6ZSA8IDI0ID8gZm9udFNpemUgKyAzIDogbWF0aFJvdW5kKGZvbnRTaXplICogMS4yKTtcblx0XHRiYXNlbGluZSA9IG1hdGhSb3VuZChsaW5lSGVpZ2h0ICogMC44KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRoOiBsaW5lSGVpZ2h0LFxuXHRcdFx0YjogYmFzZWxpbmUsXG5cdFx0XHRmOiBmb250U2l6ZVxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIENvcnJlY3QgWCBhbmQgWSBwb3NpdGlvbmluZyBvZiBhIGxhYmVsIGZvciByb3RhdGlvbiAoIzE3NjQpXG5cdCAqL1xuXHRyb3RDb3JyOiBmdW5jdGlvbiAoYmFzZWxpbmUsIHJvdGF0aW9uLCBhbHRlclkpIHtcblx0XHR2YXIgeSA9IGJhc2VsaW5lO1xuXHRcdGlmIChyb3RhdGlvbiAmJiBhbHRlclkpIHtcblx0XHRcdHkgPSBtYXRoTWF4KHkgKiBtYXRoQ29zKHJvdGF0aW9uICogZGVnMnJhZCksIDQpO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogKC1iYXNlbGluZSAvIDMpICogbWF0aFNpbihyb3RhdGlvbiAqIGRlZzJyYWQpLFxuXHRcdFx0eTogeVxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZCBhIGxhYmVsLCBhIHRleHQgaXRlbSB0aGF0IGNhbiBob2xkIGEgY29sb3JlZCBvciBncmFkaWVudCBiYWNrZ3JvdW5kXG5cdCAqIGFzIHdlbGwgYXMgYSBib3JkZXIgYW5kIHNoYWRvdy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0clxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc2hhcGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuY2hvclggSW4gY2FzZSB0aGUgc2hhcGUgaGFzIGEgcG9pbnRlciwgbGlrZSBhIGZsYWcsIHRoaXMgaXMgdGhlXG5cdCAqXHRjb29yZGluYXRlcyBpdCBzaG91bGQgYmUgcGlubmVkIHRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmNob3JZXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYmFzZWxpbmUgV2hldGhlciB0byBwb3NpdGlvbiB0aGUgbGFiZWwgcmVsYXRpdmUgdG8gdGhlIHRleHQgYmFzZWxpbmUsXG5cdCAqXHRsaWtlIHJlbmRlcmVyLnRleHQsIG9yIHRvIHRoZSB1cHBlciBib3JkZXIgb2YgdGhlIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBDbGFzcyBuYW1lIGZvciB0aGUgZ3JvdXBcblx0ICovXG5cdGxhYmVsOiBmdW5jdGlvbiAoc3RyLCB4LCB5LCBzaGFwZSwgYW5jaG9yWCwgYW5jaG9yWSwgdXNlSFRNTCwgYmFzZWxpbmUsIGNsYXNzTmFtZSkge1xuXG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdHdyYXBwZXIgPSByZW5kZXJlci5nKGNsYXNzTmFtZSksXG5cdFx0XHR0ZXh0ID0gcmVuZGVyZXIudGV4dCgnJywgMCwgMCwgdXNlSFRNTClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdHpJbmRleDogMVxuXHRcdFx0XHR9KSxcblx0XHRcdFx0Ly8uYWRkKHdyYXBwZXIpLFxuXHRcdFx0Ym94LFxuXHRcdFx0YkJveCxcblx0XHRcdGFsaWduRmFjdG9yID0gMCxcblx0XHRcdHBhZGRpbmcgPSAzLFxuXHRcdFx0cGFkZGluZ0xlZnQgPSAwLFxuXHRcdFx0d2lkdGgsXG5cdFx0XHRoZWlnaHQsXG5cdFx0XHR3cmFwcGVyWCxcblx0XHRcdHdyYXBwZXJZLFxuXHRcdFx0Y3Jpc3BBZGp1c3QgPSAwLFxuXHRcdFx0ZGVmZXJyZWRBdHRyID0ge30sXG5cdFx0XHRiYXNlbGluZU9mZnNldCxcblx0XHRcdG5lZWRzQm94O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiBydW5zIGFmdGVyIHRoZSBsYWJlbCBpcyBhZGRlZCB0byB0aGUgRE9NICh3aGVuIHRoZSBib3VuZGluZyBib3ggaXNcblx0XHQgKiBhdmFpbGFibGUpLCBhbmQgYWZ0ZXIgdGhlIHRleHQgb2YgdGhlIGxhYmVsIGlzIHVwZGF0ZWQgdG8gZGV0ZWN0IHRoZSBuZXcgYm91bmRpbmdcblx0XHQgKiBib3ggYW5kIHJlZmxlY3QgaXQgaW4gdGhlIGJvcmRlciBib3guXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdXBkYXRlQm94U2l6ZSgpIHtcblx0XHRcdHZhciBib3hYLFxuXHRcdFx0XHRib3hZLFxuXHRcdFx0XHRzdHlsZSA9IHRleHQuZWxlbWVudC5zdHlsZTtcblxuXHRcdFx0YkJveCA9ICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkIHx8IHdyYXBwZXIuc3R5bGVzLnRleHRBbGlnbikgJiYgZGVmaW5lZCh0ZXh0LnRleHRTdHIpICYmIFxuXHRcdFx0XHR0ZXh0LmdldEJCb3goKTsgLy8jMzI5NSAmJiAzNTE0IGJveCBmYWlsdXJlIHdoZW4gc3RyaW5nIGVxdWFscyAwXG5cdFx0XHR3cmFwcGVyLndpZHRoID0gKHdpZHRoIHx8IGJCb3gud2lkdGggfHwgMCkgKyAyICogcGFkZGluZyArIHBhZGRpbmdMZWZ0O1xuXHRcdFx0d3JhcHBlci5oZWlnaHQgPSAoaGVpZ2h0IHx8IGJCb3guaGVpZ2h0IHx8IDApICsgMiAqIHBhZGRpbmc7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgbGFiZWwtc2NvcGVkIHkgb2Zmc2V0XG5cdFx0XHRiYXNlbGluZU9mZnNldCA9IHBhZGRpbmcgKyByZW5kZXJlci5mb250TWV0cmljcyhzdHlsZSAmJiBzdHlsZS5mb250U2l6ZSwgdGV4dCkuYjtcblxuXHRcdFx0XG5cdFx0XHRpZiAobmVlZHNCb3gpIHtcblxuXHRcdFx0XHQvLyBjcmVhdGUgdGhlIGJvcmRlciBib3ggaWYgaXQgaXMgbm90IGFscmVhZHkgcHJlc2VudFxuXHRcdFx0XHRpZiAoIWJveCkge1xuXHRcdFx0XHRcdGJveFggPSBtYXRoUm91bmQoLWFsaWduRmFjdG9yICogcGFkZGluZykgKyBjcmlzcEFkanVzdDtcblx0XHRcdFx0XHRib3hZID0gKGJhc2VsaW5lID8gLWJhc2VsaW5lT2Zmc2V0IDogMCkgKyBjcmlzcEFkanVzdDtcblxuXHRcdFx0XHRcdHdyYXBwZXIuYm94ID0gYm94ID0gc2hhcGUgP1xuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc3ltYm9sKHNoYXBlLCBib3hYLCBib3hZLCB3cmFwcGVyLndpZHRoLCB3cmFwcGVyLmhlaWdodCwgZGVmZXJyZWRBdHRyKSA6XG5cdFx0XHRcdFx0XHRyZW5kZXJlci5yZWN0KGJveFgsIGJveFksIHdyYXBwZXIud2lkdGgsIHdyYXBwZXIuaGVpZ2h0LCAwLCBkZWZlcnJlZEF0dHJbU1RST0tFX1dJRFRIXSk7XG5cblx0XHRcdFx0XHRpZiAoIWJveC5pc0ltZykgeyAvLyAjNDMyNCwgZmlsbCBcIm5vbmVcIiBjYXVzZXMgaXQgdG8gYmUgaWdub3JlZCBieSBtb3VzZSBldmVudHMgaW4gSUVcblx0XHRcdFx0XHRcdGJveC5hdHRyKCdmaWxsJywgTk9ORSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJveC5hZGQod3JhcHBlcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhcHBseSB0aGUgYm94IGF0dHJpYnV0ZXNcblx0XHRcdFx0aWYgKCFib3guaXNJbWcpIHsgLy8gIzE2MzBcblx0XHRcdFx0XHRib3guYXR0cihleHRlbmQoe1xuXHRcdFx0XHRcdFx0d2lkdGg6IG1hdGhSb3VuZCh3cmFwcGVyLndpZHRoKSxcblx0XHRcdFx0XHRcdGhlaWdodDogbWF0aFJvdW5kKHdyYXBwZXIuaGVpZ2h0KVxuXHRcdFx0XHRcdH0sIGRlZmVycmVkQXR0cikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZmVycmVkQXR0ciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBmdW5jdGlvbiBydW5zIGFmdGVyIHNldHRpbmcgdGV4dCBvciBwYWRkaW5nLCBidXQgb25seSBpZiBwYWRkaW5nIGlzIGNoYW5nZWRcblx0XHQgKi9cblx0XHRmdW5jdGlvbiB1cGRhdGVUZXh0UGFkZGluZygpIHtcblx0XHRcdHZhciBzdHlsZXMgPSB3cmFwcGVyLnN0eWxlcyxcblx0XHRcdFx0dGV4dEFsaWduID0gc3R5bGVzICYmIHN0eWxlcy50ZXh0QWxpZ24sXG5cdFx0XHRcdHggPSBwYWRkaW5nTGVmdCArIHBhZGRpbmcgKiAoMSAtIGFsaWduRmFjdG9yKSxcblx0XHRcdFx0eTtcblxuXHRcdFx0Ly8gZGV0ZXJtaW4geSBiYXNlZCBvbiB0aGUgYmFzZWxpbmVcblx0XHRcdHkgPSBiYXNlbGluZSA/IDAgOiBiYXNlbGluZU9mZnNldDtcblxuXHRcdFx0Ly8gY29tcGVuc2F0ZSBmb3IgYWxpZ25tZW50XG5cdFx0XHRpZiAoZGVmaW5lZCh3aWR0aCkgJiYgYkJveCAmJiAodGV4dEFsaWduID09PSAnY2VudGVyJyB8fCB0ZXh0QWxpZ24gPT09ICdyaWdodCcpKSB7XG5cdFx0XHRcdHggKz0geyBjZW50ZXI6IDAuNSwgcmlnaHQ6IDEgfVt0ZXh0QWxpZ25dICogKHdpZHRoIC0gYkJveC53aWR0aCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHVwZGF0ZSBpZiBhbnl0aGluZyBjaGFuZ2VkXG5cdFx0XHRpZiAoeCAhPT0gdGV4dC54IHx8IHkgIT09IHRleHQueSkge1xuXHRcdFx0XHR0ZXh0LmF0dHIoJ3gnLCB4KTtcblx0XHRcdFx0aWYgKHkgIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdHRleHQuYXR0cigneScsIHkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlY29yZCBjdXJyZW50IHZhbHVlc1xuXHRcdFx0dGV4dC54ID0geDtcblx0XHRcdHRleHQueSA9IHk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IGEgYm94IGF0dHJpYnV0ZSwgb3IgZGVmZXIgaXQgaWYgdGhlIGJveCBpcyBub3QgeWV0IGNyZWF0ZWRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0ga2V5XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gYm94QXR0cihrZXksIHZhbHVlKSB7XG5cdFx0XHRpZiAoYm94KSB7XG5cdFx0XHRcdGJveC5hdHRyKGtleSwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWRBdHRyW2tleV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBBZnRlciB0aGUgdGV4dCBlbGVtZW50IGlzIGFkZGVkLCBnZXQgdGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgYm9yZGVyIGJveFxuXHRcdCAqIGFuZCBhZGQgaXQgYmVmb3JlIHRoZSB0ZXh0IGluIHRoZSBET00uXG5cdFx0ICovXG5cdFx0d3JhcHBlci5vbkFkZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRleHQuYWRkKHdyYXBwZXIpO1xuXHRcdFx0d3JhcHBlci5hdHRyKHtcblx0XHRcdFx0dGV4dDogKHN0ciB8fCBzdHIgPT09IDApID8gc3RyIDogJycsIC8vIGFsaWdubWVudCBpcyBhdmFpbGFibGUgbm93IC8vICMzMjk1OiAwIG5vdCByZW5kZXJlZCBpZiBnaXZlbiBhcyBhIHZhbHVlXG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHlcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoYm94ICYmIGRlZmluZWQoYW5jaG9yWCkpIHtcblx0XHRcdFx0d3JhcHBlci5hdHRyKHtcblx0XHRcdFx0XHRhbmNob3JYOiBhbmNob3JYLFxuXHRcdFx0XHRcdGFuY2hvclk6IGFuY2hvcllcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qXG5cdFx0ICogQWRkIHNwZWNpZmljIGF0dHJpYnV0ZSBzZXR0ZXJzLlxuXHRcdCAqL1xuXG5cdFx0Ly8gb25seSBjaGFuZ2UgbG9jYWwgdmFyaWFibGVzXG5cdFx0d3JhcHBlci53aWR0aFNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0d2lkdGggPSB2YWx1ZTtcblx0XHR9O1xuXHRcdHdyYXBwZXIuaGVpZ2h0U2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRoZWlnaHQgPSB2YWx1ZTtcblx0XHR9O1xuXHRcdHdyYXBwZXIucGFkZGluZ1NldHRlciA9ICBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdGlmIChkZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZSAhPT0gcGFkZGluZykge1xuXHRcdFx0XHRwYWRkaW5nID0gd3JhcHBlci5wYWRkaW5nID0gdmFsdWU7XG5cdFx0XHRcdHVwZGF0ZVRleHRQYWRkaW5nKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR3cmFwcGVyLnBhZGRpbmdMZWZ0U2V0dGVyID0gIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0aWYgKGRlZmluZWQodmFsdWUpICYmIHZhbHVlICE9PSBwYWRkaW5nTGVmdCkge1xuXHRcdFx0XHRwYWRkaW5nTGVmdCA9IHZhbHVlO1xuXHRcdFx0XHR1cGRhdGVUZXh0UGFkZGluZygpO1xuXHRcdFx0fVxuXHRcdH07XG5cblxuXHRcdC8vIGNoYW5nZSBsb2NhbCB2YXJpYWJsZSBhbmQgcHJldmVudCBzZXR0aW5nIGF0dHJpYnV0ZSBvbiB0aGUgZ3JvdXBcblx0XHR3cmFwcGVyLmFsaWduU2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRhbGlnbkZhY3RvciA9IHsgbGVmdDogMCwgY2VudGVyOiAwLjUsIHJpZ2h0OiAxIH1bdmFsdWVdO1xuXHRcdH07XG5cblx0XHQvLyBhcHBseSB0aGVzZSB0byB0aGUgYm94IGFuZCB0aGUgdGV4dCBhbGlrZVxuXHRcdHdyYXBwZXIudGV4dFNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlICE9PSBVTkRFRklORUQpIHtcblx0XHRcdFx0dGV4dC50ZXh0U2V0dGVyKHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZUJveFNpemUoKTtcblx0XHRcdHVwZGF0ZVRleHRQYWRkaW5nKCk7XG5cdFx0fTtcblxuXHRcdC8vIGFwcGx5IHRoZXNlIHRvIHRoZSBib3ggYnV0IG5vdCB0byB0aGUgdGV4dFxuXHRcdHdyYXBwZXJbJ3N0cm9rZS13aWR0aFNldHRlciddID0gZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRuZWVkc0JveCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRjcmlzcEFkanVzdCA9IHZhbHVlICUgMiAvIDI7XG5cdFx0XHRib3hBdHRyKGtleSwgdmFsdWUpO1xuXHRcdH07XG5cdFx0d3JhcHBlci5zdHJva2VTZXR0ZXIgPSB3cmFwcGVyLmZpbGxTZXR0ZXIgPSB3cmFwcGVyLnJTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0aWYgKGtleSA9PT0gJ2ZpbGwnICYmIHZhbHVlKSB7XG5cdFx0XHRcdG5lZWRzQm94ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGJveEF0dHIoa2V5LCB2YWx1ZSk7XG5cdFx0fTtcblx0XHR3cmFwcGVyLmFuY2hvclhTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0YW5jaG9yWCA9IHZhbHVlO1xuXHRcdFx0Ym94QXR0cihrZXksIG1hdGhSb3VuZCh2YWx1ZSkgLSBjcmlzcEFkanVzdCAtIHdyYXBwZXJYKTtcblx0XHR9O1xuXHRcdHdyYXBwZXIuYW5jaG9yWVNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0XHRhbmNob3JZID0gdmFsdWU7XG5cdFx0XHRib3hBdHRyKGtleSwgdmFsdWUgLSB3cmFwcGVyWSk7XG5cdFx0fTtcblxuXHRcdC8vIHJlbmFtZSBhdHRyaWJ1dGVzXG5cdFx0d3JhcHBlci54U2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHR3cmFwcGVyLnggPSB2YWx1ZTsgLy8gZm9yIGFuaW1hdGlvbiBnZXR0ZXJcblx0XHRcdGlmIChhbGlnbkZhY3Rvcikge1xuXHRcdFx0XHR2YWx1ZSAtPSBhbGlnbkZhY3RvciAqICgod2lkdGggfHwgYkJveC53aWR0aCkgKyBwYWRkaW5nKTtcblx0XHRcdH1cblx0XHRcdHdyYXBwZXJYID0gbWF0aFJvdW5kKHZhbHVlKTtcblx0XHRcdHdyYXBwZXIuYXR0cigndHJhbnNsYXRlWCcsIHdyYXBwZXJYKTtcblx0XHR9O1xuXHRcdHdyYXBwZXIueVNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0d3JhcHBlclkgPSB3cmFwcGVyLnkgPSBtYXRoUm91bmQodmFsdWUpO1xuXHRcdFx0d3JhcHBlci5hdHRyKCd0cmFuc2xhdGVZJywgd3JhcHBlclkpO1xuXHRcdH07XG5cblx0XHQvLyBSZWRpcmVjdCBjZXJ0YWluIG1ldGhvZHMgdG8gZWl0aGVyIHRoZSBib3ggb3IgdGhlIHRleHRcblx0XHR2YXIgYmFzZUNzcyA9IHdyYXBwZXIuY3NzO1xuXHRcdHJldHVybiBleHRlbmQod3JhcHBlciwge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBQaWNrIHVwIHNvbWUgcHJvcGVydGllcyBhbmQgYXBwbHkgdGhlbSB0byB0aGUgdGV4dCBpbnN0ZWFkIG9mIHRoZSB3cmFwcGVyXG5cdFx0XHQgKi9cblx0XHRcdGNzczogZnVuY3Rpb24gKHN0eWxlcykge1xuXHRcdFx0XHRpZiAoc3R5bGVzKSB7XG5cdFx0XHRcdFx0dmFyIHRleHRTdHlsZXMgPSB7fTtcblx0XHRcdFx0XHRzdHlsZXMgPSBtZXJnZShzdHlsZXMpOyAvLyBjcmVhdGUgYSBjb3B5IHRvIGF2b2lkIGFsdGVyaW5nIHRoZSBvcmlnaW5hbCBvYmplY3QgKCM1MzcpXG5cdFx0XHRcdFx0ZWFjaCh3cmFwcGVyLnRleHRQcm9wcywgZnVuY3Rpb24gKHByb3ApIHtcblx0XHRcdFx0XHRcdGlmIChzdHlsZXNbcHJvcF0gIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0XHR0ZXh0U3R5bGVzW3Byb3BdID0gc3R5bGVzW3Byb3BdO1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgc3R5bGVzW3Byb3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHRleHQuY3NzKHRleHRTdHlsZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBiYXNlQ3NzLmNhbGwod3JhcHBlciwgc3R5bGVzKTtcblx0XHRcdH0sXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybiB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBib3gsIG5vdCB0aGUgZ3JvdXBcblx0XHRcdCAqL1xuXHRcdFx0Z2V0QkJveDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHdpZHRoOiBiQm94LndpZHRoICsgMiAqIHBhZGRpbmcsXG5cdFx0XHRcdFx0aGVpZ2h0OiBiQm94LmhlaWdodCArIDIgKiBwYWRkaW5nLFxuXHRcdFx0XHRcdHg6IGJCb3gueCAtIHBhZGRpbmcsXG5cdFx0XHRcdFx0eTogYkJveC55IC0gcGFkZGluZ1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdC8qKlxuXHRcdFx0ICogQXBwbHkgdGhlIHNoYWRvdyB0byB0aGUgYm94XG5cdFx0XHQgKi9cblx0XHRcdHNoYWRvdzogZnVuY3Rpb24gKGIpIHtcblx0XHRcdFx0aWYgKGJveCkge1xuXHRcdFx0XHRcdGJveC5zaGFkb3coYik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0XHR9LFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBEZXN0cm95IGFuZCByZWxlYXNlIG1lbW9yeS5cblx0XHRcdCAqL1xuXHRcdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdC8vIEFkZGVkIGJ5IGJ1dHRvbiBpbXBsZW1lbnRhdGlvblxuXHRcdFx0XHRyZW1vdmVFdmVudCh3cmFwcGVyLmVsZW1lbnQsICdtb3VzZWVudGVyJyk7XG5cdFx0XHRcdHJlbW92ZUV2ZW50KHdyYXBwZXIuZWxlbWVudCwgJ21vdXNlbGVhdmUnKTtcblxuXHRcdFx0XHRpZiAodGV4dCkge1xuXHRcdFx0XHRcdHRleHQgPSB0ZXh0LmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYm94KSB7XG5cdFx0XHRcdFx0Ym94ID0gYm94LmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBDYWxsIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gZGVzdHJveSB0aGUgcmVzdFxuXHRcdFx0XHRTVkdFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95LmNhbGwod3JhcHBlcik7XG5cblx0XHRcdFx0Ly8gUmVsZWFzZSBsb2NhbCBwb2ludGVycyAoIzEyOTgpXG5cdFx0XHRcdHdyYXBwZXIgPSByZW5kZXJlciA9IHVwZGF0ZUJveFNpemUgPSB1cGRhdGVUZXh0UGFkZGluZyA9IGJveEF0dHIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59OyAvLyBlbmQgU1ZHUmVuZGVyZXJcblxuXG4vLyBnZW5lcmFsIHJlbmRlcmVyXG5SZW5kZXJlciA9IFNWR1JlbmRlcmVyO1xuLy8gZXh0ZW5kIFN2Z0VsZW1lbnQgZm9yIHVzZUhUTUwgb3B0aW9uXG5leHRlbmQoU1ZHRWxlbWVudC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEFwcGx5IENTUyB0byBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHVzZWQgaW4gdGV4dCB3aXRoaW4gU1ZHIHJlbmRlcmluZyBhbmRcblx0ICogYnkgdGhlIFZNTCByZW5kZXJlclxuXHQgKi9cblx0aHRtbENzczogZnVuY3Rpb24gKHN0eWxlcykge1xuXHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHR0ZXh0V2lkdGggPSBzdHlsZXMgJiYgZWxlbWVudC50YWdOYW1lID09PSAnU1BBTicgJiYgc3R5bGVzLndpZHRoO1xuXG5cdFx0aWYgKHRleHRXaWR0aCkge1xuXHRcdFx0ZGVsZXRlIHN0eWxlcy53aWR0aDtcblx0XHRcdHdyYXBwZXIudGV4dFdpZHRoID0gdGV4dFdpZHRoO1xuXHRcdFx0d3JhcHBlci51cGRhdGVUcmFuc2Zvcm0oKTtcblx0XHR9XG5cdFx0aWYgKHN0eWxlcyAmJiBzdHlsZXMudGV4dE92ZXJmbG93ID09PSAnZWxsaXBzaXMnKSB7XG5cdFx0XHRzdHlsZXMud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xuXHRcdFx0c3R5bGVzLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cdFx0fVxuXHRcdHdyYXBwZXIuc3R5bGVzID0gZXh0ZW5kKHdyYXBwZXIuc3R5bGVzLCBzdHlsZXMpO1xuXHRcdGNzcyh3cmFwcGVyLmVsZW1lbnQsIHN0eWxlcyk7XG5cblx0XHRyZXR1cm4gd3JhcHBlcjtcblx0fSxcblxuXHQvKipcblx0ICogVk1MIGFuZCB1c2VIVE1MIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgdGhlIGJvdW5kaW5nIGJveCBiYXNlZCBvbiBvZmZzZXRzXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVmcmVzaCBXaGV0aGVyIHRvIGZvcmNlIGEgZnJlc2ggdmFsdWUgZnJvbSB0aGUgRE9NIG9yIHRvXG5cdCAqIHVzZSB0aGUgY2FjaGVkIHZhbHVlXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSBoYXNoIGNvbnRhaW5pbmcgdmFsdWVzIGZvciB4LCB5LCB3aWR0aCBhbmQgaGVpZ2h0XG5cdCAqL1xuXG5cdGh0bWxHZXRCQm94OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0ZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudDtcblxuXHRcdC8vIGZha2luZyBnZXRCQm94IGluIGV4cG9ydGVkIFNWRyBpbiBsZWdhY3kgSUVcblx0XHQvLyBmYWtpbmcgZ2V0QkJveCBpbiBleHBvcnRlZCBTVkcgaW4gbGVnYWN5IElFIChpcyB0aGlzIGEgZHVwbGljYXRlIG9mIHRoZSBmaXggZm9yICMxMDc5Pylcblx0XHRpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ3RleHQnKSB7XG5cdFx0XHRlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gQUJTT0xVVEU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcblx0XHRcdHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuXHRcdFx0d2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogVk1MIG92ZXJyaWRlIHByaXZhdGUgbWV0aG9kIHRvIHVwZGF0ZSBlbGVtZW50cyBiYXNlZCBvbiBpbnRlcm5hbFxuXHQgKiBwcm9wZXJ0aWVzIGJhc2VkIG9uIFNWRyB0cmFuc2Zvcm1cblx0ICovXG5cdGh0bWxVcGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbGlnbmluZyBub24gYWRkZWQgZWxlbWVudHMgaXMgZXhwZW5zaXZlXG5cdFx0aWYgKCF0aGlzLmFkZGVkKSB7XG5cdFx0XHR0aGlzLmFsaWduT25BZGQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdHJlbmRlcmVyID0gd3JhcHBlci5yZW5kZXJlcixcblx0XHRcdGVsZW0gPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHR0cmFuc2xhdGVYID0gd3JhcHBlci50cmFuc2xhdGVYIHx8IDAsXG5cdFx0XHR0cmFuc2xhdGVZID0gd3JhcHBlci50cmFuc2xhdGVZIHx8IDAsXG5cdFx0XHR4ID0gd3JhcHBlci54IHx8IDAsXG5cdFx0XHR5ID0gd3JhcHBlci55IHx8IDAsXG5cdFx0XHRhbGlnbiA9IHdyYXBwZXIudGV4dEFsaWduIHx8ICdsZWZ0Jyxcblx0XHRcdGFsaWduQ29ycmVjdGlvbiA9IHsgbGVmdDogMCwgY2VudGVyOiAwLjUsIHJpZ2h0OiAxIH1bYWxpZ25dLFxuXHRcdFx0c2hhZG93cyA9IHdyYXBwZXIuc2hhZG93cyxcblx0XHRcdHN0eWxlcyA9IHdyYXBwZXIuc3R5bGVzO1xuXG5cdFx0Ly8gYXBwbHkgdHJhbnNsYXRlXG5cdFx0Y3NzKGVsZW0sIHtcblx0XHRcdG1hcmdpbkxlZnQ6IHRyYW5zbGF0ZVgsXG5cdFx0XHRtYXJnaW5Ub3A6IHRyYW5zbGF0ZVlcblx0XHR9KTtcblx0XHRpZiAoc2hhZG93cykgeyAvLyB1c2VkIGluIGxhYmVscy90b29sdGlwXG5cdFx0XHRlYWNoKHNoYWRvd3MsIGZ1bmN0aW9uIChzaGFkb3cpIHtcblx0XHRcdFx0Y3NzKHNoYWRvdywge1xuXHRcdFx0XHRcdG1hcmdpbkxlZnQ6IHRyYW5zbGF0ZVggKyAxLFxuXHRcdFx0XHRcdG1hcmdpblRvcDogdHJhbnNsYXRlWSArIDFcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBhcHBseSBpbnZlcnNpb25cblx0XHRpZiAod3JhcHBlci5pbnZlcnRlZCkgeyAvLyB3cmFwcGVyIGlzIGEgZ3JvdXBcblx0XHRcdGVhY2goZWxlbS5jaGlsZE5vZGVzLCBmdW5jdGlvbiAoY2hpbGQpIHtcblx0XHRcdFx0cmVuZGVyZXIuaW52ZXJ0Q2hpbGQoY2hpbGQsIGVsZW0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKGVsZW0udGFnTmFtZSA9PT0gJ1NQQU4nKSB7XG5cblx0XHRcdHZhciB3aWR0aCxcblx0XHRcdFx0cm90YXRpb24gPSB3cmFwcGVyLnJvdGF0aW9uLFxuXHRcdFx0XHRiYXNlbGluZSxcblx0XHRcdFx0dGV4dFdpZHRoID0gcEludCh3cmFwcGVyLnRleHRXaWR0aCksXG5cdFx0XHRcdGN1cnJlbnRUZXh0VHJhbnNmb3JtID0gW3JvdGF0aW9uLCBhbGlnbiwgZWxlbS5pbm5lckhUTUwsIHdyYXBwZXIudGV4dFdpZHRoLCB3cmFwcGVyLnRleHRBbGlnbl0uam9pbignLCcpO1xuXG5cdFx0XHRpZiAoY3VycmVudFRleHRUcmFuc2Zvcm0gIT09IHdyYXBwZXIuY1RUKSB7IC8vIGRvIHRoZSBjYWxjdWxhdGlvbnMgYW5kIERPTSBhY2Nlc3Mgb25seSBpZiBwcm9wZXJ0aWVzIGNoYW5nZWRcblxuXG5cdFx0XHRcdGJhc2VsaW5lID0gcmVuZGVyZXIuZm9udE1ldHJpY3MoZWxlbS5zdHlsZS5mb250U2l6ZSkuYjtcblxuXHRcdFx0XHQvLyBSZW5kZXJlciBzcGVjaWZpYyBoYW5kbGluZyBvZiBzcGFuIHJvdGF0aW9uXG5cdFx0XHRcdGlmIChkZWZpbmVkKHJvdGF0aW9uKSkge1xuXHRcdFx0XHRcdHdyYXBwZXIuc2V0U3BhblJvdGF0aW9uKHJvdGF0aW9uLCBhbGlnbkNvcnJlY3Rpb24sIGJhc2VsaW5lKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHdpZHRoID0gcGljayh3cmFwcGVyLmVsZW1XaWR0aCwgZWxlbS5vZmZzZXRXaWR0aCk7XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHRleHRXaWR0aFxuXHRcdFx0XHRpZiAod2lkdGggPiB0ZXh0V2lkdGggJiYgL1sgXFwtXS8udGVzdChlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0KSkgeyAvLyAjOTgzLCAjMTI1NFxuXHRcdFx0XHRcdGNzcyhlbGVtLCB7XG5cdFx0XHRcdFx0XHR3aWR0aDogdGV4dFdpZHRoICsgUFgsXG5cdFx0XHRcdFx0XHRkaXNwbGF5OiAnYmxvY2snLFxuXHRcdFx0XHRcdFx0d2hpdGVTcGFjZTogKHN0eWxlcyAmJiBzdHlsZXMud2hpdGVTcGFjZSkgfHwgJ25vcm1hbCcgLy8gIzMzMzFcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR3aWR0aCA9IHRleHRXaWR0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHdyYXBwZXIuZ2V0U3BhbkNvcnJlY3Rpb24od2lkdGgsIGJhc2VsaW5lLCBhbGlnbkNvcnJlY3Rpb24sIHJvdGF0aW9uLCBhbGlnbik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFwcGx5IHBvc2l0aW9uIHdpdGggY29ycmVjdGlvblxuXHRcdFx0Y3NzKGVsZW0sIHtcblx0XHRcdFx0bGVmdDogKHggKyAod3JhcHBlci54Q29yciB8fCAwKSkgKyBQWCxcblx0XHRcdFx0dG9wOiAoeSArICh3cmFwcGVyLnlDb3JyIHx8IDApKSArIFBYXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gZm9yY2UgcmVmbG93IGluIHdlYmtpdCB0byBhcHBseSB0aGUgbGVmdCBhbmQgdG9wIG9uIHVzZUhUTUwgZWxlbWVudCAoIzEyNDkpXG5cdFx0XHRpZiAoaXNXZWJLaXQpIHtcblx0XHRcdFx0YmFzZWxpbmUgPSBlbGVtLm9mZnNldEhlaWdodDsgLy8gYXNzaWduZWQgdG8gYmFzZWxpbmUgZm9yIEpTTGludCBwdXJwb3NlXG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlY29yZCBjdXJyZW50IHRleHQgdHJhbnNmb3JtXG5cdFx0XHR3cmFwcGVyLmNUVCA9IGN1cnJlbnRUZXh0VHJhbnNmb3JtO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSByb3RhdGlvbiBvZiBhbiBpbmRpdmlkdWFsIEhUTUwgc3BhblxuXHQgKi9cblx0c2V0U3BhblJvdGF0aW9uOiBmdW5jdGlvbiAocm90YXRpb24sIGFsaWduQ29ycmVjdGlvbiwgYmFzZWxpbmUpIHtcblx0XHR2YXIgcm90YXRpb25TdHlsZSA9IHt9LFxuXHRcdFx0Y3NzVHJhbnNmb3JtS2V5ID0gaXNNUyA/ICctbXMtdHJhbnNmb3JtJyA6IGlzV2ViS2l0ID8gJy13ZWJraXQtdHJhbnNmb3JtJyA6IGlzRmlyZWZveCA/ICdNb3pUcmFuc2Zvcm0nIDogaXNPcGVyYSA/ICctby10cmFuc2Zvcm0nIDogJyc7XG5cblx0XHRyb3RhdGlvblN0eWxlW2Nzc1RyYW5zZm9ybUtleV0gPSByb3RhdGlvblN0eWxlLnRyYW5zZm9ybSA9ICdyb3RhdGUoJyArIHJvdGF0aW9uICsgJ2RlZyknO1xuXHRcdHJvdGF0aW9uU3R5bGVbY3NzVHJhbnNmb3JtS2V5ICsgKGlzRmlyZWZveCA/ICdPcmlnaW4nIDogJy1vcmlnaW4nKV0gPSByb3RhdGlvblN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IChhbGlnbkNvcnJlY3Rpb24gKiAxMDApICsgJyUgJyArIGJhc2VsaW5lICsgJ3B4Jztcblx0XHRjc3ModGhpcy5lbGVtZW50LCByb3RhdGlvblN0eWxlKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBjb3JyZWN0aW9uIGluIFggYW5kIFkgcG9zaXRpb25pbmcgYXMgdGhlIGVsZW1lbnQgaXMgcm90YXRlZC5cblx0ICovXG5cdGdldFNwYW5Db3JyZWN0aW9uOiBmdW5jdGlvbiAod2lkdGgsIGJhc2VsaW5lLCBhbGlnbkNvcnJlY3Rpb24pIHtcblx0XHR0aGlzLnhDb3JyID0gLXdpZHRoICogYWxpZ25Db3JyZWN0aW9uO1xuXHRcdHRoaXMueUNvcnIgPSAtYmFzZWxpbmU7XG5cdH1cbn0pO1xuXG4vLyBFeHRlbmQgU3ZnUmVuZGVyZXIgZm9yIHVzZUhUTUwgb3B0aW9uLlxuZXh0ZW5kKFNWR1JlbmRlcmVyLnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogQ3JlYXRlIEhUTUwgdGV4dCBub2RlLiBUaGlzIGlzIHVzZWQgYnkgdGhlIFZNTCByZW5kZXJlciBhcyB3ZWxsIGFzIHRoZSBTVkdcblx0ICogcmVuZGVyZXIgdGhyb3VnaCB0aGUgdXNlSFRNTCBvcHRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICovXG5cdGh0bWw6IGZ1bmN0aW9uIChzdHIsIHgsIHkpIHtcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMuY3JlYXRlRWxlbWVudCgnc3BhbicpLFxuXHRcdFx0ZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdHJlbmRlcmVyID0gd3JhcHBlci5yZW5kZXJlcjtcblxuXHRcdC8vIFRleHQgc2V0dGVyXG5cdFx0d3JhcHBlci50ZXh0U2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgIT09IGVsZW1lbnQuaW5uZXJIVE1MKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmJCb3g7XG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50LmlubmVySFRNTCA9IHRoaXMudGV4dFN0ciA9IHZhbHVlO1xuXHRcdFx0d3JhcHBlci5odG1sVXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0fTtcblxuXHRcdC8vIFZhcmlvdXMgc2V0dGVycyB3aGljaCByZWx5IG9uIHVwZGF0ZSB0cmFuc2Zvcm1cblx0XHR3cmFwcGVyLnhTZXR0ZXIgPSB3cmFwcGVyLnlTZXR0ZXIgPSB3cmFwcGVyLmFsaWduU2V0dGVyID0gd3JhcHBlci5yb3RhdGlvblNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0XHRpZiAoa2V5ID09PSAnYWxpZ24nKSB7XG5cdFx0XHRcdGtleSA9ICd0ZXh0QWxpZ24nOyAvLyBEbyBub3Qgb3ZlcndyaXRlIHRoZSBTVkdFbGVtZW50LmFsaWduIG1ldGhvZC4gU2FtZSBhcyBWTUwuXG5cdFx0XHR9XG5cdFx0XHR3cmFwcGVyW2tleV0gPSB2YWx1ZTtcblx0XHRcdHdyYXBwZXIuaHRtbFVwZGF0ZVRyYW5zZm9ybSgpO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGRlZmF1bHQgYXR0cmlidXRlc1xuXHRcdHdyYXBwZXIuYXR0cih7XG5cdFx0XHRcdHRleHQ6IHN0cixcblx0XHRcdFx0eDogbWF0aFJvdW5kKHgpLFxuXHRcdFx0XHR5OiBtYXRoUm91bmQoeSlcblx0XHRcdH0pXG5cdFx0XHQuY3NzKHtcblx0XHRcdFx0cG9zaXRpb246IEFCU09MVVRFLFxuXHRcdFx0XHRmb250RmFtaWx5OiB0aGlzLnN0eWxlLmZvbnRGYW1pbHksXG5cdFx0XHRcdGZvbnRTaXplOiB0aGlzLnN0eWxlLmZvbnRTaXplXG5cdFx0XHR9KTtcblxuXHRcdC8vIEtlZXAgdGhlIHdoaXRlU3BhY2Ugc3R5bGUgb3V0c2lkZSB0aGUgd3JhcHBlci5zdHlsZXMgY29sbGVjdGlvblxuXHRcdGVsZW1lbnQuc3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xuXG5cdFx0Ly8gVXNlIHRoZSBIVE1MIHNwZWNpZmljIC5jc3MgbWV0aG9kXG5cdFx0d3JhcHBlci5jc3MgPSB3cmFwcGVyLmh0bWxDc3M7XG5cblx0XHQvLyBUaGlzIGlzIHNwZWNpZmljIGZvciBIVE1MIHdpdGhpbiBTVkdcblx0XHRpZiAocmVuZGVyZXIuaXNTVkcpIHtcblx0XHRcdHdyYXBwZXIuYWRkID0gZnVuY3Rpb24gKHN2Z0dyb3VwV3JhcHBlcikge1xuXG5cdFx0XHRcdHZhciBodG1sR3JvdXAsXG5cdFx0XHRcdFx0Y29udGFpbmVyID0gcmVuZGVyZXIuYm94LnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0cGFyZW50R3JvdXAsXG5cdFx0XHRcdFx0cGFyZW50cyA9IFtdO1xuXG5cdFx0XHRcdHRoaXMucGFyZW50R3JvdXAgPSBzdmdHcm91cFdyYXBwZXI7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIGEgbW9jayBncm91cCB0byBob2xkIHRoZSBIVE1MIGVsZW1lbnRzXG5cdFx0XHRcdGlmIChzdmdHcm91cFdyYXBwZXIpIHtcblx0XHRcdFx0XHRodG1sR3JvdXAgPSBzdmdHcm91cFdyYXBwZXIuZGl2O1xuXHRcdFx0XHRcdGlmICghaHRtbEdyb3VwKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlYWQgdGhlIHBhcmVudCBjaGFpbiBpbnRvIGFuIGFycmF5IGFuZCByZWFkIGZyb20gdG9wIGRvd25cblx0XHRcdFx0XHRcdHBhcmVudEdyb3VwID0gc3ZnR3JvdXBXcmFwcGVyO1xuXHRcdFx0XHRcdFx0d2hpbGUgKHBhcmVudEdyb3VwKSB7XG5cblx0XHRcdFx0XHRcdFx0cGFyZW50cy5wdXNoKHBhcmVudEdyb3VwKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBNb3ZlIHVwIHRvIHRoZSBuZXh0IHBhcmVudCBncm91cFxuXHRcdFx0XHRcdFx0XHRwYXJlbnRHcm91cCA9IHBhcmVudEdyb3VwLnBhcmVudEdyb3VwO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBFbnN1cmUgZHluYW1pY2FsbHkgdXBkYXRpbmcgcG9zaXRpb24gd2hlbiBhbnkgcGFyZW50IGlzIHRyYW5zbGF0ZWRcblx0XHRcdFx0XHRcdGVhY2gocGFyZW50cy5yZXZlcnNlKCksIGZ1bmN0aW9uIChwYXJlbnRHcm91cCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaHRtbEdyb3VwU3R5bGUsXG5cdFx0XHRcdFx0XHRcdFx0Y2xzID0gYXR0cihwYXJlbnRHcm91cC5lbGVtZW50LCAnY2xhc3MnKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoY2xzKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xzID0geyBjbGFzc05hbWU6IGNscyB9O1xuXHRcdFx0XHRcdFx0XHR9IC8vIGVsc2UgbnVsbFxuXG5cdFx0XHRcdFx0XHRcdC8vIENyZWF0ZSBhIEhUTUwgZGl2IGFuZCBhcHBlbmQgaXQgdG8gdGhlIHBhcmVudCBkaXYgdG8gZW11bGF0ZVxuXHRcdFx0XHRcdFx0XHQvLyB0aGUgU1ZHIGdyb3VwIHN0cnVjdHVyZVxuXHRcdFx0XHRcdFx0XHRodG1sR3JvdXAgPSBwYXJlbnRHcm91cC5kaXYgPSBwYXJlbnRHcm91cC5kaXYgfHwgY3JlYXRlRWxlbWVudChESVYsIGNscywge1xuXHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdFx0XHRcdFx0XHRsZWZ0OiAocGFyZW50R3JvdXAudHJhbnNsYXRlWCB8fCAwKSArIFBYLFxuXHRcdFx0XHRcdFx0XHRcdHRvcDogKHBhcmVudEdyb3VwLnRyYW5zbGF0ZVkgfHwgMCkgKyBQWFxuXHRcdFx0XHRcdFx0XHR9LCBodG1sR3JvdXAgfHwgY29udGFpbmVyKTsgLy8gdGhlIHRvcCBncm91cCBpcyBhcHBlbmRlZCB0byBjb250YWluZXJcblxuXHRcdFx0XHRcdFx0XHQvLyBTaG9ydGN1dFxuXHRcdFx0XHRcdFx0XHRodG1sR3JvdXBTdHlsZSA9IGh0bWxHcm91cC5zdHlsZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZXQgbGlzdGVuZXJzIHRvIHVwZGF0ZSB0aGUgSFRNTCBkaXYncyBwb3NpdGlvbiB3aGVuZXZlciB0aGUgU1ZHIGdyb3VwXG5cdFx0XHRcdFx0XHRcdC8vIHBvc2l0aW9uIGlzIGNoYW5nZWRcblx0XHRcdFx0XHRcdFx0ZXh0ZW5kKHBhcmVudEdyb3VwLCB7XG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNsYXRlWFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGh0bWxHcm91cFN0eWxlLmxlZnQgPSB2YWx1ZSArIFBYO1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50R3JvdXBba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50R3JvdXAuZG9UcmFuc2Zvcm0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNsYXRlWVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGh0bWxHcm91cFN0eWxlLnRvcCA9IHZhbHVlICsgUFg7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnRHcm91cFtrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnRHcm91cC5kb1RyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBzZXQgYXMgYXR0cmlidXRlcyBvbiB0aGUgU1ZHIGdyb3VwLCBhbmQgYXNcblx0XHRcdFx0XHRcdFx0Ly8gaWRlbnRpY2FsIENTUyBwcm9wZXJ0aWVzIG9uIHRoZSBkaXYuICgjMzU0Milcblx0XHRcdFx0XHRcdFx0ZWFjaChbJ29wYWNpdHknLCAndmlzaWJpbGl0eSddLCBmdW5jdGlvbiAocHJvcCkge1xuXHRcdFx0XHRcdFx0XHRcdHdyYXAocGFyZW50R3JvdXAsIHByb3AgKyAnU2V0dGVyJywgZnVuY3Rpb24gKHByb2NlZWQsIHZhbHVlLCBrZXksIGVsZW0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2NlZWQuY2FsbCh0aGlzLCB2YWx1ZSwga2V5LCBlbGVtKTtcblx0XHRcdFx0XHRcdFx0XHRcdGh0bWxHcm91cFN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRodG1sR3JvdXAgPSBjb250YWluZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRodG1sR3JvdXAuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cblx0XHRcdFx0Ly8gU2hhcmVkIHdpdGggVk1MOlxuXHRcdFx0XHR3cmFwcGVyLmFkZGVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHdyYXBwZXIuYWxpZ25PbkFkZCkge1xuXHRcdFx0XHRcdHdyYXBwZXIuaHRtbFVwZGF0ZVRyYW5zZm9ybSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gd3JhcHBlcjtcblx0fVxufSk7XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIFNUQVJUIE9GIElOVEVSTkVUIEVYUExPUkVSIDw9IDggU1BFQ0lGSUMgQ09ERSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIEZvciBhcHBsaWNhdGlvbnMgYW5kIHdlYnNpdGVzIHRoYXQgZG9uJ3QgbmVlZCBJRSBzdXBwb3J0LCBsaWtlIHBsYXRmb3JtICAgICpcbiAqIHRhcmdldGVkIG1vYmlsZSBhcHBzIGFuZCB3ZWIgYXBwcywgdGhpcyBjb2RlIGNhbiBiZSByZW1vdmVkLiAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFZNTFJlbmRlcmVyLCBWTUxFbGVtZW50O1xuaWYgKCFoYXNTVkcgJiYgIXVzZUNhblZHKSB7XG5cbi8qKlxuICogVGhlIFZNTCBlbGVtZW50IHdyYXBwZXIuXG4gKi9cblZNTEVsZW1lbnQgPSB7XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgYSBuZXcgVk1MIGVsZW1lbnQgd3JhcHBlci4gSXQgYnVpbGRzIHRoZSBtYXJrdXAgYXMgYSBzdHJpbmdcblx0ICogdG8gbWluaW1pemUgRE9NIHRyYWZmaWMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJlclxuXHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZU5hbWVcblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uIChyZW5kZXJlciwgbm9kZU5hbWUpIHtcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRtYXJrdXAgPSAgWyc8Jywgbm9kZU5hbWUsICcgZmlsbGVkPVwiZlwiIHN0cm9rZWQ9XCJmXCInXSxcblx0XHRcdHN0eWxlID0gWydwb3NpdGlvbjogJywgQUJTT0xVVEUsICc7J10sXG5cdFx0XHRpc0RpdiA9IG5vZGVOYW1lID09PSBESVY7XG5cblx0XHQvLyBkaXZzIGFuZCBzaGFwZXMgbmVlZCBzaXplXG5cdFx0aWYgKG5vZGVOYW1lID09PSAnc2hhcGUnIHx8IGlzRGl2KSB7XG5cdFx0XHRzdHlsZS5wdXNoKCdsZWZ0OjA7dG9wOjA7d2lkdGg6MXB4O2hlaWdodDoxcHg7Jyk7XG5cdFx0fVxuXHRcdHN0eWxlLnB1c2goJ3Zpc2liaWxpdHk6ICcsIGlzRGl2ID8gSElEREVOIDogVklTSUJMRSk7XG5cblx0XHRtYXJrdXAucHVzaCgnIHN0eWxlPVwiJywgc3R5bGUuam9pbignJyksICdcIi8+Jyk7XG5cblx0XHQvLyBjcmVhdGUgZWxlbWVudCB3aXRoIGRlZmF1bHQgYXR0cmlidXRlcyBhbmQgc3R5bGVcblx0XHRpZiAobm9kZU5hbWUpIHtcblx0XHRcdG1hcmt1cCA9IGlzRGl2IHx8IG5vZGVOYW1lID09PSAnc3BhbicgfHwgbm9kZU5hbWUgPT09ICdpbWcnID9cblx0XHRcdFx0bWFya3VwLmpvaW4oJycpXG5cdFx0XHRcdDogcmVuZGVyZXIucHJlcFZNTChtYXJrdXApO1xuXHRcdFx0d3JhcHBlci5lbGVtZW50ID0gY3JlYXRlRWxlbWVudChtYXJrdXApO1xuXHRcdH1cblxuXHRcdHdyYXBwZXIucmVuZGVyZXIgPSByZW5kZXJlcjtcblx0fSxcblxuXHQvKipcblx0ICogQWRkIHRoZSBub2RlIHRvIHRoZSBnaXZlbiBwYXJlbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuXHQgKi9cblx0YWRkOiBmdW5jdGlvbiAocGFyZW50KSB7XG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0cmVuZGVyZXIgPSB3cmFwcGVyLnJlbmRlcmVyLFxuXHRcdFx0ZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdGJveCA9IHJlbmRlcmVyLmJveCxcblx0XHRcdGludmVydGVkID0gcGFyZW50ICYmIHBhcmVudC5pbnZlcnRlZCxcblxuXHRcdFx0Ly8gZ2V0IHRoZSBwYXJlbnQgbm9kZVxuXHRcdFx0cGFyZW50Tm9kZSA9IHBhcmVudCA/XG5cdFx0XHRcdHBhcmVudC5lbGVtZW50IHx8IHBhcmVudCA6XG5cdFx0XHRcdGJveDtcblxuXG5cdFx0Ly8gaWYgdGhlIHBhcmVudCBncm91cCBpcyBpbnZlcnRlZCwgYXBwbHkgaW52ZXJzaW9uIG9uIGFsbCBjaGlsZHJlblxuXHRcdGlmIChpbnZlcnRlZCkgeyAvLyBvbmx5IG9uIGdyb3Vwc1xuXHRcdFx0cmVuZGVyZXIuaW52ZXJ0Q2hpbGQoZWxlbWVudCwgcGFyZW50Tm9kZSk7XG5cdFx0fVxuXG5cdFx0Ly8gYXBwZW5kIGl0XG5cdFx0cGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuXHRcdC8vIGFsaWduIHRleHQgYWZ0ZXIgYWRkaW5nIHRvIGJlIGFibGUgdG8gcmVhZCBvZmZzZXRcblx0XHR3cmFwcGVyLmFkZGVkID0gdHJ1ZTtcblx0XHRpZiAod3JhcHBlci5hbGlnbk9uQWRkICYmICF3cmFwcGVyLmRlZmVyVXBkYXRlVHJhbnNmb3JtKSB7XG5cdFx0XHR3cmFwcGVyLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXHRcdH1cblxuXHRcdC8vIGZpcmUgYW4gZXZlbnQgZm9yIGludGVybmFsIGhvb2tzXG5cdFx0aWYgKHdyYXBwZXIub25BZGQpIHtcblx0XHRcdHdyYXBwZXIub25BZGQoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gd3JhcHBlcjtcblx0fSxcblxuXHQvKipcblx0ICogVk1MIGFsd2F5cyB1c2VzIGh0bWxVcGRhdGVUcmFuc2Zvcm1cblx0ICovXG5cdHVwZGF0ZVRyYW5zZm9ybTogU1ZHRWxlbWVudC5wcm90b3R5cGUuaHRtbFVwZGF0ZVRyYW5zZm9ybSxcblxuXHQvKipcblx0ICogU2V0IHRoZSByb3RhdGlvbiBvZiBhIHNwYW4gd2l0aCBvbGRJRSdzIGZpbHRlclxuXHQgKi9cblx0c2V0U3BhblJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQWRqdXN0IGZvciBhbGlnbm1lbnQgYW5kIHJvdGF0aW9uLiBSb3RhdGlvbiBvZiB1c2VIVE1MIGNvbnRlbnQgaXMgbm90IHlldCBpbXBsZW1lbnRlZFxuXHRcdC8vIGJ1dCBpdCBjYW4gcHJvYmFibHkgYmUgaW1wbGVtZW50ZWQgZm9yIEZpcmVmb3ggMy41KyBvbiB1c2VyIHJlcXVlc3QuIEZGMy41K1xuXHRcdC8vIGhhcyBzdXBwb3J0IGZvciBDU1MzIHRyYW5zZm9ybS4gVGhlIGdldEJCb3ggbWV0aG9kIGFsc28gbmVlZHMgdG8gYmUgdXBkYXRlZFxuXHRcdC8vIHRvIGNvbXBlbnNhdGUgZm9yIHRoZSByb3RhdGlvbiwgbGlrZSBpdCBjdXJyZW50bHkgZG9lcyBmb3IgU1ZHLlxuXHRcdC8vIFRlc3QgY2FzZTogaHR0cDovL2pzZmlkZGxlLm5ldC9oaWdoY2hhcnRzL1lidDQ0L1xuXG5cdFx0dmFyIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbixcblx0XHRcdGNvc3RoZXRhID0gbWF0aENvcyhyb3RhdGlvbiAqIGRlZzJyYWQpLFxuXHRcdFx0c2ludGhldGEgPSBtYXRoU2luKHJvdGF0aW9uICogZGVnMnJhZCk7XG5cdFx0XHRcdFx0XG5cdFx0Y3NzKHRoaXMuZWxlbWVudCwge1xuXHRcdFx0ZmlsdGVyOiByb3RhdGlvbiA/IFsncHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9JywgY29zdGhldGEsXG5cdFx0XHRcdCcsIE0xMj0nLCAtc2ludGhldGEsICcsIE0yMT0nLCBzaW50aGV0YSwgJywgTTIyPScsIGNvc3RoZXRhLFxuXHRcdFx0XHQnLCBzaXppbmdNZXRob2Q9XFwnYXV0byBleHBhbmRcXCcpJ10uam9pbignJykgOiBOT05FXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgcG9zaXRpb25pbmcgY29ycmVjdGlvbiBmb3IgdGhlIHNwYW4gYWZ0ZXIgcm90YXRpbmcuIFxuXHQgKi9cblx0Z2V0U3BhbkNvcnJlY3Rpb246IGZ1bmN0aW9uICh3aWR0aCwgYmFzZWxpbmUsIGFsaWduQ29ycmVjdGlvbiwgcm90YXRpb24sIGFsaWduKSB7XG5cblx0XHR2YXIgY29zdGhldGEgPSByb3RhdGlvbiA/IG1hdGhDb3Mocm90YXRpb24gKiBkZWcycmFkKSA6IDEsXG5cdFx0XHRzaW50aGV0YSA9IHJvdGF0aW9uID8gbWF0aFNpbihyb3RhdGlvbiAqIGRlZzJyYWQpIDogMCxcblx0XHRcdGhlaWdodCA9IHBpY2sodGhpcy5lbGVtSGVpZ2h0LCB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0KSxcblx0XHRcdHF1YWQsXG5cdFx0XHRub25MZWZ0ID0gYWxpZ24gJiYgYWxpZ24gIT09ICdsZWZ0JztcblxuXHRcdC8vIGNvcnJlY3QgeCBhbmQgeVxuXHRcdHRoaXMueENvcnIgPSBjb3N0aGV0YSA8IDAgJiYgLXdpZHRoO1xuXHRcdHRoaXMueUNvcnIgPSBzaW50aGV0YSA8IDAgJiYgLWhlaWdodDtcblxuXHRcdC8vIGNvcnJlY3QgZm9yIGJhc2VsaW5lIGFuZCBjb3JuZXJzIHNwaWxsaW5nIG91dCBhZnRlciByb3RhdGlvblxuXHRcdHF1YWQgPSBjb3N0aGV0YSAqIHNpbnRoZXRhIDwgMDtcblx0XHR0aGlzLnhDb3JyICs9IHNpbnRoZXRhICogYmFzZWxpbmUgKiAocXVhZCA/IDEgLSBhbGlnbkNvcnJlY3Rpb24gOiBhbGlnbkNvcnJlY3Rpb24pO1xuXHRcdHRoaXMueUNvcnIgLT0gY29zdGhldGEgKiBiYXNlbGluZSAqIChyb3RhdGlvbiA/IChxdWFkID8gYWxpZ25Db3JyZWN0aW9uIDogMSAtIGFsaWduQ29ycmVjdGlvbikgOiAxKTtcblx0XHQvLyBjb3JyZWN0IGZvciB0aGUgbGVuZ3RoL2hlaWdodCBvZiB0aGUgdGV4dFxuXHRcdGlmIChub25MZWZ0KSB7XG5cdFx0XHR0aGlzLnhDb3JyIC09IHdpZHRoICogYWxpZ25Db3JyZWN0aW9uICogKGNvc3RoZXRhIDwgMCA/IC0xIDogMSk7XG5cdFx0XHRpZiAocm90YXRpb24pIHtcblx0XHRcdFx0dGhpcy55Q29yciAtPSBoZWlnaHQgKiBhbGlnbkNvcnJlY3Rpb24gKiAoc2ludGhldGEgPCAwID8gLTEgOiAxKTtcblx0XHRcdH1cblx0XHRcdGNzcyh0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0dGV4dEFsaWduOiBhbGlnblxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN1YnNldCBvZiBhbiBTVkcgcGF0aCBkZWZpbml0aW9uIHRvIGl0cyBWTUwgY291bnRlcnBhcnQuIFRha2VzIGFuIGFycmF5XG5cdCAqIGFzIHRoZSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgYSBzdHJpbmcuXG5cdCAqL1xuXHRwYXRoVG9WTUw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdC8vIGNvbnZlcnQgcGF0aHNcblx0XHR2YXIgaSA9IHZhbHVlLmxlbmd0aCxcblx0XHRcdHBhdGggPSBbXTtcblxuXHRcdHdoaWxlIChpLS0pIHtcblxuXHRcdFx0Ly8gTXVsdGlwbHkgYnkgMTAgdG8gYWxsb3cgc3VicGl4ZWwgcHJlY2lzaW9uLlxuXHRcdFx0Ly8gU3Vic3RyYWN0aW5nIGhhbGYgYSBwaXhlbCBzZWVtcyB0byBtYWtlIHRoZSBjb29yZGluYXRlc1xuXHRcdFx0Ly8gYWxpZ24gd2l0aCBTVkcsIGJ1dCB0aGlzIGhhc24ndCBiZWVuIHRlc3RlZCB0aG9yb3VnaGx5XG5cdFx0XHRpZiAoaXNOdW1iZXIodmFsdWVbaV0pKSB7XG5cdFx0XHRcdHBhdGhbaV0gPSBtYXRoUm91bmQodmFsdWVbaV0gKiAxMCkgLSA1O1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZVtpXSA9PT0gJ1onKSB7IC8vIGNsb3NlIHRoZSBwYXRoXG5cdFx0XHRcdHBhdGhbaV0gPSAneCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoW2ldID0gdmFsdWVbaV07XG5cblx0XHRcdFx0Ly8gV2hlbiB0aGUgc3RhcnQgWCBhbmQgZW5kIFggY29vcmRpbmF0ZXMgb2YgYW4gYXJjIGFyZSB0b28gY2xvc2UsXG5cdFx0XHRcdC8vIHRoZXkgYXJlIHJvdW5kZWQgdG8gdGhlIHNhbWUgdmFsdWUgYWJvdmUuIEluIHRoaXMgY2FzZSwgc3Vic3RyYWN0IG9yIFxuXHRcdFx0XHQvLyBhZGQgMSBmcm9tIHRoZSBlbmQgWCBhbmQgWSBwb3NpdGlvbnMuICMxODYsICM3NjAsICMxMzcxLCAjMTQxMC5cblx0XHRcdFx0aWYgKHZhbHVlLmlzQXJjICYmICh2YWx1ZVtpXSA9PT0gJ3dhJyB8fCB2YWx1ZVtpXSA9PT0gJ2F0JykpIHtcblx0XHRcdFx0XHQvLyBTdGFydCBhbmQgZW5kIFhcblx0XHRcdFx0XHRpZiAocGF0aFtpICsgNV0gPT09IHBhdGhbaSArIDddKSB7XG5cdFx0XHRcdFx0XHRwYXRoW2kgKyA3XSArPSB2YWx1ZVtpICsgN10gPiB2YWx1ZVtpICsgNV0gPyAxIDogLTE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFN0YXJ0IGFuZCBlbmQgWVxuXHRcdFx0XHRcdGlmIChwYXRoW2kgKyA2XSA9PT0gcGF0aFtpICsgOF0pIHtcblx0XHRcdFx0XHRcdHBhdGhbaSArIDhdICs9IHZhbHVlW2kgKyA4XSA+IHZhbHVlW2kgKyA2XSA/IDEgOiAtMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRcblx0XHQvLyBMb29wIHVwIGFnYWluIHRvIGhhbmRsZSBwYXRoIHNob3J0Y3V0cyAoIzIxMzIpXG5cdFx0Lyp3aGlsZSAoaSsrIDwgcGF0aC5sZW5ndGgpIHtcblx0XHRcdGlmIChwYXRoW2ldID09PSAnSCcpIHsgLy8gaG9yaXpvbnRhbCBsaW5lIHRvXG5cdFx0XHRcdHBhdGhbaV0gPSAnTCc7XG5cdFx0XHRcdHBhdGguc3BsaWNlKGkgKyAyLCAwLCBwYXRoW2kgLSAxXSk7XG5cdFx0XHR9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICdWJykgeyAvLyB2ZXJ0aWNhbCBsaW5lIHRvXG5cdFx0XHRcdHBhdGhbaV0gPSAnTCc7XG5cdFx0XHRcdHBhdGguc3BsaWNlKGkgKyAxLCAwLCBwYXRoW2kgLSAyXSk7XG5cdFx0XHR9XG5cdFx0fSovXG5cdFx0cmV0dXJuIHBhdGguam9pbignICcpIHx8ICd4Jztcblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSBlbGVtZW50J3MgY2xpcHBpbmcgdG8gYSBwcmVkZWZpbmVkIHJlY3RhbmdsZVxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBjbGlwIHJlY3RhbmdsZVxuXHQgKi9cblx0Y2xpcDogZnVuY3Rpb24gKGNsaXBSZWN0KSB7XG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0Y2xpcE1lbWJlcnMsXG5cdFx0XHRjc3NSZXQ7XG5cblx0XHRpZiAoY2xpcFJlY3QpIHtcblx0XHRcdGNsaXBNZW1iZXJzID0gY2xpcFJlY3QubWVtYmVycztcblx0XHRcdGVyYXNlKGNsaXBNZW1iZXJzLCB3cmFwcGVyKTsgLy8gRW5zdXJlIHVuaXF1ZSBsaXN0IG9mIGVsZW1lbnRzICgjMTI1OClcblx0XHRcdGNsaXBNZW1iZXJzLnB1c2god3JhcHBlcik7XG5cdFx0XHR3cmFwcGVyLmRlc3Ryb3lDbGlwID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRlcmFzZShjbGlwTWVtYmVycywgd3JhcHBlcik7XG5cdFx0XHR9O1xuXHRcdFx0Y3NzUmV0ID0gY2xpcFJlY3QuZ2V0Q1NTKHdyYXBwZXIpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh3cmFwcGVyLmRlc3Ryb3lDbGlwKSB7XG5cdFx0XHRcdHdyYXBwZXIuZGVzdHJveUNsaXAoKTtcblx0XHRcdH1cblx0XHRcdGNzc1JldCA9IHsgY2xpcDogZG9jTW9kZTggPyAnaW5oZXJpdCcgOiAncmVjdChhdXRvKScgfTsgLy8gIzEyMTRcblx0XHR9XG5cblx0XHRyZXR1cm4gd3JhcHBlci5jc3MoY3NzUmV0KTtcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgc3R5bGVzIGZvciB0aGUgZWxlbWVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG5cdCAqL1xuXHRjc3M6IFNWR0VsZW1lbnQucHJvdG90eXBlLmh0bWxDc3MsXG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSBjaGlsZCBlaXRoZXIgYnkgcmVtb3ZlQ2hpbGQgb3IgbW92ZSB0byBnYXJiYWdlQmluLlxuXHQgKiBJc3N1ZSA0OTA7IGluIFZNTCByZW1vdmVDaGlsZCByZXN1bHRzIGluIE9ycGhhbmVkIG5vZGVzIGFjY29yZGluZyB0byBzSUV2ZSwgZGlzY2FyZEVsZW1lbnQgZG9lcyBub3QuXG5cdCAqL1xuXHRzYWZlUmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0Ly8gZGlzY2FyZEVsZW1lbnQgd2lsbCBkZXRhY2ggdGhlIG5vZGUgZnJvbSBpdHMgcGFyZW50IGJlZm9yZSBhdHRhY2hpbmcgaXRcblx0XHQvLyB0byB0aGUgZ2FyYmFnZSBiaW4uIFRoZXJlZm9yZSBpdCBpcyBpbXBvcnRhbnQgdGhhdCB0aGUgbm9kZSBpcyBhdHRhY2hlZCBhbmQgaGF2ZSBwYXJlbnQuXG5cdFx0aWYgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuXHRcdFx0ZGlzY2FyZEVsZW1lbnQoZWxlbWVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBFeHRlbmQgZWxlbWVudC5kZXN0cm95IGJ5IHJlbW92aW5nIGl0IGZyb20gdGhlIGNsaXAgbWVtYmVycyBhcnJheVxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLmRlc3Ryb3lDbGlwKSB7XG5cdFx0XHR0aGlzLmRlc3Ryb3lDbGlwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFNWR0VsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kuYXBwbHkodGhpcyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZCBhbiBldmVudCBsaXN0ZW5lci4gVk1MIG92ZXJyaWRlIGZvciBub3JtYWxpemluZyBldmVudCBwYXJhbWV0ZXJzLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcblx0ICovXG5cdG9uOiBmdW5jdGlvbiAoZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG5cdFx0Ly8gc2ltcGxlc3QgcG9zc2libGUgZXZlbnQgbW9kZWwgZm9yIGludGVybmFsIHVzZVxuXHRcdHRoaXMuZWxlbWVudFsnb24nICsgZXZlbnRUeXBlXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBldnQgPSB3aW4uZXZlbnQ7XG5cdFx0XHRldnQudGFyZ2V0ID0gZXZ0LnNyY0VsZW1lbnQ7XG5cdFx0XHRoYW5kbGVyKGV2dCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogSW4gc3RhY2tlZCBjb2x1bW5zLCBjdXQgb2ZmIHRoZSBzaGFkb3dzIHNvIHRoYXQgdGhleSBkb24ndCBvdmVybGFwXG5cdCAqL1xuXHRjdXRPZmZQYXRoOiBmdW5jdGlvbiAocGF0aCwgbGVuZ3RoKSB7XG5cblx0XHR2YXIgbGVuO1xuXG5cdFx0cGF0aCA9IHBhdGguc3BsaXQoL1sgLF0vKTtcblx0XHRsZW4gPSBwYXRoLmxlbmd0aDtcblxuXHRcdGlmIChsZW4gPT09IDkgfHwgbGVuID09PSAxMSkge1xuXHRcdFx0cGF0aFtsZW4gLSA0XSA9IHBhdGhbbGVuIC0gMl0gPSBwSW50KHBhdGhbbGVuIC0gMl0pIC0gMTAgKiBsZW5ndGg7XG5cdFx0fVxuXHRcdHJldHVybiBwYXRoLmpvaW4oJyAnKTtcblx0fSxcblxuXHQvKipcblx0ICogQXBwbHkgYSBkcm9wIHNoYWRvdyBieSBjb3B5aW5nIGVsZW1lbnRzIGFuZCBnaXZpbmcgdGhlbSBkaWZmZXJlbnQgc3Ryb2tlc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBzaGFkb3dPcHRpb25zXG5cdCAqL1xuXHRzaGFkb3c6IGZ1bmN0aW9uIChzaGFkb3dPcHRpb25zLCBncm91cCwgY3V0T2ZmKSB7XG5cdFx0dmFyIHNoYWRvd3MgPSBbXSxcblx0XHRcdGksXG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuXHRcdFx0c2hhZG93LFxuXHRcdFx0ZWxlbVN0eWxlID0gZWxlbWVudC5zdHlsZSxcblx0XHRcdG1hcmt1cCxcblx0XHRcdHBhdGggPSBlbGVtZW50LnBhdGgsXG5cdFx0XHRzdHJva2VXaWR0aCxcblx0XHRcdG1vZGlmaWVkUGF0aCxcblx0XHRcdHNoYWRvd1dpZHRoLFxuXHRcdFx0c2hhZG93RWxlbWVudE9wYWNpdHk7XG5cblx0XHQvLyBzb21lIHRpbWVzIGVtcHR5IHBhdGhzIGFyZSBub3Qgc3RyaW5nc1xuXHRcdGlmIChwYXRoICYmIHR5cGVvZiBwYXRoLnZhbHVlICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cGF0aCA9ICd4Jztcblx0XHR9XG5cdFx0bW9kaWZpZWRQYXRoID0gcGF0aDtcblxuXHRcdGlmIChzaGFkb3dPcHRpb25zKSB7XG5cdFx0XHRzaGFkb3dXaWR0aCA9IHBpY2soc2hhZG93T3B0aW9ucy53aWR0aCwgMyk7XG5cdFx0XHRzaGFkb3dFbGVtZW50T3BhY2l0eSA9IChzaGFkb3dPcHRpb25zLm9wYWNpdHkgfHwgMC4xNSkgLyBzaGFkb3dXaWR0aDtcblx0XHRcdGZvciAoaSA9IDE7IGkgPD0gMzsgaSsrKSB7XG5cblx0XHRcdFx0c3Ryb2tlV2lkdGggPSAoc2hhZG93V2lkdGggKiAyKSArIDEgLSAoMiAqIGkpO1xuXG5cdFx0XHRcdC8vIEN1dCBvZmYgc2hhZG93cyBmb3Igc3RhY2tlZCBjb2x1bW4gaXRlbXNcblx0XHRcdFx0aWYgKGN1dE9mZikge1xuXHRcdFx0XHRcdG1vZGlmaWVkUGF0aCA9IHRoaXMuY3V0T2ZmUGF0aChwYXRoLnZhbHVlLCBzdHJva2VXaWR0aCArIDAuNSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXJrdXAgPSBbJzxzaGFwZSBpc1NoYWRvdz1cInRydWVcIiBzdHJva2V3ZWlnaHQ9XCInLCBzdHJva2VXaWR0aCxcblx0XHRcdFx0XHQnXCIgZmlsbGVkPVwiZmFsc2VcIiBwYXRoPVwiJywgbW9kaWZpZWRQYXRoLFxuXHRcdFx0XHRcdCdcIiBjb29yZHNpemU9XCIxMCAxMFwiIHN0eWxlPVwiJywgZWxlbWVudC5zdHlsZS5jc3NUZXh0LCAnXCIgLz4nXTtcblxuXHRcdFx0XHRzaGFkb3cgPSBjcmVhdGVFbGVtZW50KHJlbmRlcmVyLnByZXBWTUwobWFya3VwKSxcblx0XHRcdFx0XHRudWxsLCB7XG5cdFx0XHRcdFx0XHRsZWZ0OiBwSW50KGVsZW1TdHlsZS5sZWZ0KSArIHBpY2soc2hhZG93T3B0aW9ucy5vZmZzZXRYLCAxKSxcblx0XHRcdFx0XHRcdHRvcDogcEludChlbGVtU3R5bGUudG9wKSArIHBpY2soc2hhZG93T3B0aW9ucy5vZmZzZXRZLCAxKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKGN1dE9mZikge1xuXHRcdFx0XHRcdHNoYWRvdy5jdXRPZmYgPSBzdHJva2VXaWR0aCArIDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhcHBseSB0aGUgb3BhY2l0eVxuXHRcdFx0XHRtYXJrdXAgPSBbJzxzdHJva2UgY29sb3I9XCInLCBzaGFkb3dPcHRpb25zLmNvbG9yIHx8ICdibGFjaycsICdcIiBvcGFjaXR5PVwiJywgc2hhZG93RWxlbWVudE9wYWNpdHkgKiBpLCAnXCIvPiddO1xuXHRcdFx0XHRjcmVhdGVFbGVtZW50KHJlbmRlcmVyLnByZXBWTUwobWFya3VwKSwgbnVsbCwgbnVsbCwgc2hhZG93KTtcblxuXG5cdFx0XHRcdC8vIGluc2VydCBpdFxuXHRcdFx0XHRpZiAoZ3JvdXApIHtcblx0XHRcdFx0XHRncm91cC5lbGVtZW50LmFwcGVuZENoaWxkKHNoYWRvdyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzaGFkb3csIGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVjb3JkIGl0XG5cdFx0XHRcdHNoYWRvd3MucHVzaChzaGFkb3cpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2hhZG93cyA9IHNoYWRvd3M7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHR1cGRhdGVTaGFkb3dzOiBub29wLCAvLyBVc2VkIGluIFNWRyBvbmx5XG5cblx0c2V0QXR0cjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRpZiAoZG9jTW9kZTgpIHsgLy8gSUU4IHNldEF0dHJpYnV0ZSBidWdcblx0XHRcdHRoaXMuZWxlbWVudFtrZXldID0gdmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG5cdFx0fVxuXHR9LFxuXHRjbGFzc1NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0Ly8gSUU4IFN0YW5kYXJkcyBtb2RlIGhhcyBwcm9ibGVtcyByZXRyaWV2aW5nIHRoZSBjbGFzc05hbWUgdW5sZXNzIHNldCBsaWtlIHRoaXNcblx0XHR0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gdmFsdWU7XG5cdH0sXG5cdGRhc2hzdHlsZVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHR2YXIgc3Ryb2tlRWxlbSA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0cm9rZScpWzBdIHx8XG5cdFx0XHRjcmVhdGVFbGVtZW50KHRoaXMucmVuZGVyZXIucHJlcFZNTChbJzxzdHJva2UvPiddKSwgbnVsbCwgbnVsbCwgZWxlbWVudCk7XG5cdFx0c3Ryb2tlRWxlbVtrZXldID0gdmFsdWUgfHwgJ3NvbGlkJztcblx0XHR0aGlzW2tleV0gPSB2YWx1ZTsgLyogYmVjYXVzZSBjaGFuZ2luZyBzdHJva2Utd2lkdGggd2lsbCBjaGFuZ2UgdGhlIGRhc2ggbGVuZ3RoXG5cdFx0XHRhbmQgY2F1c2UgYW4gZXBpbGVwdGljIGVmZmVjdCAqL1xuXHR9LFxuXHRkU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdHZhciBpLFxuXHRcdFx0c2hhZG93cyA9IHRoaXMuc2hhZG93cztcblx0XHR2YWx1ZSA9IHZhbHVlIHx8IFtdO1xuXHRcdHRoaXMuZCA9IHZhbHVlLmpvaW4gJiYgdmFsdWUuam9pbignICcpOyAvLyB1c2VkIGluIGdldHRlciBmb3IgYW5pbWF0aW9uXG5cblx0XHRlbGVtZW50LnBhdGggPSB2YWx1ZSA9IHRoaXMucGF0aFRvVk1MKHZhbHVlKTtcblxuXHRcdC8vIHVwZGF0ZSBzaGFkb3dzXG5cdFx0aWYgKHNoYWRvd3MpIHtcblx0XHRcdGkgPSBzaGFkb3dzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0c2hhZG93c1tpXS5wYXRoID0gc2hhZG93c1tpXS5jdXRPZmYgPyB0aGlzLmN1dE9mZlBhdGgodmFsdWUsIHNoYWRvd3NbaV0uY3V0T2ZmKSA6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnNldEF0dHIoa2V5LCB2YWx1ZSk7XG5cdH0sXG5cdGZpbGxTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0dmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblx0XHRpZiAobm9kZU5hbWUgPT09ICdTUEFOJykgeyAvLyB0ZXh0IGNvbG9yXG5cdFx0XHRlbGVtZW50LnN0eWxlLmNvbG9yID0gdmFsdWU7XG5cdFx0fSBlbHNlIGlmIChub2RlTmFtZSAhPT0gJ0lNRycpIHsgLy8gIzEzMzZcblx0XHRcdGVsZW1lbnQuZmlsbGVkID0gdmFsdWUgIT09IE5PTkU7XG5cdFx0XHR0aGlzLnNldEF0dHIoJ2ZpbGxjb2xvcicsIHRoaXMucmVuZGVyZXIuY29sb3IodmFsdWUsIGVsZW1lbnQsIGtleSwgdGhpcykpO1xuXHRcdH1cblx0fSxcblx0b3BhY2l0eVNldHRlcjogbm9vcCwgLy8gRG9uJ3QgYm90aGVyIC0gYW5pbWF0aW9uIGlzIHRvbyBzbG93IGFuZCBmaWx0ZXJzIGludHJvZHVjZSBhcnRpZmFjdHNcblx0cm90YXRpb25TZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0dmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblx0XHR0aGlzW2tleV0gPSBzdHlsZVtrZXldID0gdmFsdWU7IC8vIHN0eWxlIGlzIGZvciAjMTg3M1xuXG5cdFx0Ly8gQ29ycmVjdGlvbiBmb3IgdGhlIDF4MSBzaXplIG9mIHRoZSBzaGFwZSBjb250YWluZXIuIFVzZWQgaW4gZ2F1Z2UgbmVlZGxlcy5cblx0XHRzdHlsZS5sZWZ0ID0gLW1hdGhSb3VuZChtYXRoU2luKHZhbHVlICogZGVnMnJhZCkgKyAxKSArIFBYO1xuXHRcdHN0eWxlLnRvcCA9IG1hdGhSb3VuZChtYXRoQ29zKHZhbHVlICogZGVnMnJhZCkpICsgUFg7XG5cdH0sXG5cdHN0cm9rZVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHR0aGlzLnNldEF0dHIoJ3N0cm9rZWNvbG9yJywgdGhpcy5yZW5kZXJlci5jb2xvcih2YWx1ZSwgZWxlbWVudCwga2V5KSk7XG5cdH0sXG5cdCdzdHJva2Utd2lkdGhTZXR0ZXInOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdGVsZW1lbnQuc3Ryb2tlZCA9ICEhdmFsdWU7IC8vIFZNTCBcInN0cm9rZWRcIiBhdHRyaWJ1dGVcblx0XHR0aGlzW2tleV0gPSB2YWx1ZTsgLy8gdXNlZCBpbiBnZXR0ZXIsIGlzc3VlICMxMTNcblx0XHRpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG5cdFx0XHR2YWx1ZSArPSBQWDtcblx0XHR9XG5cdFx0dGhpcy5zZXRBdHRyKCdzdHJva2V3ZWlnaHQnLCB2YWx1ZSk7XG5cdH0sXG5cdHRpdGxlU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdHRoaXMuc2V0QXR0cihrZXksIHZhbHVlKTtcblx0fSxcblx0dmlzaWJpbGl0eVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblxuXHRcdC8vIEhhbmRsZSBpbmhlcml0ZWQgdmlzaWJpbGl0eVxuXHRcdGlmICh2YWx1ZSA9PT0gJ2luaGVyaXQnKSB7XG5cdFx0XHR2YWx1ZSA9IFZJU0lCTEU7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIExldCB0aGUgc2hhZG93IGZvbGxvdyB0aGUgbWFpbiBlbGVtZW50XG5cdFx0aWYgKHRoaXMuc2hhZG93cykge1xuXHRcdFx0ZWFjaCh0aGlzLnNoYWRvd3MsIGZ1bmN0aW9uIChzaGFkb3cpIHtcblx0XHRcdFx0c2hhZG93LnN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIEluc3RlYWQgb2YgdG9nZ2xpbmcgdGhlIHZpc2liaWxpdHkgQ1NTIHByb3BlcnR5LCBtb3ZlIHRoZSBkaXYgb3V0IG9mIHRoZSB2aWV3cG9ydC5cblx0XHQvLyBUaGlzIHdvcmtzIGFyb3VuZCAjNjEgYW5kICM1ODZcblx0XHRpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0RJVicpIHtcblx0XHRcdHZhbHVlID0gdmFsdWUgPT09IEhJRERFTiA/ICctOTk5ZW0nIDogMDtcblxuXHRcdFx0Ly8gSW4gb3JkZXIgdG8gcmVkcmF3LCBJRTcgbmVlZHMgdGhlIGRpdiB0byBiZSB2aXNpYmxlIHdoZW4gdHVja2VkIGF3YXlcblx0XHRcdC8vIG91dHNpZGUgdGhlIHZpZXdwb3J0LiBTbyB0aGUgdmlzaWJpbGl0eSBpcyBhY3R1YWxseSBvcHBvc2l0ZSBvZlxuXHRcdFx0Ly8gdGhlIGV4cGVjdGVkIHZhbHVlLiBUaGlzIGFwcGxpZXMgdG8gdGhlIHRvb2x0aXAgb25seS5cblx0XHRcdGlmICghZG9jTW9kZTgpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZVtrZXldID0gdmFsdWUgPyBWSVNJQkxFIDogSElEREVOO1xuXHRcdFx0fVxuXHRcdFx0a2V5ID0gJ3RvcCc7XG5cdFx0fVxuXHRcdGVsZW1lbnQuc3R5bGVba2V5XSA9IHZhbHVlO1xuXHR9LFxuXHR4U2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdHRoaXNba2V5XSA9IHZhbHVlOyAvLyB1c2VkIGluIGdldHRlclxuXG5cdFx0aWYgKGtleSA9PT0gJ3gnKSB7XG5cdFx0XHRrZXkgPSAnbGVmdCc7XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICd5Jykge1xuXHRcdFx0a2V5ID0gJ3RvcCc7XG5cdFx0fS8qIGVsc2Uge1xuXHRcdFx0dmFsdWUgPSBtYXRoTWF4KDAsIHZhbHVlKTsgLy8gZG9uJ3Qgc2V0IHdpZHRoIG9yIGhlaWdodCBiZWxvdyB6ZXJvICgjMzExKVxuXHRcdH0qL1xuXG5cdFx0Ly8gY2xpcHBpbmcgcmVjdGFuZ2xlIHNwZWNpYWxcblx0XHRpZiAodGhpcy51cGRhdGVDbGlwcGluZykge1xuXHRcdFx0dGhpc1trZXldID0gdmFsdWU7IC8vIHRoZSBrZXkgaXMgbm93ICdsZWZ0JyBvciAndG9wJyBmb3IgJ3gnIGFuZCAneSdcblx0XHRcdHRoaXMudXBkYXRlQ2xpcHBpbmcoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gbm9ybWFsXG5cdFx0XHRlbGVtZW50LnN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHR9XG5cdH0sXG5cdHpJbmRleFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRlbGVtZW50LnN0eWxlW2tleV0gPSB2YWx1ZTtcblx0fVxufTtcbkhpZ2hjaGFydHMuVk1MRWxlbWVudCA9IFZNTEVsZW1lbnQgPSBleHRlbmRDbGFzcyhTVkdFbGVtZW50LCBWTUxFbGVtZW50KTtcblxuLy8gU29tZSBzaGFyZWQgc2V0dGVyc1xuVk1MRWxlbWVudC5wcm90b3R5cGUueVNldHRlciA9XG5cdFZNTEVsZW1lbnQucHJvdG90eXBlLndpZHRoU2V0dGVyID0gXG5cdFZNTEVsZW1lbnQucHJvdG90eXBlLmhlaWdodFNldHRlciA9IFxuXHRWTUxFbGVtZW50LnByb3RvdHlwZS54U2V0dGVyO1xuXG5cbi8qKlxuICogVGhlIFZNTCByZW5kZXJlclxuICovXG52YXIgVk1MUmVuZGVyZXJFeHRlbnNpb24gPSB7IC8vIGluaGVyaXQgU1ZHUmVuZGVyZXJcblxuXHRFbGVtZW50OiBWTUxFbGVtZW50LFxuXHRpc0lFODogdXNlckFnZW50LmluZGV4T2YoJ01TSUUgOC4wJykgPiAtMSxcblxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBWTUxSZW5kZXJlclxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdCAqL1xuXHRpbml0OiBmdW5jdGlvbiAoY29udGFpbmVyLCB3aWR0aCwgaGVpZ2h0LCBzdHlsZSkge1xuXHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRib3hXcmFwcGVyLFxuXHRcdFx0Ym94LFxuXHRcdFx0Y3NzO1xuXG5cdFx0cmVuZGVyZXIuYWxpZ25lZE9iamVjdHMgPSBbXTtcblxuXHRcdGJveFdyYXBwZXIgPSByZW5kZXJlci5jcmVhdGVFbGVtZW50KERJVilcblx0XHRcdC5jc3MoZXh0ZW5kKHRoaXMuZ2V0U3R5bGUoc3R5bGUpLCB7IHBvc2l0aW9uOiBSRUxBVElWRX0pKTtcblx0XHRib3ggPSBib3hXcmFwcGVyLmVsZW1lbnQ7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGJveFdyYXBwZXIuZWxlbWVudCk7XG5cblxuXHRcdC8vIGdlbmVyYXRlIHRoZSBjb250YWluaW5nIGJveFxuXHRcdHJlbmRlcmVyLmlzVk1MID0gdHJ1ZTtcblx0XHRyZW5kZXJlci5ib3ggPSBib3g7XG5cdFx0cmVuZGVyZXIuYm94V3JhcHBlciA9IGJveFdyYXBwZXI7XG5cdFx0cmVuZGVyZXIuY2FjaGUgPSB7fTtcblxuXG5cdFx0cmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCBmYWxzZSk7XG5cblx0XHQvLyBUaGUgb25seSB3YXkgdG8gbWFrZSBJRTYgYW5kIElFNyBwcmludCBpcyB0byB1c2UgYSBnbG9iYWwgbmFtZXNwYWNlLiBIb3dldmVyLFxuXHRcdC8vIHdpdGggSUU4IHRoZSBvbmx5IHdheSB0byBtYWtlIHRoZSBkeW5hbWljIHNoYXBlcyB2aXNpYmxlIGluIHNjcmVlbiBhbmQgcHJpbnQgbW9kZVxuXHRcdC8vIHNlZW1zIHRvIGJlIHRvIGFkZCB0aGUgeG1sbnMgYXR0cmlidXRlIGFuZCB0aGUgYmVoYXZpb3VyIHN0eWxlIGlubGluZS5cblx0XHRpZiAoIWRvYy5uYW1lc3BhY2VzLmhjdikge1xuXG5cdFx0XHRkb2MubmFtZXNwYWNlcy5hZGQoJ2hjdicsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuXG5cdFx0XHQvLyBTZXR1cCBkZWZhdWx0IENTUyAoIzIxNTMsICMyMzY4LCAjMjM4NClcblx0XHRcdGNzcyA9ICdoY3ZcXFxcOmZpbGwsIGhjdlxcXFw6cGF0aCwgaGN2XFxcXDpzaGFwZSwgaGN2XFxcXDpzdHJva2UnICtcblx0XHRcdFx0J3sgYmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCk7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgfSAnO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9jLmNyZWF0ZVN0eWxlU2hlZXQoKS5jc3NUZXh0ID0gY3NzO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRkb2Muc3R5bGVTaGVldHNbMF0uY3NzVGV4dCArPSBjc3M7XG5cdFx0XHR9XG5cblx0XHR9XG5cdH0sXG5cblxuXHQvKipcblx0ICogRGV0ZWN0IHdoZXRoZXIgdGhlIHJlbmRlcmVyIGlzIGhpZGRlbi4gVGhpcyBoYXBwZW5zIHdoZW4gb25lIG9mIHRoZSBwYXJlbnQgZWxlbWVudHNcblx0ICogaGFzIGRpc3BsYXk6IG5vbmVcblx0ICovXG5cdGlzSGlkZGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmJveC5vZmZzZXRXaWR0aDtcblx0fSxcblxuXHQvKipcblx0ICogRGVmaW5lIGEgY2xpcHBpbmcgcmVjdGFuZ2xlLiBJbiBWTUwgaXQgaXMgYWNjb21wbGlzaGVkIGJ5IHN0b3JpbmcgdGhlIHZhbHVlc1xuXHQgKiBmb3Igc2V0dGluZyB0aGUgQ1NTIHN0eWxlIHRvIGFsbCBhc3NvY2lhdGVkIG1lbWJlcnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdCAqL1xuXHRjbGlwUmVjdDogZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblxuXHRcdC8vIGNyZWF0ZSBhIGR1bW15IGVsZW1lbnRcblx0XHR2YXIgY2xpcFJlY3QgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoKSxcblx0XHRcdGlzT2JqID0gaXNPYmplY3QoeCk7XG5cblx0XHQvLyBtaW1pYyBhIHJlY3RhbmdsZSB3aXRoIGl0cyBzdHlsZSBvYmplY3QgZm9yIGF1dG9tYXRpYyB1cGRhdGluZyBpbiBhdHRyXG5cdFx0cmV0dXJuIGV4dGVuZChjbGlwUmVjdCwge1xuXHRcdFx0bWVtYmVyczogW10sXG5cdFx0XHRjb3VudDogMCxcblx0XHRcdGxlZnQ6IChpc09iaiA/IHgueCA6IHgpICsgMSxcblx0XHRcdHRvcDogKGlzT2JqID8geC55IDogeSkgKyAxLFxuXHRcdFx0d2lkdGg6IChpc09iaiA/IHgud2lkdGggOiB3aWR0aCkgLSAxLFxuXHRcdFx0aGVpZ2h0OiAoaXNPYmogPyB4LmhlaWdodCA6IGhlaWdodCkgLSAxLFxuXHRcdFx0Z2V0Q1NTOiBmdW5jdGlvbiAod3JhcHBlcikge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdFx0XHRub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUsXG5cdFx0XHRcdFx0aXNTaGFwZSA9IG5vZGVOYW1lID09PSAnc2hhcGUnLFxuXHRcdFx0XHRcdGludmVydGVkID0gd3JhcHBlci5pbnZlcnRlZCxcblx0XHRcdFx0XHRyZWN0ID0gdGhpcyxcblx0XHRcdFx0XHR0b3AgPSByZWN0LnRvcCAtIChpc1NoYXBlID8gZWxlbWVudC5vZmZzZXRUb3AgOiAwKSxcblx0XHRcdFx0XHRsZWZ0ID0gcmVjdC5sZWZ0LFxuXHRcdFx0XHRcdHJpZ2h0ID0gbGVmdCArIHJlY3Qud2lkdGgsXG5cdFx0XHRcdFx0Ym90dG9tID0gdG9wICsgcmVjdC5oZWlnaHQsXG5cdFx0XHRcdFx0cmV0ID0ge1xuXHRcdFx0XHRcdFx0Y2xpcDogJ3JlY3QoJyArXG5cdFx0XHRcdFx0XHRcdG1hdGhSb3VuZChpbnZlcnRlZCA/IGxlZnQgOiB0b3ApICsgJ3B4LCcgK1xuXHRcdFx0XHRcdFx0XHRtYXRoUm91bmQoaW52ZXJ0ZWQgPyBib3R0b20gOiByaWdodCkgKyAncHgsJyArXG5cdFx0XHRcdFx0XHRcdG1hdGhSb3VuZChpbnZlcnRlZCA/IHJpZ2h0IDogYm90dG9tKSArICdweCwnICtcblx0XHRcdFx0XHRcdFx0bWF0aFJvdW5kKGludmVydGVkID8gdG9wIDogbGVmdCkgKyAncHgpJ1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gaXNzdWUgNzQgd29ya2Fyb3VuZFxuXHRcdFx0XHRpZiAoIWludmVydGVkICYmIGRvY01vZGU4ICYmIG5vZGVOYW1lID09PSAnRElWJykge1xuXHRcdFx0XHRcdGV4dGVuZChyZXQsIHtcblx0XHRcdFx0XHRcdHdpZHRoOiByaWdodCArIFBYLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBib3R0b20gKyBQWFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyB1c2VkIGluIGF0dHIgYW5kIGFuaW1hdGlvbiB0byB1cGRhdGUgdGhlIGNsaXBwaW5nIG9mIGFsbCBtZW1iZXJzXG5cdFx0XHR1cGRhdGVDbGlwcGluZzogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRlYWNoKGNsaXBSZWN0Lm1lbWJlcnMsIGZ1bmN0aW9uIChtZW1iZXIpIHtcblx0XHRcdFx0XHRpZiAobWVtYmVyLmVsZW1lbnQpIHsgLy8gRGVsZXRlZCBzZXJpZXMsIGxpa2UgaW4gc3RvY2svbWVtYmVycy9zZXJpZXMtcmVtb3ZlIGRlbW8uIFNob3VsZCBiZSByZW1vdmVkIGZyb20gbWVtYmVycywgYnV0IHRoaXMgd2lsbCBkby5cblx0XHRcdFx0XHRcdG1lbWJlci5jc3MoY2xpcFJlY3QuZ2V0Q1NTKG1lbWJlcikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSxcblxuXG5cdC8qKlxuXHQgKiBUYWtlIGEgY29sb3IgYW5kIHJldHVybiBpdCBpZiBpdCdzIGEgc3RyaW5nLCBtYWtlIGl0IGEgZ3JhZGllbnQgaWYgaXQncyBhXG5cdCAqIGdyYWRpZW50IGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBhbmQgYXBwbHkgb3BhY2l0eS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbG9yIFRoZSBjb2xvciBvciBjb25maWcgb2JqZWN0XG5cdCAqL1xuXHRjb2xvcjogZnVuY3Rpb24gKGNvbG9yLCBlbGVtLCBwcm9wLCB3cmFwcGVyKSB7XG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdGNvbG9yT2JqZWN0LFxuXHRcdFx0cmVnZXhSZ2JhID0gL15yZ2JhLyxcblx0XHRcdG1hcmt1cCxcblx0XHRcdGZpbGxUeXBlLFxuXHRcdFx0cmV0ID0gTk9ORTtcblxuXHRcdC8vIENoZWNrIGZvciBsaW5lYXIgb3IgcmFkaWFsIGdyYWRpZW50XG5cdFx0aWYgKGNvbG9yICYmIGNvbG9yLmxpbmVhckdyYWRpZW50KSB7XG5cdFx0XHRmaWxsVHlwZSA9ICdncmFkaWVudCc7XG5cdFx0fSBlbHNlIGlmIChjb2xvciAmJiBjb2xvci5yYWRpYWxHcmFkaWVudCkge1xuXHRcdFx0ZmlsbFR5cGUgPSAncGF0dGVybic7XG5cdFx0fVxuXG5cblx0XHRpZiAoZmlsbFR5cGUpIHtcblxuXHRcdFx0dmFyIHN0b3BDb2xvcixcblx0XHRcdFx0c3RvcE9wYWNpdHksXG5cdFx0XHRcdGdyYWRpZW50ID0gY29sb3IubGluZWFyR3JhZGllbnQgfHwgY29sb3IucmFkaWFsR3JhZGllbnQsXG5cdFx0XHRcdHgxLFxuXHRcdFx0XHR5MSxcblx0XHRcdFx0eDIsXG5cdFx0XHRcdHkyLFxuXHRcdFx0XHRvcGFjaXR5MSxcblx0XHRcdFx0b3BhY2l0eTIsXG5cdFx0XHRcdGNvbG9yMSxcblx0XHRcdFx0Y29sb3IyLFxuXHRcdFx0XHRmaWxsQXR0ciA9ICcnLFxuXHRcdFx0XHRzdG9wcyA9IGNvbG9yLnN0b3BzLFxuXHRcdFx0XHRmaXJzdFN0b3AsXG5cdFx0XHRcdGxhc3RTdG9wLFxuXHRcdFx0XHRjb2xvcnMgPSBbXSxcblx0XHRcdFx0YWRkRmlsbE5vZGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Ly8gQWRkIHRoZSBmaWxsIHN1Ym5vZGUuIFdoZW4gY29sb3JzIGF0dHJpYnV0ZSBpcyB1c2VkLCB0aGUgbWVhbmluZ3Mgb2Ygb3BhY2l0eSBhbmQgbzpvcGFjaXR5MlxuXHRcdFx0XHRcdC8vIGFyZSByZXZlcnNlZC5cblx0XHRcdFx0XHRtYXJrdXAgPSBbJzxmaWxsIGNvbG9ycz1cIicgKyBjb2xvcnMuam9pbignLCcpICsgJ1wiIG9wYWNpdHk9XCInLCBvcGFjaXR5MiwgJ1wiIG86b3BhY2l0eTI9XCInLCBvcGFjaXR5MSxcblx0XHRcdFx0XHRcdCdcIiB0eXBlPVwiJywgZmlsbFR5cGUsICdcIiAnLCBmaWxsQXR0ciwgJ2ZvY3VzPVwiMTAwJVwiIG1ldGhvZD1cImFueVwiIC8+J107XG5cdFx0XHRcdFx0Y3JlYXRlRWxlbWVudChyZW5kZXJlci5wcmVwVk1MKG1hcmt1cCksIG51bGwsIG51bGwsIGVsZW0pO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHQvLyBFeHRlbmQgZnJvbSAwIHRvIDFcblx0XHRcdGZpcnN0U3RvcCA9IHN0b3BzWzBdO1xuXHRcdFx0bGFzdFN0b3AgPSBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXTtcblx0XHRcdGlmIChmaXJzdFN0b3BbMF0gPiAwKSB7XG5cdFx0XHRcdHN0b3BzLnVuc2hpZnQoW1xuXHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0Zmlyc3RTdG9wWzFdXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxhc3RTdG9wWzBdIDwgMSkge1xuXHRcdFx0XHRzdG9wcy5wdXNoKFtcblx0XHRcdFx0XHQxLFxuXHRcdFx0XHRcdGxhc3RTdG9wWzFdXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wdXRlIHRoZSBzdG9wc1xuXHRcdFx0ZWFjaChzdG9wcywgZnVuY3Rpb24gKHN0b3AsIGkpIHtcblx0XHRcdFx0aWYgKHJlZ2V4UmdiYS50ZXN0KHN0b3BbMV0pKSB7XG5cdFx0XHRcdFx0Y29sb3JPYmplY3QgPSBDb2xvcihzdG9wWzFdKTtcblx0XHRcdFx0XHRzdG9wQ29sb3IgPSBjb2xvck9iamVjdC5nZXQoJ3JnYicpO1xuXHRcdFx0XHRcdHN0b3BPcGFjaXR5ID0gY29sb3JPYmplY3QuZ2V0KCdhJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RvcENvbG9yID0gc3RvcFsxXTtcblx0XHRcdFx0XHRzdG9wT3BhY2l0eSA9IDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBCdWlsZCB0aGUgY29sb3IgYXR0cmlidXRlXG5cdFx0XHRcdGNvbG9ycy5wdXNoKChzdG9wWzBdICogMTAwKSArICclICcgKyBzdG9wQ29sb3IpO1xuXG5cdFx0XHRcdC8vIE9ubHkgc3RhcnQgYW5kIGVuZCBvcGFjaXRpZXMgYXJlIGFsbG93ZWQsIHNvIHdlIHVzZSB0aGUgZmlyc3QgYW5kIHRoZSBsYXN0XG5cdFx0XHRcdGlmICghaSkge1xuXHRcdFx0XHRcdG9wYWNpdHkxID0gc3RvcE9wYWNpdHk7XG5cdFx0XHRcdFx0Y29sb3IyID0gc3RvcENvbG9yO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9wYWNpdHkyID0gc3RvcE9wYWNpdHk7XG5cdFx0XHRcdFx0Y29sb3IxID0gc3RvcENvbG9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgdGhlIGdyYWRpZW50IHRvIGZpbGxzIG9ubHkuXG5cdFx0XHRpZiAocHJvcCA9PT0gJ2ZpbGwnKSB7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGxpbmVhciBncmFkaWVudCBhbmdsZVxuXHRcdFx0XHRpZiAoZmlsbFR5cGUgPT09ICdncmFkaWVudCcpIHtcblx0XHRcdFx0XHR4MSA9IGdyYWRpZW50LngxIHx8IGdyYWRpZW50WzBdIHx8IDA7XG5cdFx0XHRcdFx0eTEgPSBncmFkaWVudC55MSB8fCBncmFkaWVudFsxXSB8fCAwO1xuXHRcdFx0XHRcdHgyID0gZ3JhZGllbnQueDIgfHwgZ3JhZGllbnRbMl0gfHwgMDtcblx0XHRcdFx0XHR5MiA9IGdyYWRpZW50LnkyIHx8IGdyYWRpZW50WzNdIHx8IDA7XG5cdFx0XHRcdFx0ZmlsbEF0dHIgPSAnYW5nbGU9XCInICsgKDkwICAtIG1hdGguYXRhbihcblx0XHRcdFx0XHRcdCh5MiAtIHkxKSAvIC8vIHkgdmVjdG9yXG5cdFx0XHRcdFx0XHQoeDIgLSB4MSkgLy8geCB2ZWN0b3Jcblx0XHRcdFx0XHRcdCkgKiAxODAgLyBtYXRoUEkpICsgJ1wiJztcblxuXHRcdFx0XHRcdGFkZEZpbGxOb2RlKCk7XG5cblx0XHRcdFx0Ly8gUmFkaWFsIChjaXJjdWxhcikgZ3JhZGllbnRcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHZhciByID0gZ3JhZGllbnQucixcblx0XHRcdFx0XHRcdHNpemV4ID0gciAqIDIsXG5cdFx0XHRcdFx0XHRzaXpleSA9IHIgKiAyLFxuXHRcdFx0XHRcdFx0Y3ggPSBncmFkaWVudC5jeCxcblx0XHRcdFx0XHRcdGN5ID0gZ3JhZGllbnQuY3ksXG5cdFx0XHRcdFx0XHRyYWRpYWxSZWZlcmVuY2UgPSBlbGVtLnJhZGlhbFJlZmVyZW5jZSxcblx0XHRcdFx0XHRcdGJCb3gsXG5cdFx0XHRcdFx0XHRhcHBseVJhZGlhbEdyYWRpZW50ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRpZiAocmFkaWFsUmVmZXJlbmNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0YkJveCA9IHdyYXBwZXIuZ2V0QkJveCgpO1xuXHRcdFx0XHRcdFx0XHRcdGN4ICs9IChyYWRpYWxSZWZlcmVuY2VbMF0gLSBiQm94LngpIC8gYkJveC53aWR0aCAtIDAuNTtcblx0XHRcdFx0XHRcdFx0XHRjeSArPSAocmFkaWFsUmVmZXJlbmNlWzFdIC0gYkJveC55KSAvIGJCb3guaGVpZ2h0IC0gMC41O1xuXHRcdFx0XHRcdFx0XHRcdHNpemV4ICo9IHJhZGlhbFJlZmVyZW5jZVsyXSAvIGJCb3gud2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0c2l6ZXkgKj0gcmFkaWFsUmVmZXJlbmNlWzJdIC8gYkJveC5oZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZmlsbEF0dHIgPSAnc3JjPVwiJyArIGRlZmF1bHRPcHRpb25zLmdsb2JhbC5WTUxSYWRpYWxHcmFkaWVudFVSTCArICdcIiAnICtcblx0XHRcdFx0XHRcdFx0XHQnc2l6ZT1cIicgKyBzaXpleCArICcsJyArIHNpemV5ICsgJ1wiICcgK1xuXHRcdFx0XHRcdFx0XHRcdCdvcmlnaW49XCIwLjUsMC41XCIgJyArXG5cdFx0XHRcdFx0XHRcdFx0J3Bvc2l0aW9uPVwiJyArIGN4ICsgJywnICsgY3kgKyAnXCIgJyArXG5cdFx0XHRcdFx0XHRcdFx0J2NvbG9yMj1cIicgKyBjb2xvcjIgKyAnXCIgJztcblxuXHRcdFx0XHRcdFx0XHRhZGRGaWxsTm9kZSgpO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIEFwcGx5IHJhZGlhbCBncmFkaWVudFxuXHRcdFx0XHRcdGlmICh3cmFwcGVyLmFkZGVkKSB7XG5cdFx0XHRcdFx0XHRhcHBseVJhZGlhbEdyYWRpZW50KCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8ga25vdyB0aGUgYm91bmRpbmcgYm94IHRvIGdldCB0aGUgc2l6ZSBhbmQgcG9zaXRpb24gcmlnaHRcblx0XHRcdFx0XHRcdHdyYXBwZXIub25BZGQgPSBhcHBseVJhZGlhbEdyYWRpZW50O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFRoZSBmaWxsIGVsZW1lbnQncyBjb2xvciBhdHRyaWJ1dGUgaXMgYnJva2VuIGluIElFOCBzdGFuZGFyZHMgbW9kZSwgc28gd2Vcblx0XHRcdFx0XHQvLyBuZWVkIHRvIHNldCB0aGUgcGFyZW50IHNoYXBlJ3MgZmlsbGNvbG9yIGF0dHJpYnV0ZSBpbnN0ZWFkLlxuXHRcdFx0XHRcdHJldCA9IGNvbG9yMTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBHcmFkaWVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIFZNTCBzdHJva2UsIHJldHVybiB0aGUgZmlyc3QgY29sb3IuICM3MjIuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXQgPSBzdG9wQ29sb3I7XG5cdFx0XHR9XG5cblx0XHQvLyBpZiB0aGUgY29sb3IgaXMgYW4gcmdiYSBjb2xvciwgc3BsaXQgaXQgYW5kIGFkZCBhIGZpbGwgbm9kZVxuXHRcdC8vIHRvIGhvbGQgdGhlIG9wYWNpdHkgY29tcG9uZW50XG5cdFx0fSBlbHNlIGlmIChyZWdleFJnYmEudGVzdChjb2xvcikgJiYgZWxlbS50YWdOYW1lICE9PSAnSU1HJykge1xuXG5cdFx0XHRjb2xvck9iamVjdCA9IENvbG9yKGNvbG9yKTtcblxuXHRcdFx0bWFya3VwID0gWyc8JywgcHJvcCwgJyBvcGFjaXR5PVwiJywgY29sb3JPYmplY3QuZ2V0KCdhJyksICdcIi8+J107XG5cdFx0XHRjcmVhdGVFbGVtZW50KHRoaXMucHJlcFZNTChtYXJrdXApLCBudWxsLCBudWxsLCBlbGVtKTtcblxuXHRcdFx0cmV0ID0gY29sb3JPYmplY3QuZ2V0KCdyZ2InKTtcblxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwcm9wTm9kZXMgPSBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKHByb3ApOyAvLyAnc3Ryb2tlJyBvciAnZmlsbCcgbm9kZVxuXHRcdFx0aWYgKHByb3BOb2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0cHJvcE5vZGVzWzBdLm9wYWNpdHkgPSAxO1xuXHRcdFx0XHRwcm9wTm9kZXNbMF0udHlwZSA9ICdzb2xpZCc7XG5cdFx0XHR9XG5cdFx0XHRyZXQgPSBjb2xvcjtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUYWtlIGEgVk1MIHN0cmluZyBhbmQgcHJlcGFyZSBpdCBmb3IgZWl0aGVyIElFOCBvciBJRTYvSUU3LlxuXHQgKiBAcGFyYW0ge0FycmF5fSBtYXJrdXAgQSBzdHJpbmcgYXJyYXkgb2YgdGhlIFZNTCBtYXJrdXAgdG8gcHJlcGFyZVxuXHQgKi9cblx0cHJlcFZNTDogZnVuY3Rpb24gKG1hcmt1cCkge1xuXHRcdHZhciB2bWxTdHlsZSA9ICdkaXNwbGF5OmlubGluZS1ibG9jaztiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKTsnLFxuXHRcdFx0aXNJRTggPSB0aGlzLmlzSUU4O1xuXG5cdFx0bWFya3VwID0gbWFya3VwLmpvaW4oJycpO1xuXG5cdFx0aWYgKGlzSUU4KSB7IC8vIGFkZCB4bWxucyBhbmQgc3R5bGUgaW5saW5lXG5cdFx0XHRtYXJrdXAgPSBtYXJrdXAucmVwbGFjZSgnLz4nLCAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWxcIiAvPicpO1xuXHRcdFx0aWYgKG1hcmt1cC5pbmRleE9mKCdzdHlsZT1cIicpID09PSAtMSkge1xuXHRcdFx0XHRtYXJrdXAgPSBtYXJrdXAucmVwbGFjZSgnLz4nLCAnIHN0eWxlPVwiJyArIHZtbFN0eWxlICsgJ1wiIC8+Jyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXJrdXAgPSBtYXJrdXAucmVwbGFjZSgnc3R5bGU9XCInLCAnc3R5bGU9XCInICsgdm1sU3R5bGUpO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHsgLy8gYWRkIG5hbWVzcGFjZVxuXHRcdFx0bWFya3VwID0gbWFya3VwLnJlcGxhY2UoJzwnLCAnPGhjdjonKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFya3VwO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgcm90YXRlZCBhbmQgYWxpZ25lZCB0ZXh0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICovXG5cdHRleHQ6IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5odG1sLFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW5kIHJldHVybiBhIHBhdGggZWxlbWVudFxuXHQgKiBAcGFyYW0ge0FycmF5fSBwYXRoXG5cdCAqL1xuXHRwYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuXHRcdHZhciBhdHRyID0ge1xuXHRcdFx0Ly8gc3VicGl4ZWwgcHJlY2lzaW9uIGRvd24gdG8gMC4xICh3aWR0aCBhbmQgaGVpZ2h0ID0gMXB4KVxuXHRcdFx0Y29vcmRzaXplOiAnMTAgMTAnXG5cdFx0fTtcblx0XHRpZiAoaXNBcnJheShwYXRoKSkge1xuXHRcdFx0YXR0ci5kID0gcGF0aDtcblx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0KHBhdGgpKSB7IC8vIGF0dHJpYnV0ZXNcblx0XHRcdGV4dGVuZChhdHRyLCBwYXRoKTtcblx0XHR9XG5cdFx0Ly8gY3JlYXRlIHRoZSBzaGFwZVxuXHRcdHJldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnQoJ3NoYXBlJykuYXR0cihhdHRyKTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIGFuZCByZXR1cm4gYSBjaXJjbGUgZWxlbWVudC4gSW4gVk1MIGNpcmNsZXMgYXJlIGltcGxlbWVudGVkIGFzXG5cdCAqIHNoYXBlcywgd2hpY2ggaXMgZmFzdGVyIHRoYW4gdjpvdmFsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByXG5cdCAqL1xuXHRjaXJjbGU6IGZ1bmN0aW9uICh4LCB5LCByKSB7XG5cdFx0dmFyIGNpcmNsZSA9IHRoaXMuc3ltYm9sKCdjaXJjbGUnKTtcblx0XHRpZiAoaXNPYmplY3QoeCkpIHtcblx0XHRcdHIgPSB4LnI7XG5cdFx0XHR5ID0geC55O1xuXHRcdFx0eCA9IHgueDtcblx0XHR9XG5cdFx0Y2lyY2xlLmlzQ2lyY2xlID0gdHJ1ZTsgLy8gQ2F1c2VzIHggYW5kIHkgdG8gbWVhbiBjZW50ZXIgKCMxNjgyKVxuXHRcdGNpcmNsZS5yID0gcjtcblx0XHRyZXR1cm4gY2lyY2xlLmF0dHIoeyB4OiB4LCB5OiB5IH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBncm91cCB1c2luZyBhbiBvdXRlciBkaXYgYW5kIGFuIGlubmVyIHY6Z3JvdXAgdG8gYWxsb3cgcm90YXRpbmdcblx0ICogYW5kIGZsaXBwaW5nLiBBIHNpbXBsZSB2Omdyb3VwIHdvdWxkIGhhdmUgcHJvYmxlbXMgd2l0aCBwb3NpdGlvbmluZ1xuXHQgKiBjaGlsZCBIVE1MIGVsZW1lbnRzIGFuZCBDU1MgY2xpcC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGdyb3VwXG5cdCAqL1xuXHRnOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHZhciB3cmFwcGVyLFxuXHRcdFx0YXR0cmlicztcblxuXHRcdC8vIHNldCB0aGUgY2xhc3MgbmFtZVxuXHRcdGlmIChuYW1lKSB7XG5cdFx0XHRhdHRyaWJzID0geyAnY2xhc3NOYW1lJzogUFJFRklYICsgbmFtZSwgJ2NsYXNzJzogUFJFRklYICsgbmFtZSB9O1xuXHRcdH1cblxuXHRcdC8vIHRoZSBkaXYgdG8gaG9sZCBIVE1MIGFuZCBjbGlwcGluZ1xuXHRcdHdyYXBwZXIgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoRElWKS5hdHRyKGF0dHJpYnMpO1xuXG5cdFx0cmV0dXJuIHdyYXBwZXI7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFZNTCBvdmVycmlkZSB0byBjcmVhdGUgYSByZWd1bGFyIEhUTUwgaW1hZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuXHQgKi9cblx0aW1hZ2U6IGZ1bmN0aW9uIChzcmMsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR2YXIgb2JqID0gdGhpcy5jcmVhdGVFbGVtZW50KCdpbWcnKVxuXHRcdFx0LmF0dHIoeyBzcmM6IHNyYyB9KTtcblxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0b2JqLmF0dHIoe1xuXHRcdFx0XHR4OiB4LFxuXHRcdFx0XHR5OiB5LFxuXHRcdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvKipcblx0ICogRm9yIHJlY3RhbmdsZXMsIFZNTCB1c2VzIGEgc2hhcGUgZm9yIHJlY3QgdG8gb3ZlcmNvbWUgYnVncyBhbmQgcm90YXRpb24gcHJvYmxlbXNcblx0ICovXG5cdGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIChub2RlTmFtZSkge1xuXHRcdHJldHVybiBub2RlTmFtZSA9PT0gJ3JlY3QnID8gdGhpcy5zeW1ib2wobm9kZU5hbWUpIDogU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBub2RlTmFtZSk7XHRcblx0fSxcblxuXHQvKipcblx0ICogSW4gdGhlIFZNTCByZW5kZXJlciwgZWFjaCBjaGlsZCBvZiBhbiBpbnZlcnRlZCBkaXYgKGdyb3VwKSBpcyBpbnZlcnRlZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50Tm9kZVxuXHQgKi9cblx0aW52ZXJ0Q2hpbGQ6IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnROb2RlKSB7XG5cdFx0dmFyIHJlbiA9IHRoaXMsXG5cdFx0XHRwYXJlbnRTdHlsZSA9IHBhcmVudE5vZGUuc3R5bGUsXG5cdFx0XHRpbWdTdHlsZSA9IGVsZW1lbnQudGFnTmFtZSA9PT0gJ0lNRycgJiYgZWxlbWVudC5zdHlsZTsgLy8gIzExMTFcblxuXHRcdGNzcyhlbGVtZW50LCB7XG5cdFx0XHRmbGlwOiAneCcsXG5cdFx0XHRsZWZ0OiBwSW50KHBhcmVudFN0eWxlLndpZHRoKSAtIChpbWdTdHlsZSA/IHBJbnQoaW1nU3R5bGUudG9wKSA6IDEpLFxuXHRcdFx0dG9wOiBwSW50KHBhcmVudFN0eWxlLmhlaWdodCkgLSAoaW1nU3R5bGUgPyBwSW50KGltZ1N0eWxlLmxlZnQpIDogMSksXG5cdFx0XHRyb3RhdGlvbjogLTkwXG5cdFx0fSk7XG5cblx0XHQvLyBSZWN1cnNpdmVseSBpbnZlcnQgY2hpbGQgZWxlbWVudHMsIG5lZWRlZCBmb3IgbmVzdGVkIGNvbXBvc2l0ZSBzaGFwZXMgbGlrZSBib3ggcGxvdHMgYW5kIGVycm9yIGJhcnMuICMxNjgwLCAjMTgwNi5cblx0XHRlYWNoKGVsZW1lbnQuY2hpbGROb2RlcywgZnVuY3Rpb24gKGNoaWxkKSB7XG5cdFx0XHRyZW4uaW52ZXJ0Q2hpbGQoY2hpbGQsIGVsZW1lbnQpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTeW1ib2wgZGVmaW5pdGlvbnMgdGhhdCBvdmVycmlkZSB0aGUgcGFyZW50IFNWRyByZW5kZXJlcidzIHN5bWJvbHNcblx0ICpcblx0ICovXG5cdHN5bWJvbHM6IHtcblx0XHQvLyBWTUwgc3BlY2lmaWMgYXJjIGZ1bmN0aW9uXG5cdFx0YXJjOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHN0YXJ0ID0gb3B0aW9ucy5zdGFydCxcblx0XHRcdFx0ZW5kID0gb3B0aW9ucy5lbmQsXG5cdFx0XHRcdHJhZGl1cyA9IG9wdGlvbnMuciB8fCB3IHx8IGgsXG5cdFx0XHRcdGlubmVyUmFkaXVzID0gb3B0aW9ucy5pbm5lclIsXG5cdFx0XHRcdGNvc1N0YXJ0ID0gbWF0aENvcyhzdGFydCksXG5cdFx0XHRcdHNpblN0YXJ0ID0gbWF0aFNpbihzdGFydCksXG5cdFx0XHRcdGNvc0VuZCA9IG1hdGhDb3MoZW5kKSxcblx0XHRcdFx0c2luRW5kID0gbWF0aFNpbihlbmQpLFxuXHRcdFx0XHRyZXQ7XG5cblx0XHRcdGlmIChlbmQgLSBzdGFydCA9PT0gMCkgeyAvLyBubyBhbmdsZSwgZG9uJ3Qgc2hvdyBpdC5cblx0XHRcdFx0cmV0dXJuIFsneCddO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXQgPSBbXG5cdFx0XHRcdCd3YScsIC8vIGNsb2Nrd2lzZSBhcmMgdG9cblx0XHRcdFx0eCAtIHJhZGl1cywgLy8gbGVmdFxuXHRcdFx0XHR5IC0gcmFkaXVzLCAvLyB0b3Bcblx0XHRcdFx0eCArIHJhZGl1cywgLy8gcmlnaHRcblx0XHRcdFx0eSArIHJhZGl1cywgLy8gYm90dG9tXG5cdFx0XHRcdHggKyByYWRpdXMgKiBjb3NTdGFydCwgLy8gc3RhcnQgeFxuXHRcdFx0XHR5ICsgcmFkaXVzICogc2luU3RhcnQsIC8vIHN0YXJ0IHlcblx0XHRcdFx0eCArIHJhZGl1cyAqIGNvc0VuZCwgLy8gZW5kIHhcblx0XHRcdFx0eSArIHJhZGl1cyAqIHNpbkVuZCAgLy8gZW5kIHlcblx0XHRcdF07XG5cblx0XHRcdGlmIChvcHRpb25zLm9wZW4gJiYgIWlubmVyUmFkaXVzKSB7XG5cdFx0XHRcdHJldC5wdXNoKFxuXHRcdFx0XHRcdCdlJyxcblx0XHRcdFx0XHRNLFxuXHRcdFx0XHRcdHgsLy8gLSBpbm5lclJhZGl1cyxcblx0XHRcdFx0XHR5Ly8gLSBpbm5lclJhZGl1c1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXQucHVzaChcblx0XHRcdFx0J2F0JywgLy8gYW50aSBjbG9ja3dpc2UgYXJjIHRvXG5cdFx0XHRcdHggLSBpbm5lclJhZGl1cywgLy8gbGVmdFxuXHRcdFx0XHR5IC0gaW5uZXJSYWRpdXMsIC8vIHRvcFxuXHRcdFx0XHR4ICsgaW5uZXJSYWRpdXMsIC8vIHJpZ2h0XG5cdFx0XHRcdHkgKyBpbm5lclJhZGl1cywgLy8gYm90dG9tXG5cdFx0XHRcdHggKyBpbm5lclJhZGl1cyAqIGNvc0VuZCwgLy8gc3RhcnQgeFxuXHRcdFx0XHR5ICsgaW5uZXJSYWRpdXMgKiBzaW5FbmQsIC8vIHN0YXJ0IHlcblx0XHRcdFx0eCArIGlubmVyUmFkaXVzICogY29zU3RhcnQsIC8vIGVuZCB4XG5cdFx0XHRcdHkgKyBpbm5lclJhZGl1cyAqIHNpblN0YXJ0LCAvLyBlbmQgeVxuXHRcdFx0XHQneCcsIC8vIGZpbmlzaCBwYXRoXG5cdFx0XHRcdCdlJyAvLyBjbG9zZVxuXHRcdFx0KTtcblxuXHRcdFx0cmV0LmlzQXJjID0gdHJ1ZTtcblx0XHRcdHJldHVybiByZXQ7XG5cblx0XHR9LFxuXHRcdC8vIEFkZCBjaXJjbGUgc3ltYm9sIHBhdGguIFRoaXMgcGVyZm9ybXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiB2Om92YWwuXG5cdFx0Y2lyY2xlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgd3JhcHBlcikge1xuXG5cdFx0XHRpZiAod3JhcHBlcikge1xuXHRcdFx0XHR3ID0gaCA9IDIgKiB3cmFwcGVyLnI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENlbnRlciBjb3JyZWN0aW9uLCAjMTY4MlxuXHRcdFx0aWYgKHdyYXBwZXIgJiYgd3JhcHBlci5pc0NpcmNsZSkge1xuXHRcdFx0XHR4IC09IHcgLyAyO1xuXHRcdFx0XHR5IC09IGggLyAyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gdGhlIHBhdGhcblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdCd3YScsIC8vIGNsb2Nrd2lzZWFyY3RvXG5cdFx0XHRcdHgsIC8vIGxlZnRcblx0XHRcdFx0eSwgLy8gdG9wXG5cdFx0XHRcdHggKyB3LCAvLyByaWdodFxuXHRcdFx0XHR5ICsgaCwgLy8gYm90dG9tXG5cdFx0XHRcdHggKyB3LCAvLyBzdGFydCB4XG5cdFx0XHRcdHkgKyBoIC8gMiwgICAgIC8vIHN0YXJ0IHlcblx0XHRcdFx0eCArIHcsIC8vIGVuZCB4XG5cdFx0XHRcdHkgKyBoIC8gMiwgICAgIC8vIGVuZCB5XG5cdFx0XHRcdC8vJ3gnLCAvLyBmaW5pc2ggcGF0aFxuXHRcdFx0XHQnZScgLy8gY2xvc2Vcblx0XHRcdF07XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBBZGQgcmVjdGFuZ2xlIHN5bWJvbCBwYXRoIHdoaWNoIGVhc2VzIHJvdGF0aW9uIGFuZCBvbWl0cyBhcmNzaXplIHByb2JsZW1zXG5cdFx0ICogY29tcGFyZWQgdG8gdGhlIGJ1aWx0LWluIFZNTCByb3VuZHJlY3Qgc2hhcGUuIFdoZW4gYm9yZGVycyBhcmUgbm90IHJvdW5kZWQsXG5cdFx0ICogdXNlIHRoZSBzaW1wbGVyIHNxdWFyZSBwYXRoLCBlbHNlIHVzZSB0aGUgY2FsbG91dCBwYXRoIHdpdGhvdXQgdGhlIGFycm93LlxuXHRcdCAqL1xuXHRcdHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gU1ZHUmVuZGVyZXIucHJvdG90eXBlLnN5bWJvbHNbXG5cdFx0XHRcdCFkZWZpbmVkKG9wdGlvbnMpIHx8ICFvcHRpb25zLnIgPyAnc3F1YXJlJyA6ICdjYWxsb3V0J1xuXHRcdFx0XS5jYWxsKDAsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuXHRcdH1cblx0fVxufTtcbkhpZ2hjaGFydHMuVk1MUmVuZGVyZXIgPSBWTUxSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuVk1MUmVuZGVyZXIucHJvdG90eXBlID0gbWVyZ2UoU1ZHUmVuZGVyZXIucHJvdG90eXBlLCBWTUxSZW5kZXJlckV4dGVuc2lvbik7XG5cblx0Ly8gZ2VuZXJhbCByZW5kZXJlclxuXHRSZW5kZXJlciA9IFZNTFJlbmRlcmVyO1xufVxuXG4vLyBUaGlzIG1ldGhvZCBpcyB1c2VkIHdpdGggZXhwb3J0aW5nIGluIG9sZCBJRSwgd2hlbiBlbXVsYXRpbmcgU1ZHIChzZWUgIzIzMTQpXG5TVkdSZW5kZXJlci5wcm90b3R5cGUubWVhc3VyZVNwYW5XaWR0aCA9IGZ1bmN0aW9uICh0ZXh0LCBzdHlsZXMpIHtcblx0dmFyIG1lYXN1cmluZ1NwYW4gPSBkb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpLFxuXHRcdG9mZnNldFdpZHRoLFxuXHR0ZXh0Tm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcblxuXHRtZWFzdXJpbmdTcGFuLmFwcGVuZENoaWxkKHRleHROb2RlKTtcblx0Y3NzKG1lYXN1cmluZ1NwYW4sIHN0eWxlcyk7XG5cdHRoaXMuYm94LmFwcGVuZENoaWxkKG1lYXN1cmluZ1NwYW4pO1xuXHRvZmZzZXRXaWR0aCA9IG1lYXN1cmluZ1NwYW4ub2Zmc2V0V2lkdGg7XG5cdGRpc2NhcmRFbGVtZW50KG1lYXN1cmluZ1NwYW4pOyAvLyAjMjQ2M1xuXHRyZXR1cm4gb2Zmc2V0V2lkdGg7XG59O1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIEVORCBPRiBJTlRFUk5FVCBFWFBMT1JFUiA8PSA4IFNQRUNJRklDIENPREUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIFNUQVJUIE9GIEFORFJPSUQgPCAzIFNQRUNJRklDIENPREUuIFRISVMgQ0FOIEJFIFJFTU9WRUQgSUYgWU9VJ1JFIE5PVCAgICAgICpcbiAqIFRBUkdFVElORyBUSEFUIFNZU1RFTS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBDYW5WR1JlbmRlcmVyLFxuXHRDYW5WR0NvbnRyb2xsZXI7XG5cbmlmICh1c2VDYW5WRykge1xuXHQvKipcblx0ICogVGhlIENhblZHUmVuZGVyZXIgaXMgZW1wdHkgZnJvbSBzdGFydCB0byBrZWVwIHRoZSBzb3VyY2UgZm9vdHByaW50IHNtYWxsLlxuXHQgKiBXaGVuIHJlcXVlc3RlZCwgdGhlIENhblZHQ29udHJvbGxlciBkb3dubG9hZHMgdGhlIHJlc3Qgb2YgdGhlIHNvdXJjZSBwYWNrYWdlZFxuXHQgKiB0b2dldGhlciB3aXRoIHRoZSBjYW52ZyBsaWJyYXJ5LlxuXHQgKi9cblx0SGlnaGNoYXJ0cy5DYW5WR1JlbmRlcmVyID0gQ2FuVkdSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBPdmVycmlkZSB0aGUgZ2xvYmFsIFNWRyBuYW1lc3BhY2UgdG8gZmFrZSBTVkcvSFRNTCB0aGF0IGFjY2VwdHMgQ1NTXG5cdFx0U1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFydCB3aXRoIGFuIGVtcHR5IHN5bWJvbHMgb2JqZWN0LiBUaGlzIGlzIG5lZWRlZCB3aGVuIGV4cG9ydGluZyBpcyB1c2VkIChleHBvcnRpbmcuc3JjLmpzIHdpbGwgYWRkIGEgZmV3IHN5bWJvbHMpLCBidXQgXG5cdCAqIHRoZSBpbXBsZW1lbnRhdGlvbiBmcm9tIFN2Z1JlbmRlcmVyIHdpbGwgbm90IGJlIG1lcmdlZCBpbiB1bnRpbCBmaXJzdCByZW5kZXIuXG5cdCAqL1xuXHRDYW5WR1JlbmRlcmVyLnByb3RvdHlwZS5zeW1ib2xzID0ge307XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgb24gZGVtYW5kIGRvd25sb2FkIG9mIGNhbnZnIHJlbmRlcmluZyBzdXBwb3J0LlxuXHQgKi9cblx0Q2FuVkdDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcblx0XHQvLyBMaXN0IG9mIHJlbmRlcmVyaW5nIGNhbGxzXG5cdFx0dmFyIGRlZmVycmVkUmVuZGVyQ2FsbHMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gZG93bmxvYWRlZCwgd2UgYXJlIHJlYWR5IHRvIGRyYXcgZGVmZXJyZWQgY2hhcnRzLlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGRyYXdEZWZlcnJlZCgpIHtcblx0XHRcdHZhciBjYWxsTGVuZ3RoID0gZGVmZXJyZWRSZW5kZXJDYWxscy5sZW5ndGgsXG5cdFx0XHRcdGNhbGxJbmRleDtcblxuXHRcdFx0Ly8gRHJhdyBhbGwgcGVuZGluZyByZW5kZXIgY2FsbHNcblx0XHRcdGZvciAoY2FsbEluZGV4ID0gMDsgY2FsbEluZGV4IDwgY2FsbExlbmd0aDsgY2FsbEluZGV4KyspIHtcblx0XHRcdFx0ZGVmZXJyZWRSZW5kZXJDYWxsc1tjYWxsSW5kZXhdKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDbGVhciB0aGUgbGlzdFxuXHRcdFx0ZGVmZXJyZWRSZW5kZXJDYWxscyA9IFtdO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRwdXNoOiBmdW5jdGlvbiAoZnVuYywgc2NyaXB0TG9jYXRpb24pIHtcblx0XHRcdFx0Ly8gT25seSBnZXQgdGhlIHNjcmlwdCBvbmNlXG5cdFx0XHRcdGlmIChkZWZlcnJlZFJlbmRlckNhbGxzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdGdldFNjcmlwdChzY3JpcHRMb2NhdGlvbiwgZHJhd0RlZmVycmVkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBSZWdpc3RlciByZW5kZXIgY2FsbFxuXHRcdFx0XHRkZWZlcnJlZFJlbmRlckNhbGxzLnB1c2goZnVuYyk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSgpKTtcblxuXHRSZW5kZXJlciA9IENhblZHUmVuZGVyZXI7XG59IC8vIGVuZCBDYW5WR1JlbmRlcmVyXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIEVORCBPRiBBTkRST0lEIDwgMyBTUEVDSUZJQyBDT0RFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gKiBUaGUgVGljayBjbGFzc1xuICovXG5mdW5jdGlvbiBUaWNrKGF4aXMsIHBvcywgdHlwZSwgbm9MYWJlbCkge1xuXHR0aGlzLmF4aXMgPSBheGlzO1xuXHR0aGlzLnBvcyA9IHBvcztcblx0dGhpcy50eXBlID0gdHlwZSB8fCAnJztcblx0dGhpcy5pc05ldyA9IHRydWU7XG5cblx0aWYgKCF0eXBlICYmICFub0xhYmVsKSB7XG5cdFx0dGhpcy5hZGRMYWJlbCgpO1xuXHR9XG59XG5cblRpY2sucHJvdG90eXBlID0ge1xuXHQvKipcblx0ICogV3JpdGUgdGhlIHRpY2sgbGFiZWxcblx0ICovXG5cdGFkZExhYmVsOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRpY2sgPSB0aGlzLFxuXHRcdFx0YXhpcyA9IHRpY2suYXhpcyxcblx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRjYXRlZ29yaWVzID0gYXhpcy5jYXRlZ29yaWVzLFxuXHRcdFx0bmFtZXMgPSBheGlzLm5hbWVzLFxuXHRcdFx0cG9zID0gdGljay5wb3MsXG5cdFx0XHRsYWJlbE9wdGlvbnMgPSBvcHRpb25zLmxhYmVscyxcblx0XHRcdHN0cixcblx0XHRcdHRpY2tQb3NpdGlvbnMgPSBheGlzLnRpY2tQb3NpdGlvbnMsXG5cdFx0XHRpc0ZpcnN0ID0gcG9zID09PSB0aWNrUG9zaXRpb25zWzBdLFxuXHRcdFx0aXNMYXN0ID0gcG9zID09PSB0aWNrUG9zaXRpb25zW3RpY2tQb3NpdGlvbnMubGVuZ3RoIC0gMV0sXG5cdFx0XHR2YWx1ZSA9IGNhdGVnb3JpZXMgP1xuXHRcdFx0XHRwaWNrKGNhdGVnb3JpZXNbcG9zXSwgbmFtZXNbcG9zXSwgcG9zKSA6XG5cdFx0XHRcdHBvcyxcblx0XHRcdGxhYmVsID0gdGljay5sYWJlbCxcblx0XHRcdHRpY2tQb3NpdGlvbkluZm8gPSB0aWNrUG9zaXRpb25zLmluZm8sXG5cdFx0XHRkYXRlVGltZUxhYmVsRm9ybWF0O1xuXG5cdFx0Ly8gU2V0IHRoZSBkYXRldGltZSBsYWJlbCBmb3JtYXQuIElmIGEgaGlnaGVyIHJhbmsgaXMgc2V0IGZvciB0aGlzIHBvc2l0aW9uLCB1c2UgdGhhdC4gSWYgbm90LFxuXHRcdC8vIHVzZSB0aGUgZ2VuZXJhbCBmb3JtYXQuXG5cdFx0aWYgKGF4aXMuaXNEYXRldGltZUF4aXMgJiYgdGlja1Bvc2l0aW9uSW5mbykge1xuXHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdCA9IG9wdGlvbnMuZGF0ZVRpbWVMYWJlbEZvcm1hdHNbdGlja1Bvc2l0aW9uSW5mby5oaWdoZXJSYW5rc1twb3NdIHx8IHRpY2tQb3NpdGlvbkluZm8udW5pdE5hbWVdO1xuXHRcdH1cblx0XHQvLyBzZXQgcHJvcGVydGllcyBmb3IgYWNjZXNzIGluIHJlbmRlciBtZXRob2Rcblx0XHR0aWNrLmlzRmlyc3QgPSBpc0ZpcnN0O1xuXHRcdHRpY2suaXNMYXN0ID0gaXNMYXN0O1xuXG5cdFx0Ly8gZ2V0IHRoZSBzdHJpbmdcblx0XHRzdHIgPSBheGlzLmxhYmVsRm9ybWF0dGVyLmNhbGwoe1xuXHRcdFx0YXhpczogYXhpcyxcblx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdGlzRmlyc3Q6IGlzRmlyc3QsXG5cdFx0XHRpc0xhc3Q6IGlzTGFzdCxcblx0XHRcdGRhdGVUaW1lTGFiZWxGb3JtYXQ6IGRhdGVUaW1lTGFiZWxGb3JtYXQsXG5cdFx0XHR2YWx1ZTogYXhpcy5pc0xvZyA/IGNvcnJlY3RGbG9hdChsaW4ybG9nKHZhbHVlKSkgOiB2YWx1ZVxuXHRcdH0pO1xuXG5cdFx0Ly8gcHJlcGFyZSBDU1Ncblx0XHQvL2NzcyA9IHdpZHRoICYmIHsgd2lkdGg6IG1hdGhNYXgoMSwgbWF0aFJvdW5kKHdpZHRoIC0gMiAqIChsYWJlbE9wdGlvbnMucGFkZGluZyB8fCAxMCkpKSArIFBYIH07XG5cdFx0XG5cdFx0Ly8gZmlyc3QgY2FsbFxuXHRcdGlmICghZGVmaW5lZChsYWJlbCkpIHtcblxuXHRcdFx0dGljay5sYWJlbCA9IGxhYmVsID1cblx0XHRcdFx0ZGVmaW5lZChzdHIpICYmIGxhYmVsT3B0aW9ucy5lbmFibGVkID9cblx0XHRcdFx0XHRjaGFydC5yZW5kZXJlci50ZXh0KFxuXHRcdFx0XHRcdFx0XHRzdHIsXG5cdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdGxhYmVsT3B0aW9ucy51c2VIVE1MXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQvLy5hdHRyKGF0dHIpXG5cdFx0XHRcdFx0XHQvLyB3aXRob3V0IHBvc2l0aW9uIGFic29sdXRlLCBJRSBleHBvcnQgc29tZXRpbWVzIGlzIHdyb25nXG5cdFx0XHRcdFx0XHQuY3NzKG1lcmdlKGxhYmVsT3B0aW9ucy5zdHlsZSkpXG5cdFx0XHRcdFx0XHQuYWRkKGF4aXMubGFiZWxHcm91cCkgOlxuXHRcdFx0XHRcdG51bGw7XG5cdFx0XHR0aWNrLmxhYmVsTGVuZ3RoID0gbGFiZWwgJiYgbGFiZWwuZ2V0QkJveCgpLndpZHRoOyAvLyBVbi1yb3RhdGVkIGxlbmd0aFxuXHRcdFx0dGljay5yb3RhdGlvbiA9IDA7IC8vIEJhc2UgdmFsdWUgdG8gZGV0ZWN0IGNoYW5nZSBmb3IgbmV3IGNhbGxzIHRvIGdldEJCb3hcblxuXHRcdC8vIHVwZGF0ZVxuXHRcdH0gZWxzZSBpZiAobGFiZWwpIHtcblx0XHRcdGxhYmVsLmF0dHIoeyB0ZXh0OiBzdHIgfSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIG9mZnNldCBoZWlnaHQgb3Igd2lkdGggb2YgdGhlIGxhYmVsXG5cdCAqL1xuXHRnZXRMYWJlbFNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5sYWJlbCA/XG5cdFx0XHR0aGlzLmxhYmVsLmdldEJCb3goKVt0aGlzLmF4aXMuaG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCddIDpcblx0XHRcdDA7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSB0aGUgbGFiZWwgb3ZlcmZsb3cgYnkgYWRqdXN0aW5nIHRoZSBsYWJlbHMgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IGVkZ2UsIG9yXG5cdCAqIGhpZGUgdGhlbSBpZiB0aGV5IGNvbGxpZGUgaW50byB0aGUgbmVpZ2hib3VyIGxhYmVsLlxuXHQgKi9cblx0aGFuZGxlT3ZlcmZsb3c6IGZ1bmN0aW9uICh4eSkge1xuXHRcdHZhciBheGlzID0gdGhpcy5heGlzLFxuXHRcdFx0cHhQb3MgPSB4eS54LFxuXHRcdFx0Y2hhcnRXaWR0aCA9IGF4aXMuY2hhcnQuY2hhcnRXaWR0aCxcblx0XHRcdHNwYWNpbmcgPSBheGlzLmNoYXJ0LnNwYWNpbmcsXG5cdFx0XHRsZWZ0Qm91bmQgPSBwaWNrKGF4aXMubGFiZWxMZWZ0LCBtYXRoTWluKGF4aXMucG9zLCBzcGFjaW5nWzNdKSksXG5cdFx0XHRyaWdodEJvdW5kID0gcGljayhheGlzLmxhYmVsUmlnaHQsIG1hdGhNYXgoYXhpcy5wb3MgKyBheGlzLmxlbiwgY2hhcnRXaWR0aCAtIHNwYWNpbmdbMV0pKSxcblx0XHRcdGxhYmVsID0gdGhpcy5sYWJlbCxcblx0XHRcdHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbixcblx0XHRcdGZhY3RvciA9IHsgbGVmdDogMCwgY2VudGVyOiAwLjUsIHJpZ2h0OiAxIH1bYXhpcy5sYWJlbEFsaWduXSxcblx0XHRcdGxhYmVsV2lkdGggPSBsYWJlbC5nZXRCQm94KCkud2lkdGgsXG5cdFx0XHRzbG90V2lkdGggPSBheGlzLnNsb3RXaWR0aCxcblx0XHRcdHhDb3JyZWN0aW9uID0gZmFjdG9yLFxuXHRcdFx0Z29SaWdodCA9IDEsXG5cdFx0XHRsZWZ0UG9zLFxuXHRcdFx0cmlnaHRQb3MsXG5cdFx0XHR0ZXh0V2lkdGgsXG5cdFx0XHRjc3MgPSB7fTtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBsYWJlbCBvdmVyc2hvb3RzIHRoZSBjaGFydCBzcGFjaW5nIGJveC4gSWYgaXQgZG9lcywgbW92ZSBpdC5cblx0XHQvLyBJZiBpdCBub3cgb3ZlcnNob290cyB0aGUgc2xvdFdpZHRoLCBhZGQgZWxsaXBzaXMuXG5cdFx0aWYgKCFyb3RhdGlvbikge1xuXHRcdFx0bGVmdFBvcyA9IHB4UG9zIC0gZmFjdG9yICogbGFiZWxXaWR0aDtcblx0XHRcdHJpZ2h0UG9zID0gcHhQb3MgKyAoMSAtIGZhY3RvcikgKiBsYWJlbFdpZHRoO1xuXG5cdFx0XHRpZiAobGVmdFBvcyA8IGxlZnRCb3VuZCkge1xuXHRcdFx0XHRzbG90V2lkdGggPSB4eS54ICsgc2xvdFdpZHRoICogKDEgLSBmYWN0b3IpIC0gbGVmdEJvdW5kO1xuXHRcdFx0fSBlbHNlIGlmIChyaWdodFBvcyA+IHJpZ2h0Qm91bmQpIHtcblx0XHRcdFx0c2xvdFdpZHRoID0gcmlnaHRCb3VuZCAtIHh5LnggKyBzbG90V2lkdGggKiBmYWN0b3I7XG5cdFx0XHRcdGdvUmlnaHQgPSAtMTtcblx0XHRcdH1cblxuXHRcdFx0c2xvdFdpZHRoID0gbWF0aE1pbihheGlzLnNsb3RXaWR0aCwgc2xvdFdpZHRoKTsgLy8gIzQxNzdcblx0XHRcdGlmIChzbG90V2lkdGggPCBheGlzLnNsb3RXaWR0aCAmJiBheGlzLmxhYmVsQWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRcdHh5LnggKz0gZ29SaWdodCAqIChheGlzLnNsb3RXaWR0aCAtIHNsb3RXaWR0aCAtIHhDb3JyZWN0aW9uICogKGF4aXMuc2xvdFdpZHRoIC0gbWF0aE1pbihsYWJlbFdpZHRoLCBzbG90V2lkdGgpKSk7XHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoZSBsYWJlbCB3aWR0aCBleGNlZWRzIHRoZSBhdmFpbGFibGUgc3BhY2UsIHNldCBhIHRleHQgd2lkdGggdG8gYmUgXG5cdFx0XHQvLyBwaWNrZWQgdXAgYmVsb3cuIEFsc28sIGlmIGEgd2lkdGggaGFzIGJlZW4gc2V0IGJlZm9yZSwgd2UgbmVlZCB0byBzZXQgYSBuZXdcblx0XHRcdC8vIG9uZSBiZWNhdXNlIHRoZSByZXBvcnRlZCBsYWJlbFdpZHRoIHdpbGwgYmUgbGltaXRlZCBieSB0aGUgYm94ICgjMzkzOCkuXG5cdFx0XHRpZiAobGFiZWxXaWR0aCA+IHNsb3RXaWR0aCB8fCAoYXhpcy5hdXRvUm90YXRpb24gJiYgbGFiZWwuc3R5bGVzLndpZHRoKSkge1xuXHRcdFx0XHR0ZXh0V2lkdGggPSBzbG90V2lkdGg7XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxsaXBzaXMgdG8gcHJldmVudCByb3RhdGVkIGxhYmVscyB0byBiZSBjbGlwcGVkIGFnYWluc3QgdGhlIGVkZ2Ugb2YgdGhlIGNoYXJ0XG5cdFx0fSBlbHNlIGlmIChyb3RhdGlvbiA8IDAgJiYgcHhQb3MgLSBmYWN0b3IgKiBsYWJlbFdpZHRoIDwgbGVmdEJvdW5kKSB7XG5cdFx0XHR0ZXh0V2lkdGggPSBtYXRoUm91bmQocHhQb3MgLyBtYXRoQ29zKHJvdGF0aW9uICogZGVnMnJhZCkgLSBsZWZ0Qm91bmQpO1xuXHRcdH0gZWxzZSBpZiAocm90YXRpb24gPiAwICYmIHB4UG9zICsgZmFjdG9yICogbGFiZWxXaWR0aCA+IHJpZ2h0Qm91bmQpIHtcblx0XHRcdHRleHRXaWR0aCA9IG1hdGhSb3VuZCgoY2hhcnRXaWR0aCAtIHB4UG9zKSAvIG1hdGhDb3Mocm90YXRpb24gKiBkZWcycmFkKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRleHRXaWR0aCkge1xuXHRcdFx0Y3NzLndpZHRoID0gdGV4dFdpZHRoO1xuXHRcdFx0aWYgKCFheGlzLm9wdGlvbnMubGFiZWxzLnN0eWxlLnRleHRPdmVyZmxvdykge1xuXHRcdFx0XHRjc3MudGV4dE92ZXJmbG93ID0gJ2VsbGlwc2lzJztcblx0XHRcdH1cblx0XHRcdGxhYmVsLmNzcyhjc3MpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSB4IGFuZCB5IHBvc2l0aW9uIGZvciB0aWNrcyBhbmQgbGFiZWxzXG5cdCAqL1xuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKGhvcml6LCBwb3MsIHRpY2ttYXJrT2Zmc2V0LCBvbGQpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMuYXhpcyxcblx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdGNIZWlnaHQgPSAob2xkICYmIGNoYXJ0Lm9sZENoYXJ0SGVpZ2h0KSB8fCBjaGFydC5jaGFydEhlaWdodDtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBob3JpeiA/XG5cdFx0XHRcdGF4aXMudHJhbnNsYXRlKHBvcyArIHRpY2ttYXJrT2Zmc2V0LCBudWxsLCBudWxsLCBvbGQpICsgYXhpcy50cmFuc0IgOlxuXHRcdFx0XHRheGlzLmxlZnQgKyBheGlzLm9mZnNldCArIChheGlzLm9wcG9zaXRlID8gKChvbGQgJiYgY2hhcnQub2xkQ2hhcnRXaWR0aCkgfHwgY2hhcnQuY2hhcnRXaWR0aCkgLSBheGlzLnJpZ2h0IC0gYXhpcy5sZWZ0IDogMCksXG5cblx0XHRcdHk6IGhvcml6ID9cblx0XHRcdFx0Y0hlaWdodCAtIGF4aXMuYm90dG9tICsgYXhpcy5vZmZzZXQgLSAoYXhpcy5vcHBvc2l0ZSA/IGF4aXMuaGVpZ2h0IDogMCkgOlxuXHRcdFx0XHRjSGVpZ2h0IC0gYXhpcy50cmFuc2xhdGUocG9zICsgdGlja21hcmtPZmZzZXQsIG51bGwsIG51bGwsIG9sZCkgLSBheGlzLnRyYW5zQlxuXHRcdH07XG5cblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSB4LCB5IHBvc2l0aW9uIG9mIHRoZSB0aWNrIGxhYmVsXG5cdCAqL1xuXHRnZXRMYWJlbFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSwgbGFiZWwsIGhvcml6LCBsYWJlbE9wdGlvbnMsIHRpY2ttYXJrT2Zmc2V0LCBpbmRleCwgc3RlcCkge1xuXHRcdHZhciBheGlzID0gdGhpcy5heGlzLFxuXHRcdFx0dHJhbnNBID0gYXhpcy50cmFuc0EsXG5cdFx0XHRyZXZlcnNlZCA9IGF4aXMucmV2ZXJzZWQsXG5cdFx0XHRzdGFnZ2VyTGluZXMgPSBheGlzLnN0YWdnZXJMaW5lcyxcblx0XHRcdHJvdENvcnIgPSBheGlzLnRpY2tSb3RDb3JyIHx8IHsgeDogMCwgeTogMCB9LFxuXHRcdFx0eU9mZnNldCA9IHBpY2sobGFiZWxPcHRpb25zLnksIHJvdENvcnIueSArIChheGlzLnNpZGUgPT09IDIgPyA4IDogLShsYWJlbC5nZXRCQm94KCkuaGVpZ2h0IC8gMikpKSxcblx0XHRcdGxpbmU7XG5cblx0XHR4ID0geCArIGxhYmVsT3B0aW9ucy54ICsgcm90Q29yci54IC0gKHRpY2ttYXJrT2Zmc2V0ICYmIGhvcml6ID9cblx0XHRcdHRpY2ttYXJrT2Zmc2V0ICogdHJhbnNBICogKHJldmVyc2VkID8gLTEgOiAxKSA6IDApO1xuXHRcdHkgPSB5ICsgeU9mZnNldCAtICh0aWNrbWFya09mZnNldCAmJiAhaG9yaXogP1xuXHRcdFx0dGlja21hcmtPZmZzZXQgKiB0cmFuc0EgKiAocmV2ZXJzZWQgPyAxIDogLTEpIDogMCk7XG5cblx0XHQvLyBDb3JyZWN0IGZvciBzdGFnZ2VyZWQgbGFiZWxzXG5cdFx0aWYgKHN0YWdnZXJMaW5lcykge1xuXHRcdFx0bGluZSA9IChpbmRleCAvIChzdGVwIHx8IDEpICUgc3RhZ2dlckxpbmVzKTtcblx0XHRcdHkgKz0gbGluZSAqIChheGlzLmxhYmVsT2Zmc2V0IC8gc3RhZ2dlckxpbmVzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IG1hdGhSb3VuZCh5KVxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEV4dGVuZGlibGUgbWV0aG9kIHRvIHJldHVybiB0aGUgcGF0aCBvZiB0aGUgbWFya2VyXG5cdCAqL1xuXHRnZXRNYXJrUGF0aDogZnVuY3Rpb24gKHgsIHksIHRpY2tMZW5ndGgsIHRpY2tXaWR0aCwgaG9yaXosIHJlbmRlcmVyKSB7XG5cdFx0cmV0dXJuIHJlbmRlcmVyLmNyaXNwTGluZShbXG5cdFx0XHRcdE0sXG5cdFx0XHRcdHgsXG5cdFx0XHRcdHksXG5cdFx0XHRcdEwsXG5cdFx0XHRcdHggKyAoaG9yaXogPyAwIDogLXRpY2tMZW5ndGgpLFxuXHRcdFx0XHR5ICsgKGhvcml6ID8gdGlja0xlbmd0aCA6IDApXG5cdFx0XHRdLCB0aWNrV2lkdGgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQdXQgZXZlcnl0aGluZyBpbiBwbGFjZVxuXHQgKlxuXHQgKiBAcGFyYW0gaW5kZXgge051bWJlcn1cblx0ICogQHBhcmFtIG9sZCB7Qm9vbGVhbn0gVXNlIG9sZCBjb29yZGluYXRlcyB0byBwcmVwYXJlIGFuIGFuaW1hdGlvbiBpbnRvIG5ldyBwb3NpdGlvblxuXHQgKi9cblx0cmVuZGVyOiBmdW5jdGlvbiAoaW5kZXgsIG9sZCwgb3BhY2l0eSkge1xuXHRcdHZhciB0aWNrID0gdGhpcyxcblx0XHRcdGF4aXMgPSB0aWNrLmF4aXMsXG5cdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdGhvcml6ID0gYXhpcy5ob3Jpeixcblx0XHRcdHR5cGUgPSB0aWNrLnR5cGUsXG5cdFx0XHRsYWJlbCA9IHRpY2subGFiZWwsXG5cdFx0XHRwb3MgPSB0aWNrLnBvcyxcblx0XHRcdGxhYmVsT3B0aW9ucyA9IG9wdGlvbnMubGFiZWxzLFxuXHRcdFx0Z3JpZExpbmUgPSB0aWNrLmdyaWRMaW5lLFxuXHRcdFx0Z3JpZFByZWZpeCA9IHR5cGUgPyB0eXBlICsgJ0dyaWQnIDogJ2dyaWQnLFxuXHRcdFx0dGlja1ByZWZpeCA9IHR5cGUgPyB0eXBlICsgJ1RpY2snIDogJ3RpY2snLFxuXHRcdFx0Z3JpZExpbmVXaWR0aCA9IG9wdGlvbnNbZ3JpZFByZWZpeCArICdMaW5lV2lkdGgnXSxcblx0XHRcdGdyaWRMaW5lQ29sb3IgPSBvcHRpb25zW2dyaWRQcmVmaXggKyAnTGluZUNvbG9yJ10sXG5cdFx0XHRkYXNoU3R5bGUgPSBvcHRpb25zW2dyaWRQcmVmaXggKyAnTGluZURhc2hTdHlsZSddLFxuXHRcdFx0dGlja0xlbmd0aCA9IG9wdGlvbnNbdGlja1ByZWZpeCArICdMZW5ndGgnXSxcblx0XHRcdHRpY2tXaWR0aCA9IHBpY2sob3B0aW9uc1t0aWNrUHJlZml4ICsgJ1dpZHRoJ10sICF0eXBlICYmIGF4aXMuaXNYQXhpcyA/IDEgOiAwKSwgLy8gWCBheGlzIGRlZmF1bHRzIHRvIDFcblx0XHRcdHRpY2tDb2xvciA9IG9wdGlvbnNbdGlja1ByZWZpeCArICdDb2xvciddLFxuXHRcdFx0dGlja1Bvc2l0aW9uID0gb3B0aW9uc1t0aWNrUHJlZml4ICsgJ1Bvc2l0aW9uJ10sXG5cdFx0XHRncmlkTGluZVBhdGgsXG5cdFx0XHRtYXJrID0gdGljay5tYXJrLFxuXHRcdFx0bWFya1BhdGgsXG5cdFx0XHRzdGVwID0gLypheGlzLmxhYmVsU3RlcCB8fCAqL2xhYmVsT3B0aW9ucy5zdGVwLFxuXHRcdFx0YXR0cmlicyxcblx0XHRcdHNob3cgPSB0cnVlLFxuXHRcdFx0dGlja21hcmtPZmZzZXQgPSBheGlzLnRpY2ttYXJrT2Zmc2V0LFxuXHRcdFx0eHkgPSB0aWNrLmdldFBvc2l0aW9uKGhvcml6LCBwb3MsIHRpY2ttYXJrT2Zmc2V0LCBvbGQpLFxuXHRcdFx0eCA9IHh5LngsXG5cdFx0XHR5ID0geHkueSxcblx0XHRcdHJldmVyc2VDcmlzcCA9ICgoaG9yaXogJiYgeCA9PT0gYXhpcy5wb3MgKyBheGlzLmxlbikgfHwgKCFob3JpeiAmJiB5ID09PSBheGlzLnBvcykpID8gLTEgOiAxOyAvLyAjMTQ4MCwgIzE2ODdcblxuXHRcdG9wYWNpdHkgPSBwaWNrKG9wYWNpdHksIDEpO1xuXHRcdHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuXG5cdFx0Ly8gY3JlYXRlIHRoZSBncmlkIGxpbmVcblx0XHRpZiAoZ3JpZExpbmVXaWR0aCkge1xuXHRcdFx0Z3JpZExpbmVQYXRoID0gYXhpcy5nZXRQbG90TGluZVBhdGgocG9zICsgdGlja21hcmtPZmZzZXQsIGdyaWRMaW5lV2lkdGggKiByZXZlcnNlQ3Jpc3AsIG9sZCwgdHJ1ZSk7XG5cblx0XHRcdGlmIChncmlkTGluZSA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdGF0dHJpYnMgPSB7XG5cdFx0XHRcdFx0c3Ryb2tlOiBncmlkTGluZUNvbG9yLFxuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBncmlkTGluZVdpZHRoXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChkYXNoU3R5bGUpIHtcblx0XHRcdFx0XHRhdHRyaWJzLmRhc2hzdHlsZSA9IGRhc2hTdHlsZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXR5cGUpIHtcblx0XHRcdFx0XHRhdHRyaWJzLnpJbmRleCA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9sZCkge1xuXHRcdFx0XHRcdGF0dHJpYnMub3BhY2l0eSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGljay5ncmlkTGluZSA9IGdyaWRMaW5lID1cblx0XHRcdFx0XHRncmlkTGluZVdpZHRoID9cblx0XHRcdFx0XHRcdHJlbmRlcmVyLnBhdGgoZ3JpZExpbmVQYXRoKVxuXHRcdFx0XHRcdFx0XHQuYXR0cihhdHRyaWJzKS5hZGQoYXhpcy5ncmlkR3JvdXApIDpcblx0XHRcdFx0XHRcdG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSBwYXJhbWV0ZXIgJ29sZCcgaXMgc2V0LCB0aGUgY3VycmVudCBjYWxsIHdpbGwgYmUgZm9sbG93ZWRcblx0XHRcdC8vIGJ5IGFub3RoZXIgY2FsbCwgdGhlcmVmb3JlIGRvIG5vdCBkbyBhbnkgYW5pbWF0aW9ucyB0aGlzIHRpbWVcblx0XHRcdGlmICghb2xkICYmIGdyaWRMaW5lICYmIGdyaWRMaW5lUGF0aCkge1xuXHRcdFx0XHRncmlkTGluZVt0aWNrLmlzTmV3ID8gJ2F0dHInIDogJ2FuaW1hdGUnXSh7XG5cdFx0XHRcdFx0ZDogZ3JpZExpbmVQYXRoLFxuXHRcdFx0XHRcdG9wYWNpdHk6IG9wYWNpdHlcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIHRoZSB0aWNrIG1hcmtcblx0XHRpZiAodGlja1dpZHRoICYmIHRpY2tMZW5ndGgpIHtcblxuXHRcdFx0Ly8gbmVnYXRlIHRoZSBsZW5ndGhcblx0XHRcdGlmICh0aWNrUG9zaXRpb24gPT09ICdpbnNpZGUnKSB7XG5cdFx0XHRcdHRpY2tMZW5ndGggPSAtdGlja0xlbmd0aDtcblx0XHRcdH1cblx0XHRcdGlmIChheGlzLm9wcG9zaXRlKSB7XG5cdFx0XHRcdHRpY2tMZW5ndGggPSAtdGlja0xlbmd0aDtcblx0XHRcdH1cblxuXHRcdFx0bWFya1BhdGggPSB0aWNrLmdldE1hcmtQYXRoKHgsIHksIHRpY2tMZW5ndGgsIHRpY2tXaWR0aCAqIHJldmVyc2VDcmlzcCwgaG9yaXosIHJlbmRlcmVyKTtcblx0XHRcdGlmIChtYXJrKSB7IC8vIHVwZGF0aW5nXG5cdFx0XHRcdG1hcmsuYW5pbWF0ZSh7XG5cdFx0XHRcdFx0ZDogbWFya1BhdGgsXG5cdFx0XHRcdFx0b3BhY2l0eTogb3BhY2l0eVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7IC8vIGZpcnN0IHRpbWVcblx0XHRcdFx0dGljay5tYXJrID0gcmVuZGVyZXIucGF0aChcblx0XHRcdFx0XHRtYXJrUGF0aFxuXHRcdFx0XHQpLmF0dHIoe1xuXHRcdFx0XHRcdHN0cm9rZTogdGlja0NvbG9yLFxuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiB0aWNrV2lkdGgsXG5cdFx0XHRcdFx0b3BhY2l0eTogb3BhY2l0eVxuXHRcdFx0XHR9KS5hZGQoYXhpcy5heGlzR3JvdXApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoZSBsYWJlbCBpcyBjcmVhdGVkIG9uIGluaXQgLSBub3cgbW92ZSBpdCBpbnRvIHBsYWNlXG5cdFx0aWYgKGxhYmVsICYmICFpc05hTih4KSkge1xuXHRcdFx0bGFiZWwueHkgPSB4eSA9IHRpY2suZ2V0TGFiZWxQb3NpdGlvbih4LCB5LCBsYWJlbCwgaG9yaXosIGxhYmVsT3B0aW9ucywgdGlja21hcmtPZmZzZXQsIGluZGV4LCBzdGVwKTtcblxuXHRcdFx0Ly8gQXBwbHkgc2hvdyBmaXJzdCBhbmQgc2hvdyBsYXN0LiBJZiB0aGUgdGljayBpcyBib3RoIGZpcnN0IGFuZCBsYXN0LCBpdCBpc1xuXHRcdFx0Ly8gYSBzaW5nbGUgY2VudGVyZWQgdGljaywgaW4gd2hpY2ggY2FzZSB3ZSBzaG93IHRoZSBsYWJlbCBhbnl3YXkgKCMyMTAwKS5cblx0XHRcdGlmICgodGljay5pc0ZpcnN0ICYmICF0aWNrLmlzTGFzdCAmJiAhcGljayhvcHRpb25zLnNob3dGaXJzdExhYmVsLCAxKSkgfHxcblx0XHRcdFx0XHQodGljay5pc0xhc3QgJiYgIXRpY2suaXNGaXJzdCAmJiAhcGljayhvcHRpb25zLnNob3dMYXN0TGFiZWwsIDEpKSkge1xuXHRcdFx0XHRzaG93ID0gZmFsc2U7XG5cblx0XHRcdC8vIEhhbmRsZSBsYWJlbCBvdmVyZmxvdyBhbmQgc2hvdyBvciBoaWRlIGFjY29yZGluZ2x5XG5cdFx0XHR9IGVsc2UgaWYgKGhvcml6ICYmICFheGlzLmlzUmFkaWFsICYmICFsYWJlbE9wdGlvbnMuc3RlcCAmJiAhbGFiZWxPcHRpb25zLnJvdGF0aW9uICYmICFvbGQgJiYgb3BhY2l0eSAhPT0gMCkge1xuXHRcdFx0XHR0aWNrLmhhbmRsZU92ZXJmbG93KHh5KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXBwbHkgc3RlcFxuXHRcdFx0aWYgKHN0ZXAgJiYgaW5kZXggJSBzdGVwKSB7XG5cdFx0XHRcdC8vIHNob3cgdGhvc2UgaW5kaWNlcyBkaXZpZGFibGUgYnkgc3RlcFxuXHRcdFx0XHRzaG93ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgbmV3IHBvc2l0aW9uLCBhbmQgc2hvdyBvciBoaWRlXG5cdFx0XHRpZiAoc2hvdyAmJiAhaXNOYU4oeHkueSkpIHtcblx0XHRcdFx0eHkub3BhY2l0eSA9IG9wYWNpdHk7XG5cdFx0XHRcdGxhYmVsW3RpY2suaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKHh5KTtcblx0XHRcdFx0dGljay5pc05ldyA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGFiZWwuYXR0cigneScsIC05OTk5KTsgLy8gIzEzMzhcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3RydWN0b3IgZm9yIHRoZSB0aWNrIHByb3RvdHlwZVxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHRoaXMsIHRoaXMuYXhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogVGhlIG9iamVjdCB3cmFwcGVyIGZvciBwbG90IGxpbmVzIGFuZCBwbG90IGJhbmRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5IaWdoY2hhcnRzLlBsb3RMaW5lT3JCYW5kID0gZnVuY3Rpb24gKGF4aXMsIG9wdGlvbnMpIHtcblx0dGhpcy5heGlzID0gYXhpcztcblxuXHRpZiAob3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5pZCA9IG9wdGlvbnMuaWQ7XG5cdH1cbn07XG5cbkhpZ2hjaGFydHMuUGxvdExpbmVPckJhbmQucHJvdG90eXBlID0ge1xuXHRcblx0LyoqXG5cdCAqIFJlbmRlciB0aGUgcGxvdCBsaW5lIG9yIHBsb3QgYmFuZC4gSWYgaXQgaXMgYWxyZWFkeSBleGlzdGluZyxcblx0ICogbW92ZSBpdC5cblx0ICovXG5cdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwbG90TGluZSA9IHRoaXMsXG5cdFx0XHRheGlzID0gcGxvdExpbmUuYXhpcyxcblx0XHRcdGhvcml6ID0gYXhpcy5ob3Jpeixcblx0XHRcdG9wdGlvbnMgPSBwbG90TGluZS5vcHRpb25zLFxuXHRcdFx0b3B0aW9uc0xhYmVsID0gb3B0aW9ucy5sYWJlbCxcblx0XHRcdGxhYmVsID0gcGxvdExpbmUubGFiZWwsXG5cdFx0XHR3aWR0aCA9IG9wdGlvbnMud2lkdGgsXG5cdFx0XHR0byA9IG9wdGlvbnMudG8sXG5cdFx0XHRmcm9tID0gb3B0aW9ucy5mcm9tLFxuXHRcdFx0aXNCYW5kID0gZGVmaW5lZChmcm9tKSAmJiBkZWZpbmVkKHRvKSxcblx0XHRcdHZhbHVlID0gb3B0aW9ucy52YWx1ZSxcblx0XHRcdGRhc2hTdHlsZSA9IG9wdGlvbnMuZGFzaFN0eWxlLFxuXHRcdFx0c3ZnRWxlbSA9IHBsb3RMaW5lLnN2Z0VsZW0sXG5cdFx0XHRwYXRoID0gW10sXG5cdFx0XHRhZGRFdmVudCxcblx0XHRcdGV2ZW50VHlwZSxcblx0XHRcdHhzLFxuXHRcdFx0eXMsXG5cdFx0XHR4LFxuXHRcdFx0eSxcblx0XHRcdGNvbG9yID0gb3B0aW9ucy5jb2xvcixcblx0XHRcdHpJbmRleCA9IG9wdGlvbnMuekluZGV4LFxuXHRcdFx0ZXZlbnRzID0gb3B0aW9ucy5ldmVudHMsXG5cdFx0XHRhdHRyaWJzID0ge30sXG5cdFx0XHRyZW5kZXJlciA9IGF4aXMuY2hhcnQucmVuZGVyZXI7XG5cblx0XHQvLyBsb2dhcml0aG1pYyBjb252ZXJzaW9uXG5cdFx0aWYgKGF4aXMuaXNMb2cpIHtcblx0XHRcdGZyb20gPSBsb2cybGluKGZyb20pO1xuXHRcdFx0dG8gPSBsb2cybGluKHRvKTtcblx0XHRcdHZhbHVlID0gbG9nMmxpbih2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gcGxvdCBsaW5lXG5cdFx0aWYgKHdpZHRoKSB7XG5cdFx0XHRwYXRoID0gYXhpcy5nZXRQbG90TGluZVBhdGgodmFsdWUsIHdpZHRoKTtcblx0XHRcdGF0dHJpYnMgPSB7XG5cdFx0XHRcdHN0cm9rZTogY29sb3IsXG5cdFx0XHRcdCdzdHJva2Utd2lkdGgnOiB3aWR0aFxuXHRcdFx0fTtcblx0XHRcdGlmIChkYXNoU3R5bGUpIHtcblx0XHRcdFx0YXR0cmlicy5kYXNoc3R5bGUgPSBkYXNoU3R5bGU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChpc0JhbmQpIHsgLy8gcGxvdCBiYW5kXG5cblx0XHRcdHBhdGggPSBheGlzLmdldFBsb3RCYW5kUGF0aChmcm9tLCB0bywgb3B0aW9ucyk7XG5cdFx0XHRpZiAoY29sb3IpIHtcblx0XHRcdFx0YXR0cmlicy5maWxsID0gY29sb3I7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuXHRcdFx0XHRhdHRyaWJzLnN0cm9rZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG5cdFx0XHRcdGF0dHJpYnNbJ3N0cm9rZS13aWR0aCddID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyB6SW5kZXhcblx0XHRpZiAoZGVmaW5lZCh6SW5kZXgpKSB7XG5cdFx0XHRhdHRyaWJzLnpJbmRleCA9IHpJbmRleDtcblx0XHR9XG5cblx0XHQvLyBjb21tb24gZm9yIGxpbmVzIGFuZCBiYW5kc1xuXHRcdGlmIChzdmdFbGVtKSB7XG5cdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRzdmdFbGVtLmFuaW1hdGUoe1xuXHRcdFx0XHRcdGQ6IHBhdGhcblx0XHRcdFx0fSwgbnVsbCwgc3ZnRWxlbS5vbkdldFBhdGgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3ZnRWxlbS5oaWRlKCk7XG5cdFx0XHRcdHN2Z0VsZW0ub25HZXRQYXRoID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHN2Z0VsZW0uc2hvdygpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAobGFiZWwpIHtcblx0XHRcdFx0XHRwbG90TGluZS5sYWJlbCA9IGxhYmVsID0gbGFiZWwuZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChwYXRoICYmIHBhdGgubGVuZ3RoKSB7XG5cdFx0XHRwbG90TGluZS5zdmdFbGVtID0gc3ZnRWxlbSA9IHJlbmRlcmVyLnBhdGgocGF0aClcblx0XHRcdFx0LmF0dHIoYXR0cmlicykuYWRkKCk7XG5cblx0XHRcdC8vIGV2ZW50c1xuXHRcdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0XHRhZGRFdmVudCA9IGZ1bmN0aW9uIChldmVudFR5cGUpIHtcblx0XHRcdFx0XHRzdmdFbGVtLm9uKGV2ZW50VHlwZSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGV2ZW50c1tldmVudFR5cGVdLmFwcGx5KHBsb3RMaW5lLCBbZV0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRmb3IgKGV2ZW50VHlwZSBpbiBldmVudHMpIHtcblx0XHRcdFx0XHRhZGRFdmVudChldmVudFR5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIHBsb3QgYmFuZC9saW5lIGxhYmVsXG5cdFx0aWYgKG9wdGlvbnNMYWJlbCAmJiBkZWZpbmVkKG9wdGlvbnNMYWJlbC50ZXh0KSAmJiBwYXRoICYmIHBhdGgubGVuZ3RoICYmIGF4aXMud2lkdGggPiAwICYmIGF4aXMuaGVpZ2h0ID4gMCkge1xuXHRcdFx0Ly8gYXBwbHkgZGVmYXVsdHNcblx0XHRcdG9wdGlvbnNMYWJlbCA9IG1lcmdlKHtcblx0XHRcdFx0YWxpZ246IGhvcml6ICYmIGlzQmFuZCAmJiAnY2VudGVyJyxcblx0XHRcdFx0eDogaG9yaXogPyAhaXNCYW5kICYmIDQgOiAxMCxcblx0XHRcdFx0dmVydGljYWxBbGlnbiA6ICFob3JpeiAmJiBpc0JhbmQgJiYgJ21pZGRsZScsXG5cdFx0XHRcdHk6IGhvcml6ID8gaXNCYW5kID8gMTYgOiAxMCA6IGlzQmFuZCA/IDYgOiAtNCxcblx0XHRcdFx0cm90YXRpb246IGhvcml6ICYmICFpc0JhbmQgJiYgOTBcblx0XHRcdH0sIG9wdGlvbnNMYWJlbCk7XG5cblx0XHRcdC8vIGFkZCB0aGUgU1ZHIGVsZW1lbnRcblx0XHRcdGlmICghbGFiZWwpIHtcblx0XHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0XHRhbGlnbjogb3B0aW9uc0xhYmVsLnRleHRBbGlnbiB8fCBvcHRpb25zTGFiZWwuYWxpZ24sXG5cdFx0XHRcdFx0cm90YXRpb246IG9wdGlvbnNMYWJlbC5yb3RhdGlvblxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoZGVmaW5lZCh6SW5kZXgpKSB7XG5cdFx0XHRcdFx0YXR0cmlicy56SW5kZXggPSB6SW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGxvdExpbmUubGFiZWwgPSBsYWJlbCA9IHJlbmRlcmVyLnRleHQoXG5cdFx0XHRcdFx0XHRvcHRpb25zTGFiZWwudGV4dCxcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0b3B0aW9uc0xhYmVsLnVzZUhUTUxcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LmF0dHIoYXR0cmlicylcblx0XHRcdFx0XHQuY3NzKG9wdGlvbnNMYWJlbC5zdHlsZSlcblx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGdldCB0aGUgYm91bmRpbmcgYm94IGFuZCBhbGlnbiB0aGUgbGFiZWxcblx0XHRcdC8vICMzMDAwIGNoYW5nZWQgdG8gYmV0dGVyIGhhbmRsZSBjaG9pY2UgYmV0d2VlbiBwbG90YmFuZCBvciBwbG90bGluZVxuXHRcdFx0eHMgPSBbcGF0aFsxXSwgcGF0aFs0XSwgKGlzQmFuZCA/IHBhdGhbNl0gOiBwYXRoWzFdKV07XG5cdFx0XHR5cyA9IFtwYXRoWzJdLCBwYXRoWzVdLCAoaXNCYW5kID8gcGF0aFs3XSA6IHBhdGhbMl0pXTtcblx0XHRcdHggPSBhcnJheU1pbih4cyk7XG5cdFx0XHR5ID0gYXJyYXlNaW4oeXMpO1xuXG5cdFx0XHRsYWJlbC5hbGlnbihvcHRpb25zTGFiZWwsIGZhbHNlLCB7XG5cdFx0XHRcdHg6IHgsXG5cdFx0XHRcdHk6IHksXG5cdFx0XHRcdHdpZHRoOiBhcnJheU1heCh4cykgLSB4LFxuXHRcdFx0XHRoZWlnaHQ6IGFycmF5TWF4KHlzKSAtIHlcblx0XHRcdH0pO1xuXHRcdFx0bGFiZWwuc2hvdygpO1xuXG5cdFx0fSBlbHNlIGlmIChsYWJlbCkgeyAvLyBtb3ZlIG91dCBvZiBzaWdodFxuXHRcdFx0bGFiZWwuaGlkZSgpO1xuXHRcdH1cblxuXHRcdC8vIGNoYWluYWJsZVxuXHRcdHJldHVybiBwbG90TGluZTtcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIHRoZSBwbG90IGxpbmUgb3IgYmFuZFxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHJlbW92ZSBpdCBmcm9tIHRoZSBsb29rdXBcblx0XHRlcmFzZSh0aGlzLmF4aXMucGxvdExpbmVzQW5kQmFuZHMsIHRoaXMpO1xuXHRcdFxuXHRcdGRlbGV0ZSB0aGlzLmF4aXM7XG5cdFx0ZGVzdHJveU9iamVjdFByb3BlcnRpZXModGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogT2JqZWN0IHdpdGggbWVtYmVycyBmb3IgZXh0ZW5kaW5nIHRoZSBBeGlzIHByb3RvdHlwZVxuICovXG5cbkF4aXNQbG90TGluZU9yQmFuZEV4dGVuc2lvbiA9IHtcblxuXHQvKipcblx0ICogQ3JlYXRlIHRoZSBwYXRoIGZvciBhIHBsb3QgYmFuZFxuXHQgKi8gXG5cdGdldFBsb3RCYW5kUGF0aDogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG5cdFx0dmFyIHRvUGF0aCA9IHRoaXMuZ2V0UGxvdExpbmVQYXRoKHRvLCBudWxsLCBudWxsLCB0cnVlKSxcblx0XHRcdHBhdGggPSB0aGlzLmdldFBsb3RMaW5lUGF0aChmcm9tLCBudWxsLCBudWxsLCB0cnVlKTtcblxuXHRcdGlmIChwYXRoICYmIHRvUGF0aCAmJiBwYXRoLnRvU3RyaW5nKCkgIT09IHRvUGF0aC50b1N0cmluZygpKSB7IC8vICMzODM2XG5cdFx0XHRwYXRoLnB1c2goXG5cdFx0XHRcdHRvUGF0aFs0XSxcblx0XHRcdFx0dG9QYXRoWzVdLFxuXHRcdFx0XHR0b1BhdGhbMV0sXG5cdFx0XHRcdHRvUGF0aFsyXVxuXHRcdFx0KTtcblx0XHR9IGVsc2UgeyAvLyBvdXRzaWRlIHRoZSBheGlzIGFyZWFcblx0XHRcdHBhdGggPSBudWxsO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gcGF0aDtcblx0fSxcblxuXHRhZGRQbG90QmFuZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZShvcHRpb25zLCAncGxvdEJhbmRzJyk7XG5cdH0sXG5cdFxuXHRhZGRQbG90TGluZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZShvcHRpb25zLCAncGxvdExpbmVzJyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZCBhIHBsb3QgYmFuZCBvciBwbG90IGxpbmUgYWZ0ZXIgcmVuZGVyIHRpbWVcblx0ICpcblx0ICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gVGhlIHBsb3RCYW5kIG9yIHBsb3RMaW5lIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG5cdCAqL1xuXHRhZGRQbG90QmFuZE9yTGluZTogZnVuY3Rpb24gKG9wdGlvbnMsIGNvbGwpIHtcblx0XHR2YXIgb2JqID0gbmV3IEhpZ2hjaGFydHMuUGxvdExpbmVPckJhbmQodGhpcywgb3B0aW9ucykucmVuZGVyKCksXG5cdFx0XHR1c2VyT3B0aW9ucyA9IHRoaXMudXNlck9wdGlvbnM7XG5cblx0XHRpZiAob2JqKSB7IC8vICMyMTg5XG5cdFx0XHQvLyBBZGQgaXQgdG8gdGhlIHVzZXIgb3B0aW9ucyBmb3IgZXhwb3J0aW5nIGFuZCBBeGlzLnVwZGF0ZVxuXHRcdFx0aWYgKGNvbGwpIHtcblx0XHRcdFx0dXNlck9wdGlvbnNbY29sbF0gPSB1c2VyT3B0aW9uc1tjb2xsXSB8fCBbXTtcblx0XHRcdFx0dXNlck9wdGlvbnNbY29sbF0ucHVzaChvcHRpb25zKTsgXG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBsb3RMaW5lc0FuZEJhbmRzLnB1c2gob2JqKTsgXG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIHBsb3QgYmFuZCBvciBwbG90IGxpbmUgZnJvbSB0aGUgY2hhcnQgYnkgaWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGlkXG5cdCAqL1xuXHRyZW1vdmVQbG90QmFuZE9yTGluZTogZnVuY3Rpb24gKGlkKSB7XG5cdFx0dmFyIHBsb3RMaW5lc0FuZEJhbmRzID0gdGhpcy5wbG90TGluZXNBbmRCYW5kcyxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHR1c2VyT3B0aW9ucyA9IHRoaXMudXNlck9wdGlvbnMsXG5cdFx0XHRpID0gcGxvdExpbmVzQW5kQmFuZHMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGlmIChwbG90TGluZXNBbmRCYW5kc1tpXS5pZCA9PT0gaWQpIHtcblx0XHRcdFx0cGxvdExpbmVzQW5kQmFuZHNbaV0uZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlYWNoKFtvcHRpb25zLnBsb3RMaW5lcyB8fCBbXSwgdXNlck9wdGlvbnMucGxvdExpbmVzIHx8IFtdLCBvcHRpb25zLnBsb3RCYW5kcyB8fCBbXSwgdXNlck9wdGlvbnMucGxvdEJhbmRzIHx8IFtdXSwgZnVuY3Rpb24gKGFycikge1xuXHRcdFx0aSA9IGFyci5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdGlmIChhcnJbaV0uaWQgPT09IGlkKSB7XG5cdFx0XHRcdFx0ZXJhc2UoYXJyLCBhcnJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGF4aXMgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gY2hhcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbnZhciBBeGlzID0gSGlnaGNoYXJ0cy5BeGlzID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbkF4aXMucHJvdG90eXBlID0ge1xuXG5cdC8qKlxuXHQgKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBYIGF4aXMgLSB0aGUgWSBheGlzIGhhcyBleHRlbmRlZCBkZWZhdWx0c1xuXHQgKi9cblx0ZGVmYXVsdE9wdGlvbnM6IHtcblx0XHQvLyBhbGxvd0RlY2ltYWxzOiBudWxsLFxuXHRcdC8vIGFsdGVybmF0ZUdyaWRDb2xvcjogbnVsbCxcblx0XHQvLyBjYXRlZ29yaWVzOiBbXSxcblx0XHRkYXRlVGltZUxhYmVsRm9ybWF0czoge1xuXHRcdFx0bWlsbGlzZWNvbmQ6ICclSDolTTolUy4lTCcsXG5cdFx0XHRzZWNvbmQ6ICclSDolTTolUycsXG5cdFx0XHRtaW51dGU6ICclSDolTScsXG5cdFx0XHRob3VyOiAnJUg6JU0nLFxuXHRcdFx0ZGF5OiAnJWUuICViJyxcblx0XHRcdHdlZWs6ICclZS4gJWInLFxuXHRcdFx0bW9udGg6ICclYiBcXCcleScsXG5cdFx0XHR5ZWFyOiAnJVknXG5cdFx0fSxcblx0XHRlbmRPblRpY2s6IGZhbHNlLFxuXHRcdGdyaWRMaW5lQ29sb3I6ICcjRDhEOEQ4Jyxcblx0XHQvLyBncmlkTGluZURhc2hTdHlsZTogJ3NvbGlkJyxcblx0XHQvLyBncmlkTGluZVdpZHRoOiAwLFxuXHRcdC8vIHJldmVyc2VkOiBmYWxzZSxcblxuXHRcdGxhYmVsczoge1xuXHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdC8vIHJvdGF0aW9uOiAwLFxuXHRcdFx0Ly8gYWxpZ246ICdjZW50ZXInLFxuXHRcdFx0Ly8gc3RlcDogbnVsbCxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdGNvbG9yOiAnIzYwNjA2MCcsXG5cdFx0XHRcdGN1cnNvcjogJ2RlZmF1bHQnLFxuXHRcdFx0XHRmb250U2l6ZTogJzExcHgnXG5cdFx0XHR9LFxuXHRcdFx0eDogMCxcblx0XHRcdHk6IDE1XG5cdFx0XHQvKmZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0XHRcdH0sKi9cblx0XHR9LFxuXHRcdGxpbmVDb2xvcjogJyNDMEQwRTAnLFxuXHRcdGxpbmVXaWR0aDogMSxcblx0XHQvL2xpbmtlZFRvOiBudWxsLFxuXHRcdC8vbWF4OiB1bmRlZmluZWQsXG5cdFx0Ly9taW46IHVuZGVmaW5lZCxcblx0XHRtaW5QYWRkaW5nOiAwLjAxLFxuXHRcdG1heFBhZGRpbmc6IDAuMDEsXG5cdFx0Ly9taW5SYW5nZTogbnVsbCxcblx0XHRtaW5vckdyaWRMaW5lQ29sb3I6ICcjRTBFMEUwJyxcblx0XHQvLyBtaW5vckdyaWRMaW5lRGFzaFN0eWxlOiBudWxsLFxuXHRcdG1pbm9yR3JpZExpbmVXaWR0aDogMSxcblx0XHRtaW5vclRpY2tDb2xvcjogJyNBMEEwQTAnLFxuXHRcdC8vbWlub3JUaWNrSW50ZXJ2YWw6IG51bGwsXG5cdFx0bWlub3JUaWNrTGVuZ3RoOiAyLFxuXHRcdG1pbm9yVGlja1Bvc2l0aW9uOiAnb3V0c2lkZScsIC8vIGluc2lkZSBvciBvdXRzaWRlXG5cdFx0Ly9taW5vclRpY2tXaWR0aDogMCxcblx0XHQvL29wcG9zaXRlOiBmYWxzZSxcblx0XHQvL29mZnNldDogMCxcblx0XHQvL3Bsb3RCYW5kczogW3tcblx0XHQvL1x0ZXZlbnRzOiB7fSxcblx0XHQvL1x0ekluZGV4OiAxLFxuXHRcdC8vXHRsYWJlbHM6IHsgYWxpZ24sIHgsIHZlcnRpY2FsQWxpZ24sIHksIHN0eWxlLCByb3RhdGlvbiwgdGV4dEFsaWduIH1cblx0XHQvL31dLFxuXHRcdC8vcGxvdExpbmVzOiBbe1xuXHRcdC8vXHRldmVudHM6IHt9XG5cdFx0Ly8gIGRhc2hTdHlsZToge31cblx0XHQvL1x0ekluZGV4OlxuXHRcdC8vXHRsYWJlbHM6IHsgYWxpZ24sIHgsIHZlcnRpY2FsQWxpZ24sIHksIHN0eWxlLCByb3RhdGlvbiwgdGV4dEFsaWduIH1cblx0XHQvL31dLFxuXHRcdC8vcmV2ZXJzZWQ6IGZhbHNlLFxuXHRcdC8vIHNob3dGaXJzdExhYmVsOiB0cnVlLFxuXHRcdC8vIHNob3dMYXN0TGFiZWw6IHRydWUsXG5cdFx0c3RhcnRPZldlZWs6IDEsXG5cdFx0c3RhcnRPblRpY2s6IGZhbHNlLFxuXHRcdHRpY2tDb2xvcjogJyNDMEQwRTAnLFxuXHRcdC8vdGlja0ludGVydmFsOiBudWxsLFxuXHRcdHRpY2tMZW5ndGg6IDEwLFxuXHRcdHRpY2ttYXJrUGxhY2VtZW50OiAnYmV0d2VlbicsIC8vIG9uIG9yIGJldHdlZW5cblx0XHR0aWNrUGl4ZWxJbnRlcnZhbDogMTAwLFxuXHRcdHRpY2tQb3NpdGlvbjogJ291dHNpZGUnLFxuXHRcdC8vdGlja1dpZHRoOiAxLFxuXHRcdHRpdGxlOiB7XG5cdFx0XHQvL3RleHQ6IG51bGwsXG5cdFx0XHRhbGlnbjogJ21pZGRsZScsIC8vIGxvdywgbWlkZGxlIG9yIGhpZ2hcblx0XHRcdC8vbWFyZ2luOiAwIGZvciBob3Jpem9udGFsLCAxMCBmb3IgdmVydGljYWwgYXhlcyxcblx0XHRcdC8vcm90YXRpb246IDAsXG5cdFx0XHQvL3NpZGU6ICdvdXRzaWRlJyxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdGNvbG9yOiAnIzcwNzA3MCdcblx0XHRcdH1cblx0XHRcdC8veDogMCxcblx0XHRcdC8veTogMFxuXHRcdH0sXG5cdFx0dHlwZTogJ2xpbmVhcicgLy8gbGluZWFyLCBsb2dhcml0aG1pYyBvciBkYXRldGltZVxuXHRcdC8vdmlzaWJsZTogdHJ1ZVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGlzIG9wdGlvbnMgc2V0IGV4dGVuZHMgdGhlIGRlZmF1bHRPcHRpb25zIGZvciBZIGF4ZXNcblx0ICovXG5cdGRlZmF1bHRZQXhpc09wdGlvbnM6IHtcblx0XHRlbmRPblRpY2s6IHRydWUsXG5cdFx0Z3JpZExpbmVXaWR0aDogMSxcblx0XHR0aWNrUGl4ZWxJbnRlcnZhbDogNzIsXG5cdFx0c2hvd0xhc3RMYWJlbDogdHJ1ZSxcblx0XHRsYWJlbHM6IHtcblx0XHRcdHg6IC04LFxuXHRcdFx0eTogM1xuXHRcdH0sXG5cdFx0bGluZVdpZHRoOiAwLFxuXHRcdG1heFBhZGRpbmc6IDAuMDUsXG5cdFx0bWluUGFkZGluZzogMC4wNSxcblx0XHRzdGFydE9uVGljazogdHJ1ZSxcblx0XHQvL3RpY2tXaWR0aDogMCxcblx0XHR0aXRsZToge1xuXHRcdFx0cm90YXRpb246IDI3MCxcblx0XHRcdHRleHQ6ICdWYWx1ZXMnXG5cdFx0fSxcblx0XHRzdGFja0xhYmVsczoge1xuXHRcdFx0ZW5hYmxlZDogZmFsc2UsXG5cdFx0XHQvL2FsaWduOiBkeW5hbWljLFxuXHRcdFx0Ly95OiBkeW5hbWljLFxuXHRcdFx0Ly94OiBkeW5hbWljLFxuXHRcdFx0Ly92ZXJ0aWNhbEFsaWduOiBkeW5hbWljLFxuXHRcdFx0Ly90ZXh0QWxpZ246IGR5bmFtaWMsXG5cdFx0XHQvL3JvdGF0aW9uOiAwLFxuXHRcdFx0Zm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBIaWdoY2hhcnRzLm51bWJlckZvcm1hdCh0aGlzLnRvdGFsLCAtMSk7XG5cdFx0XHR9LFxuXHRcdFx0c3R5bGU6IG1lcmdlKGRlZmF1bHRQbG90T3B0aW9ucy5saW5lLmRhdGFMYWJlbHMuc3R5bGUsIHsgY29sb3I6ICcjMDAwMDAwJyB9KVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVGhlc2Ugb3B0aW9ucyBleHRlbmQgdGhlIGRlZmF1bHRPcHRpb25zIGZvciBsZWZ0IGF4ZXNcblx0ICovXG5cdGRlZmF1bHRMZWZ0QXhpc09wdGlvbnM6IHtcblx0XHRsYWJlbHM6IHtcblx0XHRcdHg6IC0xNSxcblx0XHRcdHk6IG51bGxcblx0XHR9LFxuXHRcdHRpdGxlOiB7XG5cdFx0XHRyb3RhdGlvbjogMjcwXG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGVzZSBvcHRpb25zIGV4dGVuZCB0aGUgZGVmYXVsdE9wdGlvbnMgZm9yIHJpZ2h0IGF4ZXNcblx0ICovXG5cdGRlZmF1bHRSaWdodEF4aXNPcHRpb25zOiB7XG5cdFx0bGFiZWxzOiB7XG5cdFx0XHR4OiAxNSxcblx0XHRcdHk6IG51bGxcblx0XHR9LFxuXHRcdHRpdGxlOiB7XG5cdFx0XHRyb3RhdGlvbjogOTBcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoZXNlIG9wdGlvbnMgZXh0ZW5kIHRoZSBkZWZhdWx0T3B0aW9ucyBmb3IgYm90dG9tIGF4ZXNcblx0ICovXG5cdGRlZmF1bHRCb3R0b21BeGlzT3B0aW9uczoge1xuXHRcdGxhYmVsczoge1xuXHRcdFx0YXV0b1JvdGF0aW9uOiBbLTQ1XSxcblx0XHRcdHg6IDAsXG5cdFx0XHR5OiBudWxsIC8vIGJhc2VkIG9uIGZvbnQgc2l6ZVxuXHRcdFx0Ly8gb3ZlcmZsb3c6IHVuZGVmaW5lZCxcblx0XHRcdC8vIHN0YWdnZXJMaW5lczogbnVsbFxuXHRcdH0sXG5cdFx0dGl0bGU6IHtcblx0XHRcdHJvdGF0aW9uOiAwXG5cdFx0fVxuXHR9LFxuXHQvKipcblx0ICogVGhlc2Ugb3B0aW9ucyBleHRlbmQgdGhlIGRlZmF1bHRPcHRpb25zIGZvciB0b3AgYXhlc1xuXHQgKi9cblx0ZGVmYXVsdFRvcEF4aXNPcHRpb25zOiB7XG5cdFx0bGFiZWxzOiB7XG5cdFx0XHRhdXRvUm90YXRpb246IFstNDVdLFxuXHRcdFx0eDogMCxcblx0XHRcdHk6IC0xNVxuXHRcdFx0Ly8gb3ZlcmZsb3c6IHVuZGVmaW5lZFxuXHRcdFx0Ly8gc3RhZ2dlckxpbmVzOiBudWxsXG5cdFx0fSxcblx0XHR0aXRsZToge1xuXHRcdFx0cm90YXRpb246IDBcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIGF4aXNcblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uIChjaGFydCwgdXNlck9wdGlvbnMpIHtcblxuXG5cdFx0dmFyIGlzWEF4aXMgPSB1c2VyT3B0aW9ucy5pc1gsXG5cdFx0XHRheGlzID0gdGhpcztcblxuXHRcdGF4aXMuY2hhcnQgPSBjaGFydDtcblxuXHRcdC8vIEZsYWcsIGlzIHRoZSBheGlzIGhvcml6b250YWxcblx0XHRheGlzLmhvcml6ID0gY2hhcnQuaW52ZXJ0ZWQgPyAhaXNYQXhpcyA6IGlzWEF4aXM7XG5cblx0XHQvLyBGbGFnLCBpc1hBeGlzXG5cdFx0YXhpcy5pc1hBeGlzID0gaXNYQXhpcztcblx0XHRheGlzLmNvbGwgPSBpc1hBeGlzID8gJ3hBeGlzJyA6ICd5QXhpcyc7XG5cblx0XHRheGlzLm9wcG9zaXRlID0gdXNlck9wdGlvbnMub3Bwb3NpdGU7IC8vIG5lZWRlZCBpbiBzZXRPcHRpb25zXG5cdFx0YXhpcy5zaWRlID0gdXNlck9wdGlvbnMuc2lkZSB8fCAoYXhpcy5ob3JpeiA/XG5cdFx0XHRcdChheGlzLm9wcG9zaXRlID8gMCA6IDIpIDogLy8gdG9wIDogYm90dG9tXG5cdFx0XHRcdChheGlzLm9wcG9zaXRlID8gMSA6IDMpKTsgIC8vIHJpZ2h0IDogbGVmdFxuXG5cdFx0YXhpcy5zZXRPcHRpb25zKHVzZXJPcHRpb25zKTtcblxuXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHR0eXBlID0gb3B0aW9ucy50eXBlLFxuXHRcdFx0aXNEYXRldGltZUF4aXMgPSB0eXBlID09PSAnZGF0ZXRpbWUnO1xuXG5cdFx0YXhpcy5sYWJlbEZvcm1hdHRlciA9IG9wdGlvbnMubGFiZWxzLmZvcm1hdHRlciB8fCBheGlzLmRlZmF1bHRMYWJlbEZvcm1hdHRlcjsgLy8gY2FuIGJlIG92ZXJ3cml0dGVuIGJ5IGR5bmFtaWMgZm9ybWF0XG5cblxuXHRcdC8vIEZsYWcsIHN0YWdnZXIgbGluZXMgb3Igbm90XG5cdFx0YXhpcy51c2VyT3B0aW9ucyA9IHVzZXJPcHRpb25zO1xuXG5cdFx0Ly9heGlzLmF4aXNUaXRsZU1hcmdpbiA9IFVOREVGSU5FRCwvLyA9IG9wdGlvbnMudGl0bGUubWFyZ2luLFxuXHRcdGF4aXMubWluUGl4ZWxQYWRkaW5nID0gMDtcblxuXHRcdGF4aXMucmV2ZXJzZWQgPSBvcHRpb25zLnJldmVyc2VkO1xuXHRcdGF4aXMudmlzaWJsZSA9IG9wdGlvbnMudmlzaWJsZSAhPT0gZmFsc2U7XG5cdFx0YXhpcy56b29tRW5hYmxlZCA9IG9wdGlvbnMuem9vbUVuYWJsZWQgIT09IGZhbHNlO1xuXG5cdFx0Ly8gSW5pdGlhbCBjYXRlZ29yaWVzXG5cdFx0YXhpcy5jYXRlZ29yaWVzID0gb3B0aW9ucy5jYXRlZ29yaWVzIHx8IHR5cGUgPT09ICdjYXRlZ29yeSc7XG5cdFx0YXhpcy5uYW1lcyA9IGF4aXMubmFtZXMgfHwgW107IC8vIFByZXNlcnZlIG9uIHVwZGF0ZSAoIzM4MzApXG5cblx0XHQvLyBFbGVtZW50c1xuXHRcdC8vYXhpcy5heGlzR3JvdXAgPSBVTkRFRklORUQ7XG5cdFx0Ly9heGlzLmdyaWRHcm91cCA9IFVOREVGSU5FRDtcblx0XHQvL2F4aXMuYXhpc1RpdGxlID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy5heGlzTGluZSA9IFVOREVGSU5FRDtcblxuXHRcdC8vIFNob3J0aGFuZCB0eXBlc1xuXHRcdGF4aXMuaXNMb2cgPSB0eXBlID09PSAnbG9nYXJpdGhtaWMnO1xuXHRcdGF4aXMuaXNEYXRldGltZUF4aXMgPSBpc0RhdGV0aW1lQXhpcztcblxuXHRcdC8vIEZsYWcsIGlmIGF4aXMgaXMgbGlua2VkIHRvIGFub3RoZXIgYXhpc1xuXHRcdGF4aXMuaXNMaW5rZWQgPSBkZWZpbmVkKG9wdGlvbnMubGlua2VkVG8pO1xuXHRcdC8vIExpbmtlZCBheGlzLlxuXHRcdC8vYXhpcy5saW5rZWRQYXJlbnQgPSBVTkRFRklORUQ7XG5cblx0XHQvLyBUaWNrIHBvc2l0aW9uc1xuXHRcdC8vYXhpcy50aWNrUG9zaXRpb25zID0gVU5ERUZJTkVEOyAvLyBhcnJheSBjb250YWluaW5nIHByZWRlZmluZWQgcG9zaXRpb25zXG5cdFx0Ly8gVGljayBpbnRlcnZhbHNcblx0XHQvL2F4aXMudGlja0ludGVydmFsID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy5taW5vclRpY2tJbnRlcnZhbCA9IFVOREVGSU5FRDtcblxuXHRcdFxuXHRcdC8vIE1ham9yIHRpY2tzXG5cdFx0YXhpcy50aWNrcyA9IHt9O1xuXHRcdGF4aXMubGFiZWxFZGdlID0gW107XG5cdFx0Ly8gTWlub3IgdGlja3Ncblx0XHRheGlzLm1pbm9yVGlja3MgPSB7fTtcblxuXHRcdC8vIExpc3Qgb2YgcGxvdExpbmVzL0JhbmRzXG5cdFx0YXhpcy5wbG90TGluZXNBbmRCYW5kcyA9IFtdO1xuXG5cdFx0Ly8gQWx0ZXJuYXRlIGJhbmRzXG5cdFx0YXhpcy5hbHRlcm5hdGVCYW5kcyA9IHt9O1xuXG5cdFx0Ly8gQXhpcyBtZXRyaWNzXG5cdFx0Ly9heGlzLmxlZnQgPSBVTkRFRklORUQ7XG5cdFx0Ly9heGlzLnRvcCA9IFVOREVGSU5FRDtcblx0XHQvL2F4aXMud2lkdGggPSBVTkRFRklORUQ7XG5cdFx0Ly9heGlzLmhlaWdodCA9IFVOREVGSU5FRDtcblx0XHQvL2F4aXMuYm90dG9tID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy5yaWdodCA9IFVOREVGSU5FRDtcblx0XHQvL2F4aXMudHJhbnNBID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy50cmFuc0IgPSBVTkRFRklORUQ7XG5cdFx0Ly9heGlzLm9sZFRyYW5zQSA9IFVOREVGSU5FRDtcblx0XHRheGlzLmxlbiA9IDA7XG5cdFx0Ly9heGlzLm9sZE1pbiA9IFVOREVGSU5FRDtcblx0XHQvL2F4aXMub2xkTWF4ID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy5vbGRVc2VyTWluID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy5vbGRVc2VyTWF4ID0gVU5ERUZJTkVEO1xuXHRcdC8vYXhpcy5vbGRBeGlzTGVuZ3RoID0gVU5ERUZJTkVEO1xuXHRcdGF4aXMubWluUmFuZ2UgPSBheGlzLnVzZXJNaW5SYW5nZSA9IG9wdGlvbnMubWluUmFuZ2UgfHwgb3B0aW9ucy5tYXhab29tO1xuXHRcdGF4aXMucmFuZ2UgPSBvcHRpb25zLnJhbmdlO1xuXHRcdGF4aXMub2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMDtcblxuXG5cdFx0Ly8gRGljdGlvbmFyeSBmb3Igc3RhY2tzXG5cdFx0YXhpcy5zdGFja3MgPSB7fTtcblx0XHRheGlzLm9sZFN0YWNrcyA9IHt9O1xuXHRcdGF4aXMuc3RhY2tzVG91Y2hlZCA9IDA7XG5cblx0XHQvLyBNaW4gYW5kIG1heCBpbiB0aGUgZGF0YVxuXHRcdC8vYXhpcy5kYXRhTWluID0gVU5ERUZJTkVELFxuXHRcdC8vYXhpcy5kYXRhTWF4ID0gVU5ERUZJTkVELFxuXG5cdFx0Ly8gVGhlIGF4aXMgcmFuZ2Vcblx0XHRheGlzLm1heCA9IG51bGw7XG5cdFx0YXhpcy5taW4gPSBudWxsO1xuXG5cdFx0Ly8gVXNlciBzZXQgbWluIGFuZCBtYXhcblx0XHQvL2F4aXMudXNlck1pbiA9IFVOREVGSU5FRCxcblx0XHQvL2F4aXMudXNlck1heCA9IFVOREVGSU5FRCxcblxuXHRcdC8vIENyb3NzaGFpciBvcHRpb25zXG5cdFx0YXhpcy5jcm9zc2hhaXIgPSBwaWNrKG9wdGlvbnMuY3Jvc3NoYWlyLCBzcGxhdChjaGFydC5vcHRpb25zLnRvb2x0aXAuY3Jvc3NoYWlycylbaXNYQXhpcyA/IDAgOiAxXSwgZmFsc2UpO1xuXHRcdC8vIFJ1biBBeGlzXG5cblx0XHR2YXIgZXZlbnRUeXBlLFxuXHRcdFx0ZXZlbnRzID0gYXhpcy5vcHRpb25zLmV2ZW50cztcblxuXHRcdC8vIFJlZ2lzdGVyXG5cdFx0aWYgKGluQXJyYXkoYXhpcywgY2hhcnQuYXhlcykgPT09IC0xKSB7IC8vIGRvbid0IGFkZCBpdCBhZ2FpbiBvbiBBeGlzLnVwZGF0ZSgpXG5cdFx0XHRpZiAoaXNYQXhpcyAmJiAhdGhpcy5pc0NvbG9yQXhpcykgeyAvLyAjMjcxM1xuXHRcdFx0XHRjaGFydC5heGVzLnNwbGljZShjaGFydC54QXhpcy5sZW5ndGgsIDAsIGF4aXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hhcnQuYXhlcy5wdXNoKGF4aXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGFydFtheGlzLmNvbGxdLnB1c2goYXhpcyk7XG5cdFx0fVxuXG5cdFx0YXhpcy5zZXJpZXMgPSBheGlzLnNlcmllcyB8fCBbXTsgLy8gcG9wdWxhdGVkIGJ5IFNlcmllc1xuXG5cdFx0Ly8gaW52ZXJ0ZWQgY2hhcnRzIGhhdmUgcmV2ZXJzZWQgeEF4ZXMgYXMgZGVmYXVsdFxuXHRcdGlmIChjaGFydC5pbnZlcnRlZCAmJiBpc1hBeGlzICYmIGF4aXMucmV2ZXJzZWQgPT09IFVOREVGSU5FRCkge1xuXHRcdFx0YXhpcy5yZXZlcnNlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0YXhpcy5yZW1vdmVQbG90QmFuZCA9IGF4aXMucmVtb3ZlUGxvdEJhbmRPckxpbmU7XG5cdFx0YXhpcy5yZW1vdmVQbG90TGluZSA9IGF4aXMucmVtb3ZlUGxvdEJhbmRPckxpbmU7XG5cblxuXHRcdC8vIHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVyc1xuXHRcdGZvciAoZXZlbnRUeXBlIGluIGV2ZW50cykge1xuXHRcdFx0YWRkRXZlbnQoYXhpcywgZXZlbnRUeXBlLCBldmVudHNbZXZlbnRUeXBlXSk7XG5cdFx0fVxuXG5cdFx0Ly8gZXh0ZW5kIGxvZ2FyaXRobWljIGF4aXNcblx0XHRpZiAoYXhpcy5pc0xvZykge1xuXHRcdFx0YXhpcy52YWwybGluID0gbG9nMmxpbjtcblx0XHRcdGF4aXMubGluMnZhbCA9IGxpbjJsb2c7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBNZXJnZSBhbmQgc2V0IG9wdGlvbnNcblx0ICovXG5cdHNldE9wdGlvbnM6IGZ1bmN0aW9uICh1c2VyT3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IG1lcmdlKFxuXHRcdFx0dGhpcy5kZWZhdWx0T3B0aW9ucyxcblx0XHRcdHRoaXMuaXNYQXhpcyA/IHt9IDogdGhpcy5kZWZhdWx0WUF4aXNPcHRpb25zLFxuXHRcdFx0W3RoaXMuZGVmYXVsdFRvcEF4aXNPcHRpb25zLCB0aGlzLmRlZmF1bHRSaWdodEF4aXNPcHRpb25zLFxuXHRcdFx0XHR0aGlzLmRlZmF1bHRCb3R0b21BeGlzT3B0aW9ucywgdGhpcy5kZWZhdWx0TGVmdEF4aXNPcHRpb25zXVt0aGlzLnNpZGVdLFxuXHRcdFx0bWVyZ2UoXG5cdFx0XHRcdGRlZmF1bHRPcHRpb25zW3RoaXMuY29sbF0sIC8vIGlmIHNldCBpbiBzZXRPcHRpb25zICgjMTA1Mylcblx0XHRcdFx0dXNlck9wdGlvbnNcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCBsYWJlbCBmb3JtYXR0ZXIuIFRoZSBjb250ZXh0IGlzIGEgc3BlY2lhbCBjb25maWcgb2JqZWN0IGZvciB0aGUgbGFiZWwuXG5cdCAqL1xuXHRkZWZhdWx0TGFiZWxGb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMuYXhpcyxcblx0XHRcdHZhbHVlID0gdGhpcy52YWx1ZSxcblx0XHRcdGNhdGVnb3JpZXMgPSBheGlzLmNhdGVnb3JpZXMsXG5cdFx0XHRkYXRlVGltZUxhYmVsRm9ybWF0ID0gdGhpcy5kYXRlVGltZUxhYmVsRm9ybWF0LFxuXHRcdFx0bnVtZXJpY1N5bWJvbHMgPSBkZWZhdWx0T3B0aW9ucy5sYW5nLm51bWVyaWNTeW1ib2xzLFxuXHRcdFx0aSA9IG51bWVyaWNTeW1ib2xzICYmIG51bWVyaWNTeW1ib2xzLmxlbmd0aCxcblx0XHRcdG11bHRpLFxuXHRcdFx0cmV0LFxuXHRcdFx0Zm9ybWF0T3B0aW9uID0gYXhpcy5vcHRpb25zLmxhYmVscy5mb3JtYXQsXG5cblx0XHRcdC8vIG1ha2Ugc3VyZSB0aGUgc2FtZSBzeW1ib2wgaXMgYWRkZWQgZm9yIGFsbCBsYWJlbHMgb24gYSBsaW5lYXIgYXhpc1xuXHRcdFx0bnVtZXJpY1N5bWJvbERldGVjdG9yID0gYXhpcy5pc0xvZyA/IHZhbHVlIDogYXhpcy50aWNrSW50ZXJ2YWw7XG5cblx0XHRpZiAoZm9ybWF0T3B0aW9uKSB7XG5cdFx0XHRyZXQgPSBmb3JtYXQoZm9ybWF0T3B0aW9uLCB0aGlzKTtcblxuXHRcdH0gZWxzZSBpZiAoY2F0ZWdvcmllcykge1xuXHRcdFx0cmV0ID0gdmFsdWU7XG5cblx0XHR9IGVsc2UgaWYgKGRhdGVUaW1lTGFiZWxGb3JtYXQpIHsgLy8gZGF0ZXRpbWUgYXhpc1xuXHRcdFx0cmV0ID0gZGF0ZUZvcm1hdChkYXRlVGltZUxhYmVsRm9ybWF0LCB2YWx1ZSk7XG5cblx0XHR9IGVsc2UgaWYgKGkgJiYgbnVtZXJpY1N5bWJvbERldGVjdG9yID49IDEwMDApIHtcblx0XHRcdC8vIERlY2lkZSB3aGV0aGVyIHdlIHNob3VsZCBhZGQgYSBudW1lcmljIHN5bWJvbCBsaWtlIGsgKHRob3VzYW5kcykgb3IgTSAobWlsbGlvbnMpLlxuXHRcdFx0Ly8gSWYgd2UgYXJlIHRvIGVuYWJsZSB0aGlzIGluIHRvb2x0aXAgb3Igb3RoZXIgcGxhY2VzIGFzIHdlbGwsIHdlIGNhbiBtb3ZlIHRoaXNcblx0XHRcdC8vIGxvZ2ljIHRvIHRoZSBudW1iZXJGb3JtYXR0ZXIgYW5kIGVuYWJsZSBpdCBieSBhIHBhcmFtZXRlci5cblx0XHRcdHdoaWxlIChpLS0gJiYgcmV0ID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0bXVsdGkgPSBNYXRoLnBvdygxMDAwLCBpICsgMSk7XG5cdFx0XHRcdGlmIChudW1lcmljU3ltYm9sRGV0ZWN0b3IgPj0gbXVsdGkgJiYgKHZhbHVlICogMTApICUgbXVsdGkgPT09IDAgJiYgbnVtZXJpY1N5bWJvbHNbaV0gIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXQgPSBIaWdoY2hhcnRzLm51bWJlckZvcm1hdCh2YWx1ZSAvIG11bHRpLCAtMSkgKyBudW1lcmljU3ltYm9sc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChyZXQgPT09IFVOREVGSU5FRCkge1xuXHRcdFx0aWYgKG1hdGhBYnModmFsdWUpID49IDEwMDAwKSB7IC8vIGFkZCB0aG91c2FuZHMgc2VwYXJhdG9yc1xuXHRcdFx0XHRyZXQgPSBIaWdoY2hhcnRzLm51bWJlckZvcm1hdCh2YWx1ZSwgLTEpO1xuXG5cdFx0XHR9IGVsc2UgeyAvLyBzbWFsbCBudW1iZXJzXG5cdFx0XHRcdHJldCA9IEhpZ2hjaGFydHMubnVtYmVyRm9ybWF0KHZhbHVlLCAtMSwgVU5ERUZJTkVELCAnJyk7IC8vICMyNDY2XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGZvciB0aGUgc2VyaWVzIG9mIGVhY2ggYXhpc1xuXHQgKi9cblx0Z2V0U2VyaWVzRXh0cmVtZXM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQ7XG5cblx0XHRheGlzLmhhc1Zpc2libGVTZXJpZXMgPSBmYWxzZTtcblxuXHRcdC8vIFJlc2V0IHByb3BlcnRpZXMgaW4gY2FzZSB3ZSdyZSByZWRyYXdpbmcgKCMzMzUzKVxuXHRcdGF4aXMuZGF0YU1pbiA9IGF4aXMuZGF0YU1heCA9IGF4aXMudGhyZXNob2xkID0gbnVsbDtcblx0XHRheGlzLnNvZnRUaHJlc2hvbGQgPSAhYXhpcy5pc1hBeGlzO1xuXHRcdFxuXHRcdGlmIChheGlzLmJ1aWxkU3RhY2tzKSB7XG5cdFx0XHRheGlzLmJ1aWxkU3RhY2tzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIHRoaXMgYXhpcycgc2VyaWVzXG5cdFx0ZWFjaChheGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXG5cdFx0XHRpZiAoc2VyaWVzLnZpc2libGUgfHwgIWNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzKSB7XG5cblx0XHRcdFx0dmFyIHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0XHR4RGF0YSxcblx0XHRcdFx0XHR0aHJlc2hvbGQgPSBzZXJpZXNPcHRpb25zLnRocmVzaG9sZCxcblx0XHRcdFx0XHRzZXJpZXNEYXRhTWluLFxuXHRcdFx0XHRcdHNlcmllc0RhdGFNYXg7XG5cblx0XHRcdFx0YXhpcy5oYXNWaXNpYmxlU2VyaWVzID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBWYWxpZGF0ZSB0aHJlc2hvbGQgaW4gbG9nYXJpdGhtaWMgYXhlc1xuXHRcdFx0XHRpZiAoYXhpcy5pc0xvZyAmJiB0aHJlc2hvbGQgPD0gMCkge1xuXHRcdFx0XHRcdHRocmVzaG9sZCA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZGF0YU1pbiBhbmQgZGF0YU1heCBmb3IgWCBheGVzXG5cdFx0XHRcdGlmIChheGlzLmlzWEF4aXMpIHtcblx0XHRcdFx0XHR4RGF0YSA9IHNlcmllcy54RGF0YTtcblx0XHRcdFx0XHRpZiAoeERhdGEubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRheGlzLmRhdGFNaW4gPSBtYXRoTWluKHBpY2soYXhpcy5kYXRhTWluLCB4RGF0YVswXSksIGFycmF5TWluKHhEYXRhKSk7XG5cdFx0XHRcdFx0XHRheGlzLmRhdGFNYXggPSBtYXRoTWF4KHBpY2soYXhpcy5kYXRhTWF4LCB4RGF0YVswXSksIGFycmF5TWF4KHhEYXRhKSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkYXRhTWluIGFuZCBkYXRhTWF4IGZvciBZIGF4ZXMsIGFzIHdlbGwgYXMgaGFuZGxlIHN0YWNraW5nIGFuZCBwcm9jZXNzZWQgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHRoaXMgcGFydGljdWxhciBzZXJpZXMgZXh0cmVtZXNcblx0XHRcdFx0XHRzZXJpZXMuZ2V0RXh0cmVtZXMoKTtcblx0XHRcdFx0XHRzZXJpZXNEYXRhTWF4ID0gc2VyaWVzLmRhdGFNYXg7XG5cdFx0XHRcdFx0c2VyaWVzRGF0YU1pbiA9IHNlcmllcy5kYXRhTWluO1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBkYXRhTWluIGFuZCBkYXRhTWF4IHNvIGZhci4gSWYgcGVyY2VudGFnZSBpcyB1c2VkLCB0aGUgbWluIGFuZCBtYXggYXJlXG5cdFx0XHRcdFx0Ly8gYWx3YXlzIDAgYW5kIDEwMC4gSWYgc2VyaWVzRGF0YU1pbiBhbmQgc2VyaWVzRGF0YU1heCBpcyBudWxsLCB0aGVuIHNlcmllc1xuXHRcdFx0XHRcdC8vIGRvZXNuJ3QgaGF2ZSBhY3RpdmUgeSBkYXRhLCB3ZSBjb250aW51ZSB3aXRoIG51bGxzXG5cdFx0XHRcdFx0aWYgKGRlZmluZWQoc2VyaWVzRGF0YU1pbikgJiYgZGVmaW5lZChzZXJpZXNEYXRhTWF4KSkge1xuXHRcdFx0XHRcdFx0YXhpcy5kYXRhTWluID0gbWF0aE1pbihwaWNrKGF4aXMuZGF0YU1pbiwgc2VyaWVzRGF0YU1pbiksIHNlcmllc0RhdGFNaW4pO1xuXHRcdFx0XHRcdFx0YXhpcy5kYXRhTWF4ID0gbWF0aE1heChwaWNrKGF4aXMuZGF0YU1heCwgc2VyaWVzRGF0YU1heCksIHNlcmllc0RhdGFNYXgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEFkanVzdCB0byB0aHJlc2hvbGRcblx0XHRcdFx0XHRpZiAoZGVmaW5lZCh0aHJlc2hvbGQpKSB7XG5cdFx0XHRcdFx0XHRheGlzLnRocmVzaG9sZCA9IHRocmVzaG9sZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gSWYgYW55IHNlcmllcyBoYXMgYSBoYXJkIHRocmVzaG9sZCwgaXQgdGFrZXMgcHJlY2VkZW5jZVxuXHRcdFx0XHRcdGlmICghc2VyaWVzT3B0aW9ucy5zb2Z0VGhyZXNob2xkIHx8IGF4aXMuaXNMb2cpIHtcblx0XHRcdFx0XHRcdGF4aXMuc29mdFRocmVzaG9sZCA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUcmFuc2xhdGUgZnJvbSBheGlzIHZhbHVlIHRvIHBpeGVsIHBvc2l0aW9uIG9uIHRoZSBjaGFydCwgb3IgYmFja1xuXHQgKlxuXHQgKi9cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAodmFsLCBiYWNrd2FyZHMsIGN2c0Nvb3JkLCBvbGQsIGhhbmRsZUxvZywgcG9pbnRQbGFjZW1lbnQpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMubGlua2VkUGFyZW50IHx8IHRoaXMsIC8vICMxNDE3XG5cdFx0XHRzaWduID0gMSxcblx0XHRcdGN2c09mZnNldCA9IDAsXG5cdFx0XHRsb2NhbEEgPSBvbGQgPyBheGlzLm9sZFRyYW5zQSA6IGF4aXMudHJhbnNBLFxuXHRcdFx0bG9jYWxNaW4gPSBvbGQgPyBheGlzLm9sZE1pbiA6IGF4aXMubWluLFxuXHRcdFx0cmV0dXJuVmFsdWUsXG5cdFx0XHRtaW5QaXhlbFBhZGRpbmcgPSBheGlzLm1pblBpeGVsUGFkZGluZyxcblx0XHRcdGRvUG9zdFRyYW5zbGF0ZSA9IChheGlzLmRvUG9zdFRyYW5zbGF0ZSB8fCAoYXhpcy5pc0xvZyAmJiBoYW5kbGVMb2cpKSAmJiBheGlzLmxpbjJ2YWw7XG5cblx0XHRpZiAoIWxvY2FsQSkge1xuXHRcdFx0bG9jYWxBID0gYXhpcy50cmFuc0E7XG5cdFx0fVxuXG5cdFx0Ly8gSW4gdmVydGljYWwgYXhlcywgdGhlIGNhbnZhcyBjb29yZGluYXRlcyBzdGFydCBmcm9tIDAgYXQgdGhlIHRvcCBsaWtlIGluXG5cdFx0Ly8gU1ZHLlxuXHRcdGlmIChjdnNDb29yZCkge1xuXHRcdFx0c2lnbiAqPSAtMTsgLy8gY2FudmFzIGNvb3JkaW5hdGVzIGludmVydHMgdGhlIHZhbHVlXG5cdFx0XHRjdnNPZmZzZXQgPSBheGlzLmxlbjtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgcmV2ZXJzZWQgYXhpc1xuXHRcdGlmIChheGlzLnJldmVyc2VkKSB7XG5cdFx0XHRzaWduICo9IC0xO1xuXHRcdFx0Y3ZzT2Zmc2V0IC09IHNpZ24gKiAoYXhpcy5zZWN0b3IgfHwgYXhpcy5sZW4pO1xuXHRcdH1cblxuXHRcdC8vIEZyb20gcGl4ZWxzIHRvIHZhbHVlXG5cdFx0aWYgKGJhY2t3YXJkcykgeyAvLyByZXZlcnNlIHRyYW5zbGF0aW9uXG5cblx0XHRcdHZhbCA9IHZhbCAqIHNpZ24gKyBjdnNPZmZzZXQ7XG5cdFx0XHR2YWwgLT0gbWluUGl4ZWxQYWRkaW5nO1xuXHRcdFx0cmV0dXJuVmFsdWUgPSB2YWwgLyBsb2NhbEEgKyBsb2NhbE1pbjsgLy8gZnJvbSBjaGFydCBwaXhlbCB0byB2YWx1ZVxuXHRcdFx0aWYgKGRvUG9zdFRyYW5zbGF0ZSkgeyAvLyBsb2cgYW5kIG9yZGluYWwgYXhlc1xuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IGF4aXMubGluMnZhbChyZXR1cm5WYWx1ZSk7XG5cdFx0XHR9XG5cblx0XHQvLyBGcm9tIHZhbHVlIHRvIHBpeGVsc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoZG9Qb3N0VHJhbnNsYXRlKSB7IC8vIGxvZyBhbmQgb3JkaW5hbCBheGVzXG5cdFx0XHRcdHZhbCA9IGF4aXMudmFsMmxpbih2YWwpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBvaW50UGxhY2VtZW50ID09PSAnYmV0d2VlbicpIHtcblx0XHRcdFx0cG9pbnRQbGFjZW1lbnQgPSAwLjU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm5WYWx1ZSA9IHNpZ24gKiAodmFsIC0gbG9jYWxNaW4pICogbG9jYWxBICsgY3ZzT2Zmc2V0ICsgKHNpZ24gKiBtaW5QaXhlbFBhZGRpbmcpICtcblx0XHRcdFx0KGlzTnVtYmVyKHBvaW50UGxhY2VtZW50KSA/IGxvY2FsQSAqIHBvaW50UGxhY2VtZW50ICogYXhpcy5wb2ludFJhbmdlIDogMCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVdGlsaXR5IG1ldGhvZCB0byB0cmFuc2xhdGUgYW4gYXhpcyB2YWx1ZSB0byBwaXhlbCBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIEEgdmFsdWUgaW4gdGVybXMgb2YgYXhpcyB1bml0c1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhbmVDb29yZGluYXRlcyBXaGV0aGVyIHRvIHJldHVybiB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgY2hhcnRcblx0ICogICAgICAgIG9yIGp1c3QgdGhlIGF4aXMvcGFuZSBpdHNlbGYuXG5cdCAqL1xuXHR0b1BpeGVsczogZnVuY3Rpb24gKHZhbHVlLCBwYW5lQ29vcmRpbmF0ZXMpIHtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGUodmFsdWUsIGZhbHNlLCAhdGhpcy5ob3JpeiwgbnVsbCwgdHJ1ZSkgKyAocGFuZUNvb3JkaW5hdGVzID8gMCA6IHRoaXMucG9zKTtcblx0fSxcblxuXHQvKlxuXHQgKiBVdGlsaXR5IG1ldGhvZCB0byB0cmFuc2xhdGUgYSBwaXhlbCBwb3NpdGlvbiBpbiB0byBhbiBheGlzIHZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwaXhlbCBUaGUgcGl4ZWwgdmFsdWUgY29vcmRpbmF0ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhbmVDb29yZGlhbnRlcyBXaGV0aGVyIHRoZSBpbnB1dCBwaXhlbCBpcyByZWxhdGl2ZSB0byB0aGUgY2hhcnQgb3IganVzdCB0aGVcblx0ICogICAgICAgIGF4aXMvcGFuZSBpdHNlbGYuXG5cdCAqL1xuXHR0b1ZhbHVlOiBmdW5jdGlvbiAocGl4ZWwsIHBhbmVDb29yZGluYXRlcykge1xuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZShwaXhlbCAtIChwYW5lQ29vcmRpbmF0ZXMgPyAwIDogdGhpcy5wb3MpLCB0cnVlLCAhdGhpcy5ob3JpeiwgbnVsbCwgdHJ1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSB0aGUgcGF0aCBmb3IgYSBwbG90IGxpbmUgdGhhdCBnb2VzIGZyb20gdGhlIGdpdmVuIHZhbHVlIG9uXG5cdCAqIHRoaXMgYXhpcywgYWNyb3NzIHRoZSBwbG90IHRvIHRoZSBvcHBvc2l0ZSBzaWRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGluZVdpZHRoIFVzZWQgZm9yIGNhbGN1bGF0aW9uIGNyaXNwIGxpbmVcblx0ICogQHBhcmFtIHtOdW1iZXJdIG9sZCBVc2Ugb2xkIGNvb3JkaW5hdGVzIChmb3IgcmVzaXppbmcgYW5kIHJlc2NhbGluZylcblx0ICovXG5cdGdldFBsb3RMaW5lUGF0aDogZnVuY3Rpb24gKHZhbHVlLCBsaW5lV2lkdGgsIG9sZCwgZm9yY2UsIHRyYW5zbGF0ZWRWYWx1ZSkge1xuXHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdGF4aXNMZWZ0ID0gYXhpcy5sZWZ0LFxuXHRcdFx0YXhpc1RvcCA9IGF4aXMudG9wLFxuXHRcdFx0eDEsXG5cdFx0XHR5MSxcblx0XHRcdHgyLFxuXHRcdFx0eTIsXG5cdFx0XHRjSGVpZ2h0ID0gKG9sZCAmJiBjaGFydC5vbGRDaGFydEhlaWdodCkgfHwgY2hhcnQuY2hhcnRIZWlnaHQsXG5cdFx0XHRjV2lkdGggPSAob2xkICYmIGNoYXJ0Lm9sZENoYXJ0V2lkdGgpIHx8IGNoYXJ0LmNoYXJ0V2lkdGgsXG5cdFx0XHRza2lwLFxuXHRcdFx0dHJhbnNCID0gYXhpcy50cmFuc0IsXG5cdFx0XHQvKipcblx0XHRcdCAqIENoZWNrIGlmIHggaXMgYmV0d2VlbiBhIGFuZCBiLiBJZiBub3QsIGVpdGhlciBtb3ZlIHRvIGEvYiBvciBza2lwLCBcblx0XHRcdCAqIGRlcGVuZGluZyBvbiB0aGUgZm9yY2UgcGFyYW1ldGVyLlxuXHRcdFx0ICovXG5cdFx0XHRiZXR3ZWVuID0gZnVuY3Rpb24gKHgsIGEsIGIpIHtcblx0XHRcdFx0aWYgKHggPCBhIHx8IHggPiBiKSB7XG5cdFx0XHRcdFx0aWYgKGZvcmNlKSB7XG5cdFx0XHRcdFx0XHR4ID0gbWF0aE1pbihtYXRoTWF4KGEsIHgpLCBiKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2tpcCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB4O1xuXHRcdFx0fTtcblxuXHRcdHRyYW5zbGF0ZWRWYWx1ZSA9IHBpY2sodHJhbnNsYXRlZFZhbHVlLCBheGlzLnRyYW5zbGF0ZSh2YWx1ZSwgbnVsbCwgbnVsbCwgb2xkKSk7XG5cdFx0eDEgPSB4MiA9IG1hdGhSb3VuZCh0cmFuc2xhdGVkVmFsdWUgKyB0cmFuc0IpO1xuXHRcdHkxID0geTIgPSBtYXRoUm91bmQoY0hlaWdodCAtIHRyYW5zbGF0ZWRWYWx1ZSAtIHRyYW5zQik7XG5cblx0XHRpZiAoaXNOYU4odHJhbnNsYXRlZFZhbHVlKSkgeyAvLyBubyBtaW4gb3IgbWF4XG5cdFx0XHRza2lwID0gdHJ1ZTtcblxuXHRcdH0gZWxzZSBpZiAoYXhpcy5ob3Jpeikge1xuXHRcdFx0eTEgPSBheGlzVG9wO1xuXHRcdFx0eTIgPSBjSGVpZ2h0IC0gYXhpcy5ib3R0b207XG5cdFx0XHR4MSA9IHgyID0gYmV0d2Vlbih4MSwgYXhpc0xlZnQsIGF4aXNMZWZ0ICsgYXhpcy53aWR0aCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHgxID0gYXhpc0xlZnQ7XG5cdFx0XHR4MiA9IGNXaWR0aCAtIGF4aXMucmlnaHQ7XG5cdFx0XHR5MSA9IHkyID0gYmV0d2Vlbih5MSwgYXhpc1RvcCwgYXhpc1RvcCArIGF4aXMuaGVpZ2h0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHNraXAgJiYgIWZvcmNlID9cblx0XHRcdG51bGwgOlxuXHRcdFx0Y2hhcnQucmVuZGVyZXIuY3Jpc3BMaW5lKFtNLCB4MSwgeTEsIEwsIHgyLCB5Ml0sIGxpbmVXaWR0aCB8fCAxKTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSB0aWNrIHBvc2l0aW9ucyBvZiBhIGxpbmVhciBheGlzIHRvIHJvdW5kIHZhbHVlcyBsaWtlIHdob2xlIHRlbnMgb3IgZXZlcnkgZml2ZS5cblx0ICovXG5cdGdldExpbmVhclRpY2tQb3NpdGlvbnM6IGZ1bmN0aW9uICh0aWNrSW50ZXJ2YWwsIG1pbiwgbWF4KSB7XG5cdFx0dmFyIHBvcyxcblx0XHRcdGxhc3RQb3MsXG5cdFx0XHRyb3VuZGVkTWluID0gY29ycmVjdEZsb2F0KG1hdGhGbG9vcihtaW4gLyB0aWNrSW50ZXJ2YWwpICogdGlja0ludGVydmFsKSxcblx0XHRcdHJvdW5kZWRNYXggPSBjb3JyZWN0RmxvYXQobWF0aENlaWwobWF4IC8gdGlja0ludGVydmFsKSAqIHRpY2tJbnRlcnZhbCksXG5cdFx0XHR0aWNrUG9zaXRpb25zID0gW107XG5cblx0XHQvLyBGb3Igc2luZ2xlIHBvaW50cywgYWRkIGEgdGljayByZWdhcmRsZXNzIG9mIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiAoIzI2NjIpXG5cdFx0aWYgKG1pbiA9PT0gbWF4ICYmIGlzTnVtYmVyKG1pbikpIHtcblx0XHRcdHJldHVybiBbbWluXTtcblx0XHR9XG5cblx0XHQvLyBQb3B1bGF0ZSB0aGUgaW50ZXJtZWRpYXRlIHZhbHVlc1xuXHRcdHBvcyA9IHJvdW5kZWRNaW47XG5cdFx0d2hpbGUgKHBvcyA8PSByb3VuZGVkTWF4KSB7XG5cblx0XHRcdC8vIFBsYWNlIHRoZSB0aWNrIG9uIHRoZSByb3VuZGVkIHZhbHVlXG5cdFx0XHR0aWNrUG9zaXRpb25zLnB1c2gocG9zKTtcblxuXHRcdFx0Ly8gQWx3YXlzIGFkZCB0aGUgcmF3IHRpY2tJbnRlcnZhbCwgbm90IHRoZSBjb3JyZWN0ZWQgb25lLlxuXHRcdFx0cG9zID0gY29ycmVjdEZsb2F0KHBvcyArIHRpY2tJbnRlcnZhbCk7XG5cblx0XHRcdC8vIElmIHRoZSBpbnRlcnZhbCBpcyBub3QgYmlnIGVub3VnaCBpbiB0aGUgY3VycmVudCBtaW4gLSBtYXggcmFuZ2UgdG8gYWN0dWFsbHkgaW5jcmVhc2Vcblx0XHRcdC8vIHRoZSBsb29wIHZhcmlhYmxlLCB3ZSBuZWVkIHRvIGJyZWFrIG91dCB0byBwcmV2ZW50IGVuZGxlc3MgbG9vcC4gSXNzdWUgIzYxOVxuXHRcdFx0aWYgKHBvcyA9PT0gbGFzdFBvcykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVjb3JkIHRoZSBsYXN0IHZhbHVlXG5cdFx0XHRsYXN0UG9zID0gcG9zO1xuXHRcdH1cblx0XHRyZXR1cm4gdGlja1Bvc2l0aW9ucztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBtaW5vciB0aWNrIHBvc2l0aW9ucy4gRm9yIGxvZ2FyaXRobWljIGF4ZXMsIHJldXNlIHRoZSBzYW1lIGxvZ2ljXG5cdCAqIGFzIGZvciBtYWpvciB0aWNrcy5cblx0ICovXG5cdGdldE1pbm9yVGlja1Bvc2l0aW9uczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHR0aWNrUG9zaXRpb25zID0gYXhpcy50aWNrUG9zaXRpb25zLFxuXHRcdFx0bWlub3JUaWNrSW50ZXJ2YWwgPSBheGlzLm1pbm9yVGlja0ludGVydmFsLFxuXHRcdFx0bWlub3JUaWNrUG9zaXRpb25zID0gW10sXG5cdFx0XHRwb3MsXG5cdFx0XHRpLFxuXHRcdFx0cG9pbnRSYW5nZVBhZGRpbmcgPSBheGlzLnBvaW50UmFuZ2VQYWRkaW5nIHx8IDAsIFxuXHRcdFx0bWluID0gYXhpcy5taW4gLSBwb2ludFJhbmdlUGFkZGluZywgLy8gIzE0OThcblx0XHRcdG1heCA9IGF4aXMubWF4ICsgcG9pbnRSYW5nZVBhZGRpbmcsIC8vICMxNDk4XG5cdFx0XHRyYW5nZSA9IG1heCAtIG1pbixcblx0XHRcdGxlbjtcblxuXHRcdC8vIElmIG1pbm9yIHRpY2tzIGdldCB0b28gZGVuc2UsIHRoZXkgYXJlIGhhcmQgdG8gcmVhZCwgYW5kIG1heSBjYXVzZSBsb25nIHJ1bm5pbmcgc2NyaXB0LiBTbyB3ZSBkb24ndCBkcmF3IHRoZW0uXG5cdFx0aWYgKHJhbmdlICYmIHJhbmdlIC8gbWlub3JUaWNrSW50ZXJ2YWwgPCBheGlzLmxlbiAvIDMpIHsgLy8gIzM4NzVcblxuXHRcdFx0aWYgKGF4aXMuaXNMb2cpIHtcblx0XHRcdFx0bGVuID0gdGlja1Bvc2l0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdG1pbm9yVGlja1Bvc2l0aW9ucyA9IG1pbm9yVGlja1Bvc2l0aW9ucy5jb25jYXQoXG5cdFx0XHRcdFx0XHRheGlzLmdldExvZ1RpY2tQb3NpdGlvbnMobWlub3JUaWNrSW50ZXJ2YWwsIHRpY2tQb3NpdGlvbnNbaSAtIDFdLCB0aWNrUG9zaXRpb25zW2ldLCB0cnVlKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXhpcy5pc0RhdGV0aW1lQXhpcyAmJiBvcHRpb25zLm1pbm9yVGlja0ludGVydmFsID09PSAnYXV0bycpIHsgLy8gIzEzMTRcblx0XHRcdFx0bWlub3JUaWNrUG9zaXRpb25zID0gbWlub3JUaWNrUG9zaXRpb25zLmNvbmNhdChcblx0XHRcdFx0XHRheGlzLmdldFRpbWVUaWNrcyhcblx0XHRcdFx0XHRcdGF4aXMubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbChtaW5vclRpY2tJbnRlcnZhbCksXG5cdFx0XHRcdFx0XHRtaW4sXG5cdFx0XHRcdFx0XHRtYXgsXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0YXJ0T2ZXZWVrXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChwb3MgPSBtaW4gKyAodGlja1Bvc2l0aW9uc1swXSAtIG1pbikgJSBtaW5vclRpY2tJbnRlcnZhbDsgcG9zIDw9IG1heDsgcG9zICs9IG1pbm9yVGlja0ludGVydmFsKSB7XG5cdFx0XHRcdFx0bWlub3JUaWNrUG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKG1pbm9yVGlja1Bvc2l0aW9ucy5sZW5ndGggIT09IDApIHsgLy8gZG9uJ3QgY2hhbmdlIHRoZSBleHRyZW1lcywgd2hlbiB0aGVyZSBpcyBubyBtaW5vciB0aWNrc1xuXHRcdFx0YXhpcy50cmltVGlja3MobWlub3JUaWNrUG9zaXRpb25zLCBvcHRpb25zLnN0YXJ0T25UaWNrLCBvcHRpb25zLmVuZE9uVGljayk7IC8vICMzNjUyICMzNzQzICMxNDk4XG5cdFx0fVxuXHRcdHJldHVybiBtaW5vclRpY2tQb3NpdGlvbnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkanVzdCB0aGUgbWluIGFuZCBtYXggZm9yIHRoZSBtaW5pbXVtIHJhbmdlLiBLZWVwIGluIG1pbmQgdGhhdCB0aGUgc2VyaWVzIGRhdGEgaXNcblx0ICogbm90IHlldCBwcm9jZXNzZWQsIHNvIHdlIGRvbid0IGhhdmUgaW5mb3JtYXRpb24gb24gZGF0YSBjcm9wcGluZyBhbmQgZ3JvdXBpbmcsIG9yXG5cdCAqIHVwZGF0ZWQgYXhpcy5wb2ludFJhbmdlIG9yIHNlcmllcy5wb2ludFJhbmdlLiBUaGUgZGF0YSBjYW4ndCBiZSBwcm9jZXNzZWQgdW50aWxcblx0ICogd2UgaGF2ZSBmaW5hbGx5IGVzdGFibGlzaGVkIG1pbiBhbmQgbWF4LlxuXHQgKi9cblx0YWRqdXN0Rm9yTWluUmFuZ2U6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0bWluID0gYXhpcy5taW4sXG5cdFx0XHRtYXggPSBheGlzLm1heCxcblx0XHRcdHpvb21PZmZzZXQsXG5cdFx0XHRzcGFjZUF2YWlsYWJsZSA9IGF4aXMuZGF0YU1heCAtIGF4aXMuZGF0YU1pbiA+PSBheGlzLm1pblJhbmdlLFxuXHRcdFx0Y2xvc2VzdERhdGFSYW5nZSxcblx0XHRcdGksXG5cdFx0XHRkaXN0YW5jZSxcblx0XHRcdHhEYXRhLFxuXHRcdFx0bG9vcExlbmd0aCxcblx0XHRcdG1pbkFyZ3MsXG5cdFx0XHRtYXhBcmdzLFxuXHRcdFx0bWluUmFuZ2U7XG5cblx0XHQvLyBTZXQgdGhlIGF1dG9tYXRpYyBtaW5pbXVtIHJhbmdlIGJhc2VkIG9uIHRoZSBjbG9zZXN0IHBvaW50IGRpc3RhbmNlXG5cdFx0aWYgKGF4aXMuaXNYQXhpcyAmJiBheGlzLm1pblJhbmdlID09PSBVTkRFRklORUQgJiYgIWF4aXMuaXNMb2cpIHtcblxuXHRcdFx0aWYgKGRlZmluZWQob3B0aW9ucy5taW4pIHx8IGRlZmluZWQob3B0aW9ucy5tYXgpKSB7XG5cdFx0XHRcdGF4aXMubWluUmFuZ2UgPSBudWxsOyAvLyBkb24ndCBkbyB0aGlzIGFnYWluXG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgY2xvc2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHJhdyBkYXRhIHBvaW50cywgYXMgb3Bwb3NlZCB0b1xuXHRcdFx0XHQvLyBjbG9zZXN0UG9pbnRSYW5nZSB0aGF0IGFwcGxpZXMgdG8gcHJvY2Vzc2VkIHBvaW50cyAoY3JvcHBlZCBhbmQgZ3JvdXBlZClcblx0XHRcdFx0ZWFjaChheGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHRcdHhEYXRhID0gc2VyaWVzLnhEYXRhO1xuXHRcdFx0XHRcdGxvb3BMZW5ndGggPSBzZXJpZXMueEluY3JlbWVudCA/IDEgOiB4RGF0YS5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdGZvciAoaSA9IGxvb3BMZW5ndGg7IGkgPiAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdGRpc3RhbmNlID0geERhdGFbaV0gLSB4RGF0YVtpIC0gMV07XG5cdFx0XHRcdFx0XHRpZiAoY2xvc2VzdERhdGFSYW5nZSA9PT0gVU5ERUZJTkVEIHx8IGRpc3RhbmNlIDwgY2xvc2VzdERhdGFSYW5nZSkge1xuXHRcdFx0XHRcdFx0XHRjbG9zZXN0RGF0YVJhbmdlID0gZGlzdGFuY2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0YXhpcy5taW5SYW5nZSA9IG1hdGhNaW4oY2xvc2VzdERhdGFSYW5nZSAqIDUsIGF4aXMuZGF0YU1heCAtIGF4aXMuZGF0YU1pbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaWYgbWluUmFuZ2UgaXMgZXhjZWVkZWQsIGFkanVzdFxuXHRcdGlmIChtYXggLSBtaW4gPCBheGlzLm1pblJhbmdlKSB7XG5cdFx0XHRtaW5SYW5nZSA9IGF4aXMubWluUmFuZ2U7XG5cdFx0XHR6b29tT2Zmc2V0ID0gKG1pblJhbmdlIC0gbWF4ICsgbWluKSAvIDI7XG5cblx0XHRcdC8vIGlmIG1pbiBhbmQgbWF4IG9wdGlvbnMgaGF2ZSBiZWVuIHNldCwgZG9uJ3QgZ28gYmV5b25kIGl0XG5cdFx0XHRtaW5BcmdzID0gW21pbiAtIHpvb21PZmZzZXQsIHBpY2sob3B0aW9ucy5taW4sIG1pbiAtIHpvb21PZmZzZXQpXTtcblx0XHRcdGlmIChzcGFjZUF2YWlsYWJsZSkgeyAvLyBpZiBzcGFjZSBpcyBhdmFpbGFibGUsIHN0YXkgd2l0aGluIHRoZSBkYXRhIHJhbmdlXG5cdFx0XHRcdG1pbkFyZ3NbMl0gPSBheGlzLmRhdGFNaW47XG5cdFx0XHR9XG5cdFx0XHRtaW4gPSBhcnJheU1heChtaW5BcmdzKTtcblxuXHRcdFx0bWF4QXJncyA9IFttaW4gKyBtaW5SYW5nZSwgcGljayhvcHRpb25zLm1heCwgbWluICsgbWluUmFuZ2UpXTtcblx0XHRcdGlmIChzcGFjZUF2YWlsYWJsZSkgeyAvLyBpZiBzcGFjZSBpcyBhdmFpbGFiZSwgc3RheSB3aXRoaW4gdGhlIGRhdGEgcmFuZ2Vcblx0XHRcdFx0bWF4QXJnc1syXSA9IGF4aXMuZGF0YU1heDtcblx0XHRcdH1cblxuXHRcdFx0bWF4ID0gYXJyYXlNaW4obWF4QXJncyk7XG5cblx0XHRcdC8vIG5vdyBpZiB0aGUgbWF4IGlzIGFkanVzdGVkLCBhZGp1c3QgdGhlIG1pbiBiYWNrXG5cdFx0XHRpZiAobWF4IC0gbWluIDwgbWluUmFuZ2UpIHtcblx0XHRcdFx0bWluQXJnc1swXSA9IG1heCAtIG1pblJhbmdlO1xuXHRcdFx0XHRtaW5BcmdzWzFdID0gcGljayhvcHRpb25zLm1pbiwgbWF4IC0gbWluUmFuZ2UpO1xuXHRcdFx0XHRtaW4gPSBhcnJheU1heChtaW5BcmdzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZWNvcmQgbW9kaWZpZWQgZXh0cmVtZXNcblx0XHRheGlzLm1pbiA9IG1pbjtcblx0XHRheGlzLm1heCA9IG1heDtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRyYW5zbGF0aW9uIGluZm9ybWF0aW9uXG5cdCAqL1xuXHRzZXRBeGlzVHJhbnNsYXRpb246IGZ1bmN0aW9uIChzYXZlT2xkKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0cmFuZ2UgPSBheGlzLm1heCAtIGF4aXMubWluLFxuXHRcdFx0cG9pbnRSYW5nZSA9IGF4aXMuYXhpc1BvaW50UmFuZ2UgfHwgMCxcblx0XHRcdGNsb3Nlc3RQb2ludFJhbmdlLFxuXHRcdFx0bWluUG9pbnRPZmZzZXQgPSAwLFxuXHRcdFx0cG9pbnRSYW5nZVBhZGRpbmcgPSAwLFxuXHRcdFx0bGlua2VkUGFyZW50ID0gYXhpcy5saW5rZWRQYXJlbnQsXG5cdFx0XHRvcmRpbmFsQ29ycmVjdGlvbixcblx0XHRcdGhhc0NhdGVnb3JpZXMgPSAhIWF4aXMuY2F0ZWdvcmllcyxcblx0XHRcdHRyYW5zQSA9IGF4aXMudHJhbnNBLFxuXHRcdFx0aXNYQXhpcyA9IGF4aXMuaXNYQXhpcztcblxuXHRcdC8vIEFkanVzdCB0cmFuc2xhdGlvbiBmb3IgcGFkZGluZy4gWSBheGlzIHdpdGggY2F0ZWdvcmllcyBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHNhbWUgKCMxNzg0KS5cblx0XHRpZiAoaXNYQXhpcyB8fCBoYXNDYXRlZ29yaWVzIHx8IHBvaW50UmFuZ2UpIHtcblx0XHRcdGlmIChsaW5rZWRQYXJlbnQpIHtcblx0XHRcdFx0bWluUG9pbnRPZmZzZXQgPSBsaW5rZWRQYXJlbnQubWluUG9pbnRPZmZzZXQ7XG5cdFx0XHRcdHBvaW50UmFuZ2VQYWRkaW5nID0gbGlua2VkUGFyZW50LnBvaW50UmFuZ2VQYWRkaW5nO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlYWNoKGF4aXMuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRcdFx0dmFyIHNlcmllc1BvaW50UmFuZ2UgPSBoYXNDYXRlZ29yaWVzID8gMSA6IChpc1hBeGlzID8gc2VyaWVzLnBvaW50UmFuZ2UgOiAoYXhpcy5heGlzUG9pbnRSYW5nZSB8fCAwKSksIC8vICMyODA2XG5cdFx0XHRcdFx0XHRwb2ludFBsYWNlbWVudCA9IHNlcmllcy5vcHRpb25zLnBvaW50UGxhY2VtZW50LFxuXHRcdFx0XHRcdFx0c2VyaWVzQ2xvc2VzdFBvaW50UmFuZ2UgPSBzZXJpZXMuY2xvc2VzdFBvaW50UmFuZ2U7XG5cblx0XHRcdFx0XHRwb2ludFJhbmdlID0gbWF0aE1heChwb2ludFJhbmdlLCBzZXJpZXNQb2ludFJhbmdlKTtcblxuXHRcdFx0XHRcdGlmICghYXhpcy5zaW5nbGUpIHtcblx0XHRcdFx0XHRcdC8vIG1pblBvaW50T2Zmc2V0IGlzIHRoZSB2YWx1ZSBwYWRkaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBheGlzIGluIG9yZGVyIHRvIG1ha2Vcblx0XHRcdFx0XHRcdC8vIHJvb20gZm9yIHBvaW50cyB3aXRoIGEgcG9pbnRSYW5nZSwgdHlwaWNhbGx5IGNvbHVtbnMuIFdoZW4gdGhlIHBvaW50UGxhY2VtZW50IG9wdGlvblxuXHRcdFx0XHRcdFx0Ly8gaXMgJ2JldHdlZW4nIG9yICdvbicsIHRoaXMgcGFkZGluZyBkb2VzIG5vdCBhcHBseS5cblx0XHRcdFx0XHRcdG1pblBvaW50T2Zmc2V0ID0gbWF0aE1heChcblx0XHRcdFx0XHRcdFx0bWluUG9pbnRPZmZzZXQsXG5cdFx0XHRcdFx0XHRcdGlzU3RyaW5nKHBvaW50UGxhY2VtZW50KSA/IDAgOiBzZXJpZXNQb2ludFJhbmdlIC8gMlxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gRGV0ZXJtaW5lIHRoZSB0b3RhbCBwYWRkaW5nIG5lZWRlZCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBheGlzIHRvIG1ha2Ugcm9vbSBmb3IgdGhlXG5cdFx0XHRcdFx0XHQvLyBwb2ludFJhbmdlLiBJZiB0aGUgc2VyaWVzJyBwb2ludFBsYWNlbWVudCBpcyAnb24nLCBubyBwYWRkaW5nIGlzIGFkZGVkLlxuXHRcdFx0XHRcdFx0cG9pbnRSYW5nZVBhZGRpbmcgPSBtYXRoTWF4KFxuXHRcdFx0XHRcdFx0XHRwb2ludFJhbmdlUGFkZGluZyxcblx0XHRcdFx0XHRcdFx0cG9pbnRQbGFjZW1lbnQgPT09ICdvbicgPyAwIDogc2VyaWVzUG9pbnRSYW5nZVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTZXQgdGhlIGNsb3Nlc3RQb2ludFJhbmdlXG5cdFx0XHRcdFx0aWYgKCFzZXJpZXMubm9TaGFyZWRUb29sdGlwICYmIGRlZmluZWQoc2VyaWVzQ2xvc2VzdFBvaW50UmFuZ2UpKSB7XG5cdFx0XHRcdFx0XHRjbG9zZXN0UG9pbnRSYW5nZSA9IGRlZmluZWQoY2xvc2VzdFBvaW50UmFuZ2UpID9cblx0XHRcdFx0XHRcdFx0bWF0aE1pbihjbG9zZXN0UG9pbnRSYW5nZSwgc2VyaWVzQ2xvc2VzdFBvaW50UmFuZ2UpIDpcblx0XHRcdFx0XHRcdFx0c2VyaWVzQ2xvc2VzdFBvaW50UmFuZ2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVjb3JkIG1pblBvaW50T2Zmc2V0IGFuZCBwb2ludFJhbmdlUGFkZGluZ1xuXHRcdFx0b3JkaW5hbENvcnJlY3Rpb24gPSBheGlzLm9yZGluYWxTbG9wZSAmJiBjbG9zZXN0UG9pbnRSYW5nZSA/IGF4aXMub3JkaW5hbFNsb3BlIC8gY2xvc2VzdFBvaW50UmFuZ2UgOiAxOyAvLyAjOTg4LCAjMTg1M1xuXHRcdFx0YXhpcy5taW5Qb2ludE9mZnNldCA9IG1pblBvaW50T2Zmc2V0ID0gbWluUG9pbnRPZmZzZXQgKiBvcmRpbmFsQ29ycmVjdGlvbjtcblx0XHRcdGF4aXMucG9pbnRSYW5nZVBhZGRpbmcgPSBwb2ludFJhbmdlUGFkZGluZyA9IHBvaW50UmFuZ2VQYWRkaW5nICogb3JkaW5hbENvcnJlY3Rpb247XG5cblx0XHRcdC8vIHBvaW50UmFuZ2UgbWVhbnMgdGhlIHdpZHRoIHJlc2VydmVkIGZvciBlYWNoIHBvaW50LCBsaWtlIGluIGEgY29sdW1uIGNoYXJ0XG5cdFx0XHRheGlzLnBvaW50UmFuZ2UgPSBtYXRoTWluKHBvaW50UmFuZ2UsIHJhbmdlKTtcblxuXHRcdFx0Ly8gY2xvc2VzdFBvaW50UmFuZ2UgbWVhbnMgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMuIEluIGNvbHVtbnNcblx0XHRcdC8vIGl0IGlzIG1vc3RseSBlcXVhbCB0byBwb2ludFJhbmdlLCBidXQgaW4gbGluZXMgcG9pbnRSYW5nZSBpcyAwIHdoaWxlIGNsb3Nlc3RQb2ludFJhbmdlXG5cdFx0XHQvLyBpcyBzb21lIG90aGVyIHZhbHVlXG5cdFx0XHRpZiAoaXNYQXhpcykge1xuXHRcdFx0XHRheGlzLmNsb3Nlc3RQb2ludFJhbmdlID0gY2xvc2VzdFBvaW50UmFuZ2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2Vjb25kYXJ5IHZhbHVlc1xuXHRcdGlmIChzYXZlT2xkKSB7XG5cdFx0XHRheGlzLm9sZFRyYW5zQSA9IHRyYW5zQTtcblx0XHR9XG5cdFx0YXhpcy50cmFuc2xhdGlvblNsb3BlID0gYXhpcy50cmFuc0EgPSB0cmFuc0EgPSBheGlzLmxlbiAvICgocmFuZ2UgKyBwb2ludFJhbmdlUGFkZGluZykgfHwgMSk7XG5cdFx0YXhpcy50cmFuc0IgPSBheGlzLmhvcml6ID8gYXhpcy5sZWZ0IDogYXhpcy5ib3R0b207IC8vIHRyYW5zbGF0aW9uIGFkZGVuZFxuXHRcdGF4aXMubWluUGl4ZWxQYWRkaW5nID0gdHJhbnNBICogbWluUG9pbnRPZmZzZXQ7XG5cdH0sXG5cblx0bWluRnJvbVJhbmdlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWF4IC0gdGhpcy5yYW5nZTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSB0aWNrIHBvc2l0aW9ucyB0byByb3VuZCB2YWx1ZXMgYW5kIG9wdGlvbmFsbHkgZXh0ZW5kIHRoZSBleHRyZW1lc1xuXHQgKiB0byB0aGUgbmVhcmVzdCB0aWNrXG5cdCAqL1xuXHRzZXRUaWNrSW50ZXJ2YWw6IGZ1bmN0aW9uIChzZWNvbmRQYXNzKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0b3B0aW9ucyA9IGF4aXMub3B0aW9ucyxcblx0XHRcdGlzTG9nID0gYXhpcy5pc0xvZyxcblx0XHRcdGlzRGF0ZXRpbWVBeGlzID0gYXhpcy5pc0RhdGV0aW1lQXhpcyxcblx0XHRcdGlzWEF4aXMgPSBheGlzLmlzWEF4aXMsXG5cdFx0XHRpc0xpbmtlZCA9IGF4aXMuaXNMaW5rZWQsXG5cdFx0XHRtYXhQYWRkaW5nID0gb3B0aW9ucy5tYXhQYWRkaW5nLFxuXHRcdFx0bWluUGFkZGluZyA9IG9wdGlvbnMubWluUGFkZGluZyxcblx0XHRcdGxlbmd0aCxcblx0XHRcdGxpbmtlZFBhcmVudEV4dHJlbWVzLFxuXHRcdFx0dGlja0ludGVydmFsT3B0aW9uID0gb3B0aW9ucy50aWNrSW50ZXJ2YWwsXG5cdFx0XHRtaW5UaWNrSW50ZXJ2YWwsXG5cdFx0XHR0aWNrUGl4ZWxJbnRlcnZhbE9wdGlvbiA9IG9wdGlvbnMudGlja1BpeGVsSW50ZXJ2YWwsXG5cdFx0XHRjYXRlZ29yaWVzID0gYXhpcy5jYXRlZ29yaWVzLFxuXHRcdFx0dGhyZXNob2xkID0gYXhpcy50aHJlc2hvbGQsXG5cdFx0XHRzb2Z0VGhyZXNob2xkID0gYXhpcy5zb2Z0VGhyZXNob2xkLFxuXHRcdFx0dGhyZXNob2xkTWluLFxuXHRcdFx0dGhyZXNob2xkTWF4LFxuXHRcdFx0aGFyZE1pbixcblx0XHRcdGhhcmRNYXg7XG5cblx0XHRpZiAoIWlzRGF0ZXRpbWVBeGlzICYmICFjYXRlZ29yaWVzICYmICFpc0xpbmtlZCkge1xuXHRcdFx0dGhpcy5nZXRUaWNrQW1vdW50KCk7XG5cdFx0fVxuXG5cdFx0Ly8gTWluIG9yIG1heCBzZXQgZWl0aGVyIGJ5IHpvb21pbmcvc2V0RXh0cmVtZXMgb3IgaW5pdGlhbCBvcHRpb25zXG5cdFx0aGFyZE1pbiA9IHBpY2soYXhpcy51c2VyTWluLCBvcHRpb25zLm1pbik7XG5cdFx0aGFyZE1heCA9IHBpY2soYXhpcy51c2VyTWF4LCBvcHRpb25zLm1heCk7XG5cblx0XHQvLyBMaW5rZWQgYXhpcyBnZXRzIHRoZSBleHRyZW1lcyBmcm9tIHRoZSBwYXJlbnQgYXhpc1xuXHRcdGlmIChpc0xpbmtlZCkge1xuXHRcdFx0YXhpcy5saW5rZWRQYXJlbnQgPSBjaGFydFtheGlzLmNvbGxdW29wdGlvbnMubGlua2VkVG9dO1xuXHRcdFx0bGlua2VkUGFyZW50RXh0cmVtZXMgPSBheGlzLmxpbmtlZFBhcmVudC5nZXRFeHRyZW1lcygpO1xuXHRcdFx0YXhpcy5taW4gPSBwaWNrKGxpbmtlZFBhcmVudEV4dHJlbWVzLm1pbiwgbGlua2VkUGFyZW50RXh0cmVtZXMuZGF0YU1pbik7XG5cdFx0XHRheGlzLm1heCA9IHBpY2sobGlua2VkUGFyZW50RXh0cmVtZXMubWF4LCBsaW5rZWRQYXJlbnRFeHRyZW1lcy5kYXRhTWF4KTtcblx0XHRcdGlmIChvcHRpb25zLnR5cGUgIT09IGF4aXMubGlua2VkUGFyZW50Lm9wdGlvbnMudHlwZSkge1xuXHRcdFx0XHRlcnJvcigxMSwgMSk7IC8vIENhbid0IGxpbmsgYXhlcyBvZiBkaWZmZXJlbnQgdHlwZVxuXHRcdFx0fVxuXG5cdFx0Ly8gSW5pdGlhbCBtaW4gYW5kIG1heCBmcm9tIHRoZSBleHRyZW1lIGRhdGEgdmFsdWVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQWRqdXN0IHRvIGhhcmQgdGhyZXNob2xkXG5cdFx0XHRpZiAoIXNvZnRUaHJlc2hvbGQgJiYgZGVmaW5lZCh0aHJlc2hvbGQpKSB7XG5cdFx0XHRcdGlmIChheGlzLmRhdGFNaW4gPj0gdGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0dGhyZXNob2xkTWluID0gdGhyZXNob2xkO1xuXHRcdFx0XHRcdG1pblBhZGRpbmcgPSAwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGF4aXMuZGF0YU1heCA8PSB0aHJlc2hvbGQpIHtcblx0XHRcdFx0XHR0aHJlc2hvbGRNYXggPSB0aHJlc2hvbGQ7XG5cdFx0XHRcdFx0bWF4UGFkZGluZyA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0YXhpcy5taW4gPSBwaWNrKGhhcmRNaW4sIHRocmVzaG9sZE1pbiwgYXhpcy5kYXRhTWluKTtcblx0XHRcdGF4aXMubWF4ID0gcGljayhoYXJkTWF4LCB0aHJlc2hvbGRNYXgsIGF4aXMuZGF0YU1heCk7XG5cblx0XHR9XG5cblx0XHRpZiAoaXNMb2cpIHtcblx0XHRcdGlmICghc2Vjb25kUGFzcyAmJiBtYXRoTWluKGF4aXMubWluLCBwaWNrKGF4aXMuZGF0YU1pbiwgYXhpcy5taW4pKSA8PSAwKSB7IC8vICM5Nzhcblx0XHRcdFx0ZXJyb3IoMTAsIDEpOyAvLyBDYW4ndCBwbG90IG5lZ2F0aXZlIHZhbHVlcyBvbiBsb2cgYXhpc1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGhlIGNvcnJlY3RGbG9hdCBjdXJlcyAjOTM0LCBmbG9hdCBlcnJvcnMgb24gZnVsbCB0ZW5zLiBCdXQgaXRcblx0XHRcdC8vIHdhcyB0b28gYWdncmVzc2l2ZSBmb3IgIzQzNjAgYmVjYXVzZSBvZiBjb252ZXJzaW9uIGJhY2sgdG8gbGluLFxuXHRcdFx0Ly8gdGhlcmVmb3JlIHVzZSBwcmVjaXNpb24gMTUuXG5cdFx0XHRheGlzLm1pbiA9IGNvcnJlY3RGbG9hdChsb2cybGluKGF4aXMubWluKSwgMTUpO1xuXHRcdFx0YXhpcy5tYXggPSBjb3JyZWN0RmxvYXQobG9nMmxpbihheGlzLm1heCksIDE1KTtcblx0XHR9XG5cblx0XHQvLyBoYW5kbGUgem9vbWVkIHJhbmdlXG5cdFx0aWYgKGF4aXMucmFuZ2UgJiYgZGVmaW5lZChheGlzLm1heCkpIHtcblx0XHRcdGF4aXMudXNlck1pbiA9IGF4aXMubWluID0gaGFyZE1pbiA9IG1hdGhNYXgoYXhpcy5taW4sIGF4aXMubWluRnJvbVJhbmdlKCkpOyAvLyAjNjE4XG5cdFx0XHRheGlzLnVzZXJNYXggPSBoYXJkTWF4ID0gYXhpcy5tYXg7XG5cblx0XHRcdGF4aXMucmFuZ2UgPSBudWxsOyAgLy8gZG9uJ3QgdXNlIGl0IHdoZW4gcnVubmluZyBzZXRFeHRyZW1lc1xuXHRcdH1cblxuXHRcdC8vIEhvb2sgZm9yIGFkanVzdGluZyB0aGlzLm1pbiBhbmQgdGhpcy5tYXguIFVzZWQgYnkgYnViYmxlIHNlcmllcy5cblx0XHRpZiAoYXhpcy5iZWZvcmVQYWRkaW5nKSB7XG5cdFx0XHRheGlzLmJlZm9yZVBhZGRpbmcoKTtcblx0XHR9XG5cblx0XHQvLyBhZGp1c3QgbWluIGFuZCBtYXggZm9yIHRoZSBtaW5pbXVtIHJhbmdlXG5cdFx0YXhpcy5hZGp1c3RGb3JNaW5SYW5nZSgpO1xuXG5cdFx0Ly8gUGFkIHRoZSB2YWx1ZXMgdG8gZ2V0IGNsZWFyIG9mIHRoZSBjaGFydCdzIGVkZ2VzLiBUbyBhdm9pZCB0aWNrSW50ZXJ2YWwgdGFraW5nIHRoZSBwYWRkaW5nXG5cdFx0Ly8gaW50byBhY2NvdW50LCB3ZSBkbyB0aGlzIGFmdGVyIGNvbXB1dGluZyB0aWNrIGludGVydmFsICgjMTMzNykuXG5cdFx0aWYgKCFjYXRlZ29yaWVzICYmICFheGlzLmF4aXNQb2ludFJhbmdlICYmICFheGlzLnVzZVBlcmNlbnRhZ2UgJiYgIWlzTGlua2VkICYmIGRlZmluZWQoYXhpcy5taW4pICYmIGRlZmluZWQoYXhpcy5tYXgpKSB7XG5cdFx0XHRsZW5ndGggPSBheGlzLm1heCAtIGF4aXMubWluO1xuXHRcdFx0aWYgKGxlbmd0aCkge1xuXHRcdFx0XHRpZiAoIWRlZmluZWQoaGFyZE1pbikgJiYgbWluUGFkZGluZykge1xuXHRcdFx0XHRcdGF4aXMubWluIC09IGxlbmd0aCAqIG1pblBhZGRpbmc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFkZWZpbmVkKGhhcmRNYXgpICAmJiBtYXhQYWRkaW5nKSB7XG5cdFx0XHRcdFx0YXhpcy5tYXggKz0gbGVuZ3RoICogbWF4UGFkZGluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN0YXkgd2l0aGluIGZsb29yIGFuZCBjZWlsaW5nXG5cdFx0aWYgKGlzTnVtYmVyKG9wdGlvbnMuZmxvb3IpKSB7XG5cdFx0XHRheGlzLm1pbiA9IG1hdGhNYXgoYXhpcy5taW4sIG9wdGlvbnMuZmxvb3IpO1xuXHRcdH1cblx0XHRpZiAoaXNOdW1iZXIob3B0aW9ucy5jZWlsaW5nKSkge1xuXHRcdFx0YXhpcy5tYXggPSBtYXRoTWluKGF4aXMubWF4LCBvcHRpb25zLmNlaWxpbmcpO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIHRocmVzaG9sZCBpcyBzb2Z0LCBhZGp1c3QgdGhlIGV4dHJlbWUgdmFsdWUgb25seSBpZiBcblx0XHQvLyB0aGUgZGF0YSBleHRyZW1lIGFuZCB0aGUgcGFkZGVkIGV4dHJlbWUgbGFuZCBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgdGhyZXNob2xkLiBGb3IgZXhhbXBsZSxcblx0XHQvLyBhIHNlcmllcyBvZiBbMCwgMSwgMiwgM10gd291bGQgbWFrZSB0aGUgeUF4aXMgYWRkIGEgdGljayBmb3IgLTEgYmVjYXVzZSBvZiB0aGVcblx0XHQvLyBkZWZhdWx0IG1pblBhZGRpbmcgYW5kIHN0YXJ0T25UaWNrIG9wdGlvbnMuIFRoaXMgaXMgcHJldmVudGVkIGJ5IHRoZSBzb2Z0VGhyZXNob2xkXG5cdFx0Ly8gb3B0aW9uLlxuXHRcdGlmIChzb2Z0VGhyZXNob2xkICYmIGRlZmluZWQoYXhpcy5kYXRhTWluKSkge1xuXHRcdFx0dGhyZXNob2xkID0gdGhyZXNob2xkIHx8IDA7XG5cdFx0XHRpZiAoIWRlZmluZWQoaGFyZE1pbikgJiYgYXhpcy5taW4gPCB0aHJlc2hvbGQgJiYgYXhpcy5kYXRhTWluID49IHRocmVzaG9sZCkge1xuXHRcdFx0XHRheGlzLm1pbiA9IHRocmVzaG9sZDtcblx0XHRcdH0gZWxzZSBpZiAoIWRlZmluZWQoaGFyZE1heCkgJiYgYXhpcy5tYXggPiB0aHJlc2hvbGQgJiYgYXhpcy5kYXRhTWF4IDw9IHRocmVzaG9sZCkge1xuXHRcdFx0XHRheGlzLm1heCA9IHRocmVzaG9sZDtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdC8vIGdldCB0aWNrSW50ZXJ2YWxcblx0XHRpZiAoYXhpcy5taW4gPT09IGF4aXMubWF4IHx8IGF4aXMubWluID09PSB1bmRlZmluZWQgfHwgYXhpcy5tYXggPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSAxO1xuXHRcdH0gZWxzZSBpZiAoaXNMaW5rZWQgJiYgIXRpY2tJbnRlcnZhbE9wdGlvbiAmJlxuXHRcdFx0XHR0aWNrUGl4ZWxJbnRlcnZhbE9wdGlvbiA9PT0gYXhpcy5saW5rZWRQYXJlbnQub3B0aW9ucy50aWNrUGl4ZWxJbnRlcnZhbCkge1xuXHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSB0aWNrSW50ZXJ2YWxPcHRpb24gPSBheGlzLmxpbmtlZFBhcmVudC50aWNrSW50ZXJ2YWw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGF4aXMudGlja0ludGVydmFsID0gcGljayhcblx0XHRcdFx0dGlja0ludGVydmFsT3B0aW9uLFxuXHRcdFx0XHR0aGlzLnRpY2tBbW91bnQgPyAoKGF4aXMubWF4IC0gYXhpcy5taW4pIC8gbWF0aE1heCh0aGlzLnRpY2tBbW91bnQgLSAxLCAxKSkgOiB1bmRlZmluZWQsXG5cdFx0XHRcdGNhdGVnb3JpZXMgPyAvLyBmb3IgY2F0ZWdvcmllZCBheGlzLCAxIGlzIGRlZmF1bHQsIGZvciBsaW5lYXIgYXhpcyB1c2UgdGlja1BpeFxuXHRcdFx0XHRcdDEgOlxuXHRcdFx0XHRcdC8vIGRvbid0IGxldCBpdCBiZSBtb3JlIHRoYW4gdGhlIGRhdGEgcmFuZ2Vcblx0XHRcdFx0XHQoYXhpcy5tYXggLSBheGlzLm1pbikgKiB0aWNrUGl4ZWxJbnRlcnZhbE9wdGlvbiAvIG1hdGhNYXgoYXhpcy5sZW4sIHRpY2tQaXhlbEludGVydmFsT3B0aW9uKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBOb3cgd2UncmUgZmluaXNoZWQgZGV0ZWN0aW5nIG1pbiBhbmQgbWF4LCBjcm9wIGFuZCBncm91cCBzZXJpZXMgZGF0YS4gVGhpc1xuXHRcdC8vIGlzIGluIHR1cm4gbmVlZGVkIGluIG9yZGVyIHRvIGZpbmQgdGljayBwb3NpdGlvbnMgaW4gb3JkaW5hbCBheGVzLlxuXHRcdGlmIChpc1hBeGlzICYmICFzZWNvbmRQYXNzKSB7XG5cdFx0XHRlYWNoKGF4aXMuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRcdHNlcmllcy5wcm9jZXNzRGF0YShheGlzLm1pbiAhPT0gYXhpcy5vbGRNaW4gfHwgYXhpcy5tYXggIT09IGF4aXMub2xkTWF4KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIHNldCB0aGUgdHJhbnNsYXRpb24gZmFjdG9yIHVzZWQgaW4gdHJhbnNsYXRlIGZ1bmN0aW9uXG5cdFx0YXhpcy5zZXRBeGlzVHJhbnNsYXRpb24odHJ1ZSk7XG5cblx0XHQvLyBob29rIGZvciBvcmRpbmFsIGF4ZXMgYW5kIHJhZGlhbCBheGVzXG5cdFx0aWYgKGF4aXMuYmVmb3JlU2V0VGlja1Bvc2l0aW9ucykge1xuXHRcdFx0YXhpcy5iZWZvcmVTZXRUaWNrUG9zaXRpb25zKCk7XG5cdFx0fVxuXG5cdFx0Ly8gaG9vayBmb3IgZXh0ZW5zaW9ucywgdXNlZCBpbiBIaWdoc3RvY2sgb3JkaW5hbCBheGVzXG5cdFx0aWYgKGF4aXMucG9zdFByb2Nlc3NUaWNrSW50ZXJ2YWwpIHtcblx0XHRcdGF4aXMudGlja0ludGVydmFsID0gYXhpcy5wb3N0UHJvY2Vzc1RpY2tJbnRlcnZhbChheGlzLnRpY2tJbnRlcnZhbCk7XG5cdFx0fVxuXG5cdFx0Ly8gSW4gY29sdW1uLWxpa2UgY2hhcnRzLCBkb24ndCBjcmFtcCBpbiBtb3JlIHRpY2tzIHRoYW4gdGhlcmUgYXJlIHBvaW50cyAoIzE5NDMpXG5cdFx0aWYgKGF4aXMucG9pbnRSYW5nZSkge1xuXHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBtYXRoTWF4KGF4aXMucG9pbnRSYW5nZSwgYXhpcy50aWNrSW50ZXJ2YWwpO1xuXHRcdH1cblxuXHRcdC8vIEJlZm9yZSBub3JtYWxpemluZyB0aGUgdGljayBpbnRlcnZhbCwgaGFuZGxlIG1pbmltdW0gdGljayBpbnRlcnZhbC4gVGhpcyBhcHBsaWVzIG9ubHkgaWYgdGlja0ludGVydmFsIGlzIG5vdCBkZWZpbmVkLlxuXHRcdG1pblRpY2tJbnRlcnZhbCA9IHBpY2sob3B0aW9ucy5taW5UaWNrSW50ZXJ2YWwsIGF4aXMuaXNEYXRldGltZUF4aXMgJiYgYXhpcy5jbG9zZXN0UG9pbnRSYW5nZSk7XG5cdFx0aWYgKCF0aWNrSW50ZXJ2YWxPcHRpb24gJiYgYXhpcy50aWNrSW50ZXJ2YWwgPCBtaW5UaWNrSW50ZXJ2YWwpIHtcblx0XHRcdGF4aXMudGlja0ludGVydmFsID0gbWluVGlja0ludGVydmFsO1xuXHRcdH1cblxuXHRcdC8vIGZvciBsaW5lYXIgYXhlcywgZ2V0IG1hZ25pdHVkZSBhbmQgbm9ybWFsaXplIHRoZSBpbnRlcnZhbFxuXHRcdGlmICghaXNEYXRldGltZUF4aXMgJiYgIWlzTG9nICYmICF0aWNrSW50ZXJ2YWxPcHRpb24pIHtcblx0XHRcdGF4aXMudGlja0ludGVydmFsID0gbm9ybWFsaXplVGlja0ludGVydmFsKFxuXHRcdFx0XHRheGlzLnRpY2tJbnRlcnZhbCwgXG5cdFx0XHRcdG51bGwsIFxuXHRcdFx0XHRnZXRNYWduaXR1ZGUoYXhpcy50aWNrSW50ZXJ2YWwpLCBcblx0XHRcdFx0Ly8gSWYgdGhlIHRpY2sgaW50ZXJ2YWwgaXMgYmV0d2VlbiAwLjUgYW5kIDUgYW5kIHRoZSBheGlzIG1heCBpcyBpbiB0aGUgb3JkZXIgb2Zcblx0XHRcdFx0Ly8gdGhvdXNhbmRzLCBjaGFuY2VzIGFyZSB3ZSBhcmUgZGVhbGluZyB3aXRoIHllYXJzLiBEb24ndCBhbGxvdyBkZWNpbWFscy4gIzMzNjMuXG5cdFx0XHRcdHBpY2sob3B0aW9ucy5hbGxvd0RlY2ltYWxzLCAhKGF4aXMudGlja0ludGVydmFsID4gMC41ICYmIGF4aXMudGlja0ludGVydmFsIDwgNSAmJiBheGlzLm1heCA+IDEwMDAgJiYgYXhpcy5tYXggPCA5OTk5KSksXG5cdFx0XHRcdCEhdGhpcy50aWNrQW1vdW50XG5cdFx0XHQpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBQcmV2ZW50IHRpY2tzIGZyb20gZ2V0dGluZyBzbyBjbG9zZSB0aGF0IHdlIGNhbid0IGRyYXcgdGhlIGxhYmVsc1xuXHRcdGlmICghdGhpcy50aWNrQW1vdW50ICYmIHRoaXMubGVuKSB7IC8vIENvbG9yIGF4aXMgd2l0aCBkaXNhYmxlZCBsZWdlbmQgaGFzIG5vIGxlbmd0aFxuXHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBheGlzLnVuc3F1aXNoKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRUaWNrUG9zaXRpb25zKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE5vdyB3ZSBoYXZlIGNvbXB1dGVkIHRoZSBub3JtYWxpemVkIHRpY2tJbnRlcnZhbCwgZ2V0IHRoZSB0aWNrIHBvc2l0aW9uc1xuXHQgKi9cblx0c2V0VGlja1Bvc2l0aW9uczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHR0aWNrUG9zaXRpb25zLFxuXHRcdFx0dGlja1Bvc2l0aW9uc09wdGlvbiA9IG9wdGlvbnMudGlja1Bvc2l0aW9ucyxcblx0XHRcdHRpY2tQb3NpdGlvbmVyID0gb3B0aW9ucy50aWNrUG9zaXRpb25lcixcblx0XHRcdHN0YXJ0T25UaWNrID0gb3B0aW9ucy5zdGFydE9uVGljayxcblx0XHRcdGVuZE9uVGljayA9IG9wdGlvbnMuZW5kT25UaWNrLFxuXHRcdFx0c2luZ2xlO1xuXG5cdFx0Ly8gU2V0IHRoZSB0aWNrbWFya09mZnNldFxuXHRcdHRoaXMudGlja21hcmtPZmZzZXQgPSAodGhpcy5jYXRlZ29yaWVzICYmIG9wdGlvbnMudGlja21hcmtQbGFjZW1lbnQgPT09ICdiZXR3ZWVuJyAmJiBcblx0XHRcdHRoaXMudGlja0ludGVydmFsID09PSAxKSA/IDAuNSA6IDA7IC8vICMzMjAyXG5cblxuXHRcdC8vIGdldCBtaW5vclRpY2tJbnRlcnZhbFxuXHRcdHRoaXMubWlub3JUaWNrSW50ZXJ2YWwgPSBvcHRpb25zLm1pbm9yVGlja0ludGVydmFsID09PSAnYXV0bycgJiYgdGhpcy50aWNrSW50ZXJ2YWwgP1xuXHRcdFx0dGhpcy50aWNrSW50ZXJ2YWwgLyA1IDogb3B0aW9ucy5taW5vclRpY2tJbnRlcnZhbDtcblxuXHRcdC8vIEZpbmQgdGhlIHRpY2sgcG9zaXRpb25zXG5cdFx0dGhpcy50aWNrUG9zaXRpb25zID0gdGlja1Bvc2l0aW9ucyA9IHRpY2tQb3NpdGlvbnNPcHRpb24gJiYgdGlja1Bvc2l0aW9uc09wdGlvbi5zbGljZSgpOyAvLyBXb3JrIG9uIGEgY29weSAoIzE1NjUpXG5cdFx0aWYgKCF0aWNrUG9zaXRpb25zKSB7XG5cblx0XHRcdGlmICh0aGlzLmlzRGF0ZXRpbWVBeGlzKSB7XG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMgPSB0aGlzLmdldFRpbWVUaWNrcyhcblx0XHRcdFx0XHR0aGlzLm5vcm1hbGl6ZVRpbWVUaWNrSW50ZXJ2YWwodGhpcy50aWNrSW50ZXJ2YWwsIG9wdGlvbnMudW5pdHMpLFxuXHRcdFx0XHRcdHRoaXMubWluLFxuXHRcdFx0XHRcdHRoaXMubWF4LFxuXHRcdFx0XHRcdG9wdGlvbnMuc3RhcnRPZldlZWssXG5cdFx0XHRcdFx0dGhpcy5vcmRpbmFsUG9zaXRpb25zLFxuXHRcdFx0XHRcdHRoaXMuY2xvc2VzdFBvaW50UmFuZ2UsXG5cdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmlzTG9nKSB7XG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMgPSB0aGlzLmdldExvZ1RpY2tQb3NpdGlvbnModGhpcy50aWNrSW50ZXJ2YWwsIHRoaXMubWluLCB0aGlzLm1heCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aWNrUG9zaXRpb25zID0gdGhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKHRoaXMudGlja0ludGVydmFsLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUb28gZGVuc2UgdGlja3MsIGtlZXAgb25seSB0aGUgZmlyc3QgYW5kIGxhc3QgKCM0NDc3KVxuXHRcdFx0aWYgKHRpY2tQb3NpdGlvbnMubGVuZ3RoID4gdGhpcy5sZW4pIHtcblx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IFt0aWNrUG9zaXRpb25zWzBdLCB0aWNrUG9zaXRpb25zLnBvcCgpXTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy50aWNrUG9zaXRpb25zID0gdGlja1Bvc2l0aW9ucztcblxuXHRcdFx0Ly8gUnVuIHRoZSB0aWNrIHBvc2l0aW9uZXIgY2FsbGJhY2ssIHRoYXQgYWxsb3dzIG1vZGlmeWluZyBhdXRvIHRpY2sgcG9zaXRpb25zLlxuXHRcdFx0aWYgKHRpY2tQb3NpdGlvbmVyKSB7XG5cdFx0XHRcdHRpY2tQb3NpdGlvbmVyID0gdGlja1Bvc2l0aW9uZXIuYXBwbHkodGhpcywgW3RoaXMubWluLCB0aGlzLm1heF0pO1xuXHRcdFx0XHRpZiAodGlja1Bvc2l0aW9uZXIpIHtcblx0XHRcdFx0XHR0aGlzLnRpY2tQb3NpdGlvbnMgPSB0aWNrUG9zaXRpb25zID0gdGlja1Bvc2l0aW9uZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc0xpbmtlZCkge1xuXG5cdFx0XHQvLyByZXNldCBtaW4vbWF4IG9yIHJlbW92ZSBleHRyZW1lcyBiYXNlZCBvbiBzdGFydC9lbmQgb24gdGlja1xuXHRcdFx0dGhpcy50cmltVGlja3ModGlja1Bvc2l0aW9ucywgc3RhcnRPblRpY2ssIGVuZE9uVGljayk7XG5cblx0XHRcdC8vIFdoZW4gdGhlcmUgaXMgb25seSBvbmUgcG9pbnQsIG9yIGFsbCBwb2ludHMgaGF2ZSB0aGUgc2FtZSB2YWx1ZSBvbiB0aGlzIGF4aXMsIHRoZW4gbWluXG5cdFx0XHQvLyBhbmQgbWF4IGFyZSBlcXVhbCBhbmQgdGlja1Bvc2l0aW9ucy5sZW5ndGggaXMgMCBvciAxLiBJbiB0aGlzIGNhc2UsIGFkZCBzb21lIHBhZGRpbmdcblx0XHRcdC8vIGluIG9yZGVyIHRvIGNlbnRlciB0aGUgcG9pbnQsIGJ1dCBsZWF2ZSBpdCB3aXRoIG9uZSB0aWNrLiAjMTMzNy5cblx0XHRcdGlmICh0aGlzLm1pbiA9PT0gdGhpcy5tYXggJiYgZGVmaW5lZCh0aGlzLm1pbikgJiYgIXRoaXMudGlja0Ftb3VudCkge1xuXHRcdFx0XHQvLyBTdWJzdHJhY3QgaGFsZiBhIHVuaXQgKCMyNjE5LCAjMjg0NiwgIzI1MTUsICMzMzkwKVxuXHRcdFx0XHRzaW5nbGUgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLm1pbiAtPSAwLjU7XG5cdFx0XHRcdHRoaXMubWF4ICs9IDAuNTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2luZ2xlID0gc2luZ2xlO1xuXG5cdFx0XHRpZiAoIXRpY2tQb3NpdGlvbnNPcHRpb24gJiYgIXRpY2tQb3NpdGlvbmVyKSB7XG5cdFx0XHRcdHRoaXMuYWRqdXN0VGlja0Ftb3VudCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIHN0YXJ0T25UaWNrIGFuZCBlbmRPblRpY2sgYnkgZWl0aGVyIGFkYXB0aW5nIHRvIHBhZGRpbmcgbWluL21heCBvciByb3VuZGVkIG1pbi9tYXhcblx0ICovXG5cdHRyaW1UaWNrczogZnVuY3Rpb24gKHRpY2tQb3NpdGlvbnMsIHN0YXJ0T25UaWNrLCBlbmRPblRpY2spIHtcblx0XHR2YXIgcm91bmRlZE1pbiA9IHRpY2tQb3NpdGlvbnNbMF0sXG5cdFx0XHRyb3VuZGVkTWF4ID0gdGlja1Bvc2l0aW9uc1t0aWNrUG9zaXRpb25zLmxlbmd0aCAtIDFdLFxuXHRcdFx0bWluUG9pbnRPZmZzZXQgPSB0aGlzLm1pblBvaW50T2Zmc2V0IHx8IDA7XG5cdFx0XHRcblx0XHRpZiAoc3RhcnRPblRpY2spIHtcblx0XHRcdHRoaXMubWluID0gcm91bmRlZE1pbjtcblx0XHR9IGVsc2UgaWYgKHRoaXMubWluIC0gbWluUG9pbnRPZmZzZXQgPiByb3VuZGVkTWluKSB7XG5cdFx0XHR0aWNrUG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKGVuZE9uVGljaykge1xuXHRcdFx0dGhpcy5tYXggPSByb3VuZGVkTWF4O1xuXHRcdH0gZWxzZSBpZiAodGhpcy5tYXggKyBtaW5Qb2ludE9mZnNldCA8IHJvdW5kZWRNYXgpIHtcblx0XHRcdHRpY2tQb3NpdGlvbnMucG9wKCk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbm8gdGljayBhcmUgbGVmdCwgc2V0IG9uZSB0aWNrIGluIHRoZSBtaWRkbGUgKCMzMTk1KSBcblx0XHRpZiAodGlja1Bvc2l0aW9ucy5sZW5ndGggPT09IDAgJiYgZGVmaW5lZChyb3VuZGVkTWluKSkge1xuXHRcdFx0dGlja1Bvc2l0aW9ucy5wdXNoKChyb3VuZGVkTWF4ICsgcm91bmRlZE1pbikgLyAyKTtcblx0XHR9XHRcdFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIG1heCB0aWNrcyBvZiBlaXRoZXIgdGhlIHggYW5kIHkgYXhpcyBjb2xsZWN0aW9uXG5cdCAqL1xuXHRnZXRUaWNrQW1vdW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG90aGVycyA9IHt9LCAvLyBXaGV0aGVyIHRoZXJlIGlzIGFub3RoZXIgYXhpcyB0byBwYWlyIHdpdGggdGhpcyBvbmVcblx0XHRcdGhhc090aGVyLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHRpY2tBbW91bnQgPSBvcHRpb25zLnRpY2tBbW91bnQsXG5cdFx0XHR0aWNrUGl4ZWxJbnRlcnZhbCA9IG9wdGlvbnMudGlja1BpeGVsSW50ZXJ2YWw7XG5cblx0XHRpZiAoIWRlZmluZWQob3B0aW9ucy50aWNrSW50ZXJ2YWwpICYmIHRoaXMubGVuIDwgdGlja1BpeGVsSW50ZXJ2YWwgJiYgIXRoaXMuaXNSYWRpYWwgJiZcblx0XHRcdFx0IXRoaXMuaXNMb2cgJiYgb3B0aW9ucy5zdGFydE9uVGljayAmJiBvcHRpb25zLmVuZE9uVGljaykge1xuXHRcdFx0dGlja0Ftb3VudCA9IDI7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aWNrQW1vdW50ICYmIHRoaXMuY2hhcnQub3B0aW9ucy5jaGFydC5hbGlnblRpY2tzICE9PSBmYWxzZSAmJiBvcHRpb25zLmFsaWduVGlja3MgIT09IGZhbHNlKSB7XG5cdFx0XHQvLyBDaGVjayBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgYXhlcyBpbiB0aGUgc2FtZSBwYW5lXG5cdFx0XHRlYWNoKHRoaXMuY2hhcnRbdGhpcy5jb2xsXSwgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0dmFyIG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRcdFx0aG9yaXogPSBheGlzLmhvcml6LFxuXHRcdFx0XHRcdGtleSA9IFtob3JpeiA/IG9wdGlvbnMubGVmdCA6IG9wdGlvbnMudG9wLCBob3JpeiA/IG9wdGlvbnMud2lkdGggOiBvcHRpb25zLmhlaWdodCwgb3B0aW9ucy5wYW5lXS5qb2luKCcsJyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYXhpcy5zZXJpZXMubGVuZ3RoKSB7IC8vICM0NDQyXG5cdFx0XHRcdFx0aWYgKG90aGVyc1trZXldKSB7XG5cdFx0XHRcdFx0XHRoYXNPdGhlciA9IHRydWU7IC8vICM0MjAxXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG90aGVyc1trZXldID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoaGFzT3RoZXIpIHtcblx0XHRcdFx0Ly8gQWRkIDEgYmVjYXVzZSA0IHRpY2sgaW50ZXJ2YWxzIHJlcXVpcmUgNSB0aWNrcyAoaW5jbHVkaW5nIGZpcnN0IGFuZCBsYXN0KVxuXHRcdFx0XHR0aWNrQW1vdW50ID0gbWF0aENlaWwodGhpcy5sZW4gLyB0aWNrUGl4ZWxJbnRlcnZhbCkgKyAxO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZvciB0aWNrIGFtb3VudHMgb2YgMiBhbmQgMywgY29tcHV0ZSBmaXZlIHRpY2tzIGFuZCByZW1vdmUgdGhlIGludGVybWVkaWF0ZSBvbmVzLiBUaGlzXG5cdFx0Ly8gcHJldmVudHMgdGhlIGF4aXMgZnJvbSBhZGRpbmcgdGlja3MgdGhhdCBhcmUgdG9vIGZhciBhd2F5IGZyb20gdGhlIGRhdGEgZXh0cmVtZXMuXG5cdFx0aWYgKHRpY2tBbW91bnQgPCA0KSB7XG5cdFx0XHR0aGlzLmZpbmFsVGlja0FtdCA9IHRpY2tBbW91bnQ7XG5cdFx0XHR0aWNrQW1vdW50ID0gNTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy50aWNrQW1vdW50ID0gdGlja0Ftb3VudDtcblx0fSxcblxuXHQvKipcblx0ICogV2hlbiB1c2luZyBtdWx0aXBsZSBheGVzLCBhZGp1c3QgdGhlIG51bWJlciBvZiB0aWNrcyB0byBtYXRjaCB0aGUgaGlnaGVzdFxuXHQgKiBudW1iZXIgb2YgdGlja3MgaW4gdGhhdCBncm91cFxuXHQgKi9cblx0YWRqdXN0VGlja0Ftb3VudDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0aWNrSW50ZXJ2YWwgPSB0aGlzLnRpY2tJbnRlcnZhbCxcblx0XHRcdHRpY2tQb3NpdGlvbnMgPSB0aGlzLnRpY2tQb3NpdGlvbnMsXG5cdFx0XHR0aWNrQW1vdW50ID0gdGhpcy50aWNrQW1vdW50LFxuXHRcdFx0ZmluYWxUaWNrQW10ID0gdGhpcy5maW5hbFRpY2tBbXQsXG5cdFx0XHRjdXJyZW50VGlja0Ftb3VudCA9IHRpY2tQb3NpdGlvbnMgJiYgdGlja1Bvc2l0aW9ucy5sZW5ndGgsXG5cdFx0XHRpLFxuXHRcdFx0bGVuO1xuXG5cdFx0aWYgKGN1cnJlbnRUaWNrQW1vdW50IDwgdGlja0Ftb3VudCkgeyAvLyBUT0RPOiBDaGVjayAjMzQxMVxuXHRcdFx0d2hpbGUgKHRpY2tQb3NpdGlvbnMubGVuZ3RoIDwgdGlja0Ftb3VudCkge1xuXHRcdFx0XHR0aWNrUG9zaXRpb25zLnB1c2goY29ycmVjdEZsb2F0KFxuXHRcdFx0XHRcdHRpY2tQb3NpdGlvbnNbdGlja1Bvc2l0aW9ucy5sZW5ndGggLSAxXSArIHRpY2tJbnRlcnZhbFxuXHRcdFx0XHQpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMudHJhbnNBICo9IChjdXJyZW50VGlja0Ftb3VudCAtIDEpIC8gKHRpY2tBbW91bnQgLSAxKTtcblx0XHRcdHRoaXMubWF4ID0gdGlja1Bvc2l0aW9uc1t0aWNrUG9zaXRpb25zLmxlbmd0aCAtIDFdO1xuXG5cdFx0Ly8gV2UgaGF2ZSB0b28gbWFueSB0aWNrcywgcnVuIHNlY29uZCBwYXNzIHRvIHRyeSB0byByZWR1Y2UgdGlja3Ncblx0XHR9IGVsc2UgaWYgKGN1cnJlbnRUaWNrQW1vdW50ID4gdGlja0Ftb3VudCkge1xuXHRcdFx0dGhpcy50aWNrSW50ZXJ2YWwgKj0gMjtcblx0XHRcdHRoaXMuc2V0VGlja1Bvc2l0aW9ucygpO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBmaW5hbFRpY2tBbXQgcHJvcGVydHkgaXMgc2V0IGluIGdldFRpY2tBbW91bnRcblx0XHRpZiAoZGVmaW5lZChmaW5hbFRpY2tBbXQpKSB7XG5cdFx0XHRpID0gbGVuID0gdGlja1Bvc2l0aW9ucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQoZmluYWxUaWNrQW10ID09PSAzICYmIGkgJSAyID09PSAxKSB8fCAvLyBSZW1vdmUgZXZlcnkgb3RoZXIgdGlja1xuXHRcdFx0XHRcdChmaW5hbFRpY2tBbXQgPD0gMiAmJiBpID4gMCAmJiBpIDwgbGVuIC0gMSkgLy8gUmVtb3ZlIGFsbCBidXQgZmlyc3QgYW5kIGxhc3Rcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0dGlja1Bvc2l0aW9ucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH1cdFxuXHRcdFx0fVxuXHRcdFx0dGhpcy5maW5hbFRpY2tBbXQgPSBVTkRFRklORUQ7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIHNjYWxlIGJhc2VkIG9uIGRhdGEgbWluIGFuZCBtYXgsIHVzZXIgc2V0IG1pbiBhbmQgbWF4IG9yIG9wdGlvbnNcblx0ICpcblx0ICovXG5cdHNldFNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0aXNEaXJ0eURhdGEsXG5cdFx0XHRpc0RpcnR5QXhpc0xlbmd0aDtcblxuXHRcdGF4aXMub2xkTWluID0gYXhpcy5taW47XG5cdFx0YXhpcy5vbGRNYXggPSBheGlzLm1heDtcblx0XHRheGlzLm9sZEF4aXNMZW5ndGggPSBheGlzLmxlbjtcblxuXHRcdC8vIHNldCB0aGUgbmV3IGF4aXNMZW5ndGhcblx0XHRheGlzLnNldEF4aXNTaXplKCk7XG5cdFx0Ly9heGlzTGVuZ3RoID0gaG9yaXogPyBheGlzV2lkdGggOiBheGlzSGVpZ2h0O1xuXHRcdGlzRGlydHlBeGlzTGVuZ3RoID0gYXhpcy5sZW4gIT09IGF4aXMub2xkQXhpc0xlbmd0aDtcblxuXHRcdC8vIGlzIHRoZXJlIG5ldyBkYXRhP1xuXHRcdGVhY2goYXhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdGlmIChzZXJpZXMuaXNEaXJ0eURhdGEgfHwgc2VyaWVzLmlzRGlydHkgfHxcblx0XHRcdFx0XHRzZXJpZXMueEF4aXMuaXNEaXJ0eSkgeyAvLyB3aGVuIHggYXhpcyBpcyBkaXJ0eSwgd2UgbmVlZCBuZXcgZGF0YSBleHRyZW1lcyBmb3IgeSBhcyB3ZWxsXG5cdFx0XHRcdGlzRGlydHlEYXRhID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGRvIHdlIHJlYWxseSBuZWVkIHRvIGdvIHRocm91Z2ggYWxsIHRoaXM/XG5cdFx0aWYgKGlzRGlydHlBeGlzTGVuZ3RoIHx8IGlzRGlydHlEYXRhIHx8IGF4aXMuaXNMaW5rZWQgfHwgYXhpcy5mb3JjZVJlZHJhdyB8fFxuXHRcdFx0YXhpcy51c2VyTWluICE9PSBheGlzLm9sZFVzZXJNaW4gfHwgYXhpcy51c2VyTWF4ICE9PSBheGlzLm9sZFVzZXJNYXgpIHtcblxuXHRcdFx0aWYgKGF4aXMucmVzZXRTdGFja3MpIHtcblx0XHRcdFx0YXhpcy5yZXNldFN0YWNrcygpO1xuXHRcdFx0fVxuXG5cdFx0XHRheGlzLmZvcmNlUmVkcmF3ID0gZmFsc2U7XG5cblx0XHRcdC8vIGdldCBkYXRhIGV4dHJlbWVzIGlmIG5lZWRlZFxuXHRcdFx0YXhpcy5nZXRTZXJpZXNFeHRyZW1lcygpO1xuXG5cdFx0XHQvLyBnZXQgZml4ZWQgcG9zaXRpb25zIGJhc2VkIG9uIHRpY2tJbnRlcnZhbFxuXHRcdFx0YXhpcy5zZXRUaWNrSW50ZXJ2YWwoKTtcblxuXHRcdFx0Ly8gcmVjb3JkIG9sZCB2YWx1ZXMgdG8gZGVjaWRlIHdoZXRoZXIgYSByZXNjYWxlIGlzIG5lY2Vzc2FyeSBsYXRlciBvbiAoIzU0MClcblx0XHRcdGF4aXMub2xkVXNlck1pbiA9IGF4aXMudXNlck1pbjtcblx0XHRcdGF4aXMub2xkVXNlck1heCA9IGF4aXMudXNlck1heDtcblxuXHRcdFx0Ly8gTWFyayBhcyBkaXJ0eSBpZiBpdCBpcyBub3QgYWxyZWFkeSBzZXQgdG8gZGlydHkgYW5kIGV4dHJlbWVzIGhhdmUgY2hhbmdlZC4gIzU5NS5cblx0XHRcdGlmICghYXhpcy5pc0RpcnR5KSB7XG5cdFx0XHRcdGF4aXMuaXNEaXJ0eSA9IGlzRGlydHlBeGlzTGVuZ3RoIHx8IGF4aXMubWluICE9PSBheGlzLm9sZE1pbiB8fCBheGlzLm1heCAhPT0gYXhpcy5vbGRNYXg7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChheGlzLmNsZWFuU3RhY2tzKSB7XG5cdFx0XHRheGlzLmNsZWFuU3RhY2tzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGV4dHJlbWVzIGFuZCBvcHRpb25hbGx5IHJlZHJhd1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbmV3TWluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBuZXdNYXhcblx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXdcblx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0ICogICAgY29uZmlndXJhdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRBcmd1bWVudHNcblx0ICpcblx0ICovXG5cdHNldEV4dHJlbWVzOiBmdW5jdGlvbiAobmV3TWluLCBuZXdNYXgsIHJlZHJhdywgYW5pbWF0aW9uLCBldmVudEFyZ3VtZW50cykge1xuXHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydDtcblxuXHRcdHJlZHJhdyA9IHBpY2socmVkcmF3LCB0cnVlKTsgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuXG5cdFx0ZWFjaChheGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllKSB7XG5cdFx0XHRkZWxldGUgc2VyaWUua2RUcmVlO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRXh0ZW5kIHRoZSBhcmd1bWVudHMgd2l0aCBtaW4gYW5kIG1heFxuXHRcdGV2ZW50QXJndW1lbnRzID0gZXh0ZW5kKGV2ZW50QXJndW1lbnRzLCB7XG5cdFx0XHRtaW46IG5ld01pbixcblx0XHRcdG1heDogbmV3TWF4XG5cdFx0fSk7XG5cblx0XHQvLyBGaXJlIHRoZSBldmVudFxuXHRcdGZpcmVFdmVudChheGlzLCAnc2V0RXh0cmVtZXMnLCBldmVudEFyZ3VtZW50cywgZnVuY3Rpb24gKCkgeyAvLyB0aGUgZGVmYXVsdCBldmVudCBoYW5kbGVyXG5cblx0XHRcdGF4aXMudXNlck1pbiA9IG5ld01pbjtcblx0XHRcdGF4aXMudXNlck1heCA9IG5ld01heDtcblx0XHRcdGF4aXMuZXZlbnRBcmdzID0gZXZlbnRBcmd1bWVudHM7XG5cblx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0Y2hhcnQucmVkcmF3KGFuaW1hdGlvbik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE92ZXJyaWRhYmxlIG1ldGhvZCBmb3Igem9vbWluZyBjaGFydC4gUHVsbGVkIG91dCBpbiBhIHNlcGFyYXRlIG1ldGhvZCB0byBhbGxvdyBvdmVycmlkaW5nXG5cdCAqIGluIHN0b2NrIGNoYXJ0cy5cblx0ICovXG5cdHpvb206IGZ1bmN0aW9uIChuZXdNaW4sIG5ld01heCkge1xuXHRcdHZhciBkYXRhTWluID0gdGhpcy5kYXRhTWluLFxuXHRcdFx0ZGF0YU1heCA9IHRoaXMuZGF0YU1heCxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRtaW4gPSBtYXRoTWluKGRhdGFNaW4sIHBpY2sob3B0aW9ucy5taW4sIGRhdGFNaW4pKSxcblx0XHRcdG1heCA9IG1hdGhNYXgoZGF0YU1heCwgcGljayhvcHRpb25zLm1heCwgZGF0YU1heCkpO1xuXG5cdFx0Ly8gUHJldmVudCBwaW5jaCB6b29taW5nIG91dCBvZiByYW5nZS4gQ2hlY2sgZm9yIGRlZmluZWQgaXMgZm9yICMxOTQ2LiAjMTczNC5cblx0XHRpZiAoIXRoaXMuYWxsb3dab29tT3V0c2lkZSkge1xuXHRcdFx0aWYgKGRlZmluZWQoZGF0YU1pbikgJiYgbmV3TWluIDw9IG1pbikge1xuXHRcdFx0XHRuZXdNaW4gPSBtaW47XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGVmaW5lZChkYXRhTWF4KSAmJiBuZXdNYXggPj0gbWF4KSB7XG5cdFx0XHRcdG5ld01heCA9IG1heDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJbiBmdWxsIHZpZXcsIGRpc3BsYXlpbmcgdGhlIHJlc2V0IHpvb20gYnV0dG9uIGlzIG5vdCByZXF1aXJlZFxuXHRcdHRoaXMuZGlzcGxheUJ0biA9IG5ld01pbiAhPT0gVU5ERUZJTkVEIHx8IG5ld01heCAhPT0gVU5ERUZJTkVEO1xuXG5cdFx0Ly8gRG8gaXRcblx0XHR0aGlzLnNldEV4dHJlbWVzKFxuXHRcdFx0bmV3TWluLFxuXHRcdFx0bmV3TWF4LFxuXHRcdFx0ZmFsc2UsXG5cdFx0XHRVTkRFRklORUQsXG5cdFx0XHR7IHRyaWdnZXI6ICd6b29tJyB9XG5cdFx0KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBheGlzIG1ldHJpY3Ncblx0ICovXG5cdHNldEF4aXNTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRvZmZzZXRMZWZ0ID0gb3B0aW9ucy5vZmZzZXRMZWZ0IHx8IDAsXG5cdFx0XHRvZmZzZXRSaWdodCA9IG9wdGlvbnMub2Zmc2V0UmlnaHQgfHwgMCxcblx0XHRcdGhvcml6ID0gdGhpcy5ob3Jpeixcblx0XHRcdHdpZHRoID0gcGljayhvcHRpb25zLndpZHRoLCBjaGFydC5wbG90V2lkdGggLSBvZmZzZXRMZWZ0ICsgb2Zmc2V0UmlnaHQpLFxuXHRcdFx0aGVpZ2h0ID0gcGljayhvcHRpb25zLmhlaWdodCwgY2hhcnQucGxvdEhlaWdodCksXG5cdFx0XHR0b3AgPSBwaWNrKG9wdGlvbnMudG9wLCBjaGFydC5wbG90VG9wKSxcblx0XHRcdGxlZnQgPSBwaWNrKG9wdGlvbnMubGVmdCwgY2hhcnQucGxvdExlZnQgKyBvZmZzZXRMZWZ0KSxcblx0XHRcdHBlcmNlbnRSZWdleCA9IC8lJC87XG5cblx0XHQvLyBDaGVjayBmb3IgcGVyY2VudGFnZSBiYXNlZCBpbnB1dCB2YWx1ZXNcblx0XHRpZiAocGVyY2VudFJlZ2V4LnRlc3QoaGVpZ2h0KSkge1xuXHRcdFx0aGVpZ2h0ID0gcGFyc2VGbG9hdChoZWlnaHQpIC8gMTAwICogY2hhcnQucGxvdEhlaWdodDtcblx0XHR9XG5cdFx0aWYgKHBlcmNlbnRSZWdleC50ZXN0KHRvcCkpIHtcblx0XHRcdHRvcCA9IHBhcnNlRmxvYXQodG9wKSAvIDEwMCAqIGNoYXJ0LnBsb3RIZWlnaHQgKyBjaGFydC5wbG90VG9wO1xuXHRcdH1cblxuXHRcdC8vIEV4cG9zZSBiYXNpYyB2YWx1ZXMgdG8gdXNlIGluIFNlcmllcyBvYmplY3QgYW5kIG5hdmlnYXRvclxuXHRcdHRoaXMubGVmdCA9IGxlZnQ7XG5cdFx0dGhpcy50b3AgPSB0b3A7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMuYm90dG9tID0gY2hhcnQuY2hhcnRIZWlnaHQgLSBoZWlnaHQgLSB0b3A7XG5cdFx0dGhpcy5yaWdodCA9IGNoYXJ0LmNoYXJ0V2lkdGggLSB3aWR0aCAtIGxlZnQ7XG5cblx0XHQvLyBEaXJlY3Rpb24gYWdub3N0aWMgcHJvcGVydGllc1xuXHRcdHRoaXMubGVuID0gbWF0aE1heChob3JpeiA/IHdpZHRoIDogaGVpZ2h0LCAwKTsgLy8gbWF0aE1heCBmaXhlcyAjOTA1XG5cdFx0dGhpcy5wb3MgPSBob3JpeiA/IGxlZnQgOiB0b3A7IC8vIGRpc3RhbmNlIGZyb20gU1ZHIG9yaWdpblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGFjdHVhbCBheGlzIGV4dHJlbWVzXG5cdCAqL1xuXHRnZXRFeHRyZW1lczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdGlzTG9nID0gYXhpcy5pc0xvZztcblxuXHRcdHJldHVybiB7XG5cdFx0XHRtaW46IGlzTG9nID8gY29ycmVjdEZsb2F0KGxpbjJsb2coYXhpcy5taW4pKSA6IGF4aXMubWluLFxuXHRcdFx0bWF4OiBpc0xvZyA/IGNvcnJlY3RGbG9hdChsaW4ybG9nKGF4aXMubWF4KSkgOiBheGlzLm1heCxcblx0XHRcdGRhdGFNaW46IGF4aXMuZGF0YU1pbixcblx0XHRcdGRhdGFNYXg6IGF4aXMuZGF0YU1heCxcblx0XHRcdHVzZXJNaW46IGF4aXMudXNlck1pbixcblx0XHRcdHVzZXJNYXg6IGF4aXMudXNlck1heFxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgemVybyBwbGFuZSBlaXRoZXIgYmFzZWQgb24gemVybyBvciBvbiB0aGUgbWluIG9yIG1heCB2YWx1ZS5cblx0ICogVXNlZCBpbiBiYXIgYW5kIGFyZWEgcGxvdHNcblx0ICovXG5cdGdldFRocmVzaG9sZDogZnVuY3Rpb24gKHRocmVzaG9sZCkge1xuXHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdGlzTG9nID0gYXhpcy5pc0xvZyxcblx0XHRcdHJlYWxNaW4gPSBpc0xvZyA/IGxpbjJsb2coYXhpcy5taW4pIDogYXhpcy5taW4sXG5cdFx0XHRyZWFsTWF4ID0gaXNMb2cgPyBsaW4ybG9nKGF4aXMubWF4KSA6IGF4aXMubWF4O1xuXG5cdFx0Ly8gV2l0aCBhIHRocmVzaG9sZCBvZiBudWxsLCBtYWtlIHRoZSBjb2x1bW5zL2FyZWFzIHJpc2UgZnJvbSB0aGUgdG9wIG9yIGJvdHRvbSBcblx0XHQvLyBkZXBlbmRpbmcgb24gdGhlIHZhbHVlLCBhc3N1bWluZyBhbiBhY3R1YWwgdGhyZXNob2xkIG9mIDAgKCM0MjMzKS5cblx0XHRpZiAodGhyZXNob2xkID09PSBudWxsKSB7XG5cdFx0XHR0aHJlc2hvbGQgPSByZWFsTWF4IDwgMCA/IHJlYWxNYXggOiByZWFsTWluO1xuXHRcdH0gZWxzZSBpZiAocmVhbE1pbiA+IHRocmVzaG9sZCkge1xuXHRcdFx0dGhyZXNob2xkID0gcmVhbE1pbjtcblx0XHR9IGVsc2UgaWYgKHJlYWxNYXggPCB0aHJlc2hvbGQpIHtcblx0XHRcdHRocmVzaG9sZCA9IHJlYWxNYXg7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGF4aXMudHJhbnNsYXRlKHRocmVzaG9sZCwgMCwgMSwgMCwgMSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENvbXB1dGUgYXV0byBhbGlnbm1lbnQgZm9yIHRoZSBheGlzIGxhYmVsIGJhc2VkIG9uIHdoaWNoIHNpZGUgdGhlIGF4aXMgaXMgb25cblx0ICogYW5kIHRoZSBnaXZlbiByb3RhdGlvbiBmb3IgdGhlIGxhYmVsXG5cdCAqL1xuXHRhdXRvTGFiZWxBbGlnbjogZnVuY3Rpb24gKHJvdGF0aW9uKSB7XG5cdFx0dmFyIHJldCxcblx0XHRcdGFuZ2xlID0gKHBpY2socm90YXRpb24sIDApIC0gKHRoaXMuc2lkZSAqIDkwKSArIDcyMCkgJSAzNjA7XG5cblx0XHRpZiAoYW5nbGUgPiAxNSAmJiBhbmdsZSA8IDE2NSkge1xuXHRcdFx0cmV0ID0gJ3JpZ2h0Jztcblx0XHR9IGVsc2UgaWYgKGFuZ2xlID4gMTk1ICYmIGFuZ2xlIDwgMzQ1KSB7XG5cdFx0XHRyZXQgPSAnbGVmdCc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldCA9ICdjZW50ZXInO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQcmV2ZW50IHRoZSB0aWNrcyBmcm9tIGdldHRpbmcgc28gY2xvc2Ugd2UgY2FuJ3QgZHJhdyB0aGUgbGFiZWxzLiBPbiBhIGhvcml6b250YWxcblx0ICogYXhpcywgdGhpcyBpcyBoYW5kbGVkIGJ5IHJvdGF0aW5nIHRoZSBsYWJlbHMsIHJlbW92aW5nIHRpY2tzIGFuZCBhZGRpbmcgZWxsaXBzaXMuIFxuXHQgKiBPbiBhIHZlcnRpY2FsIGF4aXMgcmVtb3ZlIHRpY2tzIGFuZCBhZGQgZWxsaXBzaXMuXG5cdCAqL1xuXHR1bnNxdWlzaDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHR0aWNrcyA9IHRoaXMudGlja3MsXG5cdFx0XHRsYWJlbE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMubGFiZWxzLFxuXHRcdFx0aG9yaXogPSB0aGlzLmhvcml6LFxuXHRcdFx0dGlja0ludGVydmFsID0gdGhpcy50aWNrSW50ZXJ2YWwsXG5cdFx0XHRuZXdUaWNrSW50ZXJ2YWwgPSB0aWNrSW50ZXJ2YWwsXG5cdFx0XHRzbG90U2l6ZSA9IHRoaXMubGVuIC8gKCgodGhpcy5jYXRlZ29yaWVzID8gMSA6IDApICsgdGhpcy5tYXggLSB0aGlzLm1pbikgLyB0aWNrSW50ZXJ2YWwpLFxuXHRcdFx0cm90YXRpb24sXG5cdFx0XHRyb3RhdGlvbk9wdGlvbiA9IGxhYmVsT3B0aW9ucy5yb3RhdGlvbixcblx0XHRcdGxhYmVsTWV0cmljcyA9IGNoYXJ0LnJlbmRlcmVyLmZvbnRNZXRyaWNzKGxhYmVsT3B0aW9ucy5zdHlsZS5mb250U2l6ZSwgdGlja3NbMF0gJiYgdGlja3NbMF0ubGFiZWwpLFxuXHRcdFx0c3RlcCxcblx0XHRcdGJlc3RTY29yZSA9IE51bWJlci5NQVhfVkFMVUUsXG5cdFx0XHRhdXRvUm90YXRpb24sXG5cdFx0XHQvLyBSZXR1cm4gdGhlIG11bHRpcGxlIG9mIHRpY2tJbnRlcnZhbCB0aGF0IGlzIG5lZWRlZCB0byBhdm9pZCBjb2xsaXNpb25cblx0XHRcdGdldFN0ZXAgPSBmdW5jdGlvbiAoc3BhY2VOZWVkZWQpIHtcblx0XHRcdFx0dmFyIHN0ZXAgPSBzcGFjZU5lZWRlZCAvIChzbG90U2l6ZSB8fCAxKTtcblx0XHRcdFx0c3RlcCA9IHN0ZXAgPiAxID8gbWF0aENlaWwoc3RlcCkgOiAxO1xuXHRcdFx0XHRyZXR1cm4gc3RlcCAqIHRpY2tJbnRlcnZhbDtcblx0XHRcdH07XG5cdFx0XG5cdFx0aWYgKGhvcml6KSB7XG5cdFx0XHRhdXRvUm90YXRpb24gPSAhbGFiZWxPcHRpb25zLnN0YWdnZXJMaW5lcyAmJiAhbGFiZWxPcHRpb25zLnN0ZXAgJiYgKCAvLyAjMzk3MVxuXHRcdFx0XHRkZWZpbmVkKHJvdGF0aW9uT3B0aW9uKSA/IFxuXHRcdFx0XHRcdFtyb3RhdGlvbk9wdGlvbl0gOlxuXHRcdFx0XHRcdHNsb3RTaXplIDwgcGljayhsYWJlbE9wdGlvbnMuYXV0b1JvdGF0aW9uTGltaXQsIDgwKSAmJiBsYWJlbE9wdGlvbnMuYXV0b1JvdGF0aW9uXG5cdFx0XHQpO1xuXG5cdFx0XHRpZiAoYXV0b1JvdGF0aW9uKSB7XG5cblx0XHRcdFx0Ly8gTG9vcCBvdmVyIHRoZSBnaXZlbiBhdXRvUm90YXRpb24gb3B0aW9ucywgYW5kIGRldGVybWluZSB3aGljaCBnaXZlcyB0aGUgYmVzdCBzY29yZS4gVGhlIFxuXHRcdFx0XHQvLyBiZXN0IHNjb3JlIGlzIHRoYXQgd2l0aCB0aGUgbG93ZXN0IG51bWJlciBvZiBzdGVwcyBhbmQgYSByb3RhdGlvbiBjbG9zZXN0IHRvIGhvcml6b250YWwuXG5cdFx0XHRcdGVhY2goYXV0b1JvdGF0aW9uLCBmdW5jdGlvbiAocm90KSB7XG5cdFx0XHRcdFx0dmFyIHNjb3JlO1xuXG5cdFx0XHRcdFx0aWYgKHJvdCA9PT0gcm90YXRpb25PcHRpb24gfHwgKHJvdCAmJiByb3QgPj0gLTkwICYmIHJvdCA8PSA5MCkpIHsgLy8gIzM4OTFcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHN0ZXAgPSBnZXRTdGVwKG1hdGhBYnMobGFiZWxNZXRyaWNzLmggLyBtYXRoU2luKGRlZzJyYWQgKiByb3QpKSk7XG5cblx0XHRcdFx0XHRcdHNjb3JlID0gc3RlcCArIG1hdGhBYnMocm90IC8gMzYwKTtcblxuXHRcdFx0XHRcdFx0aWYgKHNjb3JlIDwgYmVzdFNjb3JlKSB7XG5cdFx0XHRcdFx0XHRcdGJlc3RTY29yZSA9IHNjb3JlO1xuXHRcdFx0XHRcdFx0XHRyb3RhdGlvbiA9IHJvdDtcblx0XHRcdFx0XHRcdFx0bmV3VGlja0ludGVydmFsID0gc3RlcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICghbGFiZWxPcHRpb25zLnN0ZXApIHsgLy8gIzQ0MTFcblx0XHRcdG5ld1RpY2tJbnRlcnZhbCA9IGdldFN0ZXAobGFiZWxNZXRyaWNzLmgpO1xuXHRcdH1cblxuXHRcdHRoaXMuYXV0b1JvdGF0aW9uID0gYXV0b1JvdGF0aW9uO1xuXHRcdHRoaXMubGFiZWxSb3RhdGlvbiA9IHBpY2socm90YXRpb24sIHJvdGF0aW9uT3B0aW9uKTtcblxuXHRcdHJldHVybiBuZXdUaWNrSW50ZXJ2YWw7XG5cdH0sXG5cblx0cmVuZGVyVW5zcXVpc2g6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdHRpY2tQb3NpdGlvbnMgPSB0aGlzLnRpY2tQb3NpdGlvbnMsXG5cdFx0XHR0aWNrcyA9IHRoaXMudGlja3MsXG5cdFx0XHRsYWJlbE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMubGFiZWxzLFxuXHRcdFx0aG9yaXogPSB0aGlzLmhvcml6LFxuXHRcdFx0bWFyZ2luID0gY2hhcnQubWFyZ2luLFxuXHRcdFx0c2xvdENvdW50ID0gdGhpcy5jYXRlZ29yaWVzID8gdGlja1Bvc2l0aW9ucy5sZW5ndGggOiB0aWNrUG9zaXRpb25zLmxlbmd0aCAtIDEsXG5cdFx0XHRzbG90V2lkdGggPSB0aGlzLnNsb3RXaWR0aCA9IChob3JpeiAmJiAhbGFiZWxPcHRpb25zLnN0ZXAgJiYgIWxhYmVsT3B0aW9ucy5yb3RhdGlvbiAmJlxuXHRcdFx0XHQoKHRoaXMuc3RhZ2dlckxpbmVzIHx8IDEpICogY2hhcnQucGxvdFdpZHRoKSAvIHNsb3RDb3VudCkgfHxcblx0XHRcdFx0KCFob3JpeiAmJiAoKG1hcmdpblszXSAmJiAobWFyZ2luWzNdIC0gY2hhcnQuc3BhY2luZ1szXSkpIHx8IGNoYXJ0LmNoYXJ0V2lkdGggKiAwLjMzKSksIC8vICMxNTgwLCAjMTkzMSxcblx0XHRcdGlubmVyV2lkdGggPSBtYXRoTWF4KDEsIG1hdGhSb3VuZChzbG90V2lkdGggLSAyICogKGxhYmVsT3B0aW9ucy5wYWRkaW5nIHx8IDUpKSksXG5cdFx0XHRhdHRyID0ge30sXG5cdFx0XHRsYWJlbE1ldHJpY3MgPSByZW5kZXJlci5mb250TWV0cmljcyhsYWJlbE9wdGlvbnMuc3R5bGUuZm9udFNpemUsIHRpY2tzWzBdICYmIHRpY2tzWzBdLmxhYmVsKSxcblx0XHRcdHRleHRPdmVyZmxvd09wdGlvbiA9IGxhYmVsT3B0aW9ucy5zdHlsZS50ZXh0T3ZlcmZsb3csXG5cdFx0XHRjc3MsXG5cdFx0XHRsYWJlbExlbmd0aCA9IDAsXG5cdFx0XHRsYWJlbCxcblx0XHRcdGksXG5cdFx0XHRwb3M7XG5cblx0XHQvLyBTZXQgcm90YXRpb24gb3B0aW9uIHVubGVzcyBpdCBpcyBcImF1dG9cIiwgbGlrZSBpbiBnYXVnZXNcblx0XHRpZiAoIWlzU3RyaW5nKGxhYmVsT3B0aW9ucy5yb3RhdGlvbikpIHtcblx0XHRcdGF0dHIucm90YXRpb24gPSBsYWJlbE9wdGlvbnMucm90YXRpb24gfHwgMDsgLy8gIzQ0NDNcblx0XHR9XG5cdFx0XG5cdFx0Ly8gSGFuZGxlIGF1dG8gcm90YXRpb24gb24gaG9yaXpvbnRhbCBheGlzXG5cdFx0aWYgKHRoaXMuYXV0b1JvdGF0aW9uKSB7XG5cblx0XHRcdC8vIEdldCB0aGUgbG9uZ2VzdCBsYWJlbCBsZW5ndGhcblx0XHRcdGVhY2godGlja1Bvc2l0aW9ucywgZnVuY3Rpb24gKHRpY2spIHtcblx0XHRcdFx0dGljayA9IHRpY2tzW3RpY2tdO1xuXHRcdFx0XHRpZiAodGljayAmJiB0aWNrLmxhYmVsTGVuZ3RoID4gbGFiZWxMZW5ndGgpIHtcblx0XHRcdFx0XHRsYWJlbExlbmd0aCA9IHRpY2subGFiZWxMZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHQvLyBBcHBseSByb3RhdGlvbiBvbmx5IGlmIHRoZSBsYWJlbCBpcyB0b28gd2lkZSBmb3IgdGhlIHNsb3QsIGFuZFxuXHRcdFx0Ly8gdGhlIGxhYmVsIGlzIHdpZGVyIHRoYW4gaXRzIGhlaWdodC5cblx0XHRcdGlmIChsYWJlbExlbmd0aCA+IGlubmVyV2lkdGggJiYgbGFiZWxMZW5ndGggPiBsYWJlbE1ldHJpY3MuaCkge1xuXHRcdFx0XHRhdHRyLnJvdGF0aW9uID0gdGhpcy5sYWJlbFJvdGF0aW9uO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5sYWJlbFJvdGF0aW9uID0gMDtcblx0XHRcdH1cblxuXHRcdC8vIEhhbmRsZSB3b3JkLXdyYXAgb3IgZWxsaXBzaXMgb24gdmVydGljYWwgYXhpc1xuXHRcdH0gZWxzZSBpZiAoc2xvdFdpZHRoKSB7XG5cdFx0XHQvLyBGb3Igd29yZC13cmFwIG9yIGVsbGlwc2lzXG5cdFx0XHRjc3MgPSB7IHdpZHRoOiBpbm5lcldpZHRoICsgUFggfTtcblxuXHRcdFx0aWYgKCF0ZXh0T3ZlcmZsb3dPcHRpb24pIHtcblx0XHRcdFx0Y3NzLnRleHRPdmVyZmxvdyA9ICdjbGlwJztcblxuXHRcdFx0XHQvLyBPbiB2ZXJ0aWNhbCBheGlzLCBvbmx5IGFsbG93IHdvcmQgd3JhcCBpZiB0aGVyZSBpcyByb29tIGZvciBtb3JlIGxpbmVzLlxuXHRcdFx0XHRpID0gdGlja1Bvc2l0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICghaG9yaXogJiYgaS0tKSB7XG5cdFx0XHRcdFx0cG9zID0gdGlja1Bvc2l0aW9uc1tpXTtcblx0XHRcdFx0XHRsYWJlbCA9IHRpY2tzW3Bvc10ubGFiZWw7XG5cdFx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0XHQvLyBSZXNldCBlbGxpcHNpcyBpbiBvcmRlciB0byBnZXQgdGhlIGNvcnJlY3QgYm91bmRpbmcgYm94ICgjNDA3MClcblx0XHRcdFx0XHRcdGlmIChsYWJlbC5zdHlsZXMudGV4dE92ZXJmbG93ID09PSAnZWxsaXBzaXMnKSB7XG5cdFx0XHRcdFx0XHRcdGxhYmVsLmNzcyh7IHRleHRPdmVyZmxvdzogJ2NsaXAnIH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGxhYmVsLmdldEJCb3goKS5oZWlnaHQgPiB0aGlzLmxlbiAvIHRpY2tQb3NpdGlvbnMubGVuZ3RoIC0gKGxhYmVsTWV0cmljcy5oIC0gbGFiZWxNZXRyaWNzLmYpKSB7XG5cdFx0XHRcdFx0XHRcdGxhYmVsLnNwZWNDc3MgPSB7IHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyB9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0Ly8gQWRkIGVsbGlwc2lzIGlmIHRoZSBsYWJlbCBsZW5ndGggaXMgc2lnbmlmaWNhbnRseSBsb25nZXIgdGhhbiBpZGVhbFxuXHRcdGlmIChhdHRyLnJvdGF0aW9uKSB7XG5cdFx0XHRjc3MgPSB7IFxuXHRcdFx0XHR3aWR0aDogKGxhYmVsTGVuZ3RoID4gY2hhcnQuY2hhcnRIZWlnaHQgKiAwLjUgPyBjaGFydC5jaGFydEhlaWdodCAqIDAuMzMgOiBjaGFydC5jaGFydEhlaWdodCkgKyBQWFxuXHRcdFx0fTtcblx0XHRcdGlmICghdGV4dE92ZXJmbG93T3B0aW9uKSB7XG5cdFx0XHRcdGNzcy50ZXh0T3ZlcmZsb3cgPSAnZWxsaXBzaXMnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgZXhwbGljaXQgb3IgYXV0b21hdGljIGxhYmVsIGFsaWdubWVudFxuXHRcdHRoaXMubGFiZWxBbGlnbiA9IGF0dHIuYWxpZ24gPSBsYWJlbE9wdGlvbnMuYWxpZ24gfHwgdGhpcy5hdXRvTGFiZWxBbGlnbih0aGlzLmxhYmVsUm90YXRpb24pO1xuXG5cdFx0Ly8gQXBwbHkgZ2VuZXJhbCBhbmQgc3BlY2lmaWMgQ1NTXG5cdFx0ZWFjaCh0aWNrUG9zaXRpb25zLCBmdW5jdGlvbiAocG9zKSB7XG5cdFx0XHR2YXIgdGljayA9IHRpY2tzW3Bvc10sXG5cdFx0XHRcdGxhYmVsID0gdGljayAmJiB0aWNrLmxhYmVsO1xuXHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdGxhYmVsLmF0dHIoYXR0cik7IC8vIFRoaXMgbmVlZHMgdG8gZ28gYmVmb3JlIHRoZSBDU1MgaW4gb2xkIElFICgjNDUwMilcblx0XHRcdFx0aWYgKGNzcykge1xuXHRcdFx0XHRcdGxhYmVsLmNzcyhtZXJnZShjc3MsIGxhYmVsLnNwZWNDc3MpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgbGFiZWwuc3BlY0Nzcztcblx0XHRcdFx0dGljay5yb3RhdGlvbiA9IGF0dHIucm90YXRpb247XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBUT0RPOiBXaHkgbm90IHBhcnQgb2YgZ2V0TGFiZWxQb3NpdGlvbj9cblx0XHR0aGlzLnRpY2tSb3RDb3JyID0gcmVuZGVyZXIucm90Q29ycihsYWJlbE1ldHJpY3MuYiwgdGhpcy5sYWJlbFJvdGF0aW9uIHx8IDAsIHRoaXMuc2lkZSA9PT0gMik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybiB0cnVlIGlmIHRoZSBheGlzIGhhcyBhc3NvY2lhdGVkIGRhdGFcblx0ICovXG5cdGhhc0RhdGE6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5oYXNWaXNpYmxlU2VyaWVzIHx8IChkZWZpbmVkKHRoaXMubWluKSAmJiBkZWZpbmVkKHRoaXMubWF4KSAmJiAhIXRoaXMudGlja1Bvc2l0aW9ucyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbmRlciB0aGUgdGljayBsYWJlbHMgdG8gYSBwcmVsaW1pbmFyeSBwb3NpdGlvbiB0byBnZXQgdGhlaXIgc2l6ZXNcblx0ICovXG5cdGdldE9mZnNldDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0dGlja1Bvc2l0aW9ucyA9IGF4aXMudGlja1Bvc2l0aW9ucyxcblx0XHRcdHRpY2tzID0gYXhpcy50aWNrcyxcblx0XHRcdGhvcml6ID0gYXhpcy5ob3Jpeixcblx0XHRcdHNpZGUgPSBheGlzLnNpZGUsXG5cdFx0XHRpbnZlcnRlZFNpZGUgPSBjaGFydC5pbnZlcnRlZCA/IFsxLCAwLCAzLCAyXVtzaWRlXSA6IHNpZGUsXG5cdFx0XHRoYXNEYXRhLFxuXHRcdFx0c2hvd0F4aXMsXG5cdFx0XHR0aXRsZU9mZnNldCA9IDAsXG5cdFx0XHR0aXRsZU9mZnNldE9wdGlvbixcblx0XHRcdHRpdGxlTWFyZ2luID0gMCxcblx0XHRcdGF4aXNUaXRsZU9wdGlvbnMgPSBvcHRpb25zLnRpdGxlLFxuXHRcdFx0bGFiZWxPcHRpb25zID0gb3B0aW9ucy5sYWJlbHMsXG5cdFx0XHRsYWJlbE9mZnNldCA9IDAsIC8vIHJlc2V0XG5cdFx0XHRsYWJlbE9mZnNldFBhZGRlZCxcblx0XHRcdGF4aXNPZmZzZXQgPSBjaGFydC5heGlzT2Zmc2V0LFxuXHRcdFx0Y2xpcE9mZnNldCA9IGNoYXJ0LmNsaXBPZmZzZXQsXG5cdFx0XHRjbGlwLFxuXHRcdFx0ZGlyZWN0aW9uRmFjdG9yID0gWy0xLCAxLCAxLCAtMV1bc2lkZV0sXG5cdFx0XHRuLFxuXHRcdFx0YXhpc1BhcmVudCA9IGF4aXMuYXhpc1BhcmVudCwgLy8gVXNlZCBpbiBjb2xvciBheGlzXG5cdFx0XHRsaW5lSGVpZ2h0Q29ycmVjdGlvbjtcblxuXHRcdC8vIEZvciByZXVzZSBpbiBBeGlzLnJlbmRlclxuXHRcdGhhc0RhdGEgPSBheGlzLmhhc0RhdGEoKTtcblx0XHRheGlzLnNob3dBeGlzID0gc2hvd0F4aXMgPSBoYXNEYXRhIHx8IHBpY2sob3B0aW9ucy5zaG93RW1wdHksIHRydWUpO1xuXG5cdFx0Ly8gU2V0L3Jlc2V0IHN0YWdnZXJMaW5lc1xuXHRcdGF4aXMuc3RhZ2dlckxpbmVzID0gYXhpcy5ob3JpeiAmJiBsYWJlbE9wdGlvbnMuc3RhZ2dlckxpbmVzO1xuXG5cdFx0Ly8gQ3JlYXRlIHRoZSBheGlzR3JvdXAgYW5kIGdyaWRHcm91cCBlbGVtZW50cyBvbiBmaXJzdCBpdGVyYXRpb25cblx0XHRpZiAoIWF4aXMuYXhpc0dyb3VwKSB7XG5cdFx0XHRheGlzLmdyaWRHcm91cCA9IHJlbmRlcmVyLmcoJ2dyaWQnKVxuXHRcdFx0XHQuYXR0cih7IHpJbmRleDogb3B0aW9ucy5ncmlkWkluZGV4IHx8IDEgfSlcblx0XHRcdFx0LmFkZChheGlzUGFyZW50KTtcblx0XHRcdGF4aXMuYXhpc0dyb3VwID0gcmVuZGVyZXIuZygnYXhpcycpXG5cdFx0XHRcdC5hdHRyKHsgekluZGV4OiBvcHRpb25zLnpJbmRleCB8fCAyIH0pXG5cdFx0XHRcdC5hZGQoYXhpc1BhcmVudCk7XG5cdFx0XHRheGlzLmxhYmVsR3JvdXAgPSByZW5kZXJlci5nKCdheGlzLWxhYmVscycpXG5cdFx0XHRcdC5hdHRyKHsgekluZGV4OiBsYWJlbE9wdGlvbnMuekluZGV4IHx8IDcgfSlcblx0XHRcdFx0LmFkZENsYXNzKFBSRUZJWCArIGF4aXMuY29sbC50b0xvd2VyQ2FzZSgpICsgJy1sYWJlbHMnKVxuXHRcdFx0XHQuYWRkKGF4aXNQYXJlbnQpO1xuXHRcdH1cblxuXHRcdGlmIChoYXNEYXRhIHx8IGF4aXMuaXNMaW5rZWQpIHtcblx0XHRcdFxuXHRcdFx0Ly8gR2VuZXJhdGUgdGlja3Ncblx0XHRcdGVhY2godGlja1Bvc2l0aW9ucywgZnVuY3Rpb24gKHBvcykge1xuXHRcdFx0XHRpZiAoIXRpY2tzW3Bvc10pIHtcblx0XHRcdFx0XHR0aWNrc1twb3NdID0gbmV3IFRpY2soYXhpcywgcG9zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aWNrc1twb3NdLmFkZExhYmVsKCk7IC8vIHVwZGF0ZSBsYWJlbHMgZGVwZW5kaW5nIG9uIHRpY2sgaW50ZXJ2YWxcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGF4aXMucmVuZGVyVW5zcXVpc2goKTtcblxuXHRcdFx0ZWFjaCh0aWNrUG9zaXRpb25zLCBmdW5jdGlvbiAocG9zKSB7XG5cdFx0XHRcdC8vIGxlZnQgc2lkZSBtdXN0IGJlIGFsaWduOiByaWdodCBhbmQgcmlnaHQgc2lkZSBtdXN0IGhhdmUgYWxpZ246IGxlZnQgZm9yIGxhYmVsc1xuXHRcdFx0XHRpZiAoc2lkZSA9PT0gMCB8fCBzaWRlID09PSAyIHx8IHsgMTogJ2xlZnQnLCAzOiAncmlnaHQnIH1bc2lkZV0gPT09IGF4aXMubGFiZWxBbGlnbikge1xuXG5cdFx0XHRcdFx0Ly8gZ2V0IHRoZSBoaWdoZXN0IG9mZnNldFxuXHRcdFx0XHRcdGxhYmVsT2Zmc2V0ID0gbWF0aE1heChcblx0XHRcdFx0XHRcdHRpY2tzW3Bvc10uZ2V0TGFiZWxTaXplKCksXG5cdFx0XHRcdFx0XHRsYWJlbE9mZnNldFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoYXhpcy5zdGFnZ2VyTGluZXMpIHtcblx0XHRcdFx0bGFiZWxPZmZzZXQgKj0gYXhpcy5zdGFnZ2VyTGluZXM7XG5cdFx0XHRcdGF4aXMubGFiZWxPZmZzZXQgPSBsYWJlbE9mZnNldDtcblx0XHRcdH1cblxuXG5cdFx0fSBlbHNlIHsgLy8gZG9lc24ndCBoYXZlIGRhdGFcblx0XHRcdGZvciAobiBpbiB0aWNrcykge1xuXHRcdFx0XHR0aWNrc1tuXS5kZXN0cm95KCk7XG5cdFx0XHRcdGRlbGV0ZSB0aWNrc1tuXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoYXhpc1RpdGxlT3B0aW9ucyAmJiBheGlzVGl0bGVPcHRpb25zLnRleHQgJiYgYXhpc1RpdGxlT3B0aW9ucy5lbmFibGVkICE9PSBmYWxzZSkge1xuXHRcdFx0aWYgKCFheGlzLmF4aXNUaXRsZSkge1xuXHRcdFx0XHRheGlzLmF4aXNUaXRsZSA9IHJlbmRlcmVyLnRleHQoXG5cdFx0XHRcdFx0YXhpc1RpdGxlT3B0aW9ucy50ZXh0LFxuXHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRheGlzVGl0bGVPcHRpb25zLnVzZUhUTUxcblx0XHRcdFx0KVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0ekluZGV4OiA3LFxuXHRcdFx0XHRcdHJvdGF0aW9uOiBheGlzVGl0bGVPcHRpb25zLnJvdGF0aW9uIHx8IDAsXG5cdFx0XHRcdFx0YWxpZ246XG5cdFx0XHRcdFx0XHRheGlzVGl0bGVPcHRpb25zLnRleHRBbGlnbiB8fFxuXHRcdFx0XHRcdFx0eyBsb3c6ICdsZWZ0JywgbWlkZGxlOiAnY2VudGVyJywgaGlnaDogJ3JpZ2h0JyB9W2F4aXNUaXRsZU9wdGlvbnMuYWxpZ25dXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGRDbGFzcyhQUkVGSVggKyB0aGlzLmNvbGwudG9Mb3dlckNhc2UoKSArICctdGl0bGUnKVxuXHRcdFx0XHQuY3NzKGF4aXNUaXRsZU9wdGlvbnMuc3R5bGUpXG5cdFx0XHRcdC5hZGQoYXhpcy5heGlzR3JvdXApO1xuXHRcdFx0XHRheGlzLmF4aXNUaXRsZS5pc05ldyA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzaG93QXhpcykge1xuXHRcdFx0XHR0aXRsZU9mZnNldCA9IGF4aXMuYXhpc1RpdGxlLmdldEJCb3goKVtob3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJ107XG5cdFx0XHRcdHRpdGxlT2Zmc2V0T3B0aW9uID0gYXhpc1RpdGxlT3B0aW9ucy5vZmZzZXQ7XG5cdFx0XHRcdHRpdGxlTWFyZ2luID0gZGVmaW5lZCh0aXRsZU9mZnNldE9wdGlvbikgPyAwIDogcGljayhheGlzVGl0bGVPcHRpb25zLm1hcmdpbiwgaG9yaXogPyA1IDogMTApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBoaWRlIG9yIHNob3cgdGhlIHRpdGxlIGRlcGVuZGluZyBvbiB3aGV0aGVyIHNob3dFbXB0eSBpcyBzZXRcblx0XHRcdGF4aXMuYXhpc1RpdGxlW3Nob3dBeGlzID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuXHRcdH1cblxuXHRcdC8vIGhhbmRsZSBhdXRvbWF0aWMgb3IgdXNlciBzZXQgb2Zmc2V0XG5cdFx0YXhpcy5vZmZzZXQgPSBkaXJlY3Rpb25GYWN0b3IgKiBwaWNrKG9wdGlvbnMub2Zmc2V0LCBheGlzT2Zmc2V0W3NpZGVdKTtcblxuXHRcdGF4aXMudGlja1JvdENvcnIgPSBheGlzLnRpY2tSb3RDb3JyIHx8IHsgeDogMCwgeTogMCB9OyAvLyBwb2xhclxuXHRcdGxpbmVIZWlnaHRDb3JyZWN0aW9uID0gc2lkZSA9PT0gMiA/IGF4aXMudGlja1JvdENvcnIueSA6IDA7XG5cdFx0bGFiZWxPZmZzZXRQYWRkZWQgPSBsYWJlbE9mZnNldCArIHRpdGxlTWFyZ2luICtcblx0XHRcdChsYWJlbE9mZnNldCAmJiAoZGlyZWN0aW9uRmFjdG9yICogKGhvcml6ID8gcGljayhsYWJlbE9wdGlvbnMueSwgYXhpcy50aWNrUm90Q29yci55ICsgOCkgOiBsYWJlbE9wdGlvbnMueCkgLSBsaW5lSGVpZ2h0Q29ycmVjdGlvbikpO1xuXHRcdGF4aXMuYXhpc1RpdGxlTWFyZ2luID0gcGljayh0aXRsZU9mZnNldE9wdGlvbiwgbGFiZWxPZmZzZXRQYWRkZWQpO1xuXG5cdFx0YXhpc09mZnNldFtzaWRlXSA9IG1hdGhNYXgoXG5cdFx0XHRheGlzT2Zmc2V0W3NpZGVdLFxuXHRcdFx0YXhpcy5heGlzVGl0bGVNYXJnaW4gKyB0aXRsZU9mZnNldCArIGRpcmVjdGlvbkZhY3RvciAqIGF4aXMub2Zmc2V0LFxuXHRcdFx0bGFiZWxPZmZzZXRQYWRkZWQgLy8gIzMwMjdcblx0XHQpO1xuXG5cdFx0Ly8gRGVjaWRlIHRoZSBjbGlwcGluZyBuZWVkZWQgdG8ga2VlcCB0aGUgZ3JhcGggaW5zaWRlIHRoZSBwbG90IGFyZWEgYW5kIGF4aXMgbGluZXNcblx0XHRjbGlwID0gb3B0aW9ucy5vZmZzZXQgPyAwIDogbWF0aEZsb29yKG9wdGlvbnMubGluZVdpZHRoIC8gMikgKiAyOyAvLyAjNDMwOCwgIzQzNzFcblx0XHRjbGlwT2Zmc2V0W2ludmVydGVkU2lkZV0gPSBtYXRoTWF4KGNsaXBPZmZzZXRbaW52ZXJ0ZWRTaWRlXSwgY2xpcCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgcGF0aCBmb3IgdGhlIGF4aXMgbGluZVxuXHQgKi9cblx0Z2V0TGluZVBhdGg6IGZ1bmN0aW9uIChsaW5lV2lkdGgpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0b3Bwb3NpdGUgPSB0aGlzLm9wcG9zaXRlLFxuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQsXG5cdFx0XHRob3JpeiA9IHRoaXMuaG9yaXosXG5cdFx0XHRsaW5lTGVmdCA9IHRoaXMubGVmdCArIChvcHBvc2l0ZSA/IHRoaXMud2lkdGggOiAwKSArIG9mZnNldCxcblx0XHRcdGxpbmVUb3AgPSBjaGFydC5jaGFydEhlaWdodCAtIHRoaXMuYm90dG9tIC0gKG9wcG9zaXRlID8gdGhpcy5oZWlnaHQgOiAwKSArIG9mZnNldDtcblxuXHRcdGlmIChvcHBvc2l0ZSkge1xuXHRcdFx0bGluZVdpZHRoICo9IC0xOyAvLyBjcmlzcGlmeSB0aGUgb3RoZXIgd2F5IC0gIzE0ODAsICMxNjg3XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNoYXJ0LnJlbmRlcmVyLmNyaXNwTGluZShbXG5cdFx0XHRcdE0sXG5cdFx0XHRcdGhvcml6ID9cblx0XHRcdFx0XHR0aGlzLmxlZnQgOlxuXHRcdFx0XHRcdGxpbmVMZWZ0LFxuXHRcdFx0XHRob3JpeiA/XG5cdFx0XHRcdFx0bGluZVRvcCA6XG5cdFx0XHRcdFx0dGhpcy50b3AsXG5cdFx0XHRcdEwsXG5cdFx0XHRcdGhvcml6ID9cblx0XHRcdFx0XHRjaGFydC5jaGFydFdpZHRoIC0gdGhpcy5yaWdodCA6XG5cdFx0XHRcdFx0bGluZUxlZnQsXG5cdFx0XHRcdGhvcml6ID9cblx0XHRcdFx0XHRsaW5lVG9wIDpcblx0XHRcdFx0XHRjaGFydC5jaGFydEhlaWdodCAtIHRoaXMuYm90dG9tXG5cdFx0XHRdLCBsaW5lV2lkdGgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQb3NpdGlvbiB0aGUgdGl0bGVcblx0ICovXG5cdGdldFRpdGxlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBjb21wdXRlIGFuY2hvciBwb2ludHMgZm9yIGVhY2ggb2YgdGhlIHRpdGxlIGFsaWduIG9wdGlvbnNcblx0XHR2YXIgaG9yaXogPSB0aGlzLmhvcml6LFxuXHRcdFx0YXhpc0xlZnQgPSB0aGlzLmxlZnQsXG5cdFx0XHRheGlzVG9wID0gdGhpcy50b3AsXG5cdFx0XHRheGlzTGVuZ3RoID0gdGhpcy5sZW4sXG5cdFx0XHRheGlzVGl0bGVPcHRpb25zID0gdGhpcy5vcHRpb25zLnRpdGxlLFxuXHRcdFx0bWFyZ2luID0gaG9yaXogPyBheGlzTGVmdCA6IGF4aXNUb3AsXG5cdFx0XHRvcHBvc2l0ZSA9IHRoaXMub3Bwb3NpdGUsXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCxcblx0XHRcdHhPcHRpb24gPSBheGlzVGl0bGVPcHRpb25zLnggfHwgMCxcblx0XHRcdHlPcHRpb24gPSBheGlzVGl0bGVPcHRpb25zLnkgfHwgMCxcblx0XHRcdGZvbnRTaXplID0gcEludChheGlzVGl0bGVPcHRpb25zLnN0eWxlLmZvbnRTaXplIHx8IDEyKSxcblxuXHRcdFx0Ly8gdGhlIHBvc2l0aW9uIGluIHRoZSBsZW5ndGggZGlyZWN0aW9uIG9mIHRoZSBheGlzXG5cdFx0XHRhbG9uZ0F4aXMgPSB7XG5cdFx0XHRcdGxvdzogbWFyZ2luICsgKGhvcml6ID8gMCA6IGF4aXNMZW5ndGgpLFxuXHRcdFx0XHRtaWRkbGU6IG1hcmdpbiArIGF4aXNMZW5ndGggLyAyLFxuXHRcdFx0XHRoaWdoOiBtYXJnaW4gKyAoaG9yaXogPyBheGlzTGVuZ3RoIDogMClcblx0XHRcdH1bYXhpc1RpdGxlT3B0aW9ucy5hbGlnbl0sXG5cblx0XHRcdC8vIHRoZSBwb3NpdGlvbiBpbiB0aGUgcGVycGVuZGljdWxhciBkaXJlY3Rpb24gb2YgdGhlIGF4aXNcblx0XHRcdG9mZkF4aXMgPSAoaG9yaXogPyBheGlzVG9wICsgdGhpcy5oZWlnaHQgOiBheGlzTGVmdCkgK1xuXHRcdFx0XHQoaG9yaXogPyAxIDogLTEpICogLy8gaG9yaXpvbnRhbCBheGlzIHJldmVyc2VzIHRoZSBtYXJnaW5cblx0XHRcdFx0KG9wcG9zaXRlID8gLTEgOiAxKSAqIC8vIHNvIGRvZXMgb3Bwb3NpdGUgYXhlc1xuXHRcdFx0XHR0aGlzLmF4aXNUaXRsZU1hcmdpbiArXG5cdFx0XHRcdCh0aGlzLnNpZGUgPT09IDIgPyBmb250U2l6ZSA6IDApO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IGhvcml6ID9cblx0XHRcdFx0YWxvbmdBeGlzICsgeE9wdGlvbiA6XG5cdFx0XHRcdG9mZkF4aXMgKyAob3Bwb3NpdGUgPyB0aGlzLndpZHRoIDogMCkgKyBvZmZzZXQgKyB4T3B0aW9uLFxuXHRcdFx0eTogaG9yaXogP1xuXHRcdFx0XHRvZmZBeGlzICsgeU9wdGlvbiAtIChvcHBvc2l0ZSA/IHRoaXMuaGVpZ2h0IDogMCkgKyBvZmZzZXQgOlxuXHRcdFx0XHRhbG9uZ0F4aXMgKyB5T3B0aW9uXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogUmVuZGVyIHRoZSBheGlzXG5cdCAqL1xuXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0b3B0aW9ucyA9IGF4aXMub3B0aW9ucyxcblx0XHRcdGlzTG9nID0gYXhpcy5pc0xvZyxcblx0XHRcdGlzTGlua2VkID0gYXhpcy5pc0xpbmtlZCxcblx0XHRcdHRpY2tQb3NpdGlvbnMgPSBheGlzLnRpY2tQb3NpdGlvbnMsXG5cdFx0XHRheGlzVGl0bGUgPSBheGlzLmF4aXNUaXRsZSxcdFx0XHRcblx0XHRcdHRpY2tzID0gYXhpcy50aWNrcyxcblx0XHRcdG1pbm9yVGlja3MgPSBheGlzLm1pbm9yVGlja3MsXG5cdFx0XHRhbHRlcm5hdGVCYW5kcyA9IGF4aXMuYWx0ZXJuYXRlQmFuZHMsXG5cdFx0XHRzdGFja0xhYmVsT3B0aW9ucyA9IG9wdGlvbnMuc3RhY2tMYWJlbHMsXG5cdFx0XHRhbHRlcm5hdGVHcmlkQ29sb3IgPSBvcHRpb25zLmFsdGVybmF0ZUdyaWRDb2xvcixcblx0XHRcdHRpY2ttYXJrT2Zmc2V0ID0gYXhpcy50aWNrbWFya09mZnNldCxcblx0XHRcdGxpbmVXaWR0aCA9IG9wdGlvbnMubGluZVdpZHRoLFxuXHRcdFx0bGluZVBhdGgsXG5cdFx0XHRoYXNSZW5kZXJlZCA9IGNoYXJ0Lmhhc1JlbmRlcmVkLFxuXHRcdFx0c2xpZGVJblRpY2tzID0gaGFzUmVuZGVyZWQgJiYgZGVmaW5lZChheGlzLm9sZE1pbikgJiYgIWlzTmFOKGF4aXMub2xkTWluKSxcblx0XHRcdHNob3dBeGlzID0gYXhpcy5zaG93QXhpcyxcblx0XHRcdGdsb2JhbEFuaW1hdGlvbiA9IHJlbmRlcmVyLmdsb2JhbEFuaW1hdGlvbixcblx0XHRcdGZyb20sXG5cdFx0XHR0bztcblxuXHRcdC8vIFJlc2V0XG5cdFx0YXhpcy5sYWJlbEVkZ2UubGVuZ3RoID0gMDtcblx0XHQvL2F4aXMuanVzdGlmeVRvUGxvdCA9IG92ZXJmbG93ID09PSAnanVzdGlmeSc7XG5cdFx0YXhpcy5vdmVybGFwID0gZmFsc2U7XG5cblx0XHQvLyBNYXJrIGFsbCBlbGVtZW50cyBpbkFjdGl2ZSBiZWZvcmUgd2UgZ28gb3ZlciBhbmQgbWFyayB0aGUgYWN0aXZlIG9uZXNcblx0XHRlYWNoKFt0aWNrcywgbWlub3JUaWNrcywgYWx0ZXJuYXRlQmFuZHNdLCBmdW5jdGlvbiAoY29sbCkge1xuXHRcdFx0dmFyIHBvcztcblx0XHRcdGZvciAocG9zIGluIGNvbGwpIHtcblx0XHRcdFx0Y29sbFtwb3NdLmlzQWN0aXZlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBJZiB0aGUgc2VyaWVzIGhhcyBkYXRhIGRyYXcgdGhlIHRpY2tzLiBFbHNlIG9ubHkgdGhlIGxpbmUgYW5kIHRpdGxlXG5cdFx0aWYgKGF4aXMuaGFzRGF0YSgpIHx8IGlzTGlua2VkKSB7XG5cblx0XHRcdC8vIG1pbm9yIHRpY2tzXG5cdFx0XHRpZiAoYXhpcy5taW5vclRpY2tJbnRlcnZhbCAmJiAhYXhpcy5jYXRlZ29yaWVzKSB7XG5cdFx0XHRcdGVhY2goYXhpcy5nZXRNaW5vclRpY2tQb3NpdGlvbnMoKSwgZnVuY3Rpb24gKHBvcykge1xuXHRcdFx0XHRcdGlmICghbWlub3JUaWNrc1twb3NdKSB7XG5cdFx0XHRcdFx0XHRtaW5vclRpY2tzW3Bvc10gPSBuZXcgVGljayhheGlzLCBwb3MsICdtaW5vcicpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHJlbmRlciBuZXcgdGlja3MgaW4gb2xkIHBvc2l0aW9uXG5cdFx0XHRcdFx0aWYgKHNsaWRlSW5UaWNrcyAmJiBtaW5vclRpY2tzW3Bvc10uaXNOZXcpIHtcblx0XHRcdFx0XHRcdG1pbm9yVGlja3NbcG9zXS5yZW5kZXIobnVsbCwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWlub3JUaWNrc1twb3NdLnJlbmRlcihudWxsLCBmYWxzZSwgMSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWpvciB0aWNrcy4gUHVsbCBvdXQgdGhlIGZpcnN0IGl0ZW0gYW5kIHJlbmRlciBpdCBsYXN0IHNvIHRoYXRcblx0XHRcdC8vIHdlIGNhbiBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBuZWlnaGJvdXIgbGFiZWwuICM4MDguXG5cdFx0XHRpZiAodGlja1Bvc2l0aW9ucy5sZW5ndGgpIHsgLy8gIzEzMDBcblx0XHRcdFx0ZWFjaCh0aWNrUG9zaXRpb25zLCBmdW5jdGlvbiAocG9zLCBpKSB7XG5cblx0XHRcdFx0XHQvLyBsaW5rZWQgYXhlcyBuZWVkIGFuIGV4dHJhIGNoZWNrIHRvIGZpbmQgb3V0IGlmXG5cdFx0XHRcdFx0aWYgKCFpc0xpbmtlZCB8fCAocG9zID49IGF4aXMubWluICYmIHBvcyA8PSBheGlzLm1heCkpIHtcblxuXHRcdFx0XHRcdFx0aWYgKCF0aWNrc1twb3NdKSB7XG5cdFx0XHRcdFx0XHRcdHRpY2tzW3Bvc10gPSBuZXcgVGljayhheGlzLCBwb3MpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyByZW5kZXIgbmV3IHRpY2tzIGluIG9sZCBwb3NpdGlvblxuXHRcdFx0XHRcdFx0aWYgKHNsaWRlSW5UaWNrcyAmJiB0aWNrc1twb3NdLmlzTmV3KSB7XG5cdFx0XHRcdFx0XHRcdHRpY2tzW3Bvc10ucmVuZGVyKGksIHRydWUsIDAuMSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRpY2tzW3Bvc10ucmVuZGVyKGkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gSW4gYSBjYXRlZ29yaXplZCBheGlzLCB0aGUgdGljayBtYXJrcyBhcmUgZGlzcGxheWVkIGJldHdlZW4gbGFiZWxzLiBTb1xuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGFkZCBhIHRpY2sgbWFyayBhbmQgZ3JpZCBsaW5lIGF0IHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIFggYXhpcy5cblx0XHRcdFx0aWYgKHRpY2ttYXJrT2Zmc2V0ICYmIChheGlzLm1pbiA9PT0gMCB8fCBheGlzLnNpbmdsZSkpIHtcblx0XHRcdFx0XHRpZiAoIXRpY2tzWy0xXSkge1xuXHRcdFx0XHRcdFx0dGlja3NbLTFdID0gbmV3IFRpY2soYXhpcywgLTEsIG51bGwsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aWNrc1stMV0ucmVuZGVyKC0xKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGFsdGVybmF0ZSBncmlkIGNvbG9yXG5cdFx0XHRpZiAoYWx0ZXJuYXRlR3JpZENvbG9yKSB7XG5cdFx0XHRcdGVhY2godGlja1Bvc2l0aW9ucywgZnVuY3Rpb24gKHBvcywgaSkge1xuXHRcdFx0XHRcdHRvID0gdGlja1Bvc2l0aW9uc1tpICsgMV0gIT09IFVOREVGSU5FRCA/IHRpY2tQb3NpdGlvbnNbaSArIDFdICsgdGlja21hcmtPZmZzZXQgOiBheGlzLm1heCAtIHRpY2ttYXJrT2Zmc2V0OyBcblx0XHRcdFx0XHRpZiAoaSAlIDIgPT09IDAgJiYgcG9zIDwgYXhpcy5tYXggJiYgdG8gPD0gYXhpcy5tYXggLSB0aWNrbWFya09mZnNldCkgeyAvLyAjMjI0OFxuXHRcdFx0XHRcdFx0aWYgKCFhbHRlcm5hdGVCYW5kc1twb3NdKSB7XG5cdFx0XHRcdFx0XHRcdGFsdGVybmF0ZUJhbmRzW3Bvc10gPSBuZXcgSGlnaGNoYXJ0cy5QbG90TGluZU9yQmFuZChheGlzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZyb20gPSBwb3MgKyB0aWNrbWFya09mZnNldDsgLy8gIzk0OVxuXHRcdFx0XHRcdFx0YWx0ZXJuYXRlQmFuZHNbcG9zXS5vcHRpb25zID0ge1xuXHRcdFx0XHRcdFx0XHRmcm9tOiBpc0xvZyA/IGxpbjJsb2coZnJvbSkgOiBmcm9tLFxuXHRcdFx0XHRcdFx0XHR0bzogaXNMb2cgPyBsaW4ybG9nKHRvKSA6IHRvLFxuXHRcdFx0XHRcdFx0XHRjb2xvcjogYWx0ZXJuYXRlR3JpZENvbG9yXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0YWx0ZXJuYXRlQmFuZHNbcG9zXS5yZW5kZXIoKTtcblx0XHRcdFx0XHRcdGFsdGVybmF0ZUJhbmRzW3Bvc10uaXNBY3RpdmUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGN1c3RvbSBwbG90IGxpbmVzIGFuZCBiYW5kc1xuXHRcdFx0aWYgKCFheGlzLl9hZGRlZFBsb3RMQikgeyAvLyBvbmx5IGZpcnN0IHRpbWVcblx0XHRcdFx0ZWFjaCgob3B0aW9ucy5wbG90TGluZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLnBsb3RCYW5kcyB8fCBbXSksIGZ1bmN0aW9uIChwbG90TGluZU9wdGlvbnMpIHtcblx0XHRcdFx0XHRheGlzLmFkZFBsb3RCYW5kT3JMaW5lKHBsb3RMaW5lT3B0aW9ucyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRheGlzLl9hZGRlZFBsb3RMQiA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHR9IC8vIGVuZCBpZiBoYXNEYXRhXG5cblx0XHQvLyBSZW1vdmUgaW5hY3RpdmUgdGlja3Ncblx0XHRlYWNoKFt0aWNrcywgbWlub3JUaWNrcywgYWx0ZXJuYXRlQmFuZHNdLCBmdW5jdGlvbiAoY29sbCkge1xuXHRcdFx0dmFyIHBvcyxcblx0XHRcdFx0aSxcblx0XHRcdFx0Zm9yRGVzdHJ1Y3Rpb24gPSBbXSxcblx0XHRcdFx0ZGVsYXkgPSBnbG9iYWxBbmltYXRpb24gPyBnbG9iYWxBbmltYXRpb24uZHVyYXRpb24gfHwgNTAwIDogMCxcblx0XHRcdFx0ZGVzdHJveUluYWN0aXZlSXRlbXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aSA9IGZvckRlc3RydWN0aW9uLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0XHQvLyBXaGVuIHJlc2l6aW5nIHJhcGlkbHksIHRoZSBzYW1lIGl0ZW1zIG1heSBiZSBkZXN0cm95ZWQgaW4gZGlmZmVyZW50IHRpbWVvdXRzLFxuXHRcdFx0XHRcdFx0Ly8gb3IgdGhlIG1heSBiZSByZWFjdGl2YXRlZFxuXHRcdFx0XHRcdFx0aWYgKGNvbGxbZm9yRGVzdHJ1Y3Rpb25baV1dICYmICFjb2xsW2ZvckRlc3RydWN0aW9uW2ldXS5pc0FjdGl2ZSkge1xuXHRcdFx0XHRcdFx0XHRjb2xsW2ZvckRlc3RydWN0aW9uW2ldXS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBjb2xsW2ZvckRlc3RydWN0aW9uW2ldXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0Zm9yIChwb3MgaW4gY29sbCkge1xuXG5cdFx0XHRcdGlmICghY29sbFtwb3NdLmlzQWN0aXZlKSB7XG5cdFx0XHRcdFx0Ly8gUmVuZGVyIHRvIHplcm8gb3BhY2l0eVxuXHRcdFx0XHRcdGNvbGxbcG9zXS5yZW5kZXIocG9zLCBmYWxzZSwgMCk7XG5cdFx0XHRcdFx0Y29sbFtwb3NdLmlzQWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0Zm9yRGVzdHJ1Y3Rpb24ucHVzaChwb3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdoZW4gdGhlIG9iamVjdHMgYXJlIGZpbmlzaGVkIGZhZGluZyBvdXQsIGRlc3Ryb3kgdGhlbVxuXHRcdFx0aWYgKGNvbGwgPT09IGFsdGVybmF0ZUJhbmRzIHx8ICFjaGFydC5oYXNSZW5kZXJlZCB8fCAhZGVsYXkpIHtcblx0XHRcdFx0ZGVzdHJveUluYWN0aXZlSXRlbXMoKTtcblx0XHRcdH0gZWxzZSBpZiAoZGVsYXkpIHtcblx0XHRcdFx0c2V0VGltZW91dChkZXN0cm95SW5hY3RpdmVJdGVtcywgZGVsYXkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gU3RhdGljIGl0ZW1zLiBBcyB0aGUgYXhpcyBncm91cCBpcyBjbGVhcmVkIG9uIHN1YnNlcXVlbnQgY2FsbHNcblx0XHQvLyB0byByZW5kZXIsIHRoZXNlIGl0ZW1zIGFyZSBhZGRlZCBvdXRzaWRlIHRoZSBncm91cC5cblx0XHQvLyBheGlzIGxpbmVcblx0XHRpZiAobGluZVdpZHRoKSB7XG5cdFx0XHRsaW5lUGF0aCA9IGF4aXMuZ2V0TGluZVBhdGgobGluZVdpZHRoKTtcblx0XHRcdGlmICghYXhpcy5heGlzTGluZSkge1xuXHRcdFx0XHRheGlzLmF4aXNMaW5lID0gcmVuZGVyZXIucGF0aChsaW5lUGF0aClcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRzdHJva2U6IG9wdGlvbnMubGluZUNvbG9yLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IGxpbmVXaWR0aCxcblx0XHRcdFx0XHRcdHpJbmRleDogN1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZChheGlzLmF4aXNHcm91cCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRheGlzLmF4aXNMaW5lLmFuaW1hdGUoeyBkOiBsaW5lUGF0aCB9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2hvdyBvciBoaWRlIHRoZSBsaW5lIGRlcGVuZGluZyBvbiBvcHRpb25zLnNob3dFbXB0eVxuXHRcdFx0YXhpcy5heGlzTGluZVtzaG93QXhpcyA/ICdzaG93JyA6ICdoaWRlJ10oKTtcblx0XHR9XG5cblx0XHRpZiAoYXhpc1RpdGxlICYmIHNob3dBeGlzKSB7XG5cblx0XHRcdGF4aXNUaXRsZVtheGlzVGl0bGUuaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKFxuXHRcdFx0XHRheGlzLmdldFRpdGxlUG9zaXRpb24oKVxuXHRcdFx0KTtcblx0XHRcdGF4aXNUaXRsZS5pc05ldyA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFN0YWNrZWQgdG90YWxzOlxuXHRcdGlmIChzdGFja0xhYmVsT3B0aW9ucyAmJiBzdGFja0xhYmVsT3B0aW9ucy5lbmFibGVkKSB7XG5cdFx0XHRheGlzLnJlbmRlclN0YWNrVG90YWxzKCk7XG5cdFx0fVxuXHRcdC8vIEVuZCBzdGFja2VkIHRvdGFsc1xuXG5cdFx0YXhpcy5pc0RpcnR5ID0gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZHJhdyB0aGUgYXhpcyB0byByZWZsZWN0IGNoYW5nZXMgaW4gdGhlIGRhdGEgb3IgYXhpcyBleHRyZW1lc1xuXHQgKi9cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0XG5cdFx0aWYgKHRoaXMudmlzaWJsZSkge1xuXHRcdFx0Ly8gcmVuZGVyIHRoZSBheGlzXG5cdFx0XHR0aGlzLnJlbmRlcigpO1xuXG5cdFx0XHQvLyBtb3ZlIHBsb3QgbGluZXMgYW5kIGJhbmRzXG5cdFx0XHRlYWNoKHRoaXMucGxvdExpbmVzQW5kQmFuZHMsIGZ1bmN0aW9uIChwbG90TGluZSkge1xuXHRcdFx0XHRwbG90TGluZS5yZW5kZXIoKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIG1hcmsgYXNzb2NpYXRlZCBzZXJpZXMgYXMgZGlydHkgYW5kIHJlYWR5IGZvciByZWRyYXdcblx0XHRlYWNoKHRoaXMuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRzZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0fSk7XG5cblx0fSxcblxuXHQvKipcblx0ICogRGVzdHJveXMgYW4gQXhpcyBpbnN0YW5jZS5cblx0ICovXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uIChrZWVwRXZlbnRzKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0c3RhY2tzID0gYXhpcy5zdGFja3MsXG5cdFx0XHRzdGFja0tleSxcblx0XHRcdHBsb3RMaW5lc0FuZEJhbmRzID0gYXhpcy5wbG90TGluZXNBbmRCYW5kcyxcblx0XHRcdGk7XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV2ZW50c1xuXHRcdGlmICgha2VlcEV2ZW50cykge1xuXHRcdFx0cmVtb3ZlRXZlbnQoYXhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVzdHJveSBlYWNoIHN0YWNrIHRvdGFsXG5cdFx0Zm9yIChzdGFja0tleSBpbiBzdGFja3MpIHtcblx0XHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHN0YWNrc1tzdGFja0tleV0pO1xuXG5cdFx0XHRzdGFja3Nbc3RhY2tLZXldID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBEZXN0cm95IGNvbGxlY3Rpb25zXG5cdFx0ZWFjaChbYXhpcy50aWNrcywgYXhpcy5taW5vclRpY2tzLCBheGlzLmFsdGVybmF0ZUJhbmRzXSwgZnVuY3Rpb24gKGNvbGwpIHtcblx0XHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKGNvbGwpO1xuXHRcdH0pO1xuXHRcdGkgPSBwbG90TGluZXNBbmRCYW5kcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkgeyAvLyAjMTk3NVxuXHRcdFx0cGxvdExpbmVzQW5kQmFuZHNbaV0uZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdC8vIERlc3Ryb3kgbG9jYWwgdmFyaWFibGVzXG5cdFx0ZWFjaChbJ3N0YWNrVG90YWxHcm91cCcsICdheGlzTGluZScsICdheGlzVGl0bGUnLCAnYXhpc0dyb3VwJywgJ2Nyb3NzJywgJ2dyaWRHcm91cCcsICdsYWJlbEdyb3VwJ10sIGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0XHRpZiAoYXhpc1twcm9wXSkge1xuXHRcdFx0XHRheGlzW3Byb3BdID0gYXhpc1twcm9wXS5kZXN0cm95KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBEZXN0cm95IGNyb3NzaGFpclxuXHRcdGlmICh0aGlzLmNyb3NzKSB7XG5cdFx0XHR0aGlzLmNyb3NzLmRlc3Ryb3koKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXcgdGhlIGNyb3NzaGFpclxuXHQgKi9cblx0ZHJhd0Nyb3NzaGFpcjogZnVuY3Rpb24gKGUsIHBvaW50KSB7IC8vIGRvY3M6IE1pc3NpbmcgZG9jcyBmb3IgQXhpcy5jcm9zc2hhaXIuIEFsc28gZm9yIHByb3BlcnRpZXMuXG5cblx0XHR2YXIgcGF0aCxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLmNyb3NzaGFpcixcblx0XHRcdGFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLFxuXHRcdFx0cG9zLFxuXHRcdFx0YXR0cmlicyxcblx0XHRcdGNhdGVnb3JpemVkO1xuXHRcdFxuXHRcdGlmIChcblx0XHRcdC8vIERpc2FibGVkIGluIG9wdGlvbnNcblx0XHRcdCF0aGlzLmNyb3NzaGFpciB8fCBcblx0XHRcdC8vIFNuYXBcblx0XHRcdCgoZGVmaW5lZChwb2ludCkgfHwgIXBpY2sodGhpcy5jcm9zc2hhaXIuc25hcCwgdHJ1ZSkpID09PSBmYWxzZSkgfHwgXG5cdFx0XHQvLyBOb3Qgb24gdGhpcyBheGlzICgjNDA5NSwgIzI4ODgpXG5cdFx0XHQocG9pbnQgJiYgcG9pbnQuc2VyaWVzICYmIHBvaW50LnNlcmllc1t0aGlzLmNvbGxdICE9PSB0aGlzKVxuXHRcdCkge1xuXHRcdFx0dGhpcy5oaWRlQ3Jvc3NoYWlyKCk7XG5cdFx0XG5cdFx0fSBlbHNlIHtcdFx0XHRcblxuXHRcdFx0Ly8gR2V0IHRoZSBwYXRoXG5cdFx0XHRpZiAoIXBpY2sob3B0aW9ucy5zbmFwLCB0cnVlKSkge1xuXHRcdFx0XHRwb3MgPSAodGhpcy5ob3JpeiA/IGUuY2hhcnRYIC0gdGhpcy5wb3MgOiB0aGlzLmxlbiAtIGUuY2hhcnRZICsgdGhpcy5wb3MpO1xuXHRcdFx0fSBlbHNlIGlmIChkZWZpbmVkKHBvaW50KSkge1xuXHRcdFx0XHQvKmpzbGludCBlcWVxOiB0cnVlKi9cblx0XHRcdFx0cG9zID0gdGhpcy5pc1hBeGlzID8gcG9pbnQucGxvdFggOiB0aGlzLmxlbiAtIHBvaW50LnBsb3RZOyAvLyAjMzgzNFxuXHRcdFx0XHQvKmpzbGludCBlcWVxOiBmYWxzZSovXG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmlzUmFkaWFsKSB7XG5cdFx0XHRcdHBhdGggPSB0aGlzLmdldFBsb3RMaW5lUGF0aCh0aGlzLmlzWEF4aXMgPyBwb2ludC54IDogcGljayhwb2ludC5zdGFja1ksIHBvaW50LnkpKSB8fCBudWxsOyAvLyAjMzE4OVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aCA9IHRoaXMuZ2V0UGxvdExpbmVQYXRoKG51bGwsIG51bGwsIG51bGwsIG51bGwsIHBvcykgfHwgbnVsbDsgLy8gIzMxODlcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBhdGggPT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5oaWRlQ3Jvc3NoYWlyKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRHJhdyB0aGUgY3Jvc3Ncblx0XHRcdGlmICh0aGlzLmNyb3NzKSB7XG5cdFx0XHRcdHRoaXMuY3Jvc3Ncblx0XHRcdFx0XHQuYXR0cih7IHZpc2liaWxpdHk6IFZJU0lCTEUgfSlbYW5pbWF0aW9uID8gJ2FuaW1hdGUnIDogJ2F0dHInXSh7IGQ6IHBhdGggfSwgYW5pbWF0aW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhdGVnb3JpemVkID0gdGhpcy5jYXRlZ29yaWVzICYmICF0aGlzLmlzUmFkaWFsO1xuXHRcdFx0XHRhdHRyaWJzID0ge1xuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBvcHRpb25zLndpZHRoIHx8IChjYXRlZ29yaXplZCA/IHRoaXMudHJhbnNBIDogMSksXG5cdFx0XHRcdFx0c3Ryb2tlOiBvcHRpb25zLmNvbG9yIHx8IChjYXRlZ29yaXplZCA/ICdyZ2JhKDE1NSwyMDAsMjU1LDAuMiknIDogJyNDMEMwQzAnKSxcblx0XHRcdFx0XHR6SW5kZXg6IG9wdGlvbnMuekluZGV4IHx8IDJcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKG9wdGlvbnMuZGFzaFN0eWxlKSB7XG5cdFx0XHRcdFx0YXR0cmlicy5kYXNoc3R5bGUgPSBvcHRpb25zLmRhc2hTdHlsZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmNyb3NzID0gdGhpcy5jaGFydC5yZW5kZXJlci5wYXRoKHBhdGgpLmF0dHIoYXR0cmlicykuYWRkKCk7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHQvKipcblx0ICpcdEhpZGUgdGhlIGNyb3NzaGFpci5cblx0ICovXG5cdGhpZGVDcm9zc2hhaXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5jcm9zcykge1xuXHRcdFx0dGhpcy5jcm9zcy5oaWRlKCk7XG5cdFx0fVxuXHR9XG59OyAvLyBlbmQgQXhpc1xuXG5leHRlbmQoQXhpcy5wcm90b3R5cGUsIEF4aXNQbG90TGluZU9yQmFuZEV4dGVuc2lvbik7XG5cbi8qKlxuICogU2V0IHRoZSB0aWNrIHBvc2l0aW9ucyB0byBhIHRpbWUgdW5pdCB0aGF0IG1ha2VzIHNlbnNlLCBmb3IgZXhhbXBsZVxuICogb24gdGhlIGZpcnN0IG9mIGVhY2ggbW9udGggb3Igb24gZXZlcnkgTW9uZGF5LiBSZXR1cm4gYW4gYXJyYXlcbiAqIHdpdGggdGhlIHRpbWUgcG9zaXRpb25zLiBVc2VkIGluIGRhdGV0aW1lIGF4ZXMgYXMgd2VsbCBhcyBmb3IgZ3JvdXBpbmdcbiAqIGRhdGEgb24gYSBkYXRldGltZSBheGlzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub3JtYWxpemVkSW50ZXJ2YWwgVGhlIGludGVydmFsIGluIGF4aXMgdmFsdWVzIChtcykgYW5kIHRoZSBjb3VudFxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBUaGUgbWluaW11bSBpbiBheGlzIHZhbHVlc1xuICogQHBhcmFtIHtOdW1iZXJ9IG1heCBUaGUgbWF4aW11bSBpbiBheGlzIHZhbHVlc1xuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0T2ZXZWVrXG4gKi9cbkF4aXMucHJvdG90eXBlLmdldFRpbWVUaWNrcyA9IGZ1bmN0aW9uIChub3JtYWxpemVkSW50ZXJ2YWwsIG1pbiwgbWF4LCBzdGFydE9mV2Vlaykge1xuXHR2YXIgdGlja1Bvc2l0aW9ucyA9IFtdLFxuXHRcdGksXG5cdFx0aGlnaGVyUmFua3MgPSB7fSxcblx0XHR1c2VVVEMgPSBkZWZhdWx0T3B0aW9ucy5nbG9iYWwudXNlVVRDLFxuXHRcdG1pblllYXIsIC8vIHVzZWQgaW4gbW9udGhzIGFuZCB5ZWFycyBhcyBhIGJhc2lzIGZvciBEYXRlLlVUQygpXG5cdFx0bWluRGF0ZSA9IG5ldyBEYXRlKG1pbiAtIGdldFRaT2Zmc2V0KG1pbikpLFxuXHRcdGludGVydmFsID0gbm9ybWFsaXplZEludGVydmFsLnVuaXRSYW5nZSxcblx0XHRjb3VudCA9IG5vcm1hbGl6ZWRJbnRlcnZhbC5jb3VudDtcblxuXHRpZiAoZGVmaW5lZChtaW4pKSB7IC8vICMxMzAwXG5cdFx0bWluRGF0ZVtzZXRNaWxsaXNlY29uZHNdKGludGVydmFsID49IHRpbWVVbml0cy5zZWNvbmQgPyAwIDogLy8gIzM5MzVcblx0XHRcdGNvdW50ICogbWF0aEZsb29yKG1pbkRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgLyBjb3VudCkpOyAvLyAjMzY1MiwgIzM2NTRcblxuXHRcdGlmIChpbnRlcnZhbCA+PSB0aW1lVW5pdHMuc2Vjb25kKSB7IC8vIHNlY29uZFxuXHRcdFx0bWluRGF0ZVtzZXRTZWNvbmRzXShpbnRlcnZhbCA+PSB0aW1lVW5pdHMubWludXRlID8gMCA6IC8vICMzOTM1XG5cdFx0XHRcdGNvdW50ICogbWF0aEZsb29yKG1pbkRhdGUuZ2V0U2Vjb25kcygpIC8gY291bnQpKTtcblx0XHR9XG5cdFxuXHRcdGlmIChpbnRlcnZhbCA+PSB0aW1lVW5pdHMubWludXRlKSB7IC8vIG1pbnV0ZVxuXHRcdFx0bWluRGF0ZVtzZXRNaW51dGVzXShpbnRlcnZhbCA+PSB0aW1lVW5pdHMuaG91ciA/IDAgOlxuXHRcdFx0XHRjb3VudCAqIG1hdGhGbG9vcihtaW5EYXRlW2dldE1pbnV0ZXNdKCkgLyBjb3VudCkpO1xuXHRcdH1cblx0XG5cdFx0aWYgKGludGVydmFsID49IHRpbWVVbml0cy5ob3VyKSB7IC8vIGhvdXJcblx0XHRcdG1pbkRhdGVbc2V0SG91cnNdKGludGVydmFsID49IHRpbWVVbml0cy5kYXkgPyAwIDpcblx0XHRcdFx0Y291bnQgKiBtYXRoRmxvb3IobWluRGF0ZVtnZXRIb3Vyc10oKSAvIGNvdW50KSk7XG5cdFx0fVxuXHRcblx0XHRpZiAoaW50ZXJ2YWwgPj0gdGltZVVuaXRzLmRheSkgeyAvLyBkYXlcblx0XHRcdG1pbkRhdGVbc2V0RGF0ZV0oaW50ZXJ2YWwgPj0gdGltZVVuaXRzLm1vbnRoID8gMSA6XG5cdFx0XHRcdGNvdW50ICogbWF0aEZsb29yKG1pbkRhdGVbZ2V0RGF0ZV0oKSAvIGNvdW50KSk7XG5cdFx0fVxuXHRcblx0XHRpZiAoaW50ZXJ2YWwgPj0gdGltZVVuaXRzLm1vbnRoKSB7IC8vIG1vbnRoXG5cdFx0XHRtaW5EYXRlW3NldE1vbnRoXShpbnRlcnZhbCA+PSB0aW1lVW5pdHMueWVhciA/IDAgOlxuXHRcdFx0XHRjb3VudCAqIG1hdGhGbG9vcihtaW5EYXRlW2dldE1vbnRoXSgpIC8gY291bnQpKTtcblx0XHRcdG1pblllYXIgPSBtaW5EYXRlW2dldEZ1bGxZZWFyXSgpO1xuXHRcdH1cblx0XG5cdFx0aWYgKGludGVydmFsID49IHRpbWVVbml0cy55ZWFyKSB7IC8vIHllYXJcblx0XHRcdG1pblllYXIgLT0gbWluWWVhciAlIGNvdW50O1xuXHRcdFx0bWluRGF0ZVtzZXRGdWxsWWVhcl0obWluWWVhcik7XG5cdFx0fVxuXHRcblx0XHQvLyB3ZWVrIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcnVucyBvdXRzaWRlIHRoZSBoaWVyYXJjaHlcblx0XHRpZiAoaW50ZXJ2YWwgPT09IHRpbWVVbml0cy53ZWVrKSB7XG5cdFx0XHQvLyBnZXQgc3RhcnQgb2YgY3VycmVudCB3ZWVrLCBpbmRlcGVuZGVudCBvZiBjb3VudFxuXHRcdFx0bWluRGF0ZVtzZXREYXRlXShtaW5EYXRlW2dldERhdGVdKCkgLSBtaW5EYXRlW2dldERheV0oKSArXG5cdFx0XHRcdHBpY2soc3RhcnRPZldlZWssIDEpKTtcblx0XHR9XG5cdFxuXHRcblx0XHQvLyBnZXQgdGljayBwb3NpdGlvbnNcblx0XHRpID0gMTtcblx0XHRpZiAodGltZXpvbmVPZmZzZXQgfHwgZ2V0VGltZXpvbmVPZmZzZXQpIHtcblx0XHRcdG1pbkRhdGUgPSBtaW5EYXRlLmdldFRpbWUoKTtcblx0XHRcdG1pbkRhdGUgPSBuZXcgRGF0ZShtaW5EYXRlICsgZ2V0VFpPZmZzZXQobWluRGF0ZSkpO1xuXHRcdH1cblx0XHRtaW5ZZWFyID0gbWluRGF0ZVtnZXRGdWxsWWVhcl0oKTtcblx0XHR2YXIgdGltZSA9IG1pbkRhdGUuZ2V0VGltZSgpLFxuXHRcdFx0bWluTW9udGggPSBtaW5EYXRlW2dldE1vbnRoXSgpLFxuXHRcdFx0bWluRGF0ZURhdGUgPSBtaW5EYXRlW2dldERhdGVdKCksXG5cdFx0XHRsb2NhbFRpbWV6b25lT2Zmc2V0ID0gKHRpbWVVbml0cy5kYXkgKyBcblx0XHRcdFx0XHQodXNlVVRDID8gZ2V0VFpPZmZzZXQobWluRGF0ZSkgOiBtaW5EYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCAqIDEwMDApXG5cdFx0XHRcdCkgJSB0aW1lVW5pdHMuZGF5OyAvLyAjOTUwLCAjMzM1OVxuXHRcblx0XHQvLyBpdGVyYXRlIGFuZCBhZGQgdGljayBwb3NpdGlvbnMgYXQgYXBwcm9wcmlhdGUgdmFsdWVzXG5cdFx0d2hpbGUgKHRpbWUgPCBtYXgpIHtcblx0XHRcdHRpY2tQb3NpdGlvbnMucHVzaCh0aW1lKTtcblx0XG5cdFx0XHQvLyBpZiB0aGUgaW50ZXJ2YWwgaXMgeWVhcnMsIHVzZSBEYXRlLlVUQyB0byBpbmNyZWFzZSB5ZWFyc1xuXHRcdFx0aWYgKGludGVydmFsID09PSB0aW1lVW5pdHMueWVhcikge1xuXHRcdFx0XHR0aW1lID0gbWFrZVRpbWUobWluWWVhciArIGkgKiBjb3VudCwgMCk7XG5cdFxuXHRcdFx0Ly8gaWYgdGhlIGludGVydmFsIGlzIG1vbnRocywgdXNlIERhdGUuVVRDIHRvIGluY3JlYXNlIG1vbnRoc1xuXHRcdFx0fSBlbHNlIGlmIChpbnRlcnZhbCA9PT0gdGltZVVuaXRzLm1vbnRoKSB7XG5cdFx0XHRcdHRpbWUgPSBtYWtlVGltZShtaW5ZZWFyLCBtaW5Nb250aCArIGkgKiBjb3VudCk7XG5cdFxuXHRcdFx0Ly8gaWYgd2UncmUgdXNpbmcgZ2xvYmFsIHRpbWUsIHRoZSBpbnRlcnZhbCBpcyBub3QgZml4ZWQgYXMgaXQganVtcHNcblx0XHRcdC8vIG9uZSBob3VyIGF0IHRoZSBEU1QgY3Jvc3NvdmVyXG5cdFx0XHR9IGVsc2UgaWYgKCF1c2VVVEMgJiYgKGludGVydmFsID09PSB0aW1lVW5pdHMuZGF5IHx8IGludGVydmFsID09PSB0aW1lVW5pdHMud2VlaykpIHtcblx0XHRcdFx0dGltZSA9IG1ha2VUaW1lKG1pblllYXIsIG1pbk1vbnRoLCBtaW5EYXRlRGF0ZSArXG5cdFx0XHRcdFx0aSAqIGNvdW50ICogKGludGVydmFsID09PSB0aW1lVW5pdHMuZGF5ID8gMSA6IDcpKTtcblx0XG5cdFx0XHQvLyBlbHNlLCB0aGUgaW50ZXJ2YWwgaXMgZml4ZWQgYW5kIHdlIHVzZSBzaW1wbGUgYWRkaXRpb25cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRpbWUgKz0gaW50ZXJ2YWwgKiBjb3VudDtcblx0XHRcdH1cblx0XG5cdFx0XHRpKys7XG5cdFx0fVxuXHRcblx0XHQvLyBwdXNoIHRoZSBsYXN0IHRpbWVcblx0XHR0aWNrUG9zaXRpb25zLnB1c2godGltZSk7XG5cblxuXHRcdC8vIG1hcmsgbmV3IGRheXMgaWYgdGhlIHRpbWUgaXMgZGl2aWRpYmxlIGJ5IGRheSAoIzE2NDksICMxNzYwKVxuXHRcdGVhY2goZ3JlcCh0aWNrUG9zaXRpb25zLCBmdW5jdGlvbiAodGltZSkge1xuXHRcdFx0cmV0dXJuIGludGVydmFsIDw9IHRpbWVVbml0cy5ob3VyICYmIHRpbWUgJSB0aW1lVW5pdHMuZGF5ID09PSBsb2NhbFRpbWV6b25lT2Zmc2V0O1xuXHRcdH0pLCBmdW5jdGlvbiAodGltZSkge1xuXHRcdFx0aGlnaGVyUmFua3NbdGltZV0gPSAnZGF5Jztcblx0XHR9KTtcblx0fVxuXG5cblx0Ly8gcmVjb3JkIGluZm9ybWF0aW9uIG9uIHRoZSBjaG9zZW4gdW5pdCAtIGZvciBkeW5hbWljIGxhYmVsIGZvcm1hdHRlclxuXHR0aWNrUG9zaXRpb25zLmluZm8gPSBleHRlbmQobm9ybWFsaXplZEludGVydmFsLCB7XG5cdFx0aGlnaGVyUmFua3M6IGhpZ2hlclJhbmtzLFxuXHRcdHRvdGFsUmFuZ2U6IGludGVydmFsICogY291bnRcblx0fSk7XG5cblx0cmV0dXJuIHRpY2tQb3NpdGlvbnM7XG59O1xuXG4vKipcbiAqIEdldCBhIG5vcm1hbGl6ZWQgdGljayBpbnRlcnZhbCBmb3IgZGF0ZXMuIFJldHVybnMgYSBjb25maWd1cmF0aW9uIG9iamVjdCB3aXRoXG4gKiB1bml0IHJhbmdlIChpbnRlcnZhbCksIGNvdW50IGFuZCBuYW1lLiBVc2VkIHRvIHByZXBhcmUgZGF0YSBmb3IgZ2V0VGltZVRpY2tzLiBcbiAqIFByZXZpb3VzbHkgdGhpcyBsb2dpYyB3YXMgcGFydCBvZiBnZXRUaW1lVGlja3MsIGJ1dCBhcyBnZXRUaW1lVGlja3Mgbm93IHJ1bnNcbiAqIG9mIHNlZ21lbnRzIGluIHN0b2NrIGNoYXJ0cywgdGhlIG5vcm1hbGl6aW5nIGxvZ2ljIHdhcyBleHRyYWN0ZWQgaW4gb3JkZXIgdG8gXG4gKiBwcmV2ZW50IGl0IGZvciBydW5uaW5nIG92ZXIgYWdhaW4gZm9yIGVhY2ggc2VnbWVudCBoYXZpbmcgdGhlIHNhbWUgaW50ZXJ2YWwuIFxuICogIzY2MiwgIzY5Ny5cbiAqL1xuQXhpcy5wcm90b3R5cGUubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbCA9IGZ1bmN0aW9uICh0aWNrSW50ZXJ2YWwsIHVuaXRzT3B0aW9uKSB7XG5cdHZhciB1bml0cyA9IHVuaXRzT3B0aW9uIHx8IFtbXG5cdFx0XHRcdCdtaWxsaXNlY29uZCcsIC8vIHVuaXQgbmFtZVxuXHRcdFx0XHRbMSwgMiwgNSwgMTAsIDIwLCAyNSwgNTAsIDEwMCwgMjAwLCA1MDBdIC8vIGFsbG93ZWQgbXVsdGlwbGVzXG5cdFx0XHRdLCBbXG5cdFx0XHRcdCdzZWNvbmQnLFxuXHRcdFx0XHRbMSwgMiwgNSwgMTAsIDE1LCAzMF1cblx0XHRcdF0sIFtcblx0XHRcdFx0J21pbnV0ZScsXG5cdFx0XHRcdFsxLCAyLCA1LCAxMCwgMTUsIDMwXVxuXHRcdFx0XSwgW1xuXHRcdFx0XHQnaG91cicsXG5cdFx0XHRcdFsxLCAyLCAzLCA0LCA2LCA4LCAxMl1cblx0XHRcdF0sIFtcblx0XHRcdFx0J2RheScsXG5cdFx0XHRcdFsxLCAyXVxuXHRcdFx0XSwgW1xuXHRcdFx0XHQnd2VlaycsXG5cdFx0XHRcdFsxLCAyXVxuXHRcdFx0XSwgW1xuXHRcdFx0XHQnbW9udGgnLFxuXHRcdFx0XHRbMSwgMiwgMywgNCwgNl1cblx0XHRcdF0sIFtcblx0XHRcdFx0J3llYXInLFxuXHRcdFx0XHRudWxsXG5cdFx0XHRdXSxcblx0XHR1bml0ID0gdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV0sIC8vIGRlZmF1bHQgdW5pdCBpcyB5ZWFyc1xuXHRcdGludGVydmFsID0gdGltZVVuaXRzW3VuaXRbMF1dLFxuXHRcdG11bHRpcGxlcyA9IHVuaXRbMV0sXG5cdFx0Y291bnQsXG5cdFx0aTtcblx0XHRcblx0Ly8gbG9vcCB0aHJvdWdoIHRoZSB1bml0cyB0byBmaW5kIHRoZSBvbmUgdGhhdCBiZXN0IGZpdHMgdGhlIHRpY2tJbnRlcnZhbFxuXHRmb3IgKGkgPSAwOyBpIDwgdW5pdHMubGVuZ3RoOyBpKyspIHtcblx0XHR1bml0ID0gdW5pdHNbaV07XG5cdFx0aW50ZXJ2YWwgPSB0aW1lVW5pdHNbdW5pdFswXV07XG5cdFx0bXVsdGlwbGVzID0gdW5pdFsxXTtcblxuXG5cdFx0aWYgKHVuaXRzW2kgKyAxXSkge1xuXHRcdFx0Ly8gbGVzc1RoYW4gaXMgaW4gdGhlIG1pZGRsZSBiZXR3ZWVuIHRoZSBoaWdoZXN0IG11bHRpcGxlIGFuZCB0aGUgbmV4dCB1bml0LlxuXHRcdFx0dmFyIGxlc3NUaGFuID0gKGludGVydmFsICogbXVsdGlwbGVzW211bHRpcGxlcy5sZW5ndGggLSAxXSArXG5cdFx0XHRcdFx0XHR0aW1lVW5pdHNbdW5pdHNbaSArIDFdWzBdXSkgLyAyO1xuXG5cdFx0XHQvLyBicmVhayBhbmQga2VlcCB0aGUgY3VycmVudCB1bml0XG5cdFx0XHRpZiAodGlja0ludGVydmFsIDw9IGxlc3NUaGFuKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIHByZXZlbnQgMi41IHllYXJzIGludGVydmFscywgdGhvdWdoIDI1LCAyNTAgZXRjLiBhcmUgYWxsb3dlZFxuXHRpZiAoaW50ZXJ2YWwgPT09IHRpbWVVbml0cy55ZWFyICYmIHRpY2tJbnRlcnZhbCA8IDUgKiBpbnRlcnZhbCkge1xuXHRcdG11bHRpcGxlcyA9IFsxLCAyLCA1XTtcblx0fVxuXG5cdC8vIGdldCB0aGUgY291bnRcblx0Y291bnQgPSBub3JtYWxpemVUaWNrSW50ZXJ2YWwoXG5cdFx0dGlja0ludGVydmFsIC8gaW50ZXJ2YWwsIFxuXHRcdG11bHRpcGxlcyxcblx0XHR1bml0WzBdID09PSAneWVhcicgPyBtYXRoTWF4KGdldE1hZ25pdHVkZSh0aWNrSW50ZXJ2YWwgLyBpbnRlcnZhbCksIDEpIDogMSAvLyAjMTkxMywgIzIzNjBcblx0KTtcblx0XG5cdHJldHVybiB7XG5cdFx0dW5pdFJhbmdlOiBpbnRlcnZhbCxcblx0XHRjb3VudDogY291bnQsXG5cdFx0dW5pdE5hbWU6IHVuaXRbMF1cblx0fTtcbn07LyoqXG4gKiBNZXRob2RzIGRlZmluZWQgb24gdGhlIEF4aXMgcHJvdG90eXBlXG4gKi9cblxuLyoqXG4gKiBTZXQgdGhlIHRpY2sgcG9zaXRpb25zIG9mIGEgbG9nYXJpdGhtaWMgYXhpc1xuICovXG5BeGlzLnByb3RvdHlwZS5nZXRMb2dUaWNrUG9zaXRpb25zID0gZnVuY3Rpb24gKGludGVydmFsLCBtaW4sIG1heCwgbWlub3IpIHtcblx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0YXhpc0xlbmd0aCA9IGF4aXMubGVuLFxuXHRcdC8vIFNpbmNlIHdlIHVzZSB0aGlzIG1ldGhvZCBmb3IgYm90aCBtYWpvciBhbmQgbWlub3IgdGlja3MsXG5cdFx0Ly8gdXNlIGEgbG9jYWwgdmFyaWFibGUgYW5kIHJldHVybiB0aGUgcmVzdWx0XG5cdFx0cG9zaXRpb25zID0gW107IFxuXHRcblx0Ly8gUmVzZXRcblx0aWYgKCFtaW5vcikge1xuXHRcdGF4aXMuX21pbm9yQXV0b0ludGVydmFsID0gbnVsbDtcblx0fVxuXHRcblx0Ly8gRmlyc3QgY2FzZTogQWxsIHRpY2tzIGZhbGwgb24gd2hvbGUgbG9nYXJpdGhtczogMSwgMTAsIDEwMCBldGMuXG5cdGlmIChpbnRlcnZhbCA+PSAwLjUpIHtcblx0XHRpbnRlcnZhbCA9IG1hdGhSb3VuZChpbnRlcnZhbCk7XG5cdFx0cG9zaXRpb25zID0gYXhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKGludGVydmFsLCBtaW4sIG1heCk7XG5cdFx0XG5cdC8vIFNlY29uZCBjYXNlOiBXZSBuZWVkIGludGVybWVkaWFyeSB0aWNrcy4gRm9yIGV4YW1wbGUgXG5cdC8vIDEsIDIsIDQsIDYsIDgsIDEwLCAyMCwgNDAgZXRjLiBcblx0fSBlbHNlIGlmIChpbnRlcnZhbCA+PSAwLjA4KSB7XG5cdFx0dmFyIHJvdW5kZWRNaW4gPSBtYXRoRmxvb3IobWluKSxcblx0XHRcdGludGVybWVkaWF0ZSxcblx0XHRcdGksXG5cdFx0XHRqLFxuXHRcdFx0bGVuLFxuXHRcdFx0cG9zLFxuXHRcdFx0bGFzdFBvcyxcblx0XHRcdGJyZWFrMjtcblx0XHRcdFxuXHRcdGlmIChpbnRlcnZhbCA+IDAuMykge1xuXHRcdFx0aW50ZXJtZWRpYXRlID0gWzEsIDIsIDRdO1xuXHRcdH0gZWxzZSBpZiAoaW50ZXJ2YWwgPiAwLjE1KSB7IC8vIDAuMiBlcXVhbHMgZml2ZSBtaW5vciB0aWNrcyBwZXIgMSwgMTAsIDEwMCBldGNcblx0XHRcdGludGVybWVkaWF0ZSA9IFsxLCAyLCA0LCA2LCA4XTtcblx0XHR9IGVsc2UgeyAvLyAwLjEgZXF1YWxzIHRlbiBtaW5vciB0aWNrcyBwZXIgMSwgMTAsIDEwMCBldGNcblx0XHRcdGludGVybWVkaWF0ZSA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XTtcblx0XHR9XG5cdFx0XG5cdFx0Zm9yIChpID0gcm91bmRlZE1pbjsgaSA8IG1heCArIDEgJiYgIWJyZWFrMjsgaSsrKSB7XG5cdFx0XHRsZW4gPSBpbnRlcm1lZGlhdGUubGVuZ3RoO1xuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGxlbiAmJiAhYnJlYWsyOyBqKyspIHtcblx0XHRcdFx0cG9zID0gbG9nMmxpbihsaW4ybG9nKGkpICogaW50ZXJtZWRpYXRlW2pdKTtcblx0XHRcdFx0aWYgKHBvcyA+IG1pbiAmJiAoIW1pbm9yIHx8IGxhc3RQb3MgPD0gbWF4KSAmJiBsYXN0UG9zICE9PSBVTkRFRklORUQpIHsgLy8gIzE2NzAsIGxhc3RQb3MgaXMgIzMxMTNcblx0XHRcdFx0XHRwb3NpdGlvbnMucHVzaChsYXN0UG9zKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGxhc3RQb3MgPiBtYXgpIHtcblx0XHRcdFx0XHRicmVhazIgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RQb3MgPSBwb3M7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHQvLyBUaGlyZCBjYXNlOiBXZSBhcmUgc28gZGVlcCBpbiBiZXR3ZWVuIHdob2xlIGxvZ2FyaXRobWljIHZhbHVlcyB0aGF0XG5cdC8vIHdlIG1pZ2h0IGFzIHdlbGwgaGFuZGxlIHRoZSB0aWNrIHBvc2l0aW9ucyBsaWtlIGEgbGluZWFyIGF4aXMuIEZvclxuXHQvLyBleGFtcGxlIDEuMDEsIDEuMDIsIDEuMDMsIDEuMDQuXG5cdH0gZWxzZSB7XG5cdFx0dmFyIHJlYWxNaW4gPSBsaW4ybG9nKG1pbiksXG5cdFx0XHRyZWFsTWF4ID0gbGluMmxvZyhtYXgpLFxuXHRcdFx0dGlja0ludGVydmFsT3B0aW9uID0gb3B0aW9uc1ttaW5vciA/ICdtaW5vclRpY2tJbnRlcnZhbCcgOiAndGlja0ludGVydmFsJ10sXG5cdFx0XHRmaWx0ZXJlZFRpY2tJbnRlcnZhbE9wdGlvbiA9IHRpY2tJbnRlcnZhbE9wdGlvbiA9PT0gJ2F1dG8nID8gbnVsbCA6IHRpY2tJbnRlcnZhbE9wdGlvbixcblx0XHRcdHRpY2tQaXhlbEludGVydmFsT3B0aW9uID0gb3B0aW9ucy50aWNrUGl4ZWxJbnRlcnZhbCAvIChtaW5vciA/IDUgOiAxKSxcblx0XHRcdHRvdGFsUGl4ZWxMZW5ndGggPSBtaW5vciA/IGF4aXNMZW5ndGggLyBheGlzLnRpY2tQb3NpdGlvbnMubGVuZ3RoIDogYXhpc0xlbmd0aDtcblx0XHRcblx0XHRpbnRlcnZhbCA9IHBpY2soXG5cdFx0XHRmaWx0ZXJlZFRpY2tJbnRlcnZhbE9wdGlvbixcblx0XHRcdGF4aXMuX21pbm9yQXV0b0ludGVydmFsLFxuXHRcdFx0KHJlYWxNYXggLSByZWFsTWluKSAqIHRpY2tQaXhlbEludGVydmFsT3B0aW9uIC8gKHRvdGFsUGl4ZWxMZW5ndGggfHwgMSlcblx0XHQpO1xuXHRcdFxuXHRcdGludGVydmFsID0gbm9ybWFsaXplVGlja0ludGVydmFsKFxuXHRcdFx0aW50ZXJ2YWwsIFxuXHRcdFx0bnVsbCwgXG5cdFx0XHRnZXRNYWduaXR1ZGUoaW50ZXJ2YWwpXG5cdFx0KTtcblx0XHRcblx0XHRwb3NpdGlvbnMgPSBtYXAoYXhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKFxuXHRcdFx0aW50ZXJ2YWwsIFxuXHRcdFx0cmVhbE1pbixcblx0XHRcdHJlYWxNYXhcdFxuXHRcdCksIGxvZzJsaW4pO1xuXHRcdFxuXHRcdGlmICghbWlub3IpIHtcblx0XHRcdGF4aXMuX21pbm9yQXV0b0ludGVydmFsID0gaW50ZXJ2YWwgLyA1O1xuXHRcdH1cblx0fVxuXHRcblx0Ly8gU2V0IHRoZSBheGlzLWxldmVsIHRpY2tJbnRlcnZhbCB2YXJpYWJsZSBcblx0aWYgKCFtaW5vcikge1xuXHRcdGF4aXMudGlja0ludGVydmFsID0gaW50ZXJ2YWw7XG5cdH1cblx0cmV0dXJuIHBvc2l0aW9ucztcbn07LyoqXG4gKiBUaGUgdG9vbHRpcCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydCBUaGUgY2hhcnQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRvb2x0aXAgb3B0aW9uc1xuICovXG52YXIgVG9vbHRpcCA9IEhpZ2hjaGFydHMuVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5Ub29sdGlwLnByb3RvdHlwZSA9IHtcblxuXHRpbml0OiBmdW5jdGlvbiAoY2hhcnQsIG9wdGlvbnMpIHtcblxuXHRcdHZhciBib3JkZXJXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRzdHlsZSA9IG9wdGlvbnMuc3R5bGUsXG5cdFx0XHRwYWRkaW5nID0gcEludChzdHlsZS5wYWRkaW5nKTtcblxuXHRcdC8vIFNhdmUgdGhlIGNoYXJ0IGFuZCBvcHRpb25zXG5cdFx0dGhpcy5jaGFydCA9IGNoYXJ0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cblx0XHQvLyBLZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHNlcmllc1xuXHRcdC8vdGhpcy5jdXJyZW50U2VyaWVzID0gVU5ERUZJTkVEO1xuXG5cdFx0Ly8gTGlzdCBvZiBjcm9zc2hhaXJzXG5cdFx0dGhpcy5jcm9zc2hhaXJzID0gW107XG5cblx0XHQvLyBDdXJyZW50IHZhbHVlcyBvZiB4IGFuZCB5IHdoZW4gYW5pbWF0aW5nXG5cdFx0dGhpcy5ub3cgPSB7IHg6IDAsIHk6IDAgfTtcblxuXHRcdC8vIFRoZSB0b29sdGlwIGlzIGluaXRpYWxseSBoaWRkZW5cblx0XHR0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcblxuXG5cdFx0Ly8gY3JlYXRlIHRoZSBsYWJlbFx0XHRcblx0XHR0aGlzLmxhYmVsID0gY2hhcnQucmVuZGVyZXIubGFiZWwoJycsIDAsIDAsIG9wdGlvbnMuc2hhcGUgfHwgJ2NhbGxvdXQnLCBudWxsLCBudWxsLCBvcHRpb25zLnVzZUhUTUwsIG51bGwsICd0b29sdGlwJylcblx0XHRcdC5hdHRyKHtcblx0XHRcdFx0cGFkZGluZzogcGFkZGluZyxcblx0XHRcdFx0ZmlsbDogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBib3JkZXJXaWR0aCxcblx0XHRcdFx0cjogb3B0aW9ucy5ib3JkZXJSYWRpdXMsXG5cdFx0XHRcdHpJbmRleDogOFxuXHRcdFx0fSlcblx0XHRcdC5jc3Moc3R5bGUpXG5cdFx0XHQuY3NzKHsgcGFkZGluZzogMCB9KSAvLyBSZW1vdmUgaXQgZnJvbSBWTUwsIHRoZSBwYWRkaW5nIGlzIGFwcGxpZWQgYXMgYW4gYXR0cmlidXRlIGluc3RlYWQgKCMxMTE3KVxuXHRcdFx0LmFkZCgpXG5cdFx0XHQuYXR0cih7IHk6IC05OTk5IH0pOyAvLyAjMjMwMSwgIzI2NTdcblxuXHRcdC8vIFdoZW4gdXNpbmcgY2FuVkcgdGhlIHNoYWRvdyBzaG93cyB1cCBhcyBhIGdyYXkgY2lyY2xlXG5cdFx0Ly8gZXZlbiBpZiB0aGUgdG9vbHRpcCBpcyBoaWRkZW4uXG5cdFx0aWYgKCF1c2VDYW5WRykge1xuXHRcdFx0dGhpcy5sYWJlbC5zaGFkb3cob3B0aW9ucy5zaGFkb3cpO1xuXHRcdH1cblxuXHRcdC8vIFB1YmxpYyBwcm9wZXJ0eSBmb3IgZ2V0dGluZyB0aGUgc2hhcmVkIHN0YXRlLlxuXHRcdHRoaXMuc2hhcmVkID0gb3B0aW9ucy5zaGFyZWQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3Ryb3kgdGhlIHRvb2x0aXAgYW5kIGl0cyBlbGVtZW50cy5cblx0ICovXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBEZXN0cm95IGFuZCBjbGVhciBsb2NhbCB2YXJpYWJsZXNcblx0XHRpZiAodGhpcy5sYWJlbCkge1xuXHRcdFx0dGhpcy5sYWJlbCA9IHRoaXMubGFiZWwuZGVzdHJveSgpO1xuXHRcdH1cblx0XHRjbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLnRvb2x0aXBUaW1lb3V0KTtcblx0fSxcblxuXHQvKipcblx0ICogUHJvdmlkZSBhIHNvZnQgbW92ZW1lbnQgZm9yIHRoZSB0b29sdGlwXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRtb3ZlOiBmdW5jdGlvbiAoeCwgeSwgYW5jaG9yWCwgYW5jaG9yWSkge1xuXHRcdHZhciB0b29sdGlwID0gdGhpcyxcblx0XHRcdG5vdyA9IHRvb2x0aXAubm93LFxuXHRcdFx0YW5pbWF0ZSA9IHRvb2x0aXAub3B0aW9ucy5hbmltYXRpb24gIT09IGZhbHNlICYmICF0b29sdGlwLmlzSGlkZGVuICYmIFxuXHRcdFx0XHQvLyBXaGVuIHdlIGdldCBjbG9zZSB0byB0aGUgdGFyZ2V0IHBvc2l0aW9uLCBhYm9ydCBhbmltYXRpb24gYW5kIGxhbmQgb24gdGhlIHJpZ2h0IHBsYWNlICgjMzA1Nilcblx0XHRcdFx0KG1hdGhBYnMoeCAtIG5vdy54KSA+IDEgfHwgbWF0aEFicyh5IC0gbm93LnkpID4gMSksXG5cdFx0XHRza2lwQW5jaG9yID0gdG9vbHRpcC5mb2xsb3dQb2ludGVyIHx8IHRvb2x0aXAubGVuID4gMTtcblxuXHRcdC8vIEdldCBpbnRlcm1lZGlhdGUgdmFsdWVzIGZvciBhbmltYXRpb25cblx0XHRleHRlbmQobm93LCB7XG5cdFx0XHR4OiBhbmltYXRlID8gKDIgKiBub3cueCArIHgpIC8gMyA6IHgsXG5cdFx0XHR5OiBhbmltYXRlID8gKG5vdy55ICsgeSkgLyAyIDogeSxcblx0XHRcdGFuY2hvclg6IHNraXBBbmNob3IgPyBVTkRFRklORUQgOiBhbmltYXRlID8gKDIgKiBub3cuYW5jaG9yWCArIGFuY2hvclgpIC8gMyA6IGFuY2hvclgsXG5cdFx0XHRhbmNob3JZOiBza2lwQW5jaG9yID8gVU5ERUZJTkVEIDogYW5pbWF0ZSA/IChub3cuYW5jaG9yWSArIGFuY2hvclkpIC8gMiA6IGFuY2hvcllcblx0XHR9KTtcblxuXHRcdC8vIE1vdmUgdG8gdGhlIGludGVybWVkaWF0ZSB2YWx1ZVxuXHRcdHRvb2x0aXAubGFiZWwuYXR0cihub3cpO1xuXG5cdFx0XG5cdFx0Ly8gUnVuIG9uIG5leHQgdGljayBvZiB0aGUgbW91c2UgdHJhY2tlclxuXHRcdGlmIChhbmltYXRlKSB7XG5cdFx0XG5cdFx0XHQvLyBOZXZlciBhbGxvdyB0d28gdGltZW91dHNcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnRvb2x0aXBUaW1lb3V0KTtcblx0XHRcdFxuXHRcdFx0Ly8gU2V0IHRoZSBmaXhlZCBpbnRlcnZhbCB0aWNraW5nIGZvciB0aGUgc21vb3RoIHRvb2x0aXBcblx0XHRcdHRoaXMudG9vbHRpcFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gVGhlIGludGVydmFsIGZ1bmN0aW9uIG1heSBzdGlsbCBiZSBydW5uaW5nIGR1cmluZyBkZXN0cm95LCBzbyBjaGVjayB0aGF0IHRoZSBjaGFydCBpcyByZWFsbHkgdGhlcmUgYmVmb3JlIGNhbGxpbmcuXG5cdFx0XHRcdGlmICh0b29sdGlwKSB7XG5cdFx0XHRcdFx0dG9vbHRpcC5tb3ZlKHgsIHksIGFuY2hvclgsIGFuY2hvclkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAzMik7XG5cdFx0XHRcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhpZGUgdGhlIHRvb2x0aXBcblx0ICovXG5cdGhpZGU6IGZ1bmN0aW9uIChkZWxheSkge1xuXHRcdHZhciB0b29sdGlwID0gdGhpcyxcblx0XHRcdGhvdmVyUG9pbnRzO1xuXHRcdFxuXHRcdGNsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lcik7IC8vIGRpc2FsbG93IGR1cGxpY2F0ZSB0aW1lcnMgKCMxNzI4LCAjMTc2Nilcblx0XHRpZiAoIXRoaXMuaXNIaWRkZW4pIHtcblx0XHRcdGhvdmVyUG9pbnRzID0gdGhpcy5jaGFydC5ob3ZlclBvaW50cztcblxuXHRcdFx0dGhpcy5oaWRlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dG9vbHRpcC5sYWJlbC5mYWRlT3V0KCk7XG5cdFx0XHRcdHRvb2x0aXAuaXNIaWRkZW4gPSB0cnVlO1xuXHRcdFx0fSwgcGljayhkZWxheSwgdGhpcy5vcHRpb25zLmhpZGVEZWxheSwgNTAwKSk7XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqIFxuXHQgKiBFeHRlbmRhYmxlIG1ldGhvZCB0byBnZXQgdGhlIGFuY2hvciBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcFxuXHQgKiBmcm9tIGEgcG9pbnQgb3Igc2V0IG9mIHBvaW50c1xuXHQgKi9cblx0Z2V0QW5jaG9yOiBmdW5jdGlvbiAocG9pbnRzLCBtb3VzZUV2ZW50KSB7XG5cdFx0dmFyIHJldCxcblx0XHRcdGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdGludmVydGVkID0gY2hhcnQuaW52ZXJ0ZWQsXG5cdFx0XHRwbG90VG9wID0gY2hhcnQucGxvdFRvcCxcblx0XHRcdHBsb3RMZWZ0ID0gY2hhcnQucGxvdExlZnQsXG5cdFx0XHRwbG90WCA9IDAsXG5cdFx0XHRwbG90WSA9IDAsXG5cdFx0XHR5QXhpcyxcblx0XHRcdHhBeGlzO1xuXHRcdFxuXHRcdHBvaW50cyA9IHNwbGF0KHBvaW50cyk7XG5cdFx0XG5cdFx0Ly8gUGllIHVzZXMgYSBzcGVjaWFsIHRvb2x0aXBQb3Ncblx0XHRyZXQgPSBwb2ludHNbMF0udG9vbHRpcFBvcztcblx0XHRcblx0XHQvLyBXaGVuIHRvb2x0aXAgZm9sbG93cyBtb3VzZSwgcmVsYXRlIHRoZSBwb3NpdGlvbiB0byB0aGUgbW91c2Vcblx0XHRpZiAodGhpcy5mb2xsb3dQb2ludGVyICYmIG1vdXNlRXZlbnQpIHtcblx0XHRcdGlmIChtb3VzZUV2ZW50LmNoYXJ0WCA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdG1vdXNlRXZlbnQgPSBjaGFydC5wb2ludGVyLm5vcm1hbGl6ZShtb3VzZUV2ZW50KTtcblx0XHRcdH1cblx0XHRcdHJldCA9IFtcblx0XHRcdFx0bW91c2VFdmVudC5jaGFydFggLSBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0bW91c2VFdmVudC5jaGFydFkgLSBwbG90VG9wXG5cdFx0XHRdO1xuXHRcdH1cblx0XHQvLyBXaGVuIHNoYXJlZCwgdXNlIHRoZSBhdmVyYWdlIHBvc2l0aW9uXG5cdFx0aWYgKCFyZXQpIHtcblx0XHRcdGVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0eUF4aXMgPSBwb2ludC5zZXJpZXMueUF4aXM7XG5cdFx0XHRcdHhBeGlzID0gcG9pbnQuc2VyaWVzLnhBeGlzO1xuXHRcdFx0XHRwbG90WCArPSBwb2ludC5wbG90WCAgKyAoIWludmVydGVkICYmIHhBeGlzID8geEF4aXMubGVmdCAtIHBsb3RMZWZ0IDogMCk7IFxuXHRcdFx0XHRwbG90WSArPSAocG9pbnQucGxvdExvdyA/IChwb2ludC5wbG90TG93ICsgcG9pbnQucGxvdEhpZ2gpIC8gMiA6IHBvaW50LnBsb3RZKSArXG5cdFx0XHRcdFx0KCFpbnZlcnRlZCAmJiB5QXhpcyA/IHlBeGlzLnRvcCAtIHBsb3RUb3AgOiAwKTsgLy8gIzExNTFcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRwbG90WCAvPSBwb2ludHMubGVuZ3RoO1xuXHRcdFx0cGxvdFkgLz0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdFxuXHRcdFx0cmV0ID0gW1xuXHRcdFx0XHRpbnZlcnRlZCA/IGNoYXJ0LnBsb3RXaWR0aCAtIHBsb3RZIDogcGxvdFgsXG5cdFx0XHRcdHRoaXMuc2hhcmVkICYmICFpbnZlcnRlZCAmJiBwb2ludHMubGVuZ3RoID4gMSAmJiBtb3VzZUV2ZW50ID8gXG5cdFx0XHRcdFx0bW91c2VFdmVudC5jaGFydFkgLSBwbG90VG9wIDogLy8gcGxhY2Ugc2hhcmVkIHRvb2x0aXAgbmV4dCB0byB0aGUgbW91c2UgKCM0MjQpXG5cdFx0XHRcdFx0aW52ZXJ0ZWQgPyBjaGFydC5wbG90SGVpZ2h0IC0gcGxvdFggOiBwbG90WVxuXHRcdFx0XTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFwKHJldCwgbWF0aFJvdW5kKTtcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBQbGFjZSB0aGUgdG9vbHRpcCBpbiBhIGNoYXJ0IHdpdGhvdXQgc3BpbGxpbmcgb3ZlclxuXHQgKiBhbmQgbm90IGNvdmVyaW5nIHRoZSBwb2ludCBpdCBzZWxmLlxuXHQgKi9cblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uIChib3hXaWR0aCwgYm94SGVpZ2h0LCBwb2ludCkge1xuXHRcdFxuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRkaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UsXG5cdFx0XHRyZXQgPSB7fSxcblx0XHRcdGggPSBwb2ludC5oIHx8IDAsIC8vICM0MTE3XG5cdFx0XHRzd2FwcGVkLFxuXHRcdFx0Zmlyc3QgPSBbJ3knLCBjaGFydC5jaGFydEhlaWdodCwgYm94SGVpZ2h0LCBwb2ludC5wbG90WSArIGNoYXJ0LnBsb3RUb3AsIGNoYXJ0LnBsb3RUb3AsIGNoYXJ0LnBsb3RUb3AgKyBjaGFydC5wbG90SGVpZ2h0XSxcblx0XHRcdHNlY29uZCA9IFsneCcsIGNoYXJ0LmNoYXJ0V2lkdGgsIGJveFdpZHRoLCBwb2ludC5wbG90WCArIGNoYXJ0LnBsb3RMZWZ0LCBjaGFydC5wbG90TGVmdCwgY2hhcnQucGxvdExlZnQgKyBjaGFydC5wbG90V2lkdGhdLFxuXHRcdFx0Ly8gVGhlIGZhciBzaWRlIGlzIHJpZ2h0IG9yIGJvdHRvbVxuXHRcdFx0cHJlZmVyRmFyU2lkZSA9IHBpY2socG9pbnQudHRCZWxvdywgKGNoYXJ0LmludmVydGVkICYmICFwb2ludC5uZWdhdGl2ZSkgfHwgKCFjaGFydC5pbnZlcnRlZCAmJiBwb2ludC5uZWdhdGl2ZSkpLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBIYW5kbGUgdGhlIHByZWZlcnJlZCBkaW1lbnNpb24uIFdoZW4gdGhlIHByZWZlcnJlZCBkaW1lbnNpb24gaXMgdG9vbHRpcFxuXHRcdFx0ICogb24gdG9wIG9yIGJvdHRvbSBvZiB0aGUgcG9pbnQsIGl0IHdpbGwgbG9vayBmb3Igc3BhY2UgdGhlcmUuXG5cdFx0XHQgKi9cblx0XHRcdGZpcnN0RGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbSwgb3V0ZXJTaXplLCBpbm5lclNpemUsIHBvaW50LCBtaW4sIG1heCkge1xuXHRcdFx0XHR2YXIgcm9vbUxlZnQgPSBpbm5lclNpemUgPCBwb2ludCAtIGRpc3RhbmNlLFxuXHRcdFx0XHRcdHJvb21SaWdodCA9IHBvaW50ICsgZGlzdGFuY2UgKyBpbm5lclNpemUgPCBvdXRlclNpemUsXG5cdFx0XHRcdFx0YWxpZ25lZExlZnQgPSBwb2ludCAtIGRpc3RhbmNlIC0gaW5uZXJTaXplLFxuXHRcdFx0XHRcdGFsaWduZWRSaWdodCA9IHBvaW50ICsgZGlzdGFuY2U7XG5cblx0XHRcdFx0aWYgKHByZWZlckZhclNpZGUgJiYgcm9vbVJpZ2h0KSB7XG5cdFx0XHRcdFx0cmV0W2RpbV0gPSBhbGlnbmVkUmlnaHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXByZWZlckZhclNpZGUgJiYgcm9vbUxlZnQpIHtcblx0XHRcdFx0XHRyZXRbZGltXSA9IGFsaWduZWRMZWZ0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJvb21MZWZ0KSB7XG5cdFx0XHRcdFx0cmV0W2RpbV0gPSBtYXRoTWluKG1heCAtIGlubmVyU2l6ZSwgYWxpZ25lZExlZnQgLSBoIDwgMCA/IGFsaWduZWRMZWZ0IDogYWxpZ25lZExlZnQgLSBoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChyb29tUmlnaHQpIHtcblx0XHRcdFx0XHRyZXRbZGltXSA9IG1hdGhNYXgobWluLCBhbGlnbmVkUmlnaHQgKyBoICsgaW5uZXJTaXplID4gb3V0ZXJTaXplID8gYWxpZ25lZFJpZ2h0IDogYWxpZ25lZFJpZ2h0ICsgaCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBIYW5kbGUgdGhlIHNlY29uZGFyeSBkaW1lbnNpb24uIElmIHRoZSBwcmVmZXJyZWQgZGltZW5zaW9uIGlzIHRvb2x0aXBcblx0XHRcdCAqIG9uIHRvcCBvciBib3R0b20gb2YgdGhlIHBvaW50LCB0aGUgc2Vjb25kIGRpbWVuc2lvbiBpcyB0byBhbGlnbiB0aGUgdG9vbHRpcFxuXHRcdFx0ICogYWJvdmUgdGhlIHBvaW50LCB0cnlpbmcgdG8gYWxpZ24gY2VudGVyIGJ1dCBhbGxvd2luZyBsZWZ0IG9yIHJpZ2h0XG5cdFx0XHQgKiBhbGlnbiB3aXRoaW4gdGhlIGNoYXJ0IGJveC5cblx0XHRcdCAqL1xuXHRcdFx0c2Vjb25kRGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbSwgb3V0ZXJTaXplLCBpbm5lclNpemUsIHBvaW50KSB7XG5cdFx0XHRcdC8vIFRvbyBjbG9zZSB0byB0aGUgZWRnZSwgcmV0dXJuIGZhbHNlIGFuZCBzd2FwIGRpbWVuc2lvbnNcblx0XHRcdFx0aWYgKHBvaW50IDwgZGlzdGFuY2UgfHwgcG9pbnQgPiBvdXRlclNpemUgLSBkaXN0YW5jZSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEFsaWduIGxlZnQvdG9wXG5cdFx0XHRcdH0gZWxzZSBpZiAocG9pbnQgPCBpbm5lclNpemUgLyAyKSB7XG5cdFx0XHRcdFx0cmV0W2RpbV0gPSAxO1xuXHRcdFx0XHQvLyBBbGlnbiByaWdodC9ib3R0b21cblx0XHRcdFx0fSBlbHNlIGlmIChwb2ludCA+IG91dGVyU2l6ZSAtIGlubmVyU2l6ZSAvIDIpIHtcblx0XHRcdFx0XHRyZXRbZGltXSA9IG91dGVyU2l6ZSAtIGlubmVyU2l6ZSAtIDI7XG5cdFx0XHRcdC8vIEFsaWduIGNlbnRlclxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldFtkaW1dID0gcG9pbnQgLSBpbm5lclNpemUgLyAyO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTd2FwIHRoZSBkaW1lbnNpb25zIFxuXHRcdFx0ICovXG5cdFx0XHRzd2FwID0gZnVuY3Rpb24gKGNvdW50KSB7XG5cdFx0XHRcdHZhciB0ZW1wID0gZmlyc3Q7XG5cdFx0XHRcdGZpcnN0ID0gc2Vjb25kO1xuXHRcdFx0XHRzZWNvbmQgPSB0ZW1wO1xuXHRcdFx0XHRzd2FwcGVkID0gY291bnQ7XG5cdFx0XHR9LFxuXHRcdFx0cnVuID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoZmlyc3REaW1lbnNpb24uYXBwbHkoMCwgZmlyc3QpICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdGlmIChzZWNvbmREaW1lbnNpb24uYXBwbHkoMCwgc2Vjb25kKSA9PT0gZmFsc2UgJiYgIXN3YXBwZWQpIHtcblx0XHRcdFx0XHRcdHN3YXAodHJ1ZSk7XG5cdFx0XHRcdFx0XHRydW4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXN3YXBwZWQpIHtcblx0XHRcdFx0XHRzd2FwKHRydWUpO1xuXHRcdFx0XHRcdHJ1bigpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldC54ID0gcmV0LnkgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gVW5kZXIgdGhlc2UgY29uZGl0aW9ucywgcHJlZmVyIHRoZSB0b29sdGlwIG9uIHRoZSBzaWRlIG9mIHRoZSBwb2ludFxuXHRcdGlmIChjaGFydC5pbnZlcnRlZCB8fCB0aGlzLmxlbiA+IDEpIHtcblx0XHRcdHN3YXAoKTtcblx0XHR9XG5cdFx0cnVuKCk7XG5cblx0XHRyZXR1cm4gcmV0O1xuXHRcblx0fSxcblxuXHQvKipcblx0ICogSW4gY2FzZSBubyB1c2VyIGRlZmluZWQgZm9ybWF0dGVyIGlzIGdpdmVuLCB0aGlzIHdpbGwgYmUgdXNlZC4gTm90ZSB0aGF0IHRoZSBjb250ZXh0XG5cdCAqIGhlcmUgaXMgYW4gb2JqZWN0IGhvbGRpbmcgcG9pbnQsIHNlcmllcywgeCwgeSBldGMuXG5cdCAqL1xuXHRkZWZhdWx0Rm9ybWF0dGVyOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdHZhciBpdGVtcyA9IHRoaXMucG9pbnRzIHx8IHNwbGF0KHRoaXMpLFxuXHRcdFx0cztcblxuXHRcdC8vIGJ1aWxkIHRoZSBoZWFkZXJcblx0XHRzID0gW3Rvb2x0aXAudG9vbHRpcEZvb3RlckhlYWRlckZvcm1hdHRlcihpdGVtc1swXSldOyAvLyMzMzk3OiBhYnN0cmFjdGlvbiB0byBlbmFibGUgZm9ybWF0dGluZyBvZiBmb290ZXIgYW5kIGhlYWRlclxuXG5cdFx0Ly8gYnVpbGQgdGhlIHZhbHVlc1xuXHRcdHMgPSBzLmNvbmNhdCh0b29sdGlwLmJvZHlGb3JtYXR0ZXIoaXRlbXMpKTtcblxuXHRcdC8vIGZvb3RlclxuXHRcdHMucHVzaCh0b29sdGlwLnRvb2x0aXBGb290ZXJIZWFkZXJGb3JtYXR0ZXIoaXRlbXNbMF0sIHRydWUpKTsgLy8jMzM5NzogYWJzdHJhY3Rpb24gdG8gZW5hYmxlIGZvcm1hdHRpbmcgb2YgZm9vdGVyIGFuZCBoZWFkZXJcblxuXHRcdHJldHVybiBzLmpvaW4oJycpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWZyZXNoIHRoZSB0b29sdGlwJ3MgdGV4dCBhbmQgcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludFxuXHQgKi9cblx0cmVmcmVzaDogZnVuY3Rpb24gKHBvaW50LCBtb3VzZUV2ZW50KSB7XG5cdFx0dmFyIHRvb2x0aXAgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSB0b29sdGlwLmNoYXJ0LFxuXHRcdFx0bGFiZWwgPSB0b29sdGlwLmxhYmVsLFxuXHRcdFx0b3B0aW9ucyA9IHRvb2x0aXAub3B0aW9ucyxcblx0XHRcdHgsXG5cdFx0XHR5LFxuXHRcdFx0YW5jaG9yLFxuXHRcdFx0dGV4dENvbmZpZyA9IHt9LFxuXHRcdFx0dGV4dCxcblx0XHRcdHBvaW50Q29uZmlnID0gW10sXG5cdFx0XHRmb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCB0b29sdGlwLmRlZmF1bHRGb3JtYXR0ZXIsXG5cdFx0XHRob3ZlclBvaW50cyA9IGNoYXJ0LmhvdmVyUG9pbnRzLFxuXHRcdFx0Ym9yZGVyQ29sb3IsXG5cdFx0XHRzaGFyZWQgPSB0b29sdGlwLnNoYXJlZCxcblx0XHRcdGN1cnJlbnRTZXJpZXM7XG5cdFx0XHRcblx0XHRjbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO1xuXHRcdFxuXHRcdC8vIGdldCB0aGUgcmVmZXJlbmNlIHBvaW50IGNvb3JkaW5hdGVzIChwaWUgY2hhcnRzIHVzZSB0b29sdGlwUG9zKVxuXHRcdHRvb2x0aXAuZm9sbG93UG9pbnRlciA9IHNwbGF0KHBvaW50KVswXS5zZXJpZXMudG9vbHRpcE9wdGlvbnMuZm9sbG93UG9pbnRlcjtcblx0XHRhbmNob3IgPSB0b29sdGlwLmdldEFuY2hvcihwb2ludCwgbW91c2VFdmVudCk7XG5cdFx0eCA9IGFuY2hvclswXTtcblx0XHR5ID0gYW5jaG9yWzFdO1xuXG5cdFx0Ly8gc2hhcmVkIHRvb2x0aXAsIGFycmF5IGlzIHNlbnQgb3ZlclxuXHRcdGlmIChzaGFyZWQgJiYgIShwb2ludC5zZXJpZXMgJiYgcG9pbnQuc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCkpIHtcblx0XHRcdFxuXHRcdFx0Ly8gaGlkZSBwcmV2aW91cyBob3ZlclBvaW50cyBhbmQgc2V0IG5ld1xuXHRcdFx0XG5cdFx0XHRjaGFydC5ob3ZlclBvaW50cyA9IHBvaW50O1xuXHRcdFx0aWYgKGhvdmVyUG9pbnRzKSB7XG5cdFx0XHRcdGVhY2goaG92ZXJQb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRcdHBvaW50LnNldFN0YXRlKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRlYWNoKHBvaW50LCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0XHRpdGVtLnNldFN0YXRlKEhPVkVSX1NUQVRFKTtcblxuXHRcdFx0XHRwb2ludENvbmZpZy5wdXNoKGl0ZW0uZ2V0TGFiZWxDb25maWcoKSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGV4dENvbmZpZyA9IHtcblx0XHRcdFx0eDogcG9pbnRbMF0uY2F0ZWdvcnksXG5cdFx0XHRcdHk6IHBvaW50WzBdLnlcblx0XHRcdH07XG5cdFx0XHR0ZXh0Q29uZmlnLnBvaW50cyA9IHBvaW50Q29uZmlnO1xuXHRcdFx0dGhpcy5sZW4gPSBwb2ludENvbmZpZy5sZW5ndGg7XG5cdFx0XHRwb2ludCA9IHBvaW50WzBdO1xuXG5cdFx0Ly8gc2luZ2xlIHBvaW50IHRvb2x0aXBcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGV4dENvbmZpZyA9IHBvaW50LmdldExhYmVsQ29uZmlnKCk7XG5cdFx0fVxuXHRcdHRleHQgPSBmb3JtYXR0ZXIuY2FsbCh0ZXh0Q29uZmlnLCB0b29sdGlwKTtcblxuXHRcdC8vIHJlZ2lzdGVyIHRoZSBjdXJyZW50IHNlcmllc1xuXHRcdGN1cnJlbnRTZXJpZXMgPSBwb2ludC5zZXJpZXM7XG5cdFx0dGhpcy5kaXN0YW5jZSA9IHBpY2soY3VycmVudFNlcmllcy50b29sdGlwT3B0aW9ucy5kaXN0YW5jZSwgMTYpO1xuXG5cdFx0Ly8gdXBkYXRlIHRoZSBpbm5lciBIVE1MXG5cdFx0aWYgKHRleHQgPT09IGZhbHNlKSB7XG5cdFx0XHR0aGlzLmhpZGUoKTtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBzaG93IGl0XG5cdFx0XHRpZiAodG9vbHRpcC5pc0hpZGRlbikge1xuXHRcdFx0XHRzdG9wKGxhYmVsKTtcblx0XHRcdFx0bGFiZWwuYXR0cignb3BhY2l0eScsIDEpLnNob3coKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdXBkYXRlIHRleHRcblx0XHRcdGxhYmVsLmF0dHIoe1xuXHRcdFx0XHR0ZXh0OiB0ZXh0XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gc2V0IHRoZSBzdHJva2UgY29sb3Igb2YgdGhlIGJveFxuXHRcdFx0Ym9yZGVyQ29sb3IgPSBvcHRpb25zLmJvcmRlckNvbG9yIHx8IHBvaW50LmNvbG9yIHx8IGN1cnJlbnRTZXJpZXMuY29sb3IgfHwgJyM2MDYwNjAnO1xuXHRcdFx0bGFiZWwuYXR0cih7XG5cdFx0XHRcdHN0cm9rZTogYm9yZGVyQ29sb3Jcblx0XHRcdH0pO1xuXHRcdFx0dG9vbHRpcC51cGRhdGVQb3NpdGlvbih7IFxuXHRcdFx0XHRwbG90WDogeCwgXG5cdFx0XHRcdHBsb3RZOiB5LCBcblx0XHRcdFx0bmVnYXRpdmU6IHBvaW50Lm5lZ2F0aXZlLCBcblx0XHRcdFx0dHRCZWxvdzogcG9pbnQudHRCZWxvdywgXG5cdFx0XHRcdGg6IGFuY2hvclsyXSB8fCAwXG5cdFx0XHR9KTtcblx0XHRcblx0XHRcdHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcblx0XHR9XG5cdFx0ZmlyZUV2ZW50KGNoYXJ0LCAndG9vbHRpcFJlZnJlc2gnLCB7XG5cdFx0XHRcdHRleHQ6IHRleHQsXG5cdFx0XHRcdHg6IHggKyBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0eTogeSArIGNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdGJvcmRlckNvbG9yOiBib3JkZXJDb2xvclxuXHRcdFx0fSk7XG5cdH0sXG5cdFxuXHQvKipcblx0ICogRmluZCB0aGUgbmV3IHBvc2l0aW9uIGFuZCBwZXJmb3JtIHRoZSBtb3ZlXG5cdCAqL1xuXHR1cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdGxhYmVsID0gdGhpcy5sYWJlbCwgXG5cdFx0XHRwb3MgPSAodGhpcy5vcHRpb25zLnBvc2l0aW9uZXIgfHwgdGhpcy5nZXRQb3NpdGlvbikuY2FsbChcblx0XHRcdFx0dGhpcyxcblx0XHRcdFx0bGFiZWwud2lkdGgsXG5cdFx0XHRcdGxhYmVsLmhlaWdodCxcblx0XHRcdFx0cG9pbnRcblx0XHRcdCk7XG5cblx0XHQvLyBkbyB0aGUgbW92ZVxuXHRcdHRoaXMubW92ZShcblx0XHRcdG1hdGhSb3VuZChwb3MueCksIFxuXHRcdFx0bWF0aFJvdW5kKHBvcy55IHx8IDApLCAvLyBjYW4gYmUgdW5kZWZpbmVkICgjMzk3NykgXG5cdFx0XHRwb2ludC5wbG90WCArIGNoYXJ0LnBsb3RMZWZ0LCBcblx0XHRcdHBvaW50LnBsb3RZICsgY2hhcnQucGxvdFRvcFxuXHRcdCk7XG5cdH0sXG5cblx0LyoqIFxuXHQgKiBHZXQgdGhlIGJlc3QgWCBkYXRlIGZvcm1hdCBiYXNlZCBvbiB0aGUgY2xvc2VzdCBwb2ludCByYW5nZSBvbiB0aGUgYXhpcy5cblx0ICovXG5cdGdldFhEYXRlRm9ybWF0OiBmdW5jdGlvbiAocG9pbnQsIG9wdGlvbnMsIHhBeGlzKSB7XG5cdFx0dmFyIHhEYXRlRm9ybWF0LFxuXHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdHMgPSBvcHRpb25zLmRhdGVUaW1lTGFiZWxGb3JtYXRzLFxuXHRcdFx0Y2xvc2VzdFBvaW50UmFuZ2UgPSB4QXhpcyAmJiB4QXhpcy5jbG9zZXN0UG9pbnRSYW5nZSxcblx0XHRcdG4sXG5cdFx0XHRibGFuayA9ICcwMS0wMSAwMDowMDowMC4wMDAnLFxuXHRcdFx0c3RycG9zID0ge1xuXHRcdFx0XHRtaWxsaXNlY29uZDogMTUsXG5cdFx0XHRcdHNlY29uZDogMTIsXG5cdFx0XHRcdG1pbnV0ZTogOSxcblx0XHRcdFx0aG91cjogNixcblx0XHRcdFx0ZGF5OiAzXG5cdFx0XHR9LFxuXHRcdFx0ZGF0ZSxcblx0XHRcdGxhc3ROID0gJ21pbGxpc2Vjb25kJzsgLy8gZm9yIHN1Yi1taWxsaXNlY29uZCBkYXRhLCAjNDIyM1xuXG5cdFx0aWYgKGNsb3Nlc3RQb2ludFJhbmdlKSB7XG5cdFx0XHRkYXRlID0gZGF0ZUZvcm1hdCgnJW0tJWQgJUg6JU06JVMuJUwnLCBwb2ludC54KTtcblx0XHRcdGZvciAobiBpbiB0aW1lVW5pdHMpIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgcmFuZ2UgaXMgZXhhY3RseSBvbmUgd2VlayBhbmQgd2UncmUgbG9va2luZyBhdCBhIFN1bmRheS9Nb25kYXksIGdvIGZvciB0aGUgd2VlayBmb3JtYXRcblx0XHRcdFx0aWYgKGNsb3Nlc3RQb2ludFJhbmdlID09PSB0aW1lVW5pdHMud2VlayAmJiArZGF0ZUZvcm1hdCgnJXcnLCBwb2ludC54KSA9PT0geEF4aXMub3B0aW9ucy5zdGFydE9mV2VlayAmJiBcblx0XHRcdFx0XHRcdGRhdGUuc3Vic3RyKDYpID09PSBibGFuay5zdWJzdHIoNikpIHtcblx0XHRcdFx0XHRuID0gJ3dlZWsnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdC8vIFRoZSBmaXJzdCBmb3JtYXQgdGhhdCBpcyB0b28gZ3JlYXQgZm9yIHRoZSByYW5nZVxuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbWVVbml0c1tuXSA+IGNsb3Nlc3RQb2ludFJhbmdlKSB7XG5cdFx0XHRcdFx0biA9IGxhc3ROO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSWYgdGhlIHBvaW50IGlzIHBsYWNlZCBldmVyeSBkYXkgYXQgMjM6NTksIHdlIG5lZWQgdG8gc2hvd1xuXHRcdFx0XHQvLyB0aGUgbWludXRlcyBhcyB3ZWxsLiAjMjYzNy5cblx0XHRcdFx0fSBlbHNlIGlmIChzdHJwb3Nbbl0gJiYgZGF0ZS5zdWJzdHIoc3RycG9zW25dKSAhPT0gYmxhbmsuc3Vic3RyKHN0cnBvc1tuXSkpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlZWtzIGFyZSBvdXRzaWRlIHRoZSBoaWVyYXJjaHksIG9ubHkgYXBwbHkgdGhlbSBvbiBNb25kYXlzL1N1bmRheXMgbGlrZSBpbiB0aGUgZmlyc3QgY29uZGl0aW9uXG5cdFx0XHRcdGlmIChuICE9PSAnd2VlaycpIHtcblx0XHRcdFx0XHRsYXN0TiA9IG47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKG4pIHtcblx0XHRcdFx0eERhdGVGb3JtYXQgPSBkYXRlVGltZUxhYmVsRm9ybWF0c1tuXTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0eERhdGVGb3JtYXQgPSBkYXRlVGltZUxhYmVsRm9ybWF0cy5kYXk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHhEYXRlRm9ybWF0IHx8IGRhdGVUaW1lTGFiZWxGb3JtYXRzLnllYXI7IC8vICMyNTQ2LCAyNTgxXG5cdH0sXG5cblx0LyoqXG5cdCAqIEZvcm1hdCB0aGUgZm9vdGVyL2hlYWRlciBvZiB0aGUgdG9vbHRpcFxuXHQgKiAjMzM5NzogYWJzdHJhY3Rpb24gdG8gZW5hYmxlIGZvcm1hdHRpbmcgb2YgZm9vdGVyIGFuZCBoZWFkZXJcblx0ICovXG5cdHRvb2x0aXBGb290ZXJIZWFkZXJGb3JtYXR0ZXI6IGZ1bmN0aW9uIChwb2ludCwgaXNGb290ZXIpIHtcblx0XHR2YXIgZm9vdE9ySGVhZCA9IGlzRm9vdGVyID8gJ2Zvb3RlcicgOiAnaGVhZGVyJyxcblx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdHRvb2x0aXBPcHRpb25zID0gc2VyaWVzLnRvb2x0aXBPcHRpb25zLFxuXHRcdFx0eERhdGVGb3JtYXQgPSB0b29sdGlwT3B0aW9ucy54RGF0ZUZvcm1hdCxcblx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0aXNEYXRlVGltZSA9IHhBeGlzICYmIHhBeGlzLm9wdGlvbnMudHlwZSA9PT0gJ2RhdGV0aW1lJyAmJiBpc051bWJlcihwb2ludC5rZXkpLFxuXHRcdFx0Zm9ybWF0U3RyaW5nID0gdG9vbHRpcE9wdGlvbnNbZm9vdE9ySGVhZCsnRm9ybWF0J107XG5cblx0XHQvLyBHdWVzcyB0aGUgYmVzdCBkYXRlIGZvcm1hdCBiYXNlZCBvbiB0aGUgY2xvc2VzdCBwb2ludCBkaXN0YW5jZSAoIzU2OCwgIzM0MTgpXG5cdFx0aWYgKGlzRGF0ZVRpbWUgJiYgIXhEYXRlRm9ybWF0KSB7XG5cdFx0XHR4RGF0ZUZvcm1hdCA9IHRoaXMuZ2V0WERhdGVGb3JtYXQocG9pbnQsIHRvb2x0aXBPcHRpb25zLCB4QXhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gSW5zZXJ0IHRoZSBmb290ZXIgZGF0ZSBmb3JtYXQgaWYgYW55XG5cdFx0aWYgKGlzRGF0ZVRpbWUgJiYgeERhdGVGb3JtYXQpIHtcblx0XHRcdGZvcm1hdFN0cmluZyA9IGZvcm1hdFN0cmluZy5yZXBsYWNlKCd7cG9pbnQua2V5fScsICd7cG9pbnQua2V5OicgKyB4RGF0ZUZvcm1hdCArICd9Jyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZvcm1hdChmb3JtYXRTdHJpbmcsIHtcblx0XHRcdHBvaW50OiBwb2ludCxcblx0XHRcdHNlcmllczogc2VyaWVzXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICAgICogQnVpbGQgdGhlIGJvZHkgKGxpbmVzKSBvZiB0aGUgdG9vbHRpcCBieSBpdGVyYXRpbmcgb3ZlciB0aGUgaXRlbXMgYW5kIHJldHVybmluZyBvbmUgZW50cnkgZm9yIGVhY2ggaXRlbSxcbiAgICAgKiBhYnN0cmFjdGluZyB0aGlzIGZ1bmN0aW9uYWxpdHkgYWxsb3dzIHRvIGVhc2lseSBvdmVyd3JpdGUgYW5kIGV4dGVuZCBpdC4gXG5cdCAqL1xuXHRib2R5Rm9ybWF0dGVyOiBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG1hcChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciB0b29sdGlwT3B0aW9ucyA9IGl0ZW0uc2VyaWVzLnRvb2x0aXBPcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuICh0b29sdGlwT3B0aW9ucy5wb2ludEZvcm1hdHRlciB8fCBpdGVtLnBvaW50LnRvb2x0aXBGb3JtYXR0ZXIpLmNhbGwoaXRlbS5wb2ludCwgdG9vbHRpcE9wdGlvbnMucG9pbnRGb3JtYXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG59O1xuXG52YXIgaG92ZXJDaGFydEluZGV4O1xuXG4vLyBHbG9iYWwgZmxhZyBmb3IgdG91Y2ggc3VwcG9ydFxuaGFzVG91Y2ggPSBkb2MuZG9jdW1lbnRFbGVtZW50Lm9udG91Y2hzdGFydCAhPT0gVU5ERUZJTkVEO1xuXG4vKipcbiAqIFRoZSBtb3VzZSB0cmFja2VyIG9iamVjdC4gQWxsIG1ldGhvZHMgc3RhcnRpbmcgd2l0aCBcIm9uXCIgYXJlIHByaW1hcnkgRE9NIGV2ZW50IGhhbmRsZXJzLiBcbiAqIFN1YnNlcXVlbnQgbWV0aG9kcyBzaG91bGQgYmUgbmFtZWQgZGlmZmVyZW50bHkgZnJvbSB3aGF0IHRoZXkgYXJlIGRvaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0IFRoZSBDaGFydCBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIHJvb3Qgb3B0aW9ucyBvYmplY3RcbiAqL1xudmFyIFBvaW50ZXIgPSBIaWdoY2hhcnRzLlBvaW50ZXIgPSBmdW5jdGlvbiAoY2hhcnQsIG9wdGlvbnMpIHtcblx0dGhpcy5pbml0KGNoYXJ0LCBvcHRpb25zKTtcbn07XG5cblBvaW50ZXIucHJvdG90eXBlID0ge1xuXHQvKipcblx0ICogSW5pdGlhbGl6ZSBQb2ludGVyXG5cdCAqL1xuXHRpbml0OiBmdW5jdGlvbiAoY2hhcnQsIG9wdGlvbnMpIHtcblx0XHRcblx0XHR2YXIgY2hhcnRPcHRpb25zID0gb3B0aW9ucy5jaGFydCxcblx0XHRcdGNoYXJ0RXZlbnRzID0gY2hhcnRPcHRpb25zLmV2ZW50cyxcblx0XHRcdHpvb21UeXBlID0gdXNlQ2FuVkcgPyAnJyA6IGNoYXJ0T3B0aW9ucy56b29tVHlwZSxcblx0XHRcdGludmVydGVkID0gY2hhcnQuaW52ZXJ0ZWQsXG5cdFx0XHR6b29tWCxcblx0XHRcdHpvb21ZO1xuXG5cdFx0Ly8gU3RvcmUgcmVmZXJlbmNlc1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5jaGFydCA9IGNoYXJ0O1xuXHRcdFxuXHRcdC8vIFpvb20gc3RhdHVzXG5cdFx0dGhpcy56b29tWCA9IHpvb21YID0gL3gvLnRlc3Qoem9vbVR5cGUpO1xuXHRcdHRoaXMuem9vbVkgPSB6b29tWSA9IC95Ly50ZXN0KHpvb21UeXBlKTtcblx0XHR0aGlzLnpvb21Ib3IgPSAoem9vbVggJiYgIWludmVydGVkKSB8fCAoem9vbVkgJiYgaW52ZXJ0ZWQpO1xuXHRcdHRoaXMuem9vbVZlcnQgPSAoem9vbVkgJiYgIWludmVydGVkKSB8fCAoem9vbVggJiYgaW52ZXJ0ZWQpO1xuXHRcdHRoaXMuaGFzWm9vbSA9IHpvb21YIHx8IHpvb21ZO1xuXG5cdFx0Ly8gRG8gd2UgbmVlZCB0byBoYW5kbGUgY2xpY2sgb24gYSB0b3VjaCBkZXZpY2U/XG5cdFx0dGhpcy5ydW5DaGFydENsaWNrID0gY2hhcnRFdmVudHMgJiYgISFjaGFydEV2ZW50cy5jbGljaztcblxuXHRcdHRoaXMucGluY2hEb3duID0gW107XG5cdFx0dGhpcy5sYXN0VmFsaWRUb3VjaCA9IHt9O1xuXG5cdFx0aWYgKEhpZ2hjaGFydHMuVG9vbHRpcCAmJiBvcHRpb25zLnRvb2x0aXAuZW5hYmxlZCkge1xuXHRcdFx0Y2hhcnQudG9vbHRpcCA9IG5ldyBUb29sdGlwKGNoYXJ0LCBvcHRpb25zLnRvb2x0aXApO1xuXHRcdFx0dGhpcy5mb2xsb3dUb3VjaE1vdmUgPSBwaWNrKG9wdGlvbnMudG9vbHRpcC5mb2xsb3dUb3VjaE1vdmUsIHRydWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuc2V0RE9NRXZlbnRzKCk7XG5cdH0sIFxuXG5cdC8qKlxuXHQgKiBBZGQgY3Jvc3Nicm93c2VyIHN1cHBvcnQgZm9yIGNoYXJ0WCBhbmQgY2hhcnRZXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCBvYmplY3QgaW4gc3RhbmRhcmQgYnJvd3NlcnNcblx0ICovXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKGUsIGNoYXJ0UG9zaXRpb24pIHtcblx0XHR2YXIgY2hhcnRYLFxuXHRcdFx0Y2hhcnRZLFxuXHRcdFx0ZVBvcztcblxuXHRcdC8vIGNvbW1vbiBJRSBub3JtYWxpemluZ1xuXHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuXHRcdC8vIEZyYW1ld29yayBzcGVjaWZpYyBub3JtYWxpemluZyAoIzExNjUpXG5cdFx0ZSA9IHdhc2hNb3VzZUV2ZW50KGUpO1xuXG5cdFx0Ly8gTW9yZSBJRSBub3JtYWxpemluZywgbmVlZHMgdG8gZ28gYWZ0ZXIgd2FzaE1vdXNlRXZlbnRcblx0XHRpZiAoIWUudGFyZ2V0KSB7XG5cdFx0XHRlLnRhcmdldCA9IGUuc3JjRWxlbWVudDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gaU9TICgjMjc1Nylcblx0XHRlUG9zID0gZS50b3VjaGVzID8gIChlLnRvdWNoZXMubGVuZ3RoID8gZS50b3VjaGVzLml0ZW0oMCkgOiBlLmNoYW5nZWRUb3VjaGVzWzBdKSA6IGU7XG5cblx0XHQvLyBHZXQgbW91c2UgcG9zaXRpb25cblx0XHRpZiAoIWNoYXJ0UG9zaXRpb24pIHtcblx0XHRcdHRoaXMuY2hhcnRQb3NpdGlvbiA9IGNoYXJ0UG9zaXRpb24gPSBvZmZzZXQodGhpcy5jaGFydC5jb250YWluZXIpO1xuXHRcdH1cblxuXHRcdC8vIGNoYXJ0WCBhbmQgY2hhcnRZXG5cdFx0aWYgKGVQb3MucGFnZVggPT09IFVOREVGSU5FRCkgeyAvLyBJRSA8IDkuICM4ODYuXG5cdFx0XHRjaGFydFggPSBtYXRoTWF4KGUueCwgZS5jbGllbnRYIC0gY2hhcnRQb3NpdGlvbi5sZWZ0KTsgLy8gIzIwMDUsICMyMTI5OiB0aGUgc2Vjb25kIGNhc2UgaXMgXG5cdFx0XHRcdC8vIGZvciBJRTEwIHF1aXJrcyBtb2RlIHdpdGhpbiBmcmFtZXNldHNcblx0XHRcdGNoYXJ0WSA9IGUueTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hhcnRYID0gZVBvcy5wYWdlWCAtIGNoYXJ0UG9zaXRpb24ubGVmdDtcblx0XHRcdGNoYXJ0WSA9IGVQb3MucGFnZVkgLSBjaGFydFBvc2l0aW9uLnRvcDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXh0ZW5kKGUsIHtcblx0XHRcdGNoYXJ0WDogbWF0aFJvdW5kKGNoYXJ0WCksXG5cdFx0XHRjaGFydFk6IG1hdGhSb3VuZChjaGFydFkpXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY2xpY2sgcG9zaXRpb24gaW4gdGVybXMgb2YgYXhpcyB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlIEEgcG9pbnRlciBldmVudFxuXHQgKi9cblx0Z2V0Q29vcmRpbmF0ZXM6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGNvb3JkaW5hdGVzID0ge1xuXHRcdFx0XHR4QXhpczogW10sXG5cdFx0XHRcdHlBeGlzOiBbXVxuXHRcdFx0fTtcblxuXHRcdGVhY2godGhpcy5jaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0Y29vcmRpbmF0ZXNbYXhpcy5pc1hBeGlzID8gJ3hBeGlzJyA6ICd5QXhpcyddLnB1c2goe1xuXHRcdFx0XHRheGlzOiBheGlzLFxuXHRcdFx0XHR2YWx1ZTogYXhpcy50b1ZhbHVlKGVbYXhpcy5ob3JpeiA/ICdjaGFydFgnIDogJ2NoYXJ0WSddKVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGNvb3JkaW5hdGVzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIFdpdGggbGluZSB0eXBlIGNoYXJ0cyB3aXRoIGEgc2luZ2xlIHRyYWNrZXIsIGdldCB0aGUgcG9pbnQgY2xvc2VzdCB0byB0aGUgbW91c2UuXG5cdCAqIFJ1biBQb2ludC5vbk1vdXNlT3ZlciBhbmQgZGlzcGxheSB0b29sdGlwIGZvciB0aGUgcG9pbnQgb3IgcG9pbnRzLlxuXHQgKi9cblx0cnVuUG9pbnRBY3Rpb25zOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0dmFyIHBvaW50ZXIgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBwb2ludGVyLmNoYXJ0LFxuXHRcdFx0c2VyaWVzID0gY2hhcnQuc2VyaWVzLFxuXHRcdFx0dG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXAsXG5cdFx0XHRzaGFyZWQgPSB0b29sdGlwID8gdG9vbHRpcC5zaGFyZWQgOiBmYWxzZSxcblx0XHRcdGZvbGxvd1BvaW50ZXIsXG5cdFx0XHRob3ZlclBvaW50ID0gY2hhcnQuaG92ZXJQb2ludCxcblx0XHRcdGhvdmVyU2VyaWVzID0gY2hhcnQuaG92ZXJTZXJpZXMsXG5cdFx0XHRpLFxuXHRcdFx0ZGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFLCAvLyAjNDUxMVxuXHRcdFx0YW5jaG9yLFxuXHRcdFx0bm9TaGFyZWRUb29sdGlwLFxuXHRcdFx0c3RpY2tUb0hvdmVyU2VyaWVzLFxuXHRcdFx0ZGlyZWN0VG91Y2gsXG5cdFx0XHRrZHBvaW50cyA9IFtdLFxuXHRcdFx0a2Rwb2ludCxcblx0XHRcdGtkcG9pbnRUO1xuXG5cdFx0Ly8gRm9yIGhvdmVyaW5nIG92ZXIgdGhlIGVtcHR5IHBhcnRzIG9mIHRoZSBwbG90IGFyZWEgKGhvdmVyU2VyaWVzIGlzIHVuZGVmaW5lZCkuIFxuXHRcdC8vIElmIHRoZXJlIGlzIG9uZSBzZXJpZXMgd2l0aCBwb2ludCB0cmFja2luZyAoY29tYm8gY2hhcnQpLCBkb24ndCBnbyB0byBuZWFyZXN0IG5laWdoYm91ci5cblx0XHRpZiAoIXNoYXJlZCAmJiAhaG92ZXJTZXJpZXMpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHNlcmllc1tpXS5kaXJlY3RUb3VjaCB8fCAhc2VyaWVzW2ldLm9wdGlvbnMuc3RpY2t5VHJhY2tpbmcpIHtcblx0XHRcdFx0XHRzZXJpZXMgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIGl0IGhhcyBhIGhvdmVyUG9pbnQgYW5kIHRoYXQgc2VyaWVzIHJlcXVpcmVzIGRpcmVjdCB0b3VjaCAobGlrZSBjb2x1bW5zLCAjMzg5OSksIG9yIHdlJ3JlIG9uIFxuXHRcdC8vIGEgbm9TaGFyZWRUb29sdGlwIHNlcmllcyBhbW9uZyBzaGFyZWQgdG9vbHRpcCBzZXJpZXMgKCM0NTQ2KSwgdXNlIHRoZSBob3ZlclBvaW50IC4gT3RoZXJ3aXNlLCBcblx0XHQvLyBzZWFyY2ggdGhlIGstZCB0cmVlLlxuXHRcdHN0aWNrVG9Ib3ZlclNlcmllcyA9IGhvdmVyU2VyaWVzICYmIChzaGFyZWQgPyBob3ZlclNlcmllcy5ub1NoYXJlZFRvb2x0aXAgOiBob3ZlclNlcmllcy5kaXJlY3RUb3VjaCk7XG5cdFx0aWYgKHN0aWNrVG9Ib3ZlclNlcmllcyAmJiBob3ZlclBvaW50KSB7XG5cdFx0XHRrZHBvaW50ID0gaG92ZXJQb2ludDtcblxuXHRcdC8vIEhhbmRsZSBzaGFyZWQgdG9vbHRpcCBvciBjYXNlcyB3aGVyZSBhIHNlcmllcyBpcyBub3QgeWV0IGhvdmVyZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRmluZCBuZWFyZXN0IHBvaW50cyBvbiBhbGwgc2VyaWVzXG5cdFx0XHRlYWNoKHNlcmllcywgZnVuY3Rpb24gKHMpIHtcblx0XHRcdFx0Ly8gU2tpcCBoaWRkZW4gc2VyaWVzXG5cdFx0XHRcdG5vU2hhcmVkVG9vbHRpcCA9IHMubm9TaGFyZWRUb29sdGlwICYmIHNoYXJlZDtcblx0XHRcdFx0ZGlyZWN0VG91Y2ggPSAhc2hhcmVkICYmIHMuZGlyZWN0VG91Y2g7XG5cdFx0XHRcdGlmIChzLnZpc2libGUgJiYgIW5vU2hhcmVkVG9vbHRpcCAmJiAhZGlyZWN0VG91Y2ggJiYgcGljayhzLm9wdGlvbnMuZW5hYmxlTW91c2VUcmFja2luZywgdHJ1ZSkpIHsgLy8gIzM4MjFcblx0XHRcdFx0XHRrZHBvaW50VCA9IHMuc2VhcmNoUG9pbnQoZSwgIW5vU2hhcmVkVG9vbHRpcCAmJiBzLmtkRGltZW5zaW9ucyA9PT0gMSk7IC8vICMzODI4XG5cdFx0XHRcdFx0aWYgKGtkcG9pbnRUKSB7XG5cdFx0XHRcdFx0XHRrZHBvaW50cy5wdXNoKGtkcG9pbnRUKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0Ly8gRmluZCBhYnNvbHV0ZSBuZWFyZXN0IHBvaW50XG5cdFx0XHRlYWNoKGtkcG9pbnRzLCBmdW5jdGlvbiAocCkge1xuXHRcdFx0XHRpZiAocCAmJiB0eXBlb2YgcC5kaXN0ID09PSAnbnVtYmVyJyAmJiBwLmRpc3QgPCBkaXN0YW5jZSkge1xuXHRcdFx0XHRcdGRpc3RhbmNlID0gcC5kaXN0O1xuXHRcdFx0XHRcdGtkcG9pbnQgPSBwO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBSZWZyZXNoIHRvb2x0aXAgZm9yIGtkcG9pbnQgaWYgbmV3IGhvdmVyIHBvaW50IG9yIHRvb2x0aXAgd2FzIGhpZGRlbiAvLyAjMzkyNiwgIzQyMDBcblx0XHRpZiAoa2Rwb2ludCAmJiAoa2Rwb2ludCAhPT0gdGhpcy5wcmV2S0RQb2ludCB8fCAodG9vbHRpcCAmJiB0b29sdGlwLmlzSGlkZGVuKSkpIHtcblx0XHRcdC8vIERyYXcgdG9vbHRpcCBpZiBuZWNlc3Nhcnlcblx0XHRcdGlmIChzaGFyZWQgJiYgIWtkcG9pbnQuc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCkge1xuXHRcdFx0XHRpID0ga2Rwb2ludHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0aWYgKGtkcG9pbnRzW2ldLmNsaWVudFggIT09IGtkcG9pbnQuY2xpZW50WCB8fCBrZHBvaW50c1tpXS5zZXJpZXMubm9TaGFyZWRUb29sdGlwKSB7XG5cdFx0XHRcdFx0XHRrZHBvaW50cy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChrZHBvaW50cy5sZW5ndGggJiYgdG9vbHRpcCkge1xuXHRcdFx0XHRcdHRvb2x0aXAucmVmcmVzaChrZHBvaW50cywgZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEbyBtb3VzZW92ZXIgb24gYWxsIHBvaW50cyAoIzM5MTksICMzOTg1LCAjNDQxMClcblx0XHRcdFx0ZWFjaChrZHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdFx0cG9pbnQub25Nb3VzZU92ZXIoZSwgcG9pbnQgIT09ICgoaG92ZXJTZXJpZXMgJiYgaG92ZXJTZXJpZXMuZGlyZWN0VG91Y2ggJiYgaG92ZXJQb2ludCkgfHwga2Rwb2ludCkpO1xuXHRcdFx0XHR9KTsgXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodG9vbHRpcCkgeyBcblx0XHRcdFx0XHR0b29sdGlwLnJlZnJlc2goa2Rwb2ludCwgZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIWhvdmVyU2VyaWVzIHx8ICFob3ZlclNlcmllcy5kaXJlY3RUb3VjaCkgeyAvLyAjNDQ0OFxuXHRcdFx0XHRcdGtkcG9pbnQub25Nb3VzZU92ZXIoZSk7IFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnByZXZLRFBvaW50ID0ga2Rwb2ludDtcblx0XHRcblx0XHQvLyBVcGRhdGUgcG9zaXRpb25zIChyZWdhcmRsZXNzIG9mIGtkcG9pbnQgb3IgaG92ZXJQb2ludClcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9sbG93UG9pbnRlciA9IGhvdmVyU2VyaWVzICYmIGhvdmVyU2VyaWVzLnRvb2x0aXBPcHRpb25zLmZvbGxvd1BvaW50ZXI7XG5cdFx0XHRpZiAodG9vbHRpcCAmJiBmb2xsb3dQb2ludGVyICYmICF0b29sdGlwLmlzSGlkZGVuKSB7XG5cdFx0XHRcdGFuY2hvciA9IHRvb2x0aXAuZ2V0QW5jaG9yKFt7fV0sIGUpO1xuXHRcdFx0XHR0b29sdGlwLnVwZGF0ZVBvc2l0aW9uKHsgcGxvdFg6IGFuY2hvclswXSwgcGxvdFk6IGFuY2hvclsxXSB9KTtcdFx0XHRcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdGFydCB0aGUgZXZlbnQgbGlzdGVuZXIgdG8gcGljayB1cCB0aGUgdG9vbHRpcCBcblx0XHRpZiAodG9vbHRpcCAmJiAhcG9pbnRlci5fb25Eb2N1bWVudE1vdXNlTW92ZSkge1xuXHRcdFx0cG9pbnRlci5fb25Eb2N1bWVudE1vdXNlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmIChjaGFydHNbaG92ZXJDaGFydEluZGV4XSkge1xuXHRcdFx0XHRcdGNoYXJ0c1tob3ZlckNoYXJ0SW5kZXhdLnBvaW50ZXIub25Eb2N1bWVudE1vdXNlTW92ZShlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGFkZEV2ZW50KGRvYywgJ21vdXNlbW92ZScsIHBvaW50ZXIuX29uRG9jdW1lbnRNb3VzZU1vdmUpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBDcm9zc2hhaXJcblx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRheGlzLmRyYXdDcm9zc2hhaXIoZSwgcGljayhrZHBvaW50LCBob3ZlclBvaW50KSk7XG5cdFx0fSk7XHRcblx0XHRcblxuXHR9LFxuXG5cblxuXHQvKipcblx0ICogUmVzZXQgdGhlIHRyYWNraW5nIGJ5IGhpZGluZyB0aGUgdG9vbHRpcCwgdGhlIGhvdmVyIHNlcmllcyBzdGF0ZSBhbmQgdGhlIGhvdmVyIHBvaW50XG5cdCAqIFxuXHQgKiBAcGFyYW0gYWxsb3dNb3ZlIHtCb29sZWFufSBJbnN0ZWFkIG9mIGRlc3Ryb3lpbmcgdGhlIHRvb2x0aXAgYWx0b2dldGhlciwgYWxsb3cgbW92aW5nIGl0IGlmIHBvc3NpYmxlXG5cdCAqL1xuXHRyZXNldDogZnVuY3Rpb24gKGFsbG93TW92ZSwgZGVsYXkpIHtcblx0XHR2YXIgcG9pbnRlciA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHBvaW50ZXIuY2hhcnQsXG5cdFx0XHRob3ZlclNlcmllcyA9IGNoYXJ0LmhvdmVyU2VyaWVzLFxuXHRcdFx0aG92ZXJQb2ludCA9IGNoYXJ0LmhvdmVyUG9pbnQsXG5cdFx0XHRob3ZlclBvaW50cyA9IGNoYXJ0LmhvdmVyUG9pbnRzLFxuXHRcdFx0dG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXAsXG5cdFx0XHR0b29sdGlwUG9pbnRzID0gdG9vbHRpcCAmJiB0b29sdGlwLnNoYXJlZCA/IGhvdmVyUG9pbnRzIDogaG92ZXJQb2ludDtcblx0XHRcdFxuXHRcdC8vIE5hcnJvdyBpbiBhbGxvd01vdmVcblx0XHRhbGxvd01vdmUgPSBhbGxvd01vdmUgJiYgdG9vbHRpcCAmJiB0b29sdGlwUG9pbnRzO1xuXHRcdFx0XG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIHBvaW50cyBoYXZlIG1vdmVkIG91dHNpZGUgdGhlIHBsb3QgYXJlYSwgIzEwMDNcdFx0XG5cdFx0aWYgKGFsbG93TW92ZSAgJiYgc3BsYXQodG9vbHRpcFBvaW50cylbMF0ucGxvdFggPT09IFVOREVGSU5FRCkge1xuXHRcdFx0YWxsb3dNb3ZlID0gZmFsc2U7XG5cdFx0fVx0XG5cdFx0Ly8gSnVzdCBtb3ZlIHRoZSB0b29sdGlwLCAjMzQ5XG5cdFx0aWYgKGFsbG93TW92ZSkge1xuXHRcdFx0dG9vbHRpcC5yZWZyZXNoKHRvb2x0aXBQb2ludHMpO1xuXHRcdFx0aWYgKGhvdmVyUG9pbnQpIHsgLy8gIzI1MDBcblx0XHRcdFx0aG92ZXJQb2ludC5zZXRTdGF0ZShob3ZlclBvaW50LnN0YXRlLCB0cnVlKTtcblx0XHRcdFx0ZWFjaChjaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdGlmIChwaWNrKGF4aXMub3B0aW9ucy5jcm9zc2hhaXIgJiYgYXhpcy5vcHRpb25zLmNyb3NzaGFpci5zbmFwLCB0cnVlKSkge1xuXHRcdFx0XHRcdFx0YXhpcy5kcmF3Q3Jvc3NoYWlyKG51bGwsIGhvdmVyUG9pbnQpO1xuXHRcdFx0XHRcdH0gIGVsc2Uge1xuXHRcdFx0XHRcdFx0YXhpcy5oaWRlQ3Jvc3NoYWlyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHR9XG5cblx0XHQvLyBGdWxsIHJlc2V0XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKGhvdmVyUG9pbnQpIHtcblx0XHRcdFx0aG92ZXJQb2ludC5vbk1vdXNlT3V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChob3ZlclBvaW50cykge1xuXHRcdFx0XHRlYWNoKGhvdmVyUG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XHRwb2ludC5zZXRTdGF0ZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGhvdmVyU2VyaWVzKSB7XG5cdFx0XHRcdGhvdmVyU2VyaWVzLm9uTW91c2VPdXQoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdFx0dG9vbHRpcC5oaWRlKGRlbGF5KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBvaW50ZXIuX29uRG9jdW1lbnRNb3VzZU1vdmUpIHtcblx0XHRcdFx0cmVtb3ZlRXZlbnQoZG9jLCAnbW91c2Vtb3ZlJywgcG9pbnRlci5fb25Eb2N1bWVudE1vdXNlTW92ZSk7XG5cdFx0XHRcdHBvaW50ZXIuX29uRG9jdW1lbnRNb3VzZU1vdmUgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgY3Jvc3NoYWlyc1xuXHRcdFx0ZWFjaChjaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRheGlzLmhpZGVDcm9zc2hhaXIoKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRwb2ludGVyLmhvdmVyWCA9IGNoYXJ0LmhvdmVyUG9pbnRzID0gY2hhcnQuaG92ZXJQb2ludCA9IG51bGw7XG5cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNjYWxlIHNlcmllcyBncm91cHMgdG8gYSBjZXJ0YWluIHNjYWxlIGFuZCB0cmFuc2xhdGlvblxuXHQgKi9cblx0c2NhbGVHcm91cHM6IGZ1bmN0aW9uIChhdHRyaWJzLCBjbGlwKSB7XG5cblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0c2VyaWVzQXR0cmlicztcblxuXHRcdC8vIFNjYWxlIGVhY2ggc2VyaWVzXG5cdFx0ZWFjaChjaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdHNlcmllc0F0dHJpYnMgPSBhdHRyaWJzIHx8IHNlcmllcy5nZXRQbG90Qm94KCk7IC8vICMxNzAxXG5cdFx0XHRpZiAoc2VyaWVzLnhBeGlzICYmIHNlcmllcy54QXhpcy56b29tRW5hYmxlZCkge1xuXHRcdFx0XHRzZXJpZXMuZ3JvdXAuYXR0cihzZXJpZXNBdHRyaWJzKTtcblx0XHRcdFx0aWYgKHNlcmllcy5tYXJrZXJHcm91cCkge1xuXHRcdFx0XHRcdHNlcmllcy5tYXJrZXJHcm91cC5hdHRyKHNlcmllc0F0dHJpYnMpO1xuXHRcdFx0XHRcdHNlcmllcy5tYXJrZXJHcm91cC5jbGlwKGNsaXAgPyBjaGFydC5jbGlwUmVjdCA6IG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzZXJpZXMuZGF0YUxhYmVsc0dyb3VwKSB7XG5cdFx0XHRcdFx0c2VyaWVzLmRhdGFMYWJlbHNHcm91cC5hdHRyKHNlcmllc0F0dHJpYnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0XG5cdFx0Ly8gQ2xpcFxuXHRcdGNoYXJ0LmNsaXBSZWN0LmF0dHIoY2xpcCB8fCBjaGFydC5jbGlwQm94KTtcblx0fSxcblxuXHQvKipcblx0ICogU3RhcnQgYSBkcmFnIG9wZXJhdGlvblxuXHQgKi9cblx0ZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cblx0XHQvLyBSZWNvcmQgdGhlIHN0YXJ0IHBvc2l0aW9uXG5cdFx0Y2hhcnQubW91c2VJc0Rvd24gPSBlLnR5cGU7XG5cdFx0Y2hhcnQuY2FuY2VsQ2xpY2sgPSBmYWxzZTtcblx0XHRjaGFydC5tb3VzZURvd25YID0gdGhpcy5tb3VzZURvd25YID0gZS5jaGFydFg7XG5cdFx0Y2hhcnQubW91c2VEb3duWSA9IHRoaXMubW91c2VEb3duWSA9IGUuY2hhcnRZO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtIGEgZHJhZyBvcGVyYXRpb24gaW4gcmVzcG9uc2UgdG8gYSBtb3VzZW1vdmUgZXZlbnQgd2hpbGUgdGhlIG1vdXNlIGlzIGRvd25cblx0ICovXG5cdGRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0Y2hhcnRPcHRpb25zID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdGNoYXJ0WCA9IGUuY2hhcnRYLFxuXHRcdFx0Y2hhcnRZID0gZS5jaGFydFksXG5cdFx0XHR6b29tSG9yID0gdGhpcy56b29tSG9yLFxuXHRcdFx0em9vbVZlcnQgPSB0aGlzLnpvb21WZXJ0LFxuXHRcdFx0cGxvdExlZnQgPSBjaGFydC5wbG90TGVmdCxcblx0XHRcdHBsb3RUb3AgPSBjaGFydC5wbG90VG9wLFxuXHRcdFx0cGxvdFdpZHRoID0gY2hhcnQucGxvdFdpZHRoLFxuXHRcdFx0cGxvdEhlaWdodCA9IGNoYXJ0LnBsb3RIZWlnaHQsXG5cdFx0XHRjbGlja2VkSW5zaWRlLFxuXHRcdFx0c2l6ZSxcblx0XHRcdHNlbGVjdGlvbk1hcmtlciA9IHRoaXMuc2VsZWN0aW9uTWFya2VyLFxuXHRcdFx0bW91c2VEb3duWCA9IHRoaXMubW91c2VEb3duWCxcblx0XHRcdG1vdXNlRG93blkgPSB0aGlzLm1vdXNlRG93blksXG5cdFx0XHRwYW5LZXkgPSBjaGFydE9wdGlvbnMucGFuS2V5ICYmIGVbY2hhcnRPcHRpb25zLnBhbktleSArICdLZXknXTtcblxuXHRcdC8vIElmIHRoZSBkZXZpY2Ugc3VwcG9ydHMgYm90aCB0b3VjaCBhbmQgbW91c2UgKGxpa2UgSUUxMSksIGFuZCB3ZSBhcmUgdG91Y2gtZHJhZ2dpbmdcblx0XHQvLyBpbnNpZGUgdGhlIHBsb3QgYXJlYSwgZG9uJ3QgaGFuZGxlIHRoZSBtb3VzZSBldmVudC4gIzQzMzkuXG5cdFx0aWYgKHNlbGVjdGlvbk1hcmtlciAmJiBzZWxlY3Rpb25NYXJrZXIudG91Y2gpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbW91c2UgaXMgb3V0c2lkZSB0aGUgcGxvdCBhcmVhLCBhZGp1c3QgdG8gY29vb3JkaW5hdGVzXG5cdFx0Ly8gaW5zaWRlIHRvIHByZXZlbnQgdGhlIHNlbGVjdGlvbiBtYXJrZXIgZnJvbSBnb2luZyBvdXRzaWRlXG5cdFx0aWYgKGNoYXJ0WCA8IHBsb3RMZWZ0KSB7XG5cdFx0XHRjaGFydFggPSBwbG90TGVmdDtcblx0XHR9IGVsc2UgaWYgKGNoYXJ0WCA+IHBsb3RMZWZ0ICsgcGxvdFdpZHRoKSB7XG5cdFx0XHRjaGFydFggPSBwbG90TGVmdCArIHBsb3RXaWR0aDtcblx0XHR9XG5cblx0XHRpZiAoY2hhcnRZIDwgcGxvdFRvcCkge1xuXHRcdFx0Y2hhcnRZID0gcGxvdFRvcDtcblx0XHR9IGVsc2UgaWYgKGNoYXJ0WSA+IHBsb3RUb3AgKyBwbG90SGVpZ2h0KSB7XG5cdFx0XHRjaGFydFkgPSBwbG90VG9wICsgcGxvdEhlaWdodDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gZGV0ZXJtaW5lIGlmIHRoZSBtb3VzZSBoYXMgbW92ZWQgbW9yZSB0aGFuIDEwcHhcblx0XHR0aGlzLmhhc0RyYWdnZWQgPSBNYXRoLnNxcnQoXG5cdFx0XHRNYXRoLnBvdyhtb3VzZURvd25YIC0gY2hhcnRYLCAyKSArXG5cdFx0XHRNYXRoLnBvdyhtb3VzZURvd25ZIC0gY2hhcnRZLCAyKVxuXHRcdCk7XG5cdFx0XG5cdFx0aWYgKHRoaXMuaGFzRHJhZ2dlZCA+IDEwKSB7XG5cdFx0XHRjbGlja2VkSW5zaWRlID0gY2hhcnQuaXNJbnNpZGVQbG90KG1vdXNlRG93blggLSBwbG90TGVmdCwgbW91c2VEb3duWSAtIHBsb3RUb3ApO1xuXG5cdFx0XHQvLyBtYWtlIGEgc2VsZWN0aW9uXG5cdFx0XHRpZiAoY2hhcnQuaGFzQ2FydGVzaWFuU2VyaWVzICYmICh0aGlzLnpvb21YIHx8IHRoaXMuem9vbVkpICYmIGNsaWNrZWRJbnNpZGUgJiYgIXBhbktleSkge1xuXHRcdFx0XHRpZiAoIXNlbGVjdGlvbk1hcmtlcikge1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0aW9uTWFya2VyID0gc2VsZWN0aW9uTWFya2VyID0gY2hhcnQucmVuZGVyZXIucmVjdChcblx0XHRcdFx0XHRcdHBsb3RMZWZ0LFxuXHRcdFx0XHRcdFx0cGxvdFRvcCxcblx0XHRcdFx0XHRcdHpvb21Ib3IgPyAxIDogcGxvdFdpZHRoLFxuXHRcdFx0XHRcdFx0em9vbVZlcnQgPyAxIDogcGxvdEhlaWdodCxcblx0XHRcdFx0XHRcdDBcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0ZmlsbDogY2hhcnRPcHRpb25zLnNlbGVjdGlvbk1hcmtlckZpbGwgfHwgJ3JnYmEoNjksMTE0LDE2NywwLjI1KScsXG5cdFx0XHRcdFx0XHR6SW5kZXg6IDdcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGp1c3QgdGhlIHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gbWFya2VyXG5cdFx0XHRpZiAoc2VsZWN0aW9uTWFya2VyICYmIHpvb21Ib3IpIHtcblx0XHRcdFx0c2l6ZSA9IGNoYXJ0WCAtIG1vdXNlRG93blg7XG5cdFx0XHRcdHNlbGVjdGlvbk1hcmtlci5hdHRyKHtcblx0XHRcdFx0XHR3aWR0aDogbWF0aEFicyhzaXplKSxcblx0XHRcdFx0XHR4OiAoc2l6ZSA+IDAgPyAwIDogc2l6ZSkgKyBtb3VzZURvd25YXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWRqdXN0IHRoZSBoZWlnaHQgb2YgdGhlIHNlbGVjdGlvbiBtYXJrZXJcblx0XHRcdGlmIChzZWxlY3Rpb25NYXJrZXIgJiYgem9vbVZlcnQpIHtcblx0XHRcdFx0c2l6ZSA9IGNoYXJ0WSAtIG1vdXNlRG93blk7XG5cdFx0XHRcdHNlbGVjdGlvbk1hcmtlci5hdHRyKHtcblx0XHRcdFx0XHRoZWlnaHQ6IG1hdGhBYnMoc2l6ZSksXG5cdFx0XHRcdFx0eTogKHNpemUgPiAwID8gMCA6IHNpemUpICsgbW91c2VEb3duWVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcGFubmluZ1xuXHRcdFx0aWYgKGNsaWNrZWRJbnNpZGUgJiYgIXNlbGVjdGlvbk1hcmtlciAmJiBjaGFydE9wdGlvbnMucGFubmluZykge1xuXHRcdFx0XHRjaGFydC5wYW4oZSwgY2hhcnRPcHRpb25zLnBhbm5pbmcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogT24gbW91c2UgdXAgb3IgdG91Y2ggZW5kIGFjcm9zcyB0aGUgZW50aXJlIGRvY3VtZW50LCBkcm9wIHRoZSBzZWxlY3Rpb24uXG5cdCAqL1xuXHRkcm9wOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludGVyID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdGhhc1BpbmNoZWQgPSB0aGlzLmhhc1BpbmNoZWQ7XG5cblx0XHRpZiAodGhpcy5zZWxlY3Rpb25NYXJrZXIpIHtcblx0XHRcdHZhciBzZWxlY3Rpb25EYXRhID0ge1xuXHRcdFx0XHRcdHhBeGlzOiBbXSxcblx0XHRcdFx0XHR5QXhpczogW10sXG5cdFx0XHRcdFx0b3JpZ2luYWxFdmVudDogZS5vcmlnaW5hbEV2ZW50IHx8IGVcblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0aW9uQm94ID0gdGhpcy5zZWxlY3Rpb25NYXJrZXIsXG5cdFx0XHRcdHNlbGVjdGlvbkxlZnQgPSBzZWxlY3Rpb25Cb3guYXR0ciA/IHNlbGVjdGlvbkJveC5hdHRyKCd4JykgOiBzZWxlY3Rpb25Cb3gueCxcblx0XHRcdFx0c2VsZWN0aW9uVG9wID0gc2VsZWN0aW9uQm94LmF0dHIgPyBzZWxlY3Rpb25Cb3guYXR0cigneScpIDogc2VsZWN0aW9uQm94LnksXG5cdFx0XHRcdHNlbGVjdGlvbldpZHRoID0gc2VsZWN0aW9uQm94LmF0dHIgPyBzZWxlY3Rpb25Cb3guYXR0cignd2lkdGgnKSA6IHNlbGVjdGlvbkJveC53aWR0aCxcblx0XHRcdFx0c2VsZWN0aW9uSGVpZ2h0ID0gc2VsZWN0aW9uQm94LmF0dHIgPyBzZWxlY3Rpb25Cb3guYXR0cignaGVpZ2h0JykgOiBzZWxlY3Rpb25Cb3guaGVpZ2h0LFxuXHRcdFx0XHRydW5ab29tO1xuXG5cdFx0XHQvLyBhIHNlbGVjdGlvbiBoYXMgYmVlbiBtYWRlXG5cdFx0XHRpZiAodGhpcy5oYXNEcmFnZ2VkIHx8IGhhc1BpbmNoZWQpIHtcblxuXHRcdFx0XHQvLyByZWNvcmQgZWFjaCBheGlzJyBtaW4gYW5kIG1heFxuXHRcdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdFx0aWYgKGF4aXMuem9vbUVuYWJsZWQgJiYgZGVmaW5lZChheGlzLm1pbikgJiYgKGhhc1BpbmNoZWQgfHwgcG9pbnRlclt7IHhBeGlzOiAnem9vbVgnLCB5QXhpczogJ3pvb21ZJyB9W2F4aXMuY29sbF1dKSkgeyAvLyAjODU5LCAjMzU2OVxuXHRcdFx0XHRcdFx0dmFyIGhvcml6ID0gYXhpcy5ob3Jpeixcblx0XHRcdFx0XHRcdFx0bWluUGl4ZWxQYWRkaW5nID0gZS50eXBlID09PSAndG91Y2hlbmQnID8gYXhpcy5taW5QaXhlbFBhZGRpbmc6IDAsIC8vICMxMjA3LCAjMzA3NVxuXHRcdFx0XHRcdFx0XHRzZWxlY3Rpb25NaW4gPSBheGlzLnRvVmFsdWUoKGhvcml6ID8gc2VsZWN0aW9uTGVmdCA6IHNlbGVjdGlvblRvcCkgKyBtaW5QaXhlbFBhZGRpbmcpLFxuXHRcdFx0XHRcdFx0XHRzZWxlY3Rpb25NYXggPSBheGlzLnRvVmFsdWUoKGhvcml6ID8gc2VsZWN0aW9uTGVmdCArIHNlbGVjdGlvbldpZHRoIDogc2VsZWN0aW9uVG9wICsgc2VsZWN0aW9uSGVpZ2h0KSAtIG1pblBpeGVsUGFkZGluZyk7XG5cblx0XHRcdFx0XHRcdHNlbGVjdGlvbkRhdGFbYXhpcy5jb2xsXS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0YXhpczogYXhpcyxcblx0XHRcdFx0XHRcdFx0bWluOiBtYXRoTWluKHNlbGVjdGlvbk1pbiwgc2VsZWN0aW9uTWF4KSwgLy8gZm9yIHJldmVyc2VkIGF4ZXNcblx0XHRcdFx0XHRcdFx0bWF4OiBtYXRoTWF4KHNlbGVjdGlvbk1pbiwgc2VsZWN0aW9uTWF4KVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRydW5ab29tID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAocnVuWm9vbSkge1xuXHRcdFx0XHRcdGZpcmVFdmVudChjaGFydCwgJ3NlbGVjdGlvbicsIHNlbGVjdGlvbkRhdGEsIGZ1bmN0aW9uIChhcmdzKSB7IFxuXHRcdFx0XHRcdFx0Y2hhcnQuem9vbShleHRlbmQoYXJncywgaGFzUGluY2hlZCA/IHsgYW5pbWF0aW9uOiBmYWxzZSB9IDogbnVsbCkpOyBcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNlbGVjdGlvbk1hcmtlciA9IHRoaXMuc2VsZWN0aW9uTWFya2VyLmRlc3Ryb3koKTtcblxuXHRcdFx0Ly8gUmVzZXQgc2NhbGluZyBwcmV2aWV3XG5cdFx0XHRpZiAoaGFzUGluY2hlZCkge1xuXHRcdFx0XHR0aGlzLnNjYWxlR3JvdXBzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgYWxsXG5cdFx0aWYgKGNoYXJ0KSB7IC8vIGl0IG1heSBiZSBkZXN0cm95ZWQgb24gbW91c2UgdXAgLSAjODc3XG5cdFx0XHRjc3MoY2hhcnQuY29udGFpbmVyLCB7IGN1cnNvcjogY2hhcnQuX2N1cnNvciB9KTtcblx0XHRcdGNoYXJ0LmNhbmNlbENsaWNrID0gdGhpcy5oYXNEcmFnZ2VkID4gMTA7IC8vICMzNzBcblx0XHRcdGNoYXJ0Lm1vdXNlSXNEb3duID0gdGhpcy5oYXNEcmFnZ2VkID0gdGhpcy5oYXNQaW5jaGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLnBpbmNoRG93biA9IFtdO1xuXHRcdH1cblx0fSxcblxuXHRvbkNvbnRhaW5lck1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcblxuXHRcdGUgPSB0aGlzLm5vcm1hbGl6ZShlKTtcblxuXHRcdC8vIGlzc3VlICMyOTUsIGRyYWdnaW5nIG5vdCBhbHdheXMgd29ya2luZyBpbiBGaXJlZm94XG5cdFx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5kcmFnU3RhcnQoZSk7XG5cdH0sXG5cblx0XG5cblx0b25Eb2N1bWVudE1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGNoYXJ0c1tob3ZlckNoYXJ0SW5kZXhdKSB7XG5cdFx0XHRjaGFydHNbaG92ZXJDaGFydEluZGV4XS5wb2ludGVyLmRyb3AoZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTcGVjaWFsIGhhbmRsZXIgZm9yIG1vdXNlIG1vdmUgdGhhdCB3aWxsIGhpZGUgdGhlIHRvb2x0aXAgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBwbG90YXJlYS5cblx0ICogSXNzdWUgIzE0OSB3b3JrYXJvdW5kLiBUaGUgbW91c2VsZWF2ZSBldmVudCBkb2VzIG5vdCBhbHdheXMgZmlyZS4gXG5cdCAqL1xuXHRvbkRvY3VtZW50TW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRjaGFydFBvc2l0aW9uID0gdGhpcy5jaGFydFBvc2l0aW9uO1xuXG5cdFx0ZSA9IHRoaXMubm9ybWFsaXplKGUsIGNoYXJ0UG9zaXRpb24pO1xuXG5cdFx0Ly8gSWYgd2UncmUgb3V0c2lkZSwgaGlkZSB0aGUgdG9vbHRpcFxuXHRcdGlmIChjaGFydFBvc2l0aW9uICYmICF0aGlzLmluQ2xhc3MoZS50YXJnZXQsICdoaWdoY2hhcnRzLXRyYWNrZXInKSAmJlxuXHRcdFx0XHQhY2hhcnQuaXNJbnNpZGVQbG90KGUuY2hhcnRYIC0gY2hhcnQucGxvdExlZnQsIGUuY2hhcnRZIC0gY2hhcnQucGxvdFRvcCkpIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFdoZW4gbW91c2UgbGVhdmVzIHRoZSBjb250YWluZXIsIGhpZGUgdGhlIHRvb2x0aXAuXG5cdCAqL1xuXHRvbkNvbnRhaW5lck1vdXNlTGVhdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2hhcnQgPSBjaGFydHNbaG92ZXJDaGFydEluZGV4XTtcblx0XHRpZiAoY2hhcnQpIHtcblx0XHRcdGNoYXJ0LnBvaW50ZXIucmVzZXQoKTtcblx0XHRcdGNoYXJ0LnBvaW50ZXIuY2hhcnRQb3NpdGlvbiA9IG51bGw7IC8vIGFsc28gcmVzZXQgdGhlIGNoYXJ0IHBvc2l0aW9uLCB1c2VkIGluICMxNDkgZml4XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFRoZSBtb3VzZW1vdmUsIHRvdWNobW92ZSBhbmQgdG91Y2hzdGFydCBldmVudCBoYW5kbGVyXG5cdG9uQ29udGFpbmVyTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblxuXHRcdGhvdmVyQ2hhcnRJbmRleCA9IGNoYXJ0LmluZGV4O1xuXG5cdFx0ZSA9IHRoaXMubm9ybWFsaXplKGUpO1x0XHRcblx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7IC8vICMyMjUxLCAjMzIyNFxuXHRcdFxuXHRcdGlmIChjaGFydC5tb3VzZUlzRG93biA9PT0gJ21vdXNlZG93bicpIHtcblx0XHRcdHRoaXMuZHJhZyhlKTtcblx0XHR9IFxuXHRcdFxuXHRcdC8vIFNob3cgdGhlIHRvb2x0aXAgYW5kIHJ1biBtb3VzZSBvdmVyIGV2ZW50cyAoIzk3Nylcblx0XHRpZiAoKHRoaXMuaW5DbGFzcyhlLnRhcmdldCwgJ2hpZ2hjaGFydHMtdHJhY2tlcicpIHx8IFxuXHRcdFx0XHRjaGFydC5pc0luc2lkZVBsb3QoZS5jaGFydFggLSBjaGFydC5wbG90TGVmdCwgZS5jaGFydFkgLSBjaGFydC5wbG90VG9wKSkgJiYgIWNoYXJ0Lm9wZW5NZW51KSB7XG5cdFx0XHR0aGlzLnJ1blBvaW50QWN0aW9ucyhlKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgdG8gZGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCBoYXMsIG9yIGhhcyBhIHBhcmVudCB3aXRoLCBhIHNwZWNpZmljXG5cdCAqIGNsYXNzIG5hbWUuIFVzZWQgb24gZGV0ZWN0aW9uIG9mIHRyYWNrZXIgb2JqZWN0cyBhbmQgb24gZGVjaWRpbmcgd2hldGhlclxuXHQgKiBob3ZlcmluZyB0aGUgdG9vbHRpcCBzaG91bGQgY2F1c2UgdGhlIGFjdGl2ZSBzZXJpZXMgdG8gbW91c2Ugb3V0LlxuXHQgKi9cblx0aW5DbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuXHRcdHZhciBlbGVtQ2xhc3NOYW1lO1xuXHRcdHdoaWxlIChlbGVtZW50KSB7XG5cdFx0XHRlbGVtQ2xhc3NOYW1lID0gYXR0cihlbGVtZW50LCAnY2xhc3MnKTtcblx0XHRcdGlmIChlbGVtQ2xhc3NOYW1lKSB7XG5cdFx0XHRcdGlmIChlbGVtQ2xhc3NOYW1lLmluZGV4T2YoY2xhc3NOYW1lKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChlbGVtQ2xhc3NOYW1lLmluZGV4T2YoUFJFRklYICsgJ2NvbnRhaW5lcicpICE9PSAtMSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHR9XHRcdFxuXHR9LFxuXG5cdG9uVHJhY2tlck1vdXNlT3V0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLmNoYXJ0LmhvdmVyU2VyaWVzLFxuXHRcdFx0cmVsYXRlZFRhcmdldCA9IGUucmVsYXRlZFRhcmdldCB8fCBlLnRvRWxlbWVudDtcblx0XHRcblx0XHRpZiAoc2VyaWVzICYmICFzZXJpZXMub3B0aW9ucy5zdGlja3lUcmFja2luZyAmJiBcblx0XHRcdFx0IXRoaXMuaW5DbGFzcyhyZWxhdGVkVGFyZ2V0LCBQUkVGSVggKyAndG9vbHRpcCcpICYmXG5cdFx0XHRcdCF0aGlzLmluQ2xhc3MocmVsYXRlZFRhcmdldCwgUFJFRklYICsgJ3Nlcmllcy0nICsgc2VyaWVzLmluZGV4KSkgeyAvLyAjMjQ5OSwgIzQ0NjVcblx0XHRcdHNlcmllcy5vbk1vdXNlT3V0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdG9uQ29udGFpbmVyQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdGhvdmVyUG9pbnQgPSBjaGFydC5ob3ZlclBvaW50LCBcblx0XHRcdHBsb3RMZWZ0ID0gY2hhcnQucGxvdExlZnQsXG5cdFx0XHRwbG90VG9wID0gY2hhcnQucGxvdFRvcDtcblx0XHRcblx0XHRlID0gdGhpcy5ub3JtYWxpemUoZSk7XG5cdFx0ZS5vcmlnaW5hbEV2ZW50ID0gZTsgLy8gIzM5MTNcblxuXHRcdGlmICghY2hhcnQuY2FuY2VsQ2xpY2spIHtcblx0XHRcdFxuXHRcdFx0Ly8gT24gdHJhY2tlciBjbGljaywgZmlyZSB0aGUgc2VyaWVzIGFuZCBwb2ludCBldmVudHMuICM3ODMsICMxNTgzXG5cdFx0XHRpZiAoaG92ZXJQb2ludCAmJiB0aGlzLmluQ2xhc3MoZS50YXJnZXQsIFBSRUZJWCArICd0cmFja2VyJykpIHtcblxuXHRcdFx0XHQvLyB0aGUgc2VyaWVzIGNsaWNrIGV2ZW50XG5cdFx0XHRcdGZpcmVFdmVudChob3ZlclBvaW50LnNlcmllcywgJ2NsaWNrJywgZXh0ZW5kKGUsIHtcblx0XHRcdFx0XHRwb2ludDogaG92ZXJQb2ludFxuXHRcdFx0XHR9KSk7XG5cblx0XHRcdFx0Ly8gdGhlIHBvaW50IGNsaWNrIGV2ZW50XG5cdFx0XHRcdGlmIChjaGFydC5ob3ZlclBvaW50KSB7IC8vIGl0IG1heSBiZSBkZXN0cm95ZWQgKCMxODQ0KVxuXHRcdFx0XHRcdGhvdmVyUG9pbnQuZmlyZVBvaW50RXZlbnQoJ2NsaWNrJywgZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gV2hlbiBjbGlja2luZyBvdXRzaWRlIGEgdHJhY2tlciwgZmlyZSBhIGNoYXJ0IGV2ZW50XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRlbmQoZSwgdGhpcy5nZXRDb29yZGluYXRlcyhlKSk7XG5cblx0XHRcdFx0Ly8gZmlyZSBhIGNsaWNrIGV2ZW50IGluIHRoZSBjaGFydFxuXHRcdFx0XHRpZiAoY2hhcnQuaXNJbnNpZGVQbG90KGUuY2hhcnRYIC0gcGxvdExlZnQsIGUuY2hhcnRZIC0gcGxvdFRvcCkpIHtcblx0XHRcdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdjbGljaycsIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSBKUyBET00gZXZlbnRzIG9uIHRoZSBjb250YWluZXIgYW5kIGRvY3VtZW50LiBUaGlzIG1ldGhvZCBzaG91bGQgY29udGFpblxuXHQgKiBhIG9uZS10by1vbmUgYXNzaWdubWVudCBiZXR3ZWVuIG1ldGhvZHMgYW5kIHRoZWlyIGhhbmRsZXJzLiBBbnkgYWR2YW5jZWQgbG9naWMgc2hvdWxkXG5cdCAqIGJlIG1vdmVkIHRvIHRoZSBoYW5kbGVyIHJlZmxlY3RpbmcgdGhlIGV2ZW50J3MgbmFtZS5cblx0ICovXG5cdHNldERPTUV2ZW50czogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHBvaW50ZXIgPSB0aGlzLFxuXHRcdFx0Y29udGFpbmVyID0gcG9pbnRlci5jaGFydC5jb250YWluZXI7XG5cblx0XHRjb250YWluZXIub25tb3VzZWRvd24gPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0cG9pbnRlci5vbkNvbnRhaW5lck1vdXNlRG93bihlKTtcblx0XHR9O1xuXHRcdGNvbnRhaW5lci5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRwb2ludGVyLm9uQ29udGFpbmVyTW91c2VNb3ZlKGUpO1xuXHRcdH07XG5cdFx0Y29udGFpbmVyLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0cG9pbnRlci5vbkNvbnRhaW5lckNsaWNrKGUpO1xuXHRcdH07XG5cdFx0YWRkRXZlbnQoY29udGFpbmVyLCAnbW91c2VsZWF2ZScsIHBvaW50ZXIub25Db250YWluZXJNb3VzZUxlYXZlKTtcblx0XHRpZiAoY2hhcnRDb3VudCA9PT0gMSkge1xuXHRcdFx0YWRkRXZlbnQoZG9jLCAnbW91c2V1cCcsIHBvaW50ZXIub25Eb2N1bWVudE1vdXNlVXApO1xuXHRcdH1cblx0XHRpZiAoaGFzVG91Y2gpIHtcblx0XHRcdGNvbnRhaW5lci5vbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRwb2ludGVyLm9uQ29udGFpbmVyVG91Y2hTdGFydChlKTtcblx0XHRcdH07XG5cdFx0XHRjb250YWluZXIub250b3VjaG1vdmUgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRwb2ludGVyLm9uQ29udGFpbmVyVG91Y2hNb3ZlKGUpO1xuXHRcdFx0fTtcblx0XHRcdGlmIChjaGFydENvdW50ID09PSAxKSB7XG5cdFx0XHRcdGFkZEV2ZW50KGRvYywgJ3RvdWNoZW5kJywgcG9pbnRlci5vbkRvY3VtZW50VG91Y2hFbmQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0fSxcblxuXHQvKipcblx0ICogRGVzdHJveXMgdGhlIFBvaW50ZXIgb2JqZWN0IGFuZCBkaXNjb25uZWN0cyBET00gZXZlbnRzLlxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwcm9wO1xuXG5cdFx0cmVtb3ZlRXZlbnQodGhpcy5jaGFydC5jb250YWluZXIsICdtb3VzZWxlYXZlJywgdGhpcy5vbkNvbnRhaW5lck1vdXNlTGVhdmUpO1xuXHRcdGlmICghY2hhcnRDb3VudCkge1xuXHRcdFx0cmVtb3ZlRXZlbnQoZG9jLCAnbW91c2V1cCcsIHRoaXMub25Eb2N1bWVudE1vdXNlVXApO1xuXHRcdFx0cmVtb3ZlRXZlbnQoZG9jLCAndG91Y2hlbmQnLCB0aGlzLm9uRG9jdW1lbnRUb3VjaEVuZCk7XG5cdFx0fVxuXG5cdFx0Ly8gbWVtb3J5IGFuZCBDUFUgbGVha1xuXHRcdGNsZWFySW50ZXJ2YWwodGhpcy50b29sdGlwVGltZW91dCk7XG5cblx0XHRmb3IgKHByb3AgaW4gdGhpcykge1xuXHRcdFx0dGhpc1twcm9wXSA9IG51bGw7XG5cdFx0fVxuXHR9XG59O1xuXG5cbi8qIFN1cHBvcnQgZm9yIHRvdWNoIGRldmljZXMgKi9cbmV4dGVuZChIaWdoY2hhcnRzLlBvaW50ZXIucHJvdG90eXBlLCB7XG5cblx0LyoqXG5cdCAqIFJ1biB0cmFuc2xhdGlvbiBvcGVyYXRpb25zXG5cdCAqL1xuXHRwaW5jaFRyYW5zbGF0ZTogZnVuY3Rpb24gKHBpbmNoRG93biwgdG91Y2hlcywgdHJhbnNmb3JtLCBzZWxlY3Rpb25NYXJrZXIsIGNsaXAsIGxhc3RWYWxpZFRvdWNoKSB7XG5cdFx0aWYgKHRoaXMuem9vbUhvciB8fCB0aGlzLnBpbmNoSG9yKSB7XG5cdFx0XHR0aGlzLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uKHRydWUsIHBpbmNoRG93biwgdG91Y2hlcywgdHJhbnNmb3JtLCBzZWxlY3Rpb25NYXJrZXIsIGNsaXAsIGxhc3RWYWxpZFRvdWNoKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuem9vbVZlcnQgfHwgdGhpcy5waW5jaFZlcnQpIHtcblx0XHRcdHRoaXMucGluY2hUcmFuc2xhdGVEaXJlY3Rpb24oZmFsc2UsIHBpbmNoRG93biwgdG91Y2hlcywgdHJhbnNmb3JtLCBzZWxlY3Rpb25NYXJrZXIsIGNsaXAsIGxhc3RWYWxpZFRvdWNoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJ1biB0cmFuc2xhdGlvbiBvcGVyYXRpb25zIGZvciBlYWNoIGRpcmVjdGlvbiAoaG9yaXpvbnRhbCBhbmQgdmVydGljYWwpIGluZGVwZW5kZW50bHlcblx0ICovXG5cdHBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uOiBmdW5jdGlvbiAoaG9yaXosIHBpbmNoRG93biwgdG91Y2hlcywgdHJhbnNmb3JtLCBzZWxlY3Rpb25NYXJrZXIsIGNsaXAsIGxhc3RWYWxpZFRvdWNoLCBmb3JjZWRTY2FsZSkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHR4eSA9IGhvcml6ID8gJ3gnIDogJ3knLFxuXHRcdFx0WFkgPSBob3JpeiA/ICdYJyA6ICdZJyxcblx0XHRcdHNDaGFydFhZID0gJ2NoYXJ0JyArIFhZLFxuXHRcdFx0d2ggPSBob3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0Jyxcblx0XHRcdHBsb3RMZWZ0VG9wID0gY2hhcnRbJ3Bsb3QnICsgKGhvcml6ID8gJ0xlZnQnIDogJ1RvcCcpXSxcblx0XHRcdHNlbGVjdGlvbldILFxuXHRcdFx0c2VsZWN0aW9uWFksXG5cdFx0XHRjbGlwWFksXG5cdFx0XHRzY2FsZSA9IGZvcmNlZFNjYWxlIHx8IDEsXG5cdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0Ym91bmRzID0gY2hhcnQuYm91bmRzW2hvcml6ID8gJ2gnIDogJ3YnXSxcblx0XHRcdHNpbmdsZVRvdWNoID0gcGluY2hEb3duLmxlbmd0aCA9PT0gMSxcblx0XHRcdHRvdWNoMFN0YXJ0ID0gcGluY2hEb3duWzBdW3NDaGFydFhZXSxcblx0XHRcdHRvdWNoME5vdyA9IHRvdWNoZXNbMF1bc0NoYXJ0WFldLFxuXHRcdFx0dG91Y2gxU3RhcnQgPSAhc2luZ2xlVG91Y2ggJiYgcGluY2hEb3duWzFdW3NDaGFydFhZXSxcblx0XHRcdHRvdWNoMU5vdyA9ICFzaW5nbGVUb3VjaCAmJiB0b3VjaGVzWzFdW3NDaGFydFhZXSxcblx0XHRcdG91dE9mQm91bmRzLFxuXHRcdFx0dHJhbnNmb3JtU2NhbGUsXG5cdFx0XHRzY2FsZUtleSxcblx0XHRcdHNldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoIXNpbmdsZVRvdWNoICYmIG1hdGhBYnModG91Y2gwU3RhcnQgLSB0b3VjaDFTdGFydCkgPiAyMCkgeyAvLyBEb24ndCB6b29tIGlmIGZpbmdlcnMgYXJlIHRvbyBjbG9zZSBvbiB0aGlzIGF4aXNcblx0XHRcdFx0XHRzY2FsZSA9IGZvcmNlZFNjYWxlIHx8IG1hdGhBYnModG91Y2gwTm93IC0gdG91Y2gxTm93KSAvIG1hdGhBYnModG91Y2gwU3RhcnQgLSB0b3VjaDFTdGFydCk7IFxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjbGlwWFkgPSAoKHBsb3RMZWZ0VG9wIC0gdG91Y2gwTm93KSAvIHNjYWxlKSArIHRvdWNoMFN0YXJ0O1xuXHRcdFx0XHRzZWxlY3Rpb25XSCA9IGNoYXJ0WydwbG90JyArIChob3JpeiA/ICdXaWR0aCcgOiAnSGVpZ2h0JyldIC8gc2NhbGU7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBzY2FsZSwgZmlyc3QgcGFzc1xuXHRcdHNldFNjYWxlKCk7XG5cblx0XHRzZWxlY3Rpb25YWSA9IGNsaXBYWTsgLy8gdGhlIGNsaXAgcG9zaXRpb24gKHggb3IgeSkgaXMgYWx0ZXJlZCBpZiBvdXQgb2YgYm91bmRzLCB0aGUgc2VsZWN0aW9uIHBvc2l0aW9uIGlzIG5vdFxuXG5cdFx0Ly8gT3V0IG9mIGJvdW5kc1xuXHRcdGlmIChzZWxlY3Rpb25YWSA8IGJvdW5kcy5taW4pIHtcblx0XHRcdHNlbGVjdGlvblhZID0gYm91bmRzLm1pbjtcblx0XHRcdG91dE9mQm91bmRzID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKHNlbGVjdGlvblhZICsgc2VsZWN0aW9uV0ggPiBib3VuZHMubWF4KSB7XG5cdFx0XHRzZWxlY3Rpb25YWSA9IGJvdW5kcy5tYXggLSBzZWxlY3Rpb25XSDtcblx0XHRcdG91dE9mQm91bmRzID0gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gSXMgdGhlIGNoYXJ0IGRyYWdnZWQgb2ZmIGl0cyBib3VuZHMsIGRldGVybWluZWQgYnkgZGF0YU1pbiBhbmQgZGF0YU1heD9cblx0XHRpZiAob3V0T2ZCb3VuZHMpIHtcblxuXHRcdFx0Ly8gTW9kaWZ5IHRoZSB0b3VjaE5vdyBwb3NpdGlvbiBpbiBvcmRlciB0byBjcmVhdGUgYW4gZWxhc3RpYyBkcmFnIG1vdmVtZW50LiBUaGlzIGluZGljYXRlc1xuXHRcdFx0Ly8gdG8gdGhlIHVzZXIgdGhhdCB0aGUgY2hhcnQgaXMgcmVzcG9uc2l2ZSBidXQgY2FuJ3QgYmUgZHJhZ2dlZCBmdXJ0aGVyLlxuXHRcdFx0dG91Y2gwTm93IC09IDAuOCAqICh0b3VjaDBOb3cgLSBsYXN0VmFsaWRUb3VjaFt4eV1bMF0pO1xuXHRcdFx0aWYgKCFzaW5nbGVUb3VjaCkge1xuXHRcdFx0XHR0b3VjaDFOb3cgLT0gMC44ICogKHRvdWNoMU5vdyAtIGxhc3RWYWxpZFRvdWNoW3h5XVsxXSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgc2NhbGUsIHNlY29uZCBwYXNzIHRvIGFkYXB0IHRvIHRoZSBtb2RpZmllZCB0b3VjaE5vdyBwb3NpdGlvbnNcblx0XHRcdHNldFNjYWxlKCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0bGFzdFZhbGlkVG91Y2hbeHldID0gW3RvdWNoME5vdywgdG91Y2gxTm93XTtcblx0XHR9XG5cblx0XHQvLyBTZXQgZ2VvbWV0cnkgZm9yIGNsaXBwaW5nLCBzZWxlY3Rpb24gYW5kIHRyYW5zZm9ybWF0aW9uXG5cdFx0aWYgKCFpbnZlcnRlZCkgeyAvLyBUT0RPOiBpbXBsZW1lbnQgY2xpcHBpbmcgZm9yIGludmVydGVkIGNoYXJ0c1xuXHRcdFx0Y2xpcFt4eV0gPSBjbGlwWFkgLSBwbG90TGVmdFRvcDtcblx0XHRcdGNsaXBbd2hdID0gc2VsZWN0aW9uV0g7XG5cdFx0fVxuXHRcdHNjYWxlS2V5ID0gaW52ZXJ0ZWQgPyAoaG9yaXogPyAnc2NhbGVZJyA6ICdzY2FsZVgnKSA6ICdzY2FsZScgKyBYWTtcblx0XHR0cmFuc2Zvcm1TY2FsZSA9IGludmVydGVkID8gMSAvIHNjYWxlIDogc2NhbGU7XG5cblx0XHRzZWxlY3Rpb25NYXJrZXJbd2hdID0gc2VsZWN0aW9uV0g7XG5cdFx0c2VsZWN0aW9uTWFya2VyW3h5XSA9IHNlbGVjdGlvblhZO1xuXHRcdHRyYW5zZm9ybVtzY2FsZUtleV0gPSBzY2FsZTtcblx0XHR0cmFuc2Zvcm1bJ3RyYW5zbGF0ZScgKyBYWV0gPSAodHJhbnNmb3JtU2NhbGUgKiBwbG90TGVmdFRvcCkgKyAodG91Y2gwTm93IC0gKHRyYW5zZm9ybVNjYWxlICogdG91Y2gwU3RhcnQpKTtcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBIYW5kbGUgdG91Y2ggZXZlbnRzIHdpdGggdHdvIHRvdWNoZXNcblx0ICovXG5cdHBpbmNoOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBzZWxmLmNoYXJ0LFxuXHRcdFx0cGluY2hEb3duID0gc2VsZi5waW5jaERvd24sXG5cdFx0XHR0b3VjaGVzID0gZS50b3VjaGVzLFxuXHRcdFx0dG91Y2hlc0xlbmd0aCA9IHRvdWNoZXMubGVuZ3RoLFxuXHRcdFx0bGFzdFZhbGlkVG91Y2ggPSBzZWxmLmxhc3RWYWxpZFRvdWNoLFxuXHRcdFx0aGFzWm9vbSA9IHNlbGYuaGFzWm9vbSxcblx0XHRcdHNlbGVjdGlvbk1hcmtlciA9IHNlbGYuc2VsZWN0aW9uTWFya2VyLFxuXHRcdFx0dHJhbnNmb3JtID0ge30sXG5cdFx0XHRmaXJlQ2xpY2tFdmVudCA9IHRvdWNoZXNMZW5ndGggPT09IDEgJiYgKChzZWxmLmluQ2xhc3MoZS50YXJnZXQsIFBSRUZJWCArICd0cmFja2VyJykgJiYgXG5cdFx0XHRcdGNoYXJ0LnJ1blRyYWNrZXJDbGljaykgfHwgc2VsZi5ydW5DaGFydENsaWNrKSxcblx0XHRcdGNsaXAgPSB7fTtcblxuXHRcdC8vIERvbid0IGluaXRpYXRlIHBhbm5pbmcgdW50aWwgdGhlIHVzZXIgaGFzIHBpbmNoZWQuIFRoaXMgcHJldmVudHMgdXMgZnJvbSBcblx0XHQvLyBibG9ja2luZyBwYWdlIHNjcm9sbGluZyBhcyB1c2VycyBzY3JvbGwgZG93biBhIGxvbmcgcGFnZSAoIzQyMTApLlxuXHRcdGlmICh0b3VjaGVzTGVuZ3RoID4gMSkge1xuXHRcdFx0c2VsZi5pbml0aWF0ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9uIHRvdWNoIGRldmljZXMsIG9ubHkgcHJvY2VlZCB0byB0cmlnZ2VyIGNsaWNrIGlmIGEgaGFuZGxlciBpcyBkZWZpbmVkXG5cdFx0aWYgKGhhc1pvb20gJiYgc2VsZi5pbml0aWF0ZWQgJiYgIWZpcmVDbGlja0V2ZW50KSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIE5vcm1hbGl6ZSBlYWNoIHRvdWNoXG5cdFx0bWFwKHRvdWNoZXMsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5ub3JtYWxpemUoZSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0Ly8gUmVnaXN0ZXIgdGhlIHRvdWNoIHN0YXJ0IHBvc2l0aW9uXG5cdFx0aWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0XHRlYWNoKHRvdWNoZXMsIGZ1bmN0aW9uIChlLCBpKSB7XG5cdFx0XHRcdHBpbmNoRG93bltpXSA9IHsgY2hhcnRYOiBlLmNoYXJ0WCwgY2hhcnRZOiBlLmNoYXJ0WSB9O1xuXHRcdFx0fSk7XG5cdFx0XHRsYXN0VmFsaWRUb3VjaC54ID0gW3BpbmNoRG93blswXS5jaGFydFgsIHBpbmNoRG93blsxXSAmJiBwaW5jaERvd25bMV0uY2hhcnRYXTtcblx0XHRcdGxhc3RWYWxpZFRvdWNoLnkgPSBbcGluY2hEb3duWzBdLmNoYXJ0WSwgcGluY2hEb3duWzFdICYmIHBpbmNoRG93blsxXS5jaGFydFldO1xuXG5cdFx0XHQvLyBJZGVudGlmeSB0aGUgZGF0YSBib3VuZHMgaW4gcGl4ZWxzXG5cdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdGlmIChheGlzLnpvb21FbmFibGVkKSB7XG5cdFx0XHRcdFx0dmFyIGJvdW5kcyA9IGNoYXJ0LmJvdW5kc1theGlzLmhvcml6ID8gJ2gnIDogJ3YnXSxcblx0XHRcdFx0XHRcdG1pblBpeGVsUGFkZGluZyA9IGF4aXMubWluUGl4ZWxQYWRkaW5nLFxuXHRcdFx0XHRcdFx0bWluID0gYXhpcy50b1BpeGVscyhwaWNrKGF4aXMub3B0aW9ucy5taW4sIGF4aXMuZGF0YU1pbikpLFxuXHRcdFx0XHRcdFx0bWF4ID0gYXhpcy50b1BpeGVscyhwaWNrKGF4aXMub3B0aW9ucy5tYXgsIGF4aXMuZGF0YU1heCkpLFxuXHRcdFx0XHRcdFx0YWJzTWluID0gbWF0aE1pbihtaW4sIG1heCksXG5cdFx0XHRcdFx0XHRhYnNNYXggPSBtYXRoTWF4KG1pbiwgbWF4KTtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBib3VuZHMgZm9yIHVzZSBpbiB0aGUgdG91Y2htb3ZlIGhhbmRsZXJcblx0XHRcdFx0XHRib3VuZHMubWluID0gbWF0aE1pbihheGlzLnBvcywgYWJzTWluIC0gbWluUGl4ZWxQYWRkaW5nKTtcblx0XHRcdFx0XHRib3VuZHMubWF4ID0gbWF0aE1heChheGlzLnBvcyArIGF4aXMubGVuLCBhYnNNYXggKyBtaW5QaXhlbFBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHNlbGYucmVzID0gdHJ1ZTsgLy8gcmVzZXQgb24gbmV4dCBtb3ZlXG5cdFx0XG5cdFx0Ly8gRXZlbnQgdHlwZSBpcyB0b3VjaG1vdmUsIGhhbmRsZSBwYW5uaW5nIGFuZCBwaW5jaGluZ1xuXHRcdH0gZWxzZSBpZiAocGluY2hEb3duLmxlbmd0aCkgeyAvLyBjYW4gYmUgMCB3aGVuIHJlbGVhc2luZywgaWYgdG91Y2hlbmQgZmlyZXMgZmlyc3Rcblx0XHRcdFxuXG5cdFx0XHQvLyBTZXQgdGhlIG1hcmtlclxuXHRcdFx0aWYgKCFzZWxlY3Rpb25NYXJrZXIpIHtcblx0XHRcdFx0c2VsZi5zZWxlY3Rpb25NYXJrZXIgPSBzZWxlY3Rpb25NYXJrZXIgPSBleHRlbmQoe1xuXHRcdFx0XHRcdGRlc3Ryb3k6IG5vb3AsXG5cdFx0XHRcdFx0dG91Y2g6IHRydWVcblx0XHRcdFx0fSwgY2hhcnQucGxvdEJveCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHNlbGYucGluY2hUcmFuc2xhdGUocGluY2hEb3duLCB0b3VjaGVzLCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1hcmtlciwgY2xpcCwgbGFzdFZhbGlkVG91Y2gpO1xuXG5cdFx0XHRzZWxmLmhhc1BpbmNoZWQgPSBoYXNab29tO1xuXG5cdFx0XHQvLyBTY2FsZSBhbmQgdHJhbnNsYXRlIHRoZSBncm91cHMgdG8gcHJvdmlkZSB2aXN1YWwgZmVlZGJhY2sgZHVyaW5nIHBpbmNoaW5nXG5cdFx0XHRzZWxmLnNjYWxlR3JvdXBzKHRyYW5zZm9ybSwgY2xpcCk7XG5cdFx0XHRcblx0XHRcdC8vIE9wdGlvbmFsbHkgbW92ZSB0aGUgdG9vbHRpcCBvbiB0b3VjaG1vdmVcblx0XHRcdGlmICghaGFzWm9vbSAmJiBzZWxmLmZvbGxvd1RvdWNoTW92ZSAmJiB0b3VjaGVzTGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHRoaXMucnVuUG9pbnRBY3Rpb25zKHNlbGYubm9ybWFsaXplKGUpKTtcblx0XHRcdH0gZWxzZSBpZiAoc2VsZi5yZXMpIHtcblx0XHRcdFx0c2VsZi5yZXMgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5yZXNldChmYWxzZSwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZW5lcmFsIHRvdWNoIGhhbmRsZXIgc2hhcmVkIGJ5IHRvdWNoc3RhcnQgYW5kIHRvdWNobW92ZS5cblx0ICovXG5cdHRvdWNoOiBmdW5jdGlvbiAoZSwgc3RhcnQpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXG5cdFx0aG92ZXJDaGFydEluZGV4ID0gY2hhcnQuaW5kZXg7XG5cblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuXG5cdFx0XHRlID0gdGhpcy5ub3JtYWxpemUoZSk7XG5cblx0XHRcdGlmIChjaGFydC5pc0luc2lkZVBsb3QoZS5jaGFydFggLSBjaGFydC5wbG90TGVmdCwgZS5jaGFydFkgLSBjaGFydC5wbG90VG9wKSAmJiAhY2hhcnQub3Blbk1lbnUpIHtcblxuXHRcdFx0XHQvLyBSdW4gbW91c2UgZXZlbnRzIGFuZCBkaXNwbGF5IHRvb2x0aXAgZXRjXG5cdFx0XHRcdGlmIChzdGFydCkge1xuXHRcdFx0XHRcdHRoaXMucnVuUG9pbnRBY3Rpb25zKGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5waW5jaChlKTtcblxuXHRcdFx0fSBlbHNlIGlmIChzdGFydCkge1xuXHRcdFx0XHQvLyBIaWRlIHRoZSB0b29sdGlwIG9uIHRvdWNoaW5nIG91dHNpZGUgdGhlIHBsb3QgYXJlYSAoIzEyMDMpXG5cdFx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMikge1xuXHRcdFx0dGhpcy5waW5jaChlKTtcblx0XHR9XG5cdH0sXG5cblx0b25Db250YWluZXJUb3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMudG91Y2goZSwgdHJ1ZSk7XG5cdH0sXG5cblx0b25Db250YWluZXJUb3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy50b3VjaChlKTtcblx0fSxcblxuXHRvbkRvY3VtZW50VG91Y2hFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGNoYXJ0c1tob3ZlckNoYXJ0SW5kZXhdKSB7XG5cdFx0XHRjaGFydHNbaG92ZXJDaGFydEluZGV4XS5wb2ludGVyLmRyb3AoZSk7XG5cdFx0fVxuXHR9XG5cbn0pO1xuaWYgKHdpbi5Qb2ludGVyRXZlbnQgfHwgd2luLk1TUG9pbnRlckV2ZW50KSB7XG5cdFxuXHQvLyBUaGUgdG91Y2hlcyBvYmplY3Qga2VlcHMgdHJhY2sgb2YgdGhlIHBvaW50cyBiZWluZyB0b3VjaGVkIGF0IGFsbCB0aW1lc1xuXHR2YXIgdG91Y2hlcyA9IHt9LFxuXHRcdGhhc1BvaW50ZXJFdmVudCA9ICEhd2luLlBvaW50ZXJFdmVudCxcblx0XHRnZXRXZWJraXRUb3VjaGVzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGtleSwgZmFrZSA9IFtdO1xuXHRcdFx0ZmFrZS5pdGVtID0gZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHRoaXNbaV07IH07XG5cdFx0XHRmb3IgKGtleSBpbiB0b3VjaGVzKSB7XG5cdFx0XHRcdGlmICh0b3VjaGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRmYWtlLnB1c2goe1xuXHRcdFx0XHRcdFx0cGFnZVg6IHRvdWNoZXNba2V5XS5wYWdlWCxcblx0XHRcdFx0XHRcdHBhZ2VZOiB0b3VjaGVzW2tleV0ucGFnZVksXG5cdFx0XHRcdFx0XHR0YXJnZXQ6IHRvdWNoZXNba2V5XS50YXJnZXRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZha2U7XG5cdFx0fSxcblx0XHR0cmFuc2xhdGVNU1BvaW50ZXIgPSBmdW5jdGlvbiAoZSwgbWV0aG9kLCB3a3R5cGUsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgcDtcblx0XHRcdGUgPSBlLm9yaWdpbmFsRXZlbnQgfHwgZTtcblx0XHRcdGlmICgoZS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyB8fCBlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX1RPVUNIKSAmJiBjaGFydHNbaG92ZXJDaGFydEluZGV4XSkge1xuXHRcdFx0XHRjYWxsYmFjayhlKTtcblx0XHRcdFx0cCA9IGNoYXJ0c1tob3ZlckNoYXJ0SW5kZXhdLnBvaW50ZXI7XG5cdFx0XHRcdHBbbWV0aG9kXSh7XG5cdFx0XHRcdFx0dHlwZTogd2t0eXBlLFxuXHRcdFx0XHRcdHRhcmdldDogZS5jdXJyZW50VGFyZ2V0LFxuXHRcdFx0XHRcdHByZXZlbnREZWZhdWx0OiBub29wLFxuXHRcdFx0XHRcdHRvdWNoZXM6IGdldFdlYmtpdFRvdWNoZXMoKVxuXHRcdFx0XHR9KTtcdFx0XHRcdFxuXHRcdFx0fVxuXHRcdH07XG5cblx0LyoqXG5cdCAqIEV4dGVuZCB0aGUgUG9pbnRlciBwcm90b3R5cGUgd2l0aCBtZXRob2RzIGZvciBlYWNoIGV2ZW50IGhhbmRsZXIgYW5kIG1vcmVcblx0ICovXG5cdGV4dGVuZChQb2ludGVyLnByb3RvdHlwZSwge1xuXHRcdG9uQ29udGFpbmVyUG9pbnRlckRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR0cmFuc2xhdGVNU1BvaW50ZXIoZSwgJ29uQ29udGFpbmVyVG91Y2hTdGFydCcsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0dG91Y2hlc1tlLnBvaW50ZXJJZF0gPSB7IHBhZ2VYOiBlLnBhZ2VYLCBwYWdlWTogZS5wYWdlWSwgdGFyZ2V0OiBlLmN1cnJlbnRUYXJnZXQgfTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0b25Db250YWluZXJQb2ludGVyTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHRyYW5zbGF0ZU1TUG9pbnRlcihlLCAnb25Db250YWluZXJUb3VjaE1vdmUnLCAndG91Y2htb3ZlJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0dG91Y2hlc1tlLnBvaW50ZXJJZF0gPSB7IHBhZ2VYOiBlLnBhZ2VYLCBwYWdlWTogZS5wYWdlWSB9O1xuXHRcdFx0XHRpZiAoIXRvdWNoZXNbZS5wb2ludGVySWRdLnRhcmdldCkge1xuXHRcdFx0XHRcdHRvdWNoZXNbZS5wb2ludGVySWRdLnRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRvbkRvY3VtZW50UG9pbnRlclVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dHJhbnNsYXRlTVNQb2ludGVyKGUsICdvbkRvY3VtZW50VG91Y2hFbmQnLCAndG91Y2hlbmQnLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRkZWxldGUgdG91Y2hlc1tlLnBvaW50ZXJJZF07XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIG9yIHJlbW92ZSB0aGUgTVMgUG9pbnRlciBzcGVjaWZpYyBldmVudHNcblx0XHQgKi9cblx0XHRiYXRjaE1TRXZlbnRzOiBmdW5jdGlvbiAoZm4pIHtcblx0XHRcdGZuKHRoaXMuY2hhcnQuY29udGFpbmVyLCBoYXNQb2ludGVyRXZlbnQgPyAncG9pbnRlcmRvd24nIDogJ01TUG9pbnRlckRvd24nLCB0aGlzLm9uQ29udGFpbmVyUG9pbnRlckRvd24pO1xuXHRcdFx0Zm4odGhpcy5jaGFydC5jb250YWluZXIsIGhhc1BvaW50ZXJFdmVudCA/ICdwb2ludGVybW92ZScgOiAnTVNQb2ludGVyTW92ZScsIHRoaXMub25Db250YWluZXJQb2ludGVyTW92ZSk7XG5cdFx0XHRmbihkb2MsIGhhc1BvaW50ZXJFdmVudCA/ICdwb2ludGVydXAnIDogJ01TUG9pbnRlclVwJywgdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIERpc2FibGUgZGVmYXVsdCBJRSBhY3Rpb25zIGZvciBwaW5jaCBhbmQgc3VjaCBvbiBjaGFydCBlbGVtZW50XG5cdHdyYXAoUG9pbnRlci5wcm90b3R5cGUsICdpbml0JywgZnVuY3Rpb24gKHByb2NlZWQsIGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0cHJvY2VlZC5jYWxsKHRoaXMsIGNoYXJ0LCBvcHRpb25zKTtcblx0XHRpZiAodGhpcy5oYXNab29tKSB7IC8vICM0MDE0XG5cdFx0XHRjc3MoY2hhcnQuY29udGFpbmVyLCB7XG5cdFx0XHRcdCctbXMtdG91Y2gtYWN0aW9uJzogTk9ORSxcblx0XHRcdFx0J3RvdWNoLWFjdGlvbic6IE5PTkVcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gQWRkIElFIHNwZWNpZmljIHRvdWNoIGV2ZW50cyB0byBjaGFydFxuXHR3cmFwKFBvaW50ZXIucHJvdG90eXBlLCAnc2V0RE9NRXZlbnRzJywgZnVuY3Rpb24gKHByb2NlZWQpIHtcblx0XHRwcm9jZWVkLmFwcGx5KHRoaXMpO1xuXHRcdGlmICh0aGlzLmhhc1pvb20gfHwgdGhpcy5mb2xsb3dUb3VjaE1vdmUpIHtcblx0XHRcdHRoaXMuYmF0Y2hNU0V2ZW50cyhhZGRFdmVudCk7XG5cdFx0fVxuXHR9KTtcblx0Ly8gRGVzdHJveSBNUyBldmVudHMgYWxzb1xuXHR3cmFwKFBvaW50ZXIucHJvdG90eXBlLCAnZGVzdHJveScsIGZ1bmN0aW9uIChwcm9jZWVkKSB7XG5cdFx0dGhpcy5iYXRjaE1TRXZlbnRzKHJlbW92ZUV2ZW50KTtcblx0XHRwcm9jZWVkLmNhbGwodGhpcyk7XG5cdH0pO1xufVxuLyoqXG4gKiBUaGUgb3ZlcnZpZXcgb2YgdGhlIGNoYXJ0J3Mgc2VyaWVzXG4gKi9cbnZhciBMZWdlbmQgPSBIaWdoY2hhcnRzLkxlZ2VuZCA9IGZ1bmN0aW9uIChjaGFydCwgb3B0aW9ucykge1xuXHR0aGlzLmluaXQoY2hhcnQsIG9wdGlvbnMpO1xufTtcblxuTGVnZW5kLnByb3RvdHlwZSA9IHtcblx0XG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBsZWdlbmRcblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uIChjaGFydCwgb3B0aW9ucykge1xuXHRcdFxuXHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0aXRlbVN0eWxlID0gb3B0aW9ucy5pdGVtU3R5bGUsXG5cdFx0XHRwYWRkaW5nLFxuXHRcdFx0aXRlbU1hcmdpblRvcCA9IG9wdGlvbnMuaXRlbU1hcmdpblRvcCB8fCAwO1xuXHRcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5cdFx0aWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdGxlZ2VuZC5pdGVtU3R5bGUgPSBpdGVtU3R5bGU7XG5cdFx0bGVnZW5kLml0ZW1IaWRkZW5TdHlsZSA9IG1lcmdlKGl0ZW1TdHlsZSwgb3B0aW9ucy5pdGVtSGlkZGVuU3R5bGUpO1xuXHRcdGxlZ2VuZC5pdGVtTWFyZ2luVG9wID0gaXRlbU1hcmdpblRvcDtcblx0XHRsZWdlbmQucGFkZGluZyA9IHBhZGRpbmcgPSBwaWNrKG9wdGlvbnMucGFkZGluZywgOCk7XG5cdFx0bGVnZW5kLmluaXRpYWxJdGVtWCA9IHBhZGRpbmc7XG5cdFx0bGVnZW5kLmluaXRpYWxJdGVtWSA9IHBhZGRpbmcgLSA1OyAvLyA1IGlzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIGFib3ZlIHRoZSB0ZXh0XG5cdFx0bGVnZW5kLm1heEl0ZW1XaWR0aCA9IDA7XG5cdFx0bGVnZW5kLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0bGVnZW5kLml0ZW1IZWlnaHQgPSAwO1xuXHRcdGxlZ2VuZC5zeW1ib2xXaWR0aCA9IHBpY2sob3B0aW9ucy5zeW1ib2xXaWR0aCwgMTYpO1xuXHRcdGxlZ2VuZC5wYWdlcyA9IFtdO1xuXG5cblx0XHQvLyBSZW5kZXIgaXRcblx0XHRsZWdlbmQucmVuZGVyKCk7XG5cblx0XHQvLyBtb3ZlIGNoZWNrYm94ZXNcblx0XHRhZGRFdmVudChsZWdlbmQuY2hhcnQsICdlbmRSZXNpemUnLCBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0bGVnZW5kLnBvc2l0aW9uQ2hlY2tib3hlcygpO1xuXHRcdH0pO1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY29sb3JzIGZvciB0aGUgbGVnZW5kIGl0ZW1cblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gQSBTZXJpZXMgb3IgUG9pbnQgaW5zdGFuY2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IHZpc2libGUgRGltbWVkIG9yIGNvbG9yZWRcblx0ICovXG5cdGNvbG9yaXplSXRlbTogZnVuY3Rpb24gKGl0ZW0sIHZpc2libGUpIHtcblx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBsZWdlbmQub3B0aW9ucyxcblx0XHRcdGxlZ2VuZEl0ZW0gPSBpdGVtLmxlZ2VuZEl0ZW0sXG5cdFx0XHRsZWdlbmRMaW5lID0gaXRlbS5sZWdlbmRMaW5lLFxuXHRcdFx0bGVnZW5kU3ltYm9sID0gaXRlbS5sZWdlbmRTeW1ib2wsXG5cdFx0XHRoaWRkZW5Db2xvciA9IGxlZ2VuZC5pdGVtSGlkZGVuU3R5bGUuY29sb3IsXG5cdFx0XHR0ZXh0Q29sb3IgPSB2aXNpYmxlID8gb3B0aW9ucy5pdGVtU3R5bGUuY29sb3IgOiBoaWRkZW5Db2xvcixcblx0XHRcdHN5bWJvbENvbG9yID0gdmlzaWJsZSA/IChpdGVtLmxlZ2VuZENvbG9yIHx8IGl0ZW0uY29sb3IgfHwgJyNDQ0MnKSA6IGhpZGRlbkNvbG9yLFxuXHRcdFx0bWFya2VyT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucyAmJiBpdGVtLm9wdGlvbnMubWFya2VyLFxuXHRcdFx0c3ltYm9sQXR0ciA9IHsgZmlsbDogc3ltYm9sQ29sb3IgfSxcblx0XHRcdGtleSxcblx0XHRcdHZhbDtcblx0XHRcblx0XHRpZiAobGVnZW5kSXRlbSkge1xuXHRcdFx0bGVnZW5kSXRlbS5jc3MoeyBmaWxsOiB0ZXh0Q29sb3IsIGNvbG9yOiB0ZXh0Q29sb3IgfSk7IC8vIGNvbG9yIGZvciAjMTU1Mywgb2xkSUVcblx0XHR9XG5cdFx0aWYgKGxlZ2VuZExpbmUpIHtcblx0XHRcdGxlZ2VuZExpbmUuYXR0cih7IHN0cm9rZTogc3ltYm9sQ29sb3IgfSk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChsZWdlbmRTeW1ib2wpIHtcblx0XHRcdFxuXHRcdFx0Ly8gQXBwbHkgbWFya2VyIG9wdGlvbnNcblx0XHRcdGlmIChtYXJrZXJPcHRpb25zICYmIGxlZ2VuZFN5bWJvbC5pc01hcmtlcikgeyAvLyAjNTg1XG5cdFx0XHRcdHN5bWJvbEF0dHIuc3Ryb2tlID0gc3ltYm9sQ29sb3I7XG5cdFx0XHRcdG1hcmtlck9wdGlvbnMgPSBpdGVtLmNvbnZlcnRBdHRyaWJzKG1hcmtlck9wdGlvbnMpO1xuXHRcdFx0XHRmb3IgKGtleSBpbiBtYXJrZXJPcHRpb25zKSB7XG5cdFx0XHRcdFx0dmFsID0gbWFya2VyT3B0aW9uc1trZXldO1xuXHRcdFx0XHRcdGlmICh2YWwgIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0c3ltYm9sQXR0cltrZXldID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZWdlbmRTeW1ib2wuYXR0cihzeW1ib2xBdHRyKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFBvc2l0aW9uIHRoZSBsZWdlbmQgaXRlbVxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBBIFNlcmllcyBvciBQb2ludCBpbnN0YW5jZVxuXHQgKi9cblx0cG9zaXRpb25JdGVtOiBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IGxlZ2VuZC5vcHRpb25zLFxuXHRcdFx0c3ltYm9sUGFkZGluZyA9IG9wdGlvbnMuc3ltYm9sUGFkZGluZyxcblx0XHRcdGx0ciA9ICFvcHRpb25zLnJ0bCxcblx0XHRcdGxlZ2VuZEl0ZW1Qb3MgPSBpdGVtLl9sZWdlbmRJdGVtUG9zLFxuXHRcdFx0aXRlbVggPSBsZWdlbmRJdGVtUG9zWzBdLFxuXHRcdFx0aXRlbVkgPSBsZWdlbmRJdGVtUG9zWzFdLFxuXHRcdFx0Y2hlY2tib3ggPSBpdGVtLmNoZWNrYm94LFxuXHRcdFx0bGVnZW5kR3JvdXAgPSBpdGVtLmxlZ2VuZEdyb3VwO1xuXG5cdFx0aWYgKGxlZ2VuZEdyb3VwICYmIGxlZ2VuZEdyb3VwLmVsZW1lbnQpIHtcblx0XHRcdGxlZ2VuZEdyb3VwLnRyYW5zbGF0ZShcblx0XHRcdFx0bHRyID8gaXRlbVggOiBsZWdlbmQubGVnZW5kV2lkdGggLSBpdGVtWCAtIDIgKiBzeW1ib2xQYWRkaW5nIC0gNCxcblx0XHRcdFx0aXRlbVlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGNoZWNrYm94KSB7XG5cdFx0XHRjaGVja2JveC54ID0gaXRlbVg7XG5cdFx0XHRjaGVja2JveC55ID0gaXRlbVk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZXN0cm95IGEgc2luZ2xlIGxlZ2VuZCBpdGVtXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBzZXJpZXMgb3IgcG9pbnRcblx0ICovXG5cdGRlc3Ryb3lJdGVtOiBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhciBjaGVja2JveCA9IGl0ZW0uY2hlY2tib3g7XG5cblx0XHQvLyBkZXN0cm95IFNWRyBlbGVtZW50c1xuXHRcdGVhY2goWydsZWdlbmRJdGVtJywgJ2xlZ2VuZExpbmUnLCAnbGVnZW5kU3ltYm9sJywgJ2xlZ2VuZEdyb3VwJ10sIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGlmIChpdGVtW2tleV0pIHtcblx0XHRcdFx0aXRlbVtrZXldID0gaXRlbVtrZXldLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChjaGVja2JveCkge1xuXHRcdFx0ZGlzY2FyZEVsZW1lbnQoaXRlbS5jaGVja2JveCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgbGVnZW5kLlxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0bGVnZW5kR3JvdXAgPSBsZWdlbmQuZ3JvdXAsXG5cdFx0XHRib3ggPSBsZWdlbmQuYm94O1xuXG5cdFx0aWYgKGJveCkge1xuXHRcdFx0bGVnZW5kLmJveCA9IGJveC5kZXN0cm95KCk7XG5cdFx0fVxuXG5cdFx0aWYgKGxlZ2VuZEdyb3VwKSB7XG5cdFx0XHRsZWdlbmQuZ3JvdXAgPSBsZWdlbmRHcm91cC5kZXN0cm95KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBQb3NpdGlvbiB0aGUgY2hlY2tib3hlcyBhZnRlciB0aGUgd2lkdGggaXMgZGV0ZXJtaW5lZFxuXHQgKi9cblx0cG9zaXRpb25DaGVja2JveGVzOiBmdW5jdGlvbiAoc2Nyb2xsT2Zmc2V0KSB7XG5cdFx0dmFyIGFsaWduQXR0ciA9IHRoaXMuZ3JvdXAuYWxpZ25BdHRyLFxuXHRcdFx0dHJhbnNsYXRlWSxcblx0XHRcdGNsaXBIZWlnaHQgPSB0aGlzLmNsaXBIZWlnaHQgfHwgdGhpcy5sZWdlbmRIZWlnaHQ7XG5cblx0XHRpZiAoYWxpZ25BdHRyKSB7XG5cdFx0XHR0cmFuc2xhdGVZID0gYWxpZ25BdHRyLnRyYW5zbGF0ZVk7XG5cdFx0XHRlYWNoKHRoaXMuYWxsSXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRcdHZhciBjaGVja2JveCA9IGl0ZW0uY2hlY2tib3gsXG5cdFx0XHRcdFx0dG9wO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGNoZWNrYm94KSB7XG5cdFx0XHRcdFx0dG9wID0gKHRyYW5zbGF0ZVkgKyBjaGVja2JveC55ICsgKHNjcm9sbE9mZnNldCB8fCAwKSArIDMpO1xuXHRcdFx0XHRcdGNzcyhjaGVja2JveCwge1xuXHRcdFx0XHRcdFx0bGVmdDogKGFsaWduQXR0ci50cmFuc2xhdGVYICsgaXRlbS5jaGVja2JveE9mZnNldCArIGNoZWNrYm94LnggLSAyMCkgKyBQWCxcblx0XHRcdFx0XHRcdHRvcDogdG9wICsgUFgsXG5cdFx0XHRcdFx0XHRkaXNwbGF5OiB0b3AgPiB0cmFuc2xhdGVZIC0gNiAmJiB0b3AgPCB0cmFuc2xhdGVZICsgY2xpcEhlaWdodCAtIDYgPyAnJyA6IE5PTkVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCAqIFJlbmRlciB0aGUgbGVnZW5kIHRpdGxlIG9uIHRvcCBvZiB0aGUgbGVnZW5kXG5cdCAqL1xuXHRyZW5kZXJUaXRsZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0cGFkZGluZyA9IHRoaXMucGFkZGluZyxcblx0XHRcdHRpdGxlT3B0aW9ucyA9IG9wdGlvbnMudGl0bGUsXG5cdFx0XHR0aXRsZUhlaWdodCA9IDAsXG5cdFx0XHRiQm94O1xuXHRcdFxuXHRcdGlmICh0aXRsZU9wdGlvbnMudGV4dCkge1xuXHRcdFx0aWYgKCF0aGlzLnRpdGxlKSB7XG5cdFx0XHRcdHRoaXMudGl0bGUgPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLmxhYmVsKHRpdGxlT3B0aW9ucy50ZXh0LCBwYWRkaW5nIC0gMywgcGFkZGluZyAtIDQsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICdsZWdlbmQtdGl0bGUnKVxuXHRcdFx0XHRcdC5hdHRyKHsgekluZGV4OiAxIH0pXG5cdFx0XHRcdFx0LmNzcyh0aXRsZU9wdGlvbnMuc3R5bGUpXG5cdFx0XHRcdFx0LmFkZCh0aGlzLmdyb3VwKTtcblx0XHRcdH1cblx0XHRcdGJCb3ggPSB0aGlzLnRpdGxlLmdldEJCb3goKTtcblx0XHRcdHRpdGxlSGVpZ2h0ID0gYkJveC5oZWlnaHQ7XG5cdFx0XHR0aGlzLm9mZnNldFdpZHRoID0gYkJveC53aWR0aDsgLy8gIzE3MTdcblx0XHRcdHRoaXMuY29udGVudEdyb3VwLmF0dHIoeyB0cmFuc2xhdGVZOiB0aXRsZUhlaWdodCB9KTtcblx0XHR9XG5cdFx0dGhpcy50aXRsZUhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGxlZ2VuZCBpdGVtIHRleHRcblx0ICovXG5cdHNldFRleHQ6IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0aXRlbS5sZWdlbmRJdGVtLmF0dHIoe1xuXHRcdFx0dGV4dDogb3B0aW9ucy5sYWJlbEZvcm1hdCA/IGZvcm1hdChvcHRpb25zLmxhYmVsRm9ybWF0LCBpdGVtKSA6IG9wdGlvbnMubGFiZWxGb3JtYXR0ZXIuY2FsbChpdGVtKVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW5kZXIgYSBzaW5nbGUgc3BlY2lmaWMgbGVnZW5kIGl0ZW1cblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gQSBzZXJpZXMgb3IgcG9pbnRcblx0ICovXG5cdHJlbmRlckl0ZW06IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIGxlZ2VuZCA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IGxlZ2VuZC5jaGFydCxcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRvcHRpb25zID0gbGVnZW5kLm9wdGlvbnMsXG5cdFx0XHRob3Jpem9udGFsID0gb3B0aW9ucy5sYXlvdXQgPT09ICdob3Jpem9udGFsJyxcblx0XHRcdHN5bWJvbFdpZHRoID0gbGVnZW5kLnN5bWJvbFdpZHRoLFxuXHRcdFx0c3ltYm9sUGFkZGluZyA9IG9wdGlvbnMuc3ltYm9sUGFkZGluZyxcblx0XHRcdGl0ZW1TdHlsZSA9IGxlZ2VuZC5pdGVtU3R5bGUsXG5cdFx0XHRpdGVtSGlkZGVuU3R5bGUgPSBsZWdlbmQuaXRlbUhpZGRlblN0eWxlLFxuXHRcdFx0cGFkZGluZyA9IGxlZ2VuZC5wYWRkaW5nLFxuXHRcdFx0aXRlbURpc3RhbmNlID0gaG9yaXpvbnRhbCA/IHBpY2sob3B0aW9ucy5pdGVtRGlzdGFuY2UsIDIwKSA6IDAsXG5cdFx0XHRsdHIgPSAhb3B0aW9ucy5ydGwsXG5cdFx0XHRpdGVtSGVpZ2h0LFxuXHRcdFx0d2lkdGhPcHRpb24gPSBvcHRpb25zLndpZHRoLFxuXHRcdFx0aXRlbU1hcmdpbkJvdHRvbSA9IG9wdGlvbnMuaXRlbU1hcmdpbkJvdHRvbSB8fCAwLFxuXHRcdFx0aXRlbU1hcmdpblRvcCA9IGxlZ2VuZC5pdGVtTWFyZ2luVG9wLFxuXHRcdFx0aW5pdGlhbEl0ZW1YID0gbGVnZW5kLmluaXRpYWxJdGVtWCxcblx0XHRcdGJCb3gsXG5cdFx0XHRpdGVtV2lkdGgsXG5cdFx0XHRsaSA9IGl0ZW0ubGVnZW5kSXRlbSxcblx0XHRcdHNlcmllcyA9IGl0ZW0uc2VyaWVzICYmIGl0ZW0uc2VyaWVzLmRyYXdMZWdlbmRTeW1ib2wgPyBpdGVtLnNlcmllcyA6IGl0ZW0sXG5cdFx0XHRzZXJpZXNPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRzaG93Q2hlY2tib3ggPSBsZWdlbmQuY3JlYXRlQ2hlY2tib3hGb3JJdGVtICYmIHNlcmllc09wdGlvbnMgJiYgc2VyaWVzT3B0aW9ucy5zaG93Q2hlY2tib3gsXG5cdFx0XHR1c2VIVE1MID0gb3B0aW9ucy51c2VIVE1MO1xuXG5cdFx0aWYgKCFsaSkgeyAvLyBnZW5lcmF0ZSBpdCBvbmNlLCBsYXRlciBtb3ZlIGl0XG5cblx0XHRcdC8vIEdlbmVyYXRlIHRoZSBncm91cCBib3hcblx0XHRcdC8vIEEgZ3JvdXAgdG8gaG9sZCB0aGUgc3ltYm9sIGFuZCB0ZXh0LiBUZXh0IGlzIHRvIGJlIGFwcGVuZGVkIGluIExlZ2VuZCBjbGFzcy5cblx0XHRcdGl0ZW0ubGVnZW5kR3JvdXAgPSByZW5kZXJlci5nKCdsZWdlbmQtaXRlbScpXG5cdFx0XHRcdC5hdHRyKHsgekluZGV4OiAxIH0pXG5cdFx0XHRcdC5hZGQobGVnZW5kLnNjcm9sbEdyb3VwKTtcblxuXHRcdFx0Ly8gR2VuZXJhdGUgdGhlIGxpc3QgaXRlbSB0ZXh0IGFuZCBhZGQgaXQgdG8gdGhlIGdyb3VwXG5cdFx0XHRpdGVtLmxlZ2VuZEl0ZW0gPSBsaSA9IHJlbmRlcmVyLnRleHQoXG5cdFx0XHRcdFx0JycsXG5cdFx0XHRcdFx0bHRyID8gc3ltYm9sV2lkdGggKyBzeW1ib2xQYWRkaW5nIDogLXN5bWJvbFBhZGRpbmcsXG5cdFx0XHRcdFx0bGVnZW5kLmJhc2VsaW5lIHx8IDAsXG5cdFx0XHRcdFx0dXNlSFRNTFxuXHRcdFx0XHQpXG5cdFx0XHRcdC5jc3MobWVyZ2UoaXRlbS52aXNpYmxlID8gaXRlbVN0eWxlIDogaXRlbUhpZGRlblN0eWxlKSkgLy8gbWVyZ2UgdG8gcHJldmVudCBtb2RpZnlpbmcgb3JpZ2luYWwgKCMxMDIxKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0YWxpZ246IGx0ciA/ICdsZWZ0JyA6ICdyaWdodCcsXG5cdFx0XHRcdFx0ekluZGV4OiAyXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGQoaXRlbS5sZWdlbmRHcm91cCk7XG5cblx0XHRcdC8vIEdldCB0aGUgYmFzZWxpbmUgZm9yIHRoZSBmaXJzdCBpdGVtIC0gdGhlIGZvbnQgc2l6ZSBpcyBlcXVhbCBmb3IgYWxsXG5cdFx0XHRpZiAoIWxlZ2VuZC5iYXNlbGluZSkge1xuXHRcdFx0XHRsZWdlbmQuZm9udE1ldHJpY3MgPSByZW5kZXJlci5mb250TWV0cmljcyhpdGVtU3R5bGUuZm9udFNpemUsIGxpKTtcblx0XHRcdFx0bGVnZW5kLmJhc2VsaW5lID0gbGVnZW5kLmZvbnRNZXRyaWNzLmYgKyAzICsgaXRlbU1hcmdpblRvcDtcblx0XHRcdFx0bGkuYXR0cigneScsIGxlZ2VuZC5iYXNlbGluZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERyYXcgdGhlIGxlZ2VuZCBzeW1ib2wgaW5zaWRlIHRoZSBncm91cCBib3hcblx0XHRcdHNlcmllcy5kcmF3TGVnZW5kU3ltYm9sKGxlZ2VuZCwgaXRlbSk7XG5cblx0XHRcdGlmIChsZWdlbmQuc2V0SXRlbUV2ZW50cykge1xuXHRcdFx0XHRsZWdlbmQuc2V0SXRlbUV2ZW50cyhpdGVtLCBsaSwgdXNlSFRNTCwgaXRlbVN0eWxlLCBpdGVtSGlkZGVuU3R5bGUpO1xuXHRcdFx0fVx0XHRcdFxuXG5cdFx0XHQvLyBDb2xvcml6ZSB0aGUgaXRlbXNcblx0XHRcdGxlZ2VuZC5jb2xvcml6ZUl0ZW0oaXRlbSwgaXRlbS52aXNpYmxlKTtcblxuXHRcdFx0Ly8gYWRkIHRoZSBIVE1MIGNoZWNrYm94IG9uIHRvcFxuXHRcdFx0aWYgKHNob3dDaGVja2JveCkge1xuXHRcdFx0XHRsZWdlbmQuY3JlYXRlQ2hlY2tib3hGb3JJdGVtKGl0ZW0pO1x0XHRcdFx0XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIHVwZGF0ZSB0aGUgdGV4dFxuXHRcdGxlZ2VuZC5zZXRUZXh0KGl0ZW0pO1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbnMgZm9yIHRoZSBuZXh0IGxpbmVcblx0XHRiQm94ID0gbGkuZ2V0QkJveCgpO1xuXG5cdFx0aXRlbVdpZHRoID0gaXRlbS5jaGVja2JveE9mZnNldCA9IFxuXHRcdFx0b3B0aW9ucy5pdGVtV2lkdGggfHwgXG5cdFx0XHRpdGVtLmxlZ2VuZEl0ZW1XaWR0aCB8fCBcblx0XHRcdHN5bWJvbFdpZHRoICsgc3ltYm9sUGFkZGluZyArIGJCb3gud2lkdGggKyBpdGVtRGlzdGFuY2UgKyAoc2hvd0NoZWNrYm94ID8gMjAgOiAwKTtcblx0XHRsZWdlbmQuaXRlbUhlaWdodCA9IGl0ZW1IZWlnaHQgPSBtYXRoUm91bmQoaXRlbS5sZWdlbmRJdGVtSGVpZ2h0IHx8IGJCb3guaGVpZ2h0KTtcblxuXHRcdC8vIGlmIHRoZSBpdGVtIGV4Y2VlZHMgdGhlIHdpZHRoLCBzdGFydCBhIG5ldyBsaW5lXG5cdFx0aWYgKGhvcml6b250YWwgJiYgbGVnZW5kLml0ZW1YIC0gaW5pdGlhbEl0ZW1YICsgaXRlbVdpZHRoID5cblx0XHRcdFx0KHdpZHRoT3B0aW9uIHx8IChjaGFydC5jaGFydFdpZHRoIC0gMiAqIHBhZGRpbmcgLSBpbml0aWFsSXRlbVggLSBvcHRpb25zLngpKSkge1xuXHRcdFx0bGVnZW5kLml0ZW1YID0gaW5pdGlhbEl0ZW1YO1xuXHRcdFx0bGVnZW5kLml0ZW1ZICs9IGl0ZW1NYXJnaW5Ub3AgKyBsZWdlbmQubGFzdExpbmVIZWlnaHQgKyBpdGVtTWFyZ2luQm90dG9tO1xuXHRcdFx0bGVnZW5kLmxhc3RMaW5lSGVpZ2h0ID0gMDsgLy8gcmVzZXQgZm9yIG5leHQgbGluZSAoIzkxNSwgIzM5NzYpXG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIGl0ZW0gZXhjZWVkcyB0aGUgaGVpZ2h0LCBzdGFydCBhIG5ldyBjb2x1bW5cblx0XHQvKmlmICghaG9yaXpvbnRhbCAmJiBsZWdlbmQuaXRlbVkgKyBvcHRpb25zLnkgKyBpdGVtSGVpZ2h0ID4gY2hhcnQuY2hhcnRIZWlnaHQgLSBzcGFjaW5nVG9wIC0gc3BhY2luZ0JvdHRvbSkge1xuXHRcdFx0bGVnZW5kLml0ZW1ZID0gbGVnZW5kLmluaXRpYWxJdGVtWTtcblx0XHRcdGxlZ2VuZC5pdGVtWCArPSBsZWdlbmQubWF4SXRlbVdpZHRoO1xuXHRcdFx0bGVnZW5kLm1heEl0ZW1XaWR0aCA9IDA7XG5cdFx0fSovXG5cblx0XHQvLyBTZXQgdGhlIGVkZ2UgcG9zaXRpb25zXG5cdFx0bGVnZW5kLm1heEl0ZW1XaWR0aCA9IG1hdGhNYXgobGVnZW5kLm1heEl0ZW1XaWR0aCwgaXRlbVdpZHRoKTtcblx0XHRsZWdlbmQubGFzdEl0ZW1ZID0gaXRlbU1hcmdpblRvcCArIGxlZ2VuZC5pdGVtWSArIGl0ZW1NYXJnaW5Cb3R0b207XG5cdFx0bGVnZW5kLmxhc3RMaW5lSGVpZ2h0ID0gbWF0aE1heChpdGVtSGVpZ2h0LCBsZWdlbmQubGFzdExpbmVIZWlnaHQpOyAvLyAjOTE1XG5cblx0XHQvLyBjYWNoZSB0aGUgcG9zaXRpb24gb2YgdGhlIG5ld2x5IGdlbmVyYXRlZCBvciByZW9yZGVyZWQgaXRlbXNcblx0XHRpdGVtLl9sZWdlbmRJdGVtUG9zID0gW2xlZ2VuZC5pdGVtWCwgbGVnZW5kLml0ZW1ZXTtcblxuXHRcdC8vIGFkdmFuY2Vcblx0XHRpZiAoaG9yaXpvbnRhbCkge1xuXHRcdFx0bGVnZW5kLml0ZW1YICs9IGl0ZW1XaWR0aDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZWdlbmQuaXRlbVkgKz0gaXRlbU1hcmdpblRvcCArIGl0ZW1IZWlnaHQgKyBpdGVtTWFyZ2luQm90dG9tO1xuXHRcdFx0bGVnZW5kLmxhc3RMaW5lSGVpZ2h0ID0gaXRlbUhlaWdodDtcblx0XHR9XG5cblx0XHQvLyB0aGUgd2lkdGggb2YgdGhlIHdpZGVzdCBpdGVtXG5cdFx0bGVnZW5kLm9mZnNldFdpZHRoID0gd2lkdGhPcHRpb24gfHwgbWF0aE1heChcblx0XHRcdChob3Jpem9udGFsID8gbGVnZW5kLml0ZW1YIC0gaW5pdGlhbEl0ZW1YIC0gaXRlbURpc3RhbmNlIDogaXRlbVdpZHRoKSArIHBhZGRpbmcsXG5cdFx0XHRsZWdlbmQub2Zmc2V0V2lkdGhcblx0XHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYWxsIGl0ZW1zLCB3aGljaCBpcyBvbmUgaXRlbSBwZXIgc2VyaWVzIGZvciBub3JtYWwgc2VyaWVzIGFuZCBvbmUgaXRlbSBwZXIgcG9pbnRcblx0ICogZm9yIHBpZSBzZXJpZXMuXG5cdCAqL1xuXHRnZXRBbGxJdGVtczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBhbGxJdGVtcyA9IFtdO1xuXHRcdGVhY2godGhpcy5jaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdHZhciBzZXJpZXNPcHRpb25zID0gc2VyaWVzLm9wdGlvbnM7XG5cblx0XHRcdC8vIEhhbmRsZSBzaG93SW5MZWdlbmQuIElmIHRoZSBzZXJpZXMgaXMgbGlua2VkIHRvIGFub3RoZXIgc2VyaWVzLCBkZWZhdWx0cyB0byBmYWxzZS5cblx0XHRcdGlmICghcGljayhzZXJpZXNPcHRpb25zLnNob3dJbkxlZ2VuZCwgIWRlZmluZWQoc2VyaWVzT3B0aW9ucy5saW5rZWRUbykgPyBVTkRFRklORUQgOiBmYWxzZSwgdHJ1ZSkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB1c2UgcG9pbnRzIG9yIHNlcmllcyBmb3IgdGhlIGxlZ2VuZCBpdGVtIGRlcGVuZGluZyBvbiBsZWdlbmRUeXBlXG5cdFx0XHRhbGxJdGVtcyA9IGFsbEl0ZW1zLmNvbmNhdChcblx0XHRcdFx0XHRzZXJpZXMubGVnZW5kSXRlbXMgfHxcblx0XHRcdFx0XHQoc2VyaWVzT3B0aW9ucy5sZWdlbmRUeXBlID09PSAncG9pbnQnID9cblx0XHRcdFx0XHRcdFx0c2VyaWVzLmRhdGEgOlxuXHRcdFx0XHRcdFx0XHRzZXJpZXMpXG5cdFx0XHQpO1xuXHRcdH0pO1xuXHRcdHJldHVybiBhbGxJdGVtcztcblx0fSxcblxuXHQvKipcblx0ICogQWRqdXN0IHRoZSBjaGFydCBtYXJnaW5zIGJ5IHJlc2VydmluZyBzcGFjZSBmb3IgdGhlIGxlZ2VuZCBvbiBvbmx5IG9uZSBzaWRlXG5cdCAqIG9mIHRoZSBjaGFydC4gSWYgdGhlIHBvc2l0aW9uIGlzIHNldCB0byBhIGNvcm5lciwgdG9wIG9yIGJvdHRvbSBpcyByZXNlcnZlZFxuXHQgKiBmb3IgaG9yaXpvbnRhbCBsZWdlbmRzIGFuZCBsZWZ0IG9yIHJpZ2h0IGZvciB2ZXJ0aWNhbCBvbmVzLlxuXHQgKi9cblx0YWRqdXN0TWFyZ2luczogZnVuY3Rpb24gKG1hcmdpbiwgc3BhY2luZykge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsIFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdC8vIFVzZSB0aGUgZmlyc3QgbGV0dGVyIG9mIGVhY2ggYWxpZ25tZW50IG9wdGlvbiBpbiBvcmRlciB0byBkZXRlY3QgdGhlIHNpZGUgXG5cdFx0XHRhbGlnbm1lbnQgPSBvcHRpb25zLmFsaWduLmNoYXJBdCgwKSArIG9wdGlvbnMudmVydGljYWxBbGlnbi5jaGFyQXQoMCkgKyBvcHRpb25zLmxheW91dC5jaGFyQXQoMCk7IC8vICM0MTg5IC0gdXNlIGNoYXJBdCh4KSBub3RhdGlvbiBpbnN0ZWFkIG9mIFt4XSBmb3IgSUU3XG5cdFx0XHRcblx0XHRpZiAodGhpcy5kaXNwbGF5ICYmICFvcHRpb25zLmZsb2F0aW5nKSB7XG5cblx0XHRcdGVhY2goW1xuXHRcdFx0XHQvKGx0aHxjdHxydGgpLyxcblx0XHRcdFx0LyhydHZ8cm18cmJ2KS8sXG5cdFx0XHRcdC8ocmJofGNifGxiaCkvLFxuXHRcdFx0XHQvKGxidnxsbXxsdHYpL1xuXHRcdFx0XSwgZnVuY3Rpb24gKGFsaWdubWVudHMsIHNpZGUpIHtcblx0XHRcdFx0aWYgKGFsaWdubWVudHMudGVzdChhbGlnbm1lbnQpICYmICFkZWZpbmVkKG1hcmdpbltzaWRlXSkpIHtcblx0XHRcdFx0XHQvLyBOb3cgd2UgaGF2ZSBkZXRlY3RlZCBvbiB3aGljaCBzaWRlIG9mIHRoZSBjaGFydCB3ZSBzaG91bGQgcmVzZXJ2ZSBzcGFjZSBmb3IgdGhlIGxlZ2VuZFxuXHRcdFx0XHRcdGNoYXJ0W21hcmdpbk5hbWVzW3NpZGVdXSA9IG1hdGhNYXgoXG5cdFx0XHRcdFx0XHRjaGFydFttYXJnaW5OYW1lc1tzaWRlXV0sXG5cdFx0XHRcdFx0XHRjaGFydC5sZWdlbmRbKHNpZGUgKyAxKSAlIDIgPyAnbGVnZW5kSGVpZ2h0JyA6ICdsZWdlbmRXaWR0aCddICsgXG5cdFx0XHRcdFx0XHRcdFsxLCAtMSwgLTEsIDFdW3NpZGVdICogb3B0aW9uc1soc2lkZSAlIDIpID8gJ3gnIDogJ3knXSArIFxuXHRcdFx0XHRcdFx0XHRwaWNrKG9wdGlvbnMubWFyZ2luLCAxMikgK1xuXHRcdFx0XHRcdFx0XHRzcGFjaW5nW3NpZGVdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW5kZXIgdGhlIGxlZ2VuZC4gVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBib3RoIGJlZm9yZSBhbmQgYWZ0ZXJcblx0ICogY2hhcnQucmVuZGVyLiBJZiBjYWxsZWQgYWZ0ZXIsIGl0IHdpbGwgb25seSByZWFycmFuZ2UgaXRlbXMgaW5zdGVhZFxuXHQgKiBvZiBjcmVhdGluZyBuZXcgb25lcy5cblx0ICovXG5cdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBsZWdlbmQuY2hhcnQsXG5cdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0bGVnZW5kR3JvdXAgPSBsZWdlbmQuZ3JvdXAsXG5cdFx0XHRhbGxJdGVtcyxcblx0XHRcdGRpc3BsYXksXG5cdFx0XHRsZWdlbmRXaWR0aCxcblx0XHRcdGxlZ2VuZEhlaWdodCxcblx0XHRcdGJveCA9IGxlZ2VuZC5ib3gsXG5cdFx0XHRvcHRpb25zID0gbGVnZW5kLm9wdGlvbnMsXG5cdFx0XHRwYWRkaW5nID0gbGVnZW5kLnBhZGRpbmcsXG5cdFx0XHRsZWdlbmRCb3JkZXJXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRsZWdlbmRCYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcblxuXHRcdGxlZ2VuZC5pdGVtWCA9IGxlZ2VuZC5pbml0aWFsSXRlbVg7XG5cdFx0bGVnZW5kLml0ZW1ZID0gbGVnZW5kLmluaXRpYWxJdGVtWTtcblx0XHRsZWdlbmQub2Zmc2V0V2lkdGggPSAwO1xuXHRcdGxlZ2VuZC5sYXN0SXRlbVkgPSAwO1xuXG5cdFx0aWYgKCFsZWdlbmRHcm91cCkge1xuXHRcdFx0bGVnZW5kLmdyb3VwID0gbGVnZW5kR3JvdXAgPSByZW5kZXJlci5nKCdsZWdlbmQnKVxuXHRcdFx0XHQuYXR0cih7IHpJbmRleDogNyB9KSBcblx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0bGVnZW5kLmNvbnRlbnRHcm91cCA9IHJlbmRlcmVyLmcoKVxuXHRcdFx0XHQuYXR0cih7IHpJbmRleDogMSB9KSAvLyBhYm92ZSBiYWNrZ3JvdW5kXG5cdFx0XHRcdC5hZGQobGVnZW5kR3JvdXApO1xuXHRcdFx0bGVnZW5kLnNjcm9sbEdyb3VwID0gcmVuZGVyZXIuZygpXG5cdFx0XHRcdC5hZGQobGVnZW5kLmNvbnRlbnRHcm91cCk7XG5cdFx0fVxuXHRcdFxuXHRcdGxlZ2VuZC5yZW5kZXJUaXRsZSgpO1xuXG5cdFx0Ly8gYWRkIGVhY2ggc2VyaWVzIG9yIHBvaW50XG5cdFx0YWxsSXRlbXMgPSBsZWdlbmQuZ2V0QWxsSXRlbXMoKTtcblxuXHRcdC8vIHNvcnQgYnkgbGVnZW5kSW5kZXhcblx0XHRzdGFibGVTb3J0KGFsbEl0ZW1zLCBmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0cmV0dXJuICgoYS5vcHRpb25zICYmIGEub3B0aW9ucy5sZWdlbmRJbmRleCkgfHwgMCkgLSAoKGIub3B0aW9ucyAmJiBiLm9wdGlvbnMubGVnZW5kSW5kZXgpIHx8IDApO1xuXHRcdH0pO1xuXG5cdFx0Ly8gcmV2ZXJzZWQgbGVnZW5kXG5cdFx0aWYgKG9wdGlvbnMucmV2ZXJzZWQpIHtcblx0XHRcdGFsbEl0ZW1zLnJldmVyc2UoKTtcblx0XHR9XG5cblx0XHRsZWdlbmQuYWxsSXRlbXMgPSBhbGxJdGVtcztcblx0XHRsZWdlbmQuZGlzcGxheSA9IGRpc3BsYXkgPSAhIWFsbEl0ZW1zLmxlbmd0aDtcblxuXHRcdC8vIHJlbmRlciB0aGUgaXRlbXNcblx0XHRsZWdlbmQubGFzdExpbmVIZWlnaHQgPSAwO1xuXHRcdGVhY2goYWxsSXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRsZWdlbmQucmVuZGVySXRlbShpdGVtKTsgXG5cdFx0fSk7XG5cblx0XHQvLyBHZXQgdGhlIGJveFxuXHRcdGxlZ2VuZFdpZHRoID0gKG9wdGlvbnMud2lkdGggfHwgbGVnZW5kLm9mZnNldFdpZHRoKSArIHBhZGRpbmc7XG5cdFx0bGVnZW5kSGVpZ2h0ID0gbGVnZW5kLmxhc3RJdGVtWSArIGxlZ2VuZC5sYXN0TGluZUhlaWdodCArIGxlZ2VuZC50aXRsZUhlaWdodDtcblx0XHRsZWdlbmRIZWlnaHQgPSBsZWdlbmQuaGFuZGxlT3ZlcmZsb3cobGVnZW5kSGVpZ2h0KTtcblx0XHRsZWdlbmRIZWlnaHQgKz0gcGFkZGluZztcblxuXHRcdC8vIERyYXcgdGhlIGJvcmRlciBhbmQvb3IgYmFja2dyb3VuZFxuXHRcdGlmIChsZWdlbmRCb3JkZXJXaWR0aCB8fCBsZWdlbmRCYWNrZ3JvdW5kQ29sb3IpIHtcblxuXHRcdFx0aWYgKCFib3gpIHtcblx0XHRcdFx0bGVnZW5kLmJveCA9IGJveCA9IHJlbmRlcmVyLnJlY3QoXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdGxlZ2VuZFdpZHRoLFxuXHRcdFx0XHRcdGxlZ2VuZEhlaWdodCxcblx0XHRcdFx0XHRvcHRpb25zLmJvcmRlclJhZGl1cyxcblx0XHRcdFx0XHRsZWdlbmRCb3JkZXJXaWR0aCB8fCAwXG5cdFx0XHRcdCkuYXR0cih7XG5cdFx0XHRcdFx0c3Ryb2tlOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBsZWdlbmRCb3JkZXJXaWR0aCB8fCAwLFxuXHRcdFx0XHRcdGZpbGw6IGxlZ2VuZEJhY2tncm91bmRDb2xvciB8fCBOT05FXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGQobGVnZW5kR3JvdXApXG5cdFx0XHRcdC5zaGFkb3cob3B0aW9ucy5zaGFkb3cpO1xuXHRcdFx0XHRib3guaXNOZXcgPSB0cnVlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKGxlZ2VuZFdpZHRoID4gMCAmJiBsZWdlbmRIZWlnaHQgPiAwKSB7XG5cdFx0XHRcdGJveFtib3guaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKFxuXHRcdFx0XHRcdGJveC5jcmlzcCh7IHdpZHRoOiBsZWdlbmRXaWR0aCwgaGVpZ2h0OiBsZWdlbmRIZWlnaHQgfSlcblx0XHRcdFx0KTtcblx0XHRcdFx0Ym94LmlzTmV3ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGhpZGUgdGhlIGJvcmRlciBpZiBubyBpdGVtc1xuXHRcdFx0Ym94W2Rpc3BsYXkgPyAnc2hvdycgOiAnaGlkZSddKCk7XG5cdFx0fVxuXHRcdFxuXHRcdGxlZ2VuZC5sZWdlbmRXaWR0aCA9IGxlZ2VuZFdpZHRoO1xuXHRcdGxlZ2VuZC5sZWdlbmRIZWlnaHQgPSBsZWdlbmRIZWlnaHQ7XG5cblx0XHQvLyBOb3cgdGhhdCB0aGUgbGVnZW5kIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGVzdGFibGlzaGVkLCBwdXQgdGhlIGl0ZW1zIGluIHRoZSBcblx0XHQvLyBmaW5hbCBwb3NpdGlvblxuXHRcdGVhY2goYWxsSXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRsZWdlbmQucG9zaXRpb25JdGVtKGl0ZW0pO1xuXHRcdH0pO1xuXG5cdFx0Ly8gMS54IGNvbXBhdGliaWxpdHk6IHBvc2l0aW9uaW5nIGJhc2VkIG9uIHN0eWxlXG5cdFx0Lyp2YXIgcHJvcHMgPSBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuXHRcdFx0cHJvcCxcblx0XHRcdGkgPSA0O1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdHByb3AgPSBwcm9wc1tpXTtcblx0XHRcdGlmIChvcHRpb25zLnN0eWxlW3Byb3BdICYmIG9wdGlvbnMuc3R5bGVbcHJvcF0gIT09ICdhdXRvJykge1xuXHRcdFx0XHRvcHRpb25zW2kgPCAyID8gJ2FsaWduJyA6ICd2ZXJ0aWNhbEFsaWduJ10gPSBwcm9wO1xuXHRcdFx0XHRvcHRpb25zW2kgPCAyID8gJ3gnIDogJ3knXSA9IHBJbnQob3B0aW9ucy5zdHlsZVtwcm9wXSkgKiAoaSAlIDIgPyAtMSA6IDEpO1xuXHRcdFx0fVxuXHRcdH0qL1xuXG5cdFx0aWYgKGRpc3BsYXkpIHtcblx0XHRcdGxlZ2VuZEdyb3VwLmFsaWduKGV4dGVuZCh7XG5cdFx0XHRcdHdpZHRoOiBsZWdlbmRXaWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBsZWdlbmRIZWlnaHRcblx0XHRcdH0sIG9wdGlvbnMpLCB0cnVlLCAnc3BhY2luZ0JveCcpO1xuXHRcdH1cblxuXHRcdGlmICghY2hhcnQuaXNSZXNpemluZykge1xuXHRcdFx0dGhpcy5wb3NpdGlvbkNoZWNrYm94ZXMoKTtcblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0ICogU2V0IHVwIHRoZSBvdmVyZmxvdyBoYW5kbGluZyBieSBhZGRpbmcgbmF2aWdhdGlvbiB3aXRoIHVwIGFuZCBkb3duIGFycm93cyBiZWxvdyB0aGVcblx0ICogbGVnZW5kLlxuXHQgKi9cblx0aGFuZGxlT3ZlcmZsb3c6IGZ1bmN0aW9uIChsZWdlbmRIZWlnaHQpIHtcblx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0b3B0aW9uc1kgPSBvcHRpb25zLnksXG5cdFx0XHRhbGlnblRvcCA9IG9wdGlvbnMudmVydGljYWxBbGlnbiA9PT0gJ3RvcCcsXG5cdFx0XHRzcGFjZUhlaWdodCA9IGNoYXJ0LnNwYWNpbmdCb3guaGVpZ2h0ICsgKGFsaWduVG9wID8gLW9wdGlvbnNZIDogb3B0aW9uc1kpIC0gdGhpcy5wYWRkaW5nLFxuXHRcdFx0bWF4SGVpZ2h0ID0gb3B0aW9ucy5tYXhIZWlnaHQsXG5cdFx0XHRjbGlwSGVpZ2h0LFxuXHRcdFx0Y2xpcFJlY3QgPSB0aGlzLmNsaXBSZWN0LFxuXHRcdFx0bmF2T3B0aW9ucyA9IG9wdGlvbnMubmF2aWdhdGlvbixcblx0XHRcdGFuaW1hdGlvbiA9IHBpY2sobmF2T3B0aW9ucy5hbmltYXRpb24sIHRydWUpLFxuXHRcdFx0YXJyb3dTaXplID0gbmF2T3B0aW9ucy5hcnJvd1NpemUgfHwgMTIsXG5cdFx0XHRuYXYgPSB0aGlzLm5hdixcblx0XHRcdHBhZ2VzID0gdGhpcy5wYWdlcyxcblx0XHRcdHBhZGRpbmcgPSB0aGlzLnBhZGRpbmcsXG5cdFx0XHRsYXN0WSxcblx0XHRcdGFsbEl0ZW1zID0gdGhpcy5hbGxJdGVtcyxcblx0XHRcdGNsaXBUb0hlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcblx0XHRcdFx0Y2xpcFJlY3QuYXR0cih7XG5cdFx0XHRcdFx0aGVpZ2h0OiBoZWlnaHRcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gdXNlSFRNTFxuXHRcdFx0XHRpZiAobGVnZW5kLmNvbnRlbnRHcm91cC5kaXYpIHtcblx0XHRcdFx0XHRsZWdlbmQuY29udGVudEdyb3VwLmRpdi5zdHlsZS5jbGlwID0gJ3JlY3QoJyArIHBhZGRpbmcgKyAncHgsOTk5OXB4LCcgKyAocGFkZGluZyArIGhlaWdodCkgKyAncHgsMCknO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRcblx0XHQvLyBBZGp1c3QgdGhlIGhlaWdodFxuXHRcdGlmIChvcHRpb25zLmxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG5cdFx0XHRzcGFjZUhlaWdodCAvPSAyO1xuXHRcdH1cblx0XHRpZiAobWF4SGVpZ2h0KSB7XG5cdFx0XHRzcGFjZUhlaWdodCA9IG1hdGhNaW4oc3BhY2VIZWlnaHQsIG1heEhlaWdodCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFJlc2V0IHRoZSBsZWdlbmQgaGVpZ2h0IGFuZCBhZGp1c3QgdGhlIGNsaXBwaW5nIHJlY3RhbmdsZVxuXHRcdHBhZ2VzLmxlbmd0aCA9IDA7XG5cdFx0aWYgKGxlZ2VuZEhlaWdodCA+IHNwYWNlSGVpZ2h0KSB7XG5cblx0XHRcdHRoaXMuY2xpcEhlaWdodCA9IGNsaXBIZWlnaHQgPSBtYXRoTWF4KHNwYWNlSGVpZ2h0IC0gMjAgLSB0aGlzLnRpdGxlSGVpZ2h0IC0gcGFkZGluZywgMCk7XG5cdFx0XHR0aGlzLmN1cnJlbnRQYWdlID0gcGljayh0aGlzLmN1cnJlbnRQYWdlLCAxKTtcblx0XHRcdHRoaXMuZnVsbEhlaWdodCA9IGxlZ2VuZEhlaWdodDtcblx0XHRcdFxuXHRcdFx0Ly8gRmlsbCBwYWdlcyB3aXRoIFkgcG9zaXRpb25zIHNvIHRoYXQgdGhlIHRvcCBvZiBlYWNoIGEgbGVnZW5kIGl0ZW0gZGVmaW5lc1xuXHRcdFx0Ly8gdGhlIHNjcm9sbCB0b3AgZm9yIGVhY2ggcGFnZSAoIzIwOTgpXG5cdFx0XHRlYWNoKGFsbEl0ZW1zLCBmdW5jdGlvbiAoaXRlbSwgaSkge1xuXHRcdFx0XHR2YXIgeSA9IGl0ZW0uX2xlZ2VuZEl0ZW1Qb3NbMV0sXG5cdFx0XHRcdFx0aCA9IG1hdGhSb3VuZChpdGVtLmxlZ2VuZEl0ZW0uZ2V0QkJveCgpLmhlaWdodCksXG5cdFx0XHRcdFx0bGVuID0gcGFnZXMubGVuZ3RoO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFsZW4gfHwgKHkgLSBwYWdlc1tsZW4gLSAxXSA+IGNsaXBIZWlnaHQgJiYgKGxhc3RZIHx8IHkpICE9PSBwYWdlc1tsZW4gLSAxXSkpIHtcblx0XHRcdFx0XHRwYWdlcy5wdXNoKGxhc3RZIHx8IHkpO1xuXHRcdFx0XHRcdGxlbisrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoaSA9PT0gYWxsSXRlbXMubGVuZ3RoIC0gMSAmJiB5ICsgaCAtIHBhZ2VzW2xlbiAtIDFdID4gY2xpcEhlaWdodCkge1xuXHRcdFx0XHRcdHBhZ2VzLnB1c2goeSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHkgIT09IGxhc3RZKSB7XG5cdFx0XHRcdFx0bGFzdFkgPSB5O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gT25seSBhcHBseSBjbGlwcGluZyBpZiBuZWVkZWQuIENsaXBwaW5nIGNhdXNlcyBibHVycmVkIGxlZ2VuZCBpbiBQREYgZXhwb3J0ICgjMTc4Nylcblx0XHRcdGlmICghY2xpcFJlY3QpIHtcblx0XHRcdFx0Y2xpcFJlY3QgPSBsZWdlbmQuY2xpcFJlY3QgPSByZW5kZXJlci5jbGlwUmVjdCgwLCBwYWRkaW5nLCA5OTk5LCAwKTtcblx0XHRcdFx0bGVnZW5kLmNvbnRlbnRHcm91cC5jbGlwKGNsaXBSZWN0KTtcblx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRjbGlwVG9IZWlnaHQoY2xpcEhlaWdodCk7XG5cblx0XHRcdC8vIEFkZCBuYXZpZ2F0aW9uIGVsZW1lbnRzXG5cdFx0XHRpZiAoIW5hdikge1xuXHRcdFx0XHR0aGlzLm5hdiA9IG5hdiA9IHJlbmRlcmVyLmcoKS5hdHRyKHsgekluZGV4OiAxIH0pLmFkZCh0aGlzLmdyb3VwKTtcblx0XHRcdFx0dGhpcy51cCA9IHJlbmRlcmVyLnN5bWJvbCgndHJpYW5nbGUnLCAwLCAwLCBhcnJvd1NpemUsIGFycm93U2l6ZSlcblx0XHRcdFx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0bGVnZW5kLnNjcm9sbCgtMSwgYW5pbWF0aW9uKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGQobmF2KTtcblx0XHRcdFx0dGhpcy5wYWdlciA9IHJlbmRlcmVyLnRleHQoJycsIDE1LCAxMClcblx0XHRcdFx0XHQuY3NzKG5hdk9wdGlvbnMuc3R5bGUpXG5cdFx0XHRcdFx0LmFkZChuYXYpO1xuXHRcdFx0XHR0aGlzLmRvd24gPSByZW5kZXJlci5zeW1ib2woJ3RyaWFuZ2xlLWRvd24nLCAwLCAwLCBhcnJvd1NpemUsIGFycm93U2l6ZSlcblx0XHRcdFx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0bGVnZW5kLnNjcm9sbCgxLCBhbmltYXRpb24pO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZChuYXYpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBTZXQgaW5pdGlhbCBwb3NpdGlvblxuXHRcdFx0bGVnZW5kLnNjcm9sbCgwKTtcblx0XHRcdFxuXHRcdFx0bGVnZW5kSGVpZ2h0ID0gc3BhY2VIZWlnaHQ7XG5cdFx0XHRcblx0XHR9IGVsc2UgaWYgKG5hdikge1xuXHRcdFx0Y2xpcFRvSGVpZ2h0KGNoYXJ0LmNoYXJ0SGVpZ2h0KTtcblx0XHRcdG5hdi5oaWRlKCk7XG5cdFx0XHR0aGlzLnNjcm9sbEdyb3VwLmF0dHIoe1xuXHRcdFx0XHR0cmFuc2xhdGVZOiAxXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuY2xpcEhlaWdodCA9IDA7IC8vICMxMzc5XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBsZWdlbmRIZWlnaHQ7XG5cdH0sXG5cdFxuXHQvKipcblx0ICogU2Nyb2xsIHRoZSBsZWdlbmQgYnkgYSBudW1iZXIgb2YgcGFnZXNcblx0ICogQHBhcmFtIHtPYmplY3R9IHNjcm9sbEJ5XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhbmltYXRpb25cblx0ICovXG5cdHNjcm9sbDogZnVuY3Rpb24gKHNjcm9sbEJ5LCBhbmltYXRpb24pIHtcblx0XHR2YXIgcGFnZXMgPSB0aGlzLnBhZ2VzLFxuXHRcdFx0cGFnZUNvdW50ID0gcGFnZXMubGVuZ3RoLFxuXHRcdFx0Y3VycmVudFBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlICsgc2Nyb2xsQnksXG5cdFx0XHRjbGlwSGVpZ2h0ID0gdGhpcy5jbGlwSGVpZ2h0LFxuXHRcdFx0bmF2T3B0aW9ucyA9IHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uLFxuXHRcdFx0YWN0aXZlQ29sb3IgPSBuYXZPcHRpb25zLmFjdGl2ZUNvbG9yLFxuXHRcdFx0aW5hY3RpdmVDb2xvciA9IG5hdk9wdGlvbnMuaW5hY3RpdmVDb2xvcixcblx0XHRcdHBhZ2VyID0gdGhpcy5wYWdlcixcblx0XHRcdHBhZGRpbmcgPSB0aGlzLnBhZGRpbmcsXG5cdFx0XHRzY3JvbGxPZmZzZXQ7XG5cdFx0XG5cdFx0Ly8gV2hlbiByZXNpemluZyB3aGlsZSBsb29raW5nIGF0IHRoZSBsYXN0IHBhZ2Vcblx0XHRpZiAoY3VycmVudFBhZ2UgPiBwYWdlQ291bnQpIHtcblx0XHRcdGN1cnJlbnRQYWdlID0gcGFnZUNvdW50O1xuXHRcdH1cblx0XHRcblx0XHRpZiAoY3VycmVudFBhZ2UgPiAwKSB7XG5cdFx0XHRcblx0XHRcdGlmIChhbmltYXRpb24gIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRzZXRBbmltYXRpb24oYW5pbWF0aW9uLCB0aGlzLmNoYXJ0KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5uYXYuYXR0cih7XG5cdFx0XHRcdHRyYW5zbGF0ZVg6IHBhZGRpbmcsXG5cdFx0XHRcdHRyYW5zbGF0ZVk6IGNsaXBIZWlnaHQgKyB0aGlzLnBhZGRpbmcgKyA3ICsgdGhpcy50aXRsZUhlaWdodCxcblx0XHRcdFx0dmlzaWJpbGl0eTogVklTSUJMRVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLnVwLmF0dHIoe1xuXHRcdFx0XHRcdGZpbGw6IGN1cnJlbnRQYWdlID09PSAxID8gaW5hY3RpdmVDb2xvciA6IGFjdGl2ZUNvbG9yXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdGN1cnNvcjogY3VycmVudFBhZ2UgPT09IDEgPyAnZGVmYXVsdCcgOiAncG9pbnRlcidcblx0XHRcdFx0fSk7XG5cdFx0XHRwYWdlci5hdHRyKHtcblx0XHRcdFx0dGV4dDogY3VycmVudFBhZ2UgKyAnLycgKyBwYWdlQ291bnRcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5kb3duLmF0dHIoe1xuXHRcdFx0XHRcdHg6IDE4ICsgdGhpcy5wYWdlci5nZXRCQm94KCkud2lkdGgsIC8vIGFkanVzdCB0byB0ZXh0IHdpZHRoXG5cdFx0XHRcdFx0ZmlsbDogY3VycmVudFBhZ2UgPT09IHBhZ2VDb3VudCA/IGluYWN0aXZlQ29sb3IgOiBhY3RpdmVDb2xvclxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY3NzKHtcblx0XHRcdFx0XHRjdXJzb3I6IGN1cnJlbnRQYWdlID09PSBwYWdlQ291bnQgPyAnZGVmYXVsdCcgOiAncG9pbnRlcidcblx0XHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHNjcm9sbE9mZnNldCA9IC1wYWdlc1tjdXJyZW50UGFnZSAtIDFdICsgdGhpcy5pbml0aWFsSXRlbVk7XG5cblx0XHRcdHRoaXMuc2Nyb2xsR3JvdXAuYW5pbWF0ZSh7XG5cdFx0XHRcdHRyYW5zbGF0ZVk6IHNjcm9sbE9mZnNldFxuXHRcdFx0fSk7XHRcdFx0XG5cdFx0XHRcblx0XHRcdHRoaXMuY3VycmVudFBhZ2UgPSBjdXJyZW50UGFnZTtcblx0XHRcdHRoaXMucG9zaXRpb25DaGVja2JveGVzKHNjcm9sbE9mZnNldCk7XG5cdFx0fVxuXHRcdFx0XG5cdH1cblx0XG59O1xuXG4vKlxuICogTGVnZW5kU3ltYm9sTWl4aW5cbiAqLyBcblxudmFyIExlZ2VuZFN5bWJvbE1peGluID0gSGlnaGNoYXJ0cy5MZWdlbmRTeW1ib2xNaXhpbiA9IHtcblxuXHQvKipcblx0ICogR2V0IHRoZSBzZXJpZXMnIHN5bWJvbCBpbiB0aGUgbGVnZW5kXG5cdCAqIFxuXHQgKiBAcGFyYW0ge09iamVjdH0gbGVnZW5kIFRoZSBsZWdlbmQgb2JqZWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBzZXJpZXMgKHRoaXMpIG9yIHBvaW50XG5cdCAqL1xuXHRkcmF3UmVjdGFuZ2xlOiBmdW5jdGlvbiAobGVnZW5kLCBpdGVtKSB7XG5cdFx0dmFyIHN5bWJvbEhlaWdodCA9IGxlZ2VuZC5vcHRpb25zLnN5bWJvbEhlaWdodCB8fCBsZWdlbmQuZm9udE1ldHJpY3MuZjtcblxuXHRcdGl0ZW0ubGVnZW5kU3ltYm9sID0gdGhpcy5jaGFydC5yZW5kZXJlci5yZWN0KFxuXHRcdFx0MCxcblx0XHRcdGxlZ2VuZC5iYXNlbGluZSAtIHN5bWJvbEhlaWdodCArIDEsIC8vICMzOTg4XG5cdFx0XHRsZWdlbmQuc3ltYm9sV2lkdGgsXG5cdFx0XHRzeW1ib2xIZWlnaHQsXG5cdFx0XHRsZWdlbmQub3B0aW9ucy5zeW1ib2xSYWRpdXMgfHwgMFxuXHRcdCkuYXR0cih7XG5cdFx0XHR6SW5kZXg6IDNcblx0XHR9KS5hZGQoaXRlbS5sZWdlbmRHcm91cCk7XHRcdFxuXHRcdFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHNlcmllcycgc3ltYm9sIGluIHRoZSBsZWdlbmQuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkYWJsZSB0byBjcmVhdGUgY3VzdG9tIFxuXHQgKiBzeW1ib2xzIHRocm91Z2ggSGlnaGNoYXJ0cy5zZXJpZXNUeXBlc1t0eXBlXS5wcm90b3R5cGUuZHJhd0xlZ2VuZFN5bWJvbHMuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge09iamVjdH0gbGVnZW5kIFRoZSBsZWdlbmQgb2JqZWN0XG5cdCAqL1xuXHRkcmF3TGluZU1hcmtlcjogZnVuY3Rpb24gKGxlZ2VuZCkge1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRtYXJrZXJPcHRpb25zID0gb3B0aW9ucy5tYXJrZXIsXG5cdFx0XHRyYWRpdXMsXG5cdFx0XHRsZWdlbmRTeW1ib2wsXG5cdFx0XHRzeW1ib2xXaWR0aCA9IGxlZ2VuZC5zeW1ib2xXaWR0aCxcblx0XHRcdHJlbmRlcmVyID0gdGhpcy5jaGFydC5yZW5kZXJlcixcblx0XHRcdGxlZ2VuZEl0ZW1Hcm91cCA9IHRoaXMubGVnZW5kR3JvdXAsXG5cdFx0XHR2ZXJ0aWNhbENlbnRlciA9IGxlZ2VuZC5iYXNlbGluZSAtIG1hdGhSb3VuZChsZWdlbmQuZm9udE1ldHJpY3MuYiAqIDAuMyksXG5cdFx0XHRhdHRyO1xuXG5cdFx0Ly8gRHJhdyB0aGUgbGluZVxuXHRcdGlmIChvcHRpb25zLmxpbmVXaWR0aCkge1xuXHRcdFx0YXR0ciA9IHtcblx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IG9wdGlvbnMubGluZVdpZHRoXG5cdFx0XHR9O1xuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaFN0eWxlKSB7XG5cdFx0XHRcdGF0dHIuZGFzaHN0eWxlID0gb3B0aW9ucy5kYXNoU3R5bGU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxlZ2VuZExpbmUgPSByZW5kZXJlci5wYXRoKFtcblx0XHRcdFx0TSxcblx0XHRcdFx0MCxcblx0XHRcdFx0dmVydGljYWxDZW50ZXIsXG5cdFx0XHRcdEwsXG5cdFx0XHRcdHN5bWJvbFdpZHRoLFxuXHRcdFx0XHR2ZXJ0aWNhbENlbnRlclxuXHRcdFx0XSlcblx0XHRcdC5hdHRyKGF0dHIpXG5cdFx0XHQuYWRkKGxlZ2VuZEl0ZW1Hcm91cCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIERyYXcgdGhlIG1hcmtlclxuXHRcdGlmIChtYXJrZXJPcHRpb25zICYmIG1hcmtlck9wdGlvbnMuZW5hYmxlZCAhPT0gZmFsc2UpIHtcblx0XHRcdHJhZGl1cyA9IG1hcmtlck9wdGlvbnMucmFkaXVzO1xuXHRcdFx0dGhpcy5sZWdlbmRTeW1ib2wgPSBsZWdlbmRTeW1ib2wgPSByZW5kZXJlci5zeW1ib2woXG5cdFx0XHRcdHRoaXMuc3ltYm9sLFxuXHRcdFx0XHQoc3ltYm9sV2lkdGggLyAyKSAtIHJhZGl1cyxcblx0XHRcdFx0dmVydGljYWxDZW50ZXIgLSByYWRpdXMsXG5cdFx0XHRcdDIgKiByYWRpdXMsXG5cdFx0XHRcdDIgKiByYWRpdXNcblx0XHRcdClcblx0XHRcdC5hZGQobGVnZW5kSXRlbUdyb3VwKTtcblx0XHRcdGxlZ2VuZFN5bWJvbC5pc01hcmtlciA9IHRydWU7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBXb3JrYXJvdW5kIGZvciAjMjAzMCwgaG9yaXpvbnRhbCBsZWdlbmQgaXRlbXMgbm90IGRpc3BsYXlpbmcgaW4gSUUxMSBQcmV2aWV3LFxuLy8gYW5kIGZvciAjMjU4MCwgYSBzaW1pbGFyIGRyYXdpbmcgZmxhdyBpbiBGaXJlZm94IDI2LlxuLy8gVE9ETzogRXhwbG9yZSBpZiB0aGVyZSdzIGEgZ2VuZXJhbCBjYXVzZSBmb3IgdGhpcy4gVGhlIHByb2JsZW0gbWF5IGJlIHJlbGF0ZWQgXG4vLyB0byBuZXN0ZWQgZ3JvdXAgZWxlbWVudHMsIGFzIHRoZSBsZWdlbmQgaXRlbSB0ZXh0cyBhcmUgd2l0aGluIDQgZ3JvdXAgZWxlbWVudHMuXG5pZiAoL1RyaWRlbnRcXC83XFwuMC8udGVzdCh1c2VyQWdlbnQpIHx8IGlzRmlyZWZveCkge1xuXHR3cmFwKExlZ2VuZC5wcm90b3R5cGUsICdwb3NpdGlvbkl0ZW0nLCBmdW5jdGlvbiAocHJvY2VlZCwgaXRlbSkge1xuXHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0cnVuUG9zaXRpb25JdGVtID0gZnVuY3Rpb24gKCkgeyAvLyBJZiBjaGFydCBkZXN0cm95ZWQgaW4gc3luYywgdGhpcyBpcyB1bmRlZmluZWQgKCMyMDMwKVxuXHRcdFx0XHRpZiAoaXRlbS5fbGVnZW5kSXRlbVBvcykge1xuXHRcdFx0XHRcdHByb2NlZWQuY2FsbChsZWdlbmQsIGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gRG8gaXQgbm93LCBmb3IgZXhwb3J0IGFuZCB0byBnZXQgY2hlY2tib3ggcGxhY2VtZW50XG5cdFx0cnVuUG9zaXRpb25JdGVtKCk7XG5cdFx0XG5cdFx0Ly8gRG8gaXQgYWZ0ZXIgdG8gd29yayBhcm91bmQgdGhlIGNvcmUgaXNzdWVcblx0XHRzZXRUaW1lb3V0KHJ1blBvc2l0aW9uSXRlbSk7XG5cdH0pO1xufVxuLyoqXG4gKiBUaGUgY2hhcnQgY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgY2hhcnQgaGFzIGxvYWRlZFxuICovXG52YXIgQ2hhcnQgPSBIaWdoY2hhcnRzLkNoYXJ0ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbkNoYXJ0LnByb3RvdHlwZSA9IHtcblxuXHQvKipcblx0ICogSG9vayBmb3IgbW9kdWxlc1xuXHQgKi9cblx0Y2FsbGJhY2tzOiBbXSxcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgY2hhcnRcblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uICh1c2VyT3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHRcdC8vIEhhbmRsZSByZWd1bGFyIG9wdGlvbnNcblx0XHR2YXIgb3B0aW9ucyxcblx0XHRcdHNlcmllc09wdGlvbnMgPSB1c2VyT3B0aW9ucy5zZXJpZXM7IC8vIHNraXAgbWVyZ2luZyBkYXRhIHBvaW50cyB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuXG5cdFx0dXNlck9wdGlvbnMuc2VyaWVzID0gbnVsbDtcblx0XHRvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIHVzZXJPcHRpb25zKTsgLy8gZG8gdGhlIG1lcmdlXG5cdFx0b3B0aW9ucy5zZXJpZXMgPSB1c2VyT3B0aW9ucy5zZXJpZXMgPSBzZXJpZXNPcHRpb25zOyAvLyBzZXQgYmFjayB0aGUgc2VyaWVzIGRhdGFcblx0XHR0aGlzLnVzZXJPcHRpb25zID0gdXNlck9wdGlvbnM7XG5cblx0XHR2YXIgb3B0aW9uc0NoYXJ0ID0gb3B0aW9ucy5jaGFydDtcblx0XHRcblx0XHQvLyBDcmVhdGUgbWFyZ2luICYgc3BhY2luZyBhcnJheVxuXHRcdHRoaXMubWFyZ2luID0gdGhpcy5zcGxhc2hBcnJheSgnbWFyZ2luJywgb3B0aW9uc0NoYXJ0KTtcblx0XHR0aGlzLnNwYWNpbmcgPSB0aGlzLnNwbGFzaEFycmF5KCdzcGFjaW5nJywgb3B0aW9uc0NoYXJ0KTtcblxuXHRcdHZhciBjaGFydEV2ZW50cyA9IG9wdGlvbnNDaGFydC5ldmVudHM7XG5cblx0XHQvL3RoaXMucnVuQ2hhcnRDbGljayA9IGNoYXJ0RXZlbnRzICYmICEhY2hhcnRFdmVudHMuY2xpY2s7XG5cdFx0dGhpcy5ib3VuZHMgPSB7IGg6IHt9LCB2OiB7fSB9OyAvLyBQaXhlbCBkYXRhIGJvdW5kcyBmb3IgdG91Y2ggem9vbVxuXG5cdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHRoaXMuaXNSZXNpemluZyA9IDA7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHQvL2NoYXJ0VGl0bGVPcHRpb25zID0gVU5ERUZJTkVEO1xuXHRcdC8vY2hhcnRTdWJ0aXRsZU9wdGlvbnMgPSBVTkRFRklORUQ7XG5cblx0XHR0aGlzLmF4ZXMgPSBbXTtcblx0XHR0aGlzLnNlcmllcyA9IFtdO1xuXHRcdHRoaXMuaGFzQ2FydGVzaWFuU2VyaWVzID0gb3B0aW9uc0NoYXJ0LnNob3dBeGVzO1xuXHRcdC8vdGhpcy5heGlzT2Zmc2V0ID0gVU5ERUZJTkVEO1xuXHRcdC8vdGhpcy5tYXhUaWNrcyA9IFVOREVGSU5FRDsgLy8gaGFuZGxlIHRoZSBncmVhdGVzdCBhbW91bnQgb2YgdGlja3Mgb24gZ3JvdXBlZCBheGVzXG5cdFx0Ly90aGlzLmludmVydGVkID0gVU5ERUZJTkVEO1xuXHRcdC8vdGhpcy5sb2FkaW5nU2hvd24gPSBVTkRFRklORUQ7XG5cdFx0Ly90aGlzLmNvbnRhaW5lciA9IFVOREVGSU5FRDtcblx0XHQvL3RoaXMuY2hhcnRXaWR0aCA9IFVOREVGSU5FRDtcblx0XHQvL3RoaXMuY2hhcnRIZWlnaHQgPSBVTkRFRklORUQ7XG5cdFx0Ly90aGlzLm1hcmdpblJpZ2h0ID0gVU5ERUZJTkVEO1xuXHRcdC8vdGhpcy5tYXJnaW5Cb3R0b20gPSBVTkRFRklORUQ7XG5cdFx0Ly90aGlzLmNvbnRhaW5lcldpZHRoID0gVU5ERUZJTkVEO1xuXHRcdC8vdGhpcy5jb250YWluZXJIZWlnaHQgPSBVTkRFRklORUQ7XG5cdFx0Ly90aGlzLm9sZENoYXJ0V2lkdGggPSBVTkRFRklORUQ7XG5cdFx0Ly90aGlzLm9sZENoYXJ0SGVpZ2h0ID0gVU5ERUZJTkVEO1xuXG5cdFx0Ly90aGlzLnJlbmRlclRvID0gVU5ERUZJTkVEO1xuXHRcdC8vdGhpcy5yZW5kZXJUb0Nsb25lID0gVU5ERUZJTkVEO1xuXG5cdFx0Ly90aGlzLnNwYWNpbmdCb3ggPSBVTkRFRklORURcblxuXHRcdC8vdGhpcy5sZWdlbmQgPSBVTkRFRklORUQ7XG5cblx0XHQvLyBFbGVtZW50c1xuXHRcdC8vdGhpcy5jaGFydEJhY2tncm91bmQgPSBVTkRFRklORUQ7XG5cdFx0Ly90aGlzLnBsb3RCYWNrZ3JvdW5kID0gVU5ERUZJTkVEO1xuXHRcdC8vdGhpcy5wbG90QkdJbWFnZSA9IFVOREVGSU5FRDtcblx0XHQvL3RoaXMucGxvdEJvcmRlciA9IFVOREVGSU5FRDtcblx0XHQvL3RoaXMubG9hZGluZ0RpdiA9IFVOREVGSU5FRDtcblx0XHQvL3RoaXMubG9hZGluZ1NwYW4gPSBVTkRFRklORUQ7XG5cblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0ZXZlbnRUeXBlO1xuXG5cdFx0Ly8gQWRkIHRoZSBjaGFydCB0byB0aGUgZ2xvYmFsIGxvb2t1cFxuXHRcdGNoYXJ0LmluZGV4ID0gY2hhcnRzLmxlbmd0aDtcblx0XHRjaGFydHMucHVzaChjaGFydCk7XG5cdFx0Y2hhcnRDb3VudCsrO1xuXG5cdFx0Ly8gU2V0IHVwIGF1dG8gcmVzaXplXG5cdFx0aWYgKG9wdGlvbnNDaGFydC5yZWZsb3cgIT09IGZhbHNlKSB7XG5cdFx0XHRhZGRFdmVudChjaGFydCwgJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNoYXJ0LmluaXRSZWZsb3coKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIENoYXJ0IGV2ZW50IGhhbmRsZXJzXG5cdFx0aWYgKGNoYXJ0RXZlbnRzKSB7XG5cdFx0XHRmb3IgKGV2ZW50VHlwZSBpbiBjaGFydEV2ZW50cykge1xuXHRcdFx0XHRhZGRFdmVudChjaGFydCwgZXZlbnRUeXBlLCBjaGFydEV2ZW50c1tldmVudFR5cGVdKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjaGFydC54QXhpcyA9IFtdO1xuXHRcdGNoYXJ0LnlBeGlzID0gW107XG5cblx0XHQvLyBFeHBvc2UgbWV0aG9kcyBhbmQgdmFyaWFibGVzXG5cdFx0Y2hhcnQuYW5pbWF0aW9uID0gdXNlQ2FuVkcgPyBmYWxzZSA6IHBpY2sob3B0aW9uc0NoYXJ0LmFuaW1hdGlvbiwgdHJ1ZSk7XG5cdFx0Y2hhcnQucG9pbnRDb3VudCA9IGNoYXJ0LmNvbG9yQ291bnRlciA9IGNoYXJ0LnN5bWJvbENvdW50ZXIgPSAwO1xuXG5cdFx0Y2hhcnQuZmlyc3RSZW5kZXIoKTtcblx0fSxcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSBhbiBpbmRpdmlkdWFsIHNlcmllcywgY2FsbGVkIGludGVybmFsbHkgYmVmb3JlIHJlbmRlciB0aW1lXG5cdCAqL1xuXHRpbml0U2VyaWVzOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zQ2hhcnQgPSBjaGFydC5vcHRpb25zLmNoYXJ0LFxuXHRcdFx0dHlwZSA9IG9wdGlvbnMudHlwZSB8fCBvcHRpb25zQ2hhcnQudHlwZSB8fCBvcHRpb25zQ2hhcnQuZGVmYXVsdFNlcmllc1R5cGUsXG5cdFx0XHRzZXJpZXMsXG5cdFx0XHRjb25zdHIgPSBzZXJpZXNUeXBlc1t0eXBlXTtcblxuXHRcdC8vIE5vIHN1Y2ggc2VyaWVzIHR5cGVcblx0XHRpZiAoIWNvbnN0cikge1xuXHRcdFx0ZXJyb3IoMTcsIHRydWUpO1xuXHRcdH1cblxuXHRcdHNlcmllcyA9IG5ldyBjb25zdHIoKTtcblx0XHRzZXJpZXMuaW5pdCh0aGlzLCBvcHRpb25zKTtcblx0XHRyZXR1cm4gc2VyaWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIGEgZ2l2ZW4gcG9pbnQgaXMgd2l0aGluIHRoZSBwbG90IGFyZWFcblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBsb3RYIFBpeGVsIHggcmVsYXRpdmUgdG8gdGhlIHBsb3QgYXJlYVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGxvdFkgUGl4ZWwgeSByZWxhdGl2ZSB0byB0aGUgcGxvdCBhcmVhXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaW52ZXJ0ZWQgV2hldGhlciB0aGUgY2hhcnQgaXMgaW52ZXJ0ZWRcblx0ICovXG5cdGlzSW5zaWRlUGxvdDogZnVuY3Rpb24gKHBsb3RYLCBwbG90WSwgaW52ZXJ0ZWQpIHtcblx0XHR2YXIgeCA9IGludmVydGVkID8gcGxvdFkgOiBwbG90WCxcblx0XHRcdHkgPSBpbnZlcnRlZCA/IHBsb3RYIDogcGxvdFk7XG5cdFx0XHRcblx0XHRyZXR1cm4geCA+PSAwICYmXG5cdFx0XHR4IDw9IHRoaXMucGxvdFdpZHRoICYmXG5cdFx0XHR5ID49IDAgJiZcblx0XHRcdHkgPD0gdGhpcy5wbG90SGVpZ2h0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWRyYXcgbGVnZW5kLCBheGVzIG9yIHNlcmllcyBiYXNlZCBvbiB1cGRhdGVkIGRhdGFcblx0ICpcblx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0ICogICAgY29uZmlndXJhdGlvblxuXHQgKi9cblx0cmVkcmF3OiBmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdGF4ZXMgPSBjaGFydC5heGVzLFxuXHRcdFx0c2VyaWVzID0gY2hhcnQuc2VyaWVzLFxuXHRcdFx0cG9pbnRlciA9IGNoYXJ0LnBvaW50ZXIsXG5cdFx0XHRsZWdlbmQgPSBjaGFydC5sZWdlbmQsXG5cdFx0XHRyZWRyYXdMZWdlbmQgPSBjaGFydC5pc0RpcnR5TGVnZW5kLFxuXHRcdFx0aGFzU3RhY2tlZFNlcmllcyxcblx0XHRcdGhhc0RpcnR5U3RhY2tzLFxuXHRcdFx0aGFzQ2FydGVzaWFuU2VyaWVzID0gY2hhcnQuaGFzQ2FydGVzaWFuU2VyaWVzLFxuXHRcdFx0aXNEaXJ0eUJveCA9IGNoYXJ0LmlzRGlydHlCb3gsIC8vIHRvZG86IGNoZWNrIGlmIGl0IGhhcyBhY3R1YWxseSBjaGFuZ2VkP1xuXHRcdFx0c2VyaWVzTGVuZ3RoID0gc2VyaWVzLmxlbmd0aCxcblx0XHRcdGkgPSBzZXJpZXNMZW5ndGgsXG5cdFx0XHRzZXJpZSxcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRpc0hpZGRlbkNoYXJ0ID0gcmVuZGVyZXIuaXNIaWRkZW4oKSxcblx0XHRcdGFmdGVyUmVkcmF3ID0gW107XG5cdFx0XHRcblx0XHRzZXRBbmltYXRpb24oYW5pbWF0aW9uLCBjaGFydCk7XG5cdFx0XG5cdFx0aWYgKGlzSGlkZGVuQ2hhcnQpIHtcblx0XHRcdGNoYXJ0LmNsb25lUmVuZGVyVG8oKTtcblx0XHR9XG5cblx0XHQvLyBBZGp1c3QgdGl0bGUgbGF5b3V0IChyZWZsb3cgbXVsdGlsaW5lIHRleHQpXG5cdFx0Y2hhcnQubGF5T3V0VGl0bGVzKCk7XG5cblx0XHQvLyBsaW5rIHN0YWNrZWQgc2VyaWVzXG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0c2VyaWUgPSBzZXJpZXNbaV07XG5cblx0XHRcdGlmIChzZXJpZS5vcHRpb25zLnN0YWNraW5nKSB7XG5cdFx0XHRcdGhhc1N0YWNrZWRTZXJpZXMgPSB0cnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHNlcmllLmlzRGlydHkpIHtcblx0XHRcdFx0XHRoYXNEaXJ0eVN0YWNrcyA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGhhc0RpcnR5U3RhY2tzKSB7IC8vIG1hcmsgb3RoZXJzIGFzIGRpcnR5XG5cdFx0XHRpID0gc2VyaWVzTGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRzZXJpZSA9IHNlcmllc1tpXTtcblx0XHRcdFx0aWYgKHNlcmllLm9wdGlvbnMuc3RhY2tpbmcpIHtcblx0XHRcdFx0XHRzZXJpZS5pc0RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSB1cGRhdGVkIGRhdGEgaW4gdGhlIHNlcmllc1xuXHRcdGVhY2goc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWUpIHtcblx0XHRcdGlmIChzZXJpZS5pc0RpcnR5KSB7XG5cdFx0XHRcdGlmIChzZXJpZS5vcHRpb25zLmxlZ2VuZFR5cGUgPT09ICdwb2ludCcpIHtcblx0XHRcdFx0XHRpZiAoc2VyaWUudXBkYXRlVG90YWxzKSB7XG5cdFx0XHRcdFx0XHRzZXJpZS51cGRhdGVUb3RhbHMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVkcmF3TGVnZW5kID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gaGFuZGxlIGFkZGVkIG9yIHJlbW92ZWQgc2VyaWVzXG5cdFx0aWYgKHJlZHJhd0xlZ2VuZCAmJiBsZWdlbmQub3B0aW9ucy5lbmFibGVkKSB7IC8vIHNlcmllcyBvciBwaWUgcG9pbnRzIGFyZSBhZGRlZCBvciByZW1vdmVkXG5cdFx0XHQvLyBkcmF3IGxlZ2VuZCBncmFwaGljc1xuXHRcdFx0bGVnZW5kLnJlbmRlcigpO1xuXG5cdFx0XHRjaGFydC5pc0RpcnR5TGVnZW5kID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gcmVzZXQgc3RhY2tzXG5cdFx0aWYgKGhhc1N0YWNrZWRTZXJpZXMpIHtcblx0XHRcdGNoYXJ0LmdldFN0YWNrcygpO1xuXHRcdH1cblxuXG5cdFx0aWYgKGhhc0NhcnRlc2lhblNlcmllcykge1xuXHRcdFx0aWYgKCFjaGFydC5pc1Jlc2l6aW5nKSB7XG5cblx0XHRcdFx0Ly8gcmVzZXQgbWF4VGlja3Ncblx0XHRcdFx0Y2hhcnQubWF4VGlja3MgPSBudWxsO1xuXG5cdFx0XHRcdC8vIHNldCBheGVzIHNjYWxlc1xuXHRcdFx0XHRlYWNoKGF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdFx0YXhpcy5zZXRTY2FsZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjaGFydC5nZXRNYXJnaW5zKCk7IC8vICMzMDk4XG5cblx0XHRpZiAoaGFzQ2FydGVzaWFuU2VyaWVzKSB7XG5cdFx0XHQvLyBJZiBvbmUgYXhpcyBpcyBkaXJ0eSwgYWxsIGF4ZXMgbXVzdCBiZSByZWRyYXduICgjNzkyLCAjMjE2OSlcblx0XHRcdGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0aWYgKGF4aXMuaXNEaXJ0eSkge1xuXHRcdFx0XHRcdGlzRGlydHlCb3ggPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmVkcmF3IGF4ZXNcblx0XHRcdGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblxuXHRcdFx0XHQvLyBGaXJlICdhZnRlclNldEV4dHJlbWVzJyBvbmx5IGlmIGV4dHJlbWVzIGFyZSBzZXRcblx0XHRcdFx0dmFyIGtleSA9IGF4aXMubWluICsgJywnICsgYXhpcy5tYXg7XG5cdFx0XHRcdGlmIChheGlzLmV4dEtleSAhPT0ga2V5KSB7IC8vICM4MjEsICM0NDUyXG5cdFx0XHRcdFx0YXhpcy5leHRLZXkgPSBrZXk7XG5cdFx0XHRcdFx0YWZ0ZXJSZWRyYXcucHVzaChmdW5jdGlvbiAoKSB7IC8vIHByZXZlbnQgYSByZWN1cnNpdmUgY2FsbCB0byBjaGFydC5yZWRyYXcoKSAoIzExMTkpXG5cdFx0XHRcdFx0XHRmaXJlRXZlbnQoYXhpcywgJ2FmdGVyU2V0RXh0cmVtZXMnLCBleHRlbmQoYXhpcy5ldmVudEFyZ3MsIGF4aXMuZ2V0RXh0cmVtZXMoKSkpOyAvLyAjNzQ3LCAjNzUxXG5cdFx0XHRcdFx0XHRkZWxldGUgYXhpcy5ldmVudEFyZ3M7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzRGlydHlCb3ggfHwgaGFzU3RhY2tlZFNlcmllcykge1xuXHRcdFx0XHRcdGF4aXMucmVkcmF3KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvLyB0aGUgcGxvdCBhcmVhcyBzaXplIGhhcyBjaGFuZ2VkXG5cdFx0aWYgKGlzRGlydHlCb3gpIHtcblx0XHRcdGNoYXJ0LmRyYXdDaGFydEJveCgpO1xuXHRcdH1cblxuXG5cdFx0Ly8gcmVkcmF3IGFmZmVjdGVkIHNlcmllc1xuXHRcdGVhY2goc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWUpIHtcblx0XHRcdGlmIChzZXJpZS5pc0RpcnR5ICYmIHNlcmllLnZpc2libGUgJiZcblx0XHRcdFx0XHQoIXNlcmllLmlzQ2FydGVzaWFuIHx8IHNlcmllLnhBeGlzKSkgeyAvLyBpc3N1ZSAjMTUzXG5cdFx0XHRcdHNlcmllLnJlZHJhdygpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gbW92ZSB0b29sdGlwIG9yIHJlc2V0XG5cdFx0aWYgKHBvaW50ZXIpIHtcblx0XHRcdHBvaW50ZXIucmVzZXQodHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVkcmF3IGlmIGNhbnZhc1xuXHRcdHJlbmRlcmVyLmRyYXcoKTtcblxuXHRcdC8vIGZpcmUgdGhlIGV2ZW50XG5cdFx0ZmlyZUV2ZW50KGNoYXJ0LCAncmVkcmF3Jyk7IC8vIGpRdWVyeSBicmVha3MgdGhpcyB3aGVuIGNhbGxpbmcgaXQgZnJvbSBhZGRFdmVudC4gT3ZlcndyaXRlcyBjaGFydC5yZWRyYXdcblx0XHRcblx0XHRpZiAoaXNIaWRkZW5DaGFydCkge1xuXHRcdFx0Y2hhcnQuY2xvbmVSZW5kZXJUbyh0cnVlKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gRmlyZSBjYWxsYmFja3MgdGhhdCBhcmUgcHV0IG9uIGhvbGQgdW50aWwgYWZ0ZXIgdGhlIHJlZHJhd1xuXHRcdGVhY2goYWZ0ZXJSZWRyYXcsIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2suY2FsbCgpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYW4gYXhpcywgc2VyaWVzIG9yIHBvaW50IG9iamVjdCBieSBpZC5cblx0ICogQHBhcmFtIGlkIHtTdHJpbmd9IFRoZSBpZCBhcyBnaXZlbiBpbiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zXG5cdCAqL1xuXHRnZXQ6IGZ1bmN0aW9uIChpZCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRheGVzID0gY2hhcnQuYXhlcyxcblx0XHRcdHNlcmllcyA9IGNoYXJ0LnNlcmllcztcblxuXHRcdHZhciBpLFxuXHRcdFx0aixcblx0XHRcdHBvaW50cztcblxuXHRcdC8vIHNlYXJjaCBheGVzXG5cdFx0Zm9yIChpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChheGVzW2ldLm9wdGlvbnMuaWQgPT09IGlkKSB7XG5cdFx0XHRcdHJldHVybiBheGVzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHNlYXJjaCBzZXJpZXNcblx0XHRmb3IgKGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoc2VyaWVzW2ldLm9wdGlvbnMuaWQgPT09IGlkKSB7XG5cdFx0XHRcdHJldHVybiBzZXJpZXNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc2VhcmNoIHBvaW50c1xuXHRcdGZvciAoaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHBvaW50cyA9IHNlcmllc1tpXS5wb2ludHMgfHwgW107XG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmIChwb2ludHNbal0uaWQgPT09IGlkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBvaW50c1tqXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIHRoZSBBeGlzIGluc3RhbmNlcyBiYXNlZCBvbiB0aGUgY29uZmlnIG9wdGlvbnNcblx0ICovXG5cdGdldEF4ZXM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHhBeGlzT3B0aW9ucyA9IG9wdGlvbnMueEF4aXMgPSBzcGxhdChvcHRpb25zLnhBeGlzIHx8IHt9KSxcblx0XHRcdHlBeGlzT3B0aW9ucyA9IG9wdGlvbnMueUF4aXMgPSBzcGxhdChvcHRpb25zLnlBeGlzIHx8IHt9KSxcblx0XHRcdG9wdGlvbnNBcnJheSxcblx0XHRcdGF4aXM7XG5cblx0XHQvLyBtYWtlIHN1cmUgdGhlIG9wdGlvbnMgYXJlIGFycmF5cyBhbmQgYWRkIHNvbWUgbWVtYmVyc1xuXHRcdGVhY2goeEF4aXNPcHRpb25zLCBmdW5jdGlvbiAoYXhpcywgaSkge1xuXHRcdFx0YXhpcy5pbmRleCA9IGk7XG5cdFx0XHRheGlzLmlzWCA9IHRydWU7XG5cdFx0fSk7XG5cblx0XHRlYWNoKHlBeGlzT3B0aW9ucywgZnVuY3Rpb24gKGF4aXMsIGkpIHtcblx0XHRcdGF4aXMuaW5kZXggPSBpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gY29uY2F0ZW5hdGUgYWxsIGF4aXMgb3B0aW9ucyBpbnRvIG9uZSBhcnJheVxuXHRcdG9wdGlvbnNBcnJheSA9IHhBeGlzT3B0aW9ucy5jb25jYXQoeUF4aXNPcHRpb25zKTtcblxuXHRcdGVhY2gob3B0aW9uc0FycmF5LCBmdW5jdGlvbiAoYXhpc09wdGlvbnMpIHtcblx0XHRcdGF4aXMgPSBuZXcgQXhpcyhjaGFydCwgYXhpc09wdGlvbnMpO1xuXHRcdH0pO1xuXHR9LFxuXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBvaW50cyBmcm9tIGFsbCBzZXJpZXNcblx0ICovXG5cdGdldFNlbGVjdGVkUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvaW50cyA9IFtdO1xuXHRcdGVhY2godGhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZSkge1xuXHRcdFx0cG9pbnRzID0gcG9pbnRzLmNvbmNhdChncmVwKHNlcmllLnBvaW50cyB8fCBbXSwgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdHJldHVybiBwb2ludC5zZWxlY3RlZDtcblx0XHRcdH0pKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gcG9pbnRzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBzZXJpZXNcblx0ICovXG5cdGdldFNlbGVjdGVkU2VyaWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGdyZXAodGhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZSkge1xuXHRcdFx0cmV0dXJuIHNlcmllLnNlbGVjdGVkO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTaG93IHRoZSB0aXRsZSBhbmQgc3VidGl0bGUgb2YgdGhlIGNoYXJ0XG5cdCAqXG5cdCAqIEBwYXJhbSB0aXRsZU9wdGlvbnMge09iamVjdH0gTmV3IHRpdGxlIG9wdGlvbnNcblx0ICogQHBhcmFtIHN1YnRpdGxlT3B0aW9ucyB7T2JqZWN0fSBOZXcgc3VidGl0bGUgb3B0aW9uc1xuXHQgKlxuXHQgKi9cblx0c2V0VGl0bGU6IGZ1bmN0aW9uICh0aXRsZU9wdGlvbnMsIHN1YnRpdGxlT3B0aW9ucywgcmVkcmF3KSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLFxuXHRcdFx0Y2hhcnRUaXRsZU9wdGlvbnMsXG5cdFx0XHRjaGFydFN1YnRpdGxlT3B0aW9ucztcblxuXHRcdGNoYXJ0VGl0bGVPcHRpb25zID0gb3B0aW9ucy50aXRsZSA9IG1lcmdlKG9wdGlvbnMudGl0bGUsIHRpdGxlT3B0aW9ucyk7XG5cdFx0Y2hhcnRTdWJ0aXRsZU9wdGlvbnMgPSBvcHRpb25zLnN1YnRpdGxlID0gbWVyZ2Uob3B0aW9ucy5zdWJ0aXRsZSwgc3VidGl0bGVPcHRpb25zKTtcblxuXHRcdC8vIGFkZCB0aXRsZSBhbmQgc3VidGl0bGVcblx0XHRlYWNoKFtcblx0XHRcdFsndGl0bGUnLCB0aXRsZU9wdGlvbnMsIGNoYXJ0VGl0bGVPcHRpb25zXSxcblx0XHRcdFsnc3VidGl0bGUnLCBzdWJ0aXRsZU9wdGlvbnMsIGNoYXJ0U3VidGl0bGVPcHRpb25zXVxuXHRcdF0sIGZ1bmN0aW9uIChhcnIpIHtcblx0XHRcdHZhciBuYW1lID0gYXJyWzBdLFxuXHRcdFx0XHR0aXRsZSA9IGNoYXJ0W25hbWVdLFxuXHRcdFx0XHR0aXRsZU9wdGlvbnMgPSBhcnJbMV0sXG5cdFx0XHRcdGNoYXJ0VGl0bGVPcHRpb25zID0gYXJyWzJdO1xuXG5cdFx0XHRpZiAodGl0bGUgJiYgdGl0bGVPcHRpb25zKSB7XG5cdFx0XHRcdGNoYXJ0W25hbWVdID0gdGl0bGUgPSB0aXRsZS5kZXN0cm95KCk7IC8vIHJlbW92ZSBvbGRcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGNoYXJ0VGl0bGVPcHRpb25zICYmIGNoYXJ0VGl0bGVPcHRpb25zLnRleHQgJiYgIXRpdGxlKSB7XG5cdFx0XHRcdGNoYXJ0W25hbWVdID0gY2hhcnQucmVuZGVyZXIudGV4dChcblx0XHRcdFx0XHRjaGFydFRpdGxlT3B0aW9ucy50ZXh0LFxuXHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRjaGFydFRpdGxlT3B0aW9ucy51c2VIVE1MXG5cdFx0XHRcdClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdGFsaWduOiBjaGFydFRpdGxlT3B0aW9ucy5hbGlnbixcblx0XHRcdFx0XHQnY2xhc3MnOiBQUkVGSVggKyBuYW1lLFxuXHRcdFx0XHRcdHpJbmRleDogY2hhcnRUaXRsZU9wdGlvbnMuekluZGV4IHx8IDRcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNzcyhjaGFydFRpdGxlT3B0aW9ucy5zdHlsZSlcblx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0fVx0XG5cdFx0fSk7XG5cdFx0Y2hhcnQubGF5T3V0VGl0bGVzKHJlZHJhdyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIExheSBvdXQgdGhlIGNoYXJ0IHRpdGxlcyBhbmQgY2FjaGUgdGhlIGZ1bGwgb2Zmc2V0IGhlaWdodCBmb3IgdXNlIGluIGdldE1hcmdpbnNcblx0ICovXG5cdGxheU91dFRpdGxlczogZnVuY3Rpb24gKHJlZHJhdykge1xuXHRcdHZhciB0aXRsZU9mZnNldCA9IDAsXG5cdFx0XHR0aXRsZSA9IHRoaXMudGl0bGUsXG5cdFx0XHRzdWJ0aXRsZSA9IHRoaXMuc3VidGl0bGUsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0dGl0bGVPcHRpb25zID0gb3B0aW9ucy50aXRsZSxcblx0XHRcdHN1YnRpdGxlT3B0aW9ucyA9IG9wdGlvbnMuc3VidGl0bGUsXG5cdFx0XHRyZXF1aXJlc0RpcnR5Qm94LFxuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuXHRcdFx0YXV0b1dpZHRoID0gdGhpcy5zcGFjaW5nQm94LndpZHRoIC0gNDQ7IC8vIDQ0IG1ha2VzIHJvb20gZm9yIGRlZmF1bHQgY29udGV4dCBidXR0b25cblxuXHRcdGlmICh0aXRsZSkge1xuXHRcdFx0dGl0bGVcblx0XHRcdFx0LmNzcyh7IHdpZHRoOiAodGl0bGVPcHRpb25zLndpZHRoIHx8IGF1dG9XaWR0aCkgKyBQWCB9KVxuXHRcdFx0XHQuYWxpZ24oZXh0ZW5kKHsgXG5cdFx0XHRcdFx0eTogcmVuZGVyZXIuZm9udE1ldHJpY3ModGl0bGVPcHRpb25zLnN0eWxlLmZvbnRTaXplLCB0aXRsZSkuYiAtIDNcblx0XHRcdFx0fSwgdGl0bGVPcHRpb25zKSwgZmFsc2UsICdzcGFjaW5nQm94Jyk7XG5cdFx0XHRcblx0XHRcdGlmICghdGl0bGVPcHRpb25zLmZsb2F0aW5nICYmICF0aXRsZU9wdGlvbnMudmVydGljYWxBbGlnbikge1xuXHRcdFx0XHR0aXRsZU9mZnNldCA9IHRpdGxlLmdldEJCb3goKS5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzdWJ0aXRsZSkge1xuXHRcdFx0c3VidGl0bGVcblx0XHRcdFx0LmNzcyh7IHdpZHRoOiAoc3VidGl0bGVPcHRpb25zLndpZHRoIHx8IGF1dG9XaWR0aCkgKyBQWCB9KVxuXHRcdFx0XHQuYWxpZ24oZXh0ZW5kKHsgXG5cdFx0XHRcdFx0eTogdGl0bGVPZmZzZXQgKyAodGl0bGVPcHRpb25zLm1hcmdpbiAtIDEzKSArIHJlbmRlcmVyLmZvbnRNZXRyaWNzKHN1YnRpdGxlT3B0aW9ucy5zdHlsZS5mb250U2l6ZSwgdGl0bGUpLmIgXG5cdFx0XHRcdH0sIHN1YnRpdGxlT3B0aW9ucyksIGZhbHNlLCAnc3BhY2luZ0JveCcpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXN1YnRpdGxlT3B0aW9ucy5mbG9hdGluZyAmJiAhc3VidGl0bGVPcHRpb25zLnZlcnRpY2FsQWxpZ24pIHtcblx0XHRcdFx0dGl0bGVPZmZzZXQgPSBtYXRoQ2VpbCh0aXRsZU9mZnNldCArIHN1YnRpdGxlLmdldEJCb3goKS5oZWlnaHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJlcXVpcmVzRGlydHlCb3ggPSB0aGlzLnRpdGxlT2Zmc2V0ICE9PSB0aXRsZU9mZnNldDtcdFx0XHRcdFxuXHRcdHRoaXMudGl0bGVPZmZzZXQgPSB0aXRsZU9mZnNldDsgLy8gdXNlZCBpbiBnZXRNYXJnaW5zXG5cblx0XHRpZiAoIXRoaXMuaXNEaXJ0eUJveCAmJiByZXF1aXJlc0RpcnR5Qm94KSB7XG5cdFx0XHR0aGlzLmlzRGlydHlCb3ggPSByZXF1aXJlc0RpcnR5Qm94O1xuXHRcdFx0Ly8gUmVkcmF3IGlmIG5lY2Vzc2FyeSAoIzI3MTksICMyNzQ0KVx0XHRcblx0XHRcdGlmICh0aGlzLmhhc1JlbmRlcmVkICYmIHBpY2socmVkcmF3LCB0cnVlKSAmJiB0aGlzLmlzRGlydHlCb3gpIHtcblx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBjaGFydCB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byBvcHRpb25zIGFuZCBjb250YWluZXIgc2l6ZVxuXHQgKi9cblx0Z2V0Q2hhcnRTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHR3aWR0aE9wdGlvbiA9IG9wdGlvbnNDaGFydC53aWR0aCxcblx0XHRcdGhlaWdodE9wdGlvbiA9IG9wdGlvbnNDaGFydC5oZWlnaHQsXG5cdFx0XHRyZW5kZXJUbyA9IGNoYXJ0LnJlbmRlclRvQ2xvbmUgfHwgY2hhcnQucmVuZGVyVG87XG5cblx0XHQvLyBnZXQgaW5uZXIgd2lkdGggYW5kIGhlaWdodCBmcm9tIGpRdWVyeSAoIzgyNClcblx0XHRpZiAoIWRlZmluZWQod2lkdGhPcHRpb24pKSB7XG5cdFx0XHRjaGFydC5jb250YWluZXJXaWR0aCA9IGFkYXB0ZXJSdW4ocmVuZGVyVG8sICd3aWR0aCcpO1xuXHRcdH1cblx0XHRpZiAoIWRlZmluZWQoaGVpZ2h0T3B0aW9uKSkge1xuXHRcdFx0Y2hhcnQuY29udGFpbmVySGVpZ2h0ID0gYWRhcHRlclJ1bihyZW5kZXJUbywgJ2hlaWdodCcpO1xuXHRcdH1cblx0XHRcblx0XHRjaGFydC5jaGFydFdpZHRoID0gbWF0aE1heCgwLCB3aWR0aE9wdGlvbiB8fCBjaGFydC5jb250YWluZXJXaWR0aCB8fCA2MDApOyAvLyAjMTM5MywgMTQ2MFxuXHRcdGNoYXJ0LmNoYXJ0SGVpZ2h0ID0gbWF0aE1heCgwLCBwaWNrKGhlaWdodE9wdGlvbixcblx0XHRcdC8vIHRoZSBvZmZzZXRIZWlnaHQgb2YgYW4gZW1wdHkgY29udGFpbmVyIGlzIDAgaW4gc3RhbmRhcmQgYnJvd3NlcnMsIGJ1dCAxOSBpbiBJRTc6XG5cdFx0XHRjaGFydC5jb250YWluZXJIZWlnaHQgPiAxOSA/IGNoYXJ0LmNvbnRhaW5lckhlaWdodCA6IDQwMCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGUgY2hhcnQncyByZW5kZXJUbyBkaXYgYW5kIHBsYWNlIGl0IG91dHNpZGUgdGhlIHZpZXdwb3J0IHRvIGFsbG93XG5cdCAqIHNpemUgY29tcHV0YXRpb24gb24gY2hhcnQucmVuZGVyIGFuZCBjaGFydC5yZWRyYXdcblx0ICovXG5cdGNsb25lUmVuZGVyVG86IGZ1bmN0aW9uIChyZXZlcnQpIHtcblx0XHR2YXIgY2xvbmUgPSB0aGlzLnJlbmRlclRvQ2xvbmUsXG5cdFx0XHRjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcblx0XHRcblx0XHQvLyBEZXN0cm95IHRoZSBjbG9uZSBhbmQgYnJpbmcgdGhlIGNvbnRhaW5lciBiYWNrIHRvIHRoZSByZWFsIHJlbmRlclRvIGRpdlxuXHRcdGlmIChyZXZlcnQpIHtcblx0XHRcdGlmIChjbG9uZSkge1xuXHRcdFx0XHR0aGlzLnJlbmRlclRvLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cdFx0XHRcdGRpc2NhcmRFbGVtZW50KGNsb25lKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMucmVuZGVyVG9DbG9uZTtcblx0XHRcdH1cblx0XHRcblx0XHQvLyBTZXQgdXAgdGhlIGNsb25lXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRoaXMucmVuZGVyVG8pIHtcblx0XHRcdFx0dGhpcy5yZW5kZXJUby5yZW1vdmVDaGlsZChjb250YWluZXIpOyAvLyBkbyBub3QgY2xvbmUgdGhpc1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZW5kZXJUb0Nsb25lID0gY2xvbmUgPSB0aGlzLnJlbmRlclRvLmNsb25lTm9kZSgwKTtcblx0XHRcdGNzcyhjbG9uZSwge1xuXHRcdFx0XHRwb3NpdGlvbjogQUJTT0xVVEUsXG5cdFx0XHRcdHRvcDogJy05OTk5cHgnLFxuXHRcdFx0XHRkaXNwbGF5OiAnYmxvY2snIC8vICM4MzNcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGNsb25lLnN0eWxlLnNldFByb3BlcnR5KSB7IC8vICMyNjMxXG5cdFx0XHRcdGNsb25lLnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ2Jsb2NrJywgJ2ltcG9ydGFudCcpO1xuXHRcdFx0fVxuXHRcdFx0ZG9jLmJvZHkuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuXHRcdFx0aWYgKGNvbnRhaW5lcikge1xuXHRcdFx0XHRjbG9uZS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBjb250YWluaW5nIGVsZW1lbnQsIGRldGVybWluZSB0aGUgc2l6ZSBhbmQgY3JlYXRlIHRoZSBpbm5lciBjb250YWluZXJcblx0ICogZGl2IHRvIGhvbGQgdGhlIGNoYXJ0XG5cdCAqL1xuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0Y29udGFpbmVyLFxuXHRcdFx0b3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMsXG5cdFx0XHRvcHRpb25zQ2hhcnQgPSBvcHRpb25zLmNoYXJ0LFxuXHRcdFx0Y2hhcnRXaWR0aCxcblx0XHRcdGNoYXJ0SGVpZ2h0LFxuXHRcdFx0cmVuZGVyVG8sXG5cdFx0XHRpbmRleEF0dHJOYW1lID0gJ2RhdGEtaGlnaGNoYXJ0cy1jaGFydCcsXG5cdFx0XHRvbGRDaGFydEluZGV4LFxuXHRcdFx0UmVuLFxuXHRcdFx0Y29udGFpbmVySWQ7XG5cblx0XHRjaGFydC5yZW5kZXJUbyA9IHJlbmRlclRvID0gb3B0aW9uc0NoYXJ0LnJlbmRlclRvO1xuXHRcdGNvbnRhaW5lcklkID0gUFJFRklYICsgaWRDb3VudGVyKys7XG5cblx0XHRpZiAoaXNTdHJpbmcocmVuZGVyVG8pKSB7XG5cdFx0XHRjaGFydC5yZW5kZXJUbyA9IHJlbmRlclRvID0gZG9jLmdldEVsZW1lbnRCeUlkKHJlbmRlclRvKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gRGlzcGxheSBhbiBlcnJvciBpZiB0aGUgcmVuZGVyVG8gaXMgd3Jvbmdcblx0XHRpZiAoIXJlbmRlclRvKSB7XG5cdFx0XHRlcnJvcigxMywgdHJ1ZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIElmIHRoZSBjb250YWluZXIgYWxyZWFkeSBob2xkcyBhIGNoYXJ0LCBkZXN0cm95IGl0LiBUaGUgY2hlY2sgZm9yIGhhc1JlbmRlcmVkIGlzIHRoZXJlXG5cdFx0Ly8gYmVjYXVzZSB3ZWIgcGFnZXMgdGhhdCBhcmUgc2F2ZWQgdG8gZGlzayBmcm9tIHRoZSBicm93c2VyLCB3aWxsIHByZXNlcnZlIHRoZSBkYXRhLWhpZ2hjaGFydHMtY2hhcnRcblx0XHQvLyBhdHRyaWJ1dGUgYW5kIHRoZSBTVkcgY29udGVudHMsIGJ1dCBub3QgYW4gaW50ZXJhY3RpdmUgY2hhcnQuIFNvIGluIHRoaXMgY2FzZSxcblx0XHQvLyBjaGFydHNbb2xkQ2hhcnRJbmRleF0gd2lsbCBwb2ludCB0byB0aGUgd3JvbmcgY2hhcnQgaWYgYW55ICgjMjYwOSkuXG5cdFx0b2xkQ2hhcnRJbmRleCA9IHBJbnQoYXR0cihyZW5kZXJUbywgaW5kZXhBdHRyTmFtZSkpO1xuXHRcdGlmICghaXNOYU4ob2xkQ2hhcnRJbmRleCkgJiYgY2hhcnRzW29sZENoYXJ0SW5kZXhdICYmIGNoYXJ0c1tvbGRDaGFydEluZGV4XS5oYXNSZW5kZXJlZCkge1xuXHRcdFx0Y2hhcnRzW29sZENoYXJ0SW5kZXhdLmRlc3Ryb3koKTtcblx0XHR9XHRcdFxuXHRcdFxuXHRcdC8vIE1ha2UgYSByZWZlcmVuY2UgdG8gdGhlIGNoYXJ0IGZyb20gdGhlIGRpdlxuXHRcdGF0dHIocmVuZGVyVG8sIGluZGV4QXR0ck5hbWUsIGNoYXJ0LmluZGV4KTtcblxuXHRcdC8vIHJlbW92ZSBwcmV2aW91cyBjaGFydFxuXHRcdHJlbmRlclRvLmlubmVySFRNTCA9ICcnO1xuXG5cdFx0Ly8gSWYgdGhlIGNvbnRhaW5lciBkb2Vzbid0IGhhdmUgYW4gb2Zmc2V0V2lkdGgsIGl0IGhhcyBvciBpcyBhIGNoaWxkIG9mIGEgbm9kZVxuXHRcdC8vIHRoYXQgaGFzIGRpc3BsYXk6bm9uZS4gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSBtb3ZlIGl0IG91dCB0byBhIHZpc2libGVcblx0XHQvLyBzdGF0ZSB0byBkZXRlcm1pbmUgdGhlIHNpemUsIGVsc2UgdGhlIGxlZ2VuZCBhbmQgdG9vbHRpcHMgd29uJ3QgcmVuZGVyXG5cdFx0Ly8gcHJvcGVybHkuIFRoZSBhbGxvd0Nsb25lIG9wdGlvbiBpcyB1c2VkIGluIHNwYXJrbGluZXMgYXMgYSBtaWNybyBvcHRpbWl6YXRpb24sXG5cdFx0Ly8gc2F2aW5nIGFib3V0IDEtMiBtcyBlYWNoIGNoYXJ0LlxuXHRcdGlmICghb3B0aW9uc0NoYXJ0LnNraXBDbG9uZSAmJiAhcmVuZGVyVG8ub2Zmc2V0V2lkdGgpIHtcblx0XHRcdGNoYXJ0LmNsb25lUmVuZGVyVG8oKTtcblx0XHR9XG5cblx0XHQvLyBnZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHRcblx0XHRjaGFydC5nZXRDaGFydFNpemUoKTtcblx0XHRjaGFydFdpZHRoID0gY2hhcnQuY2hhcnRXaWR0aDtcblx0XHRjaGFydEhlaWdodCA9IGNoYXJ0LmNoYXJ0SGVpZ2h0O1xuXG5cdFx0Ly8gY3JlYXRlIHRoZSBpbm5lciBjb250YWluZXJcblx0XHRjaGFydC5jb250YWluZXIgPSBjb250YWluZXIgPSBjcmVhdGVFbGVtZW50KERJViwge1xuXHRcdFx0XHRjbGFzc05hbWU6IFBSRUZJWCArICdjb250YWluZXInICtcblx0XHRcdFx0XHQob3B0aW9uc0NoYXJ0LmNsYXNzTmFtZSA/ICcgJyArIG9wdGlvbnNDaGFydC5jbGFzc05hbWUgOiAnJyksXG5cdFx0XHRcdGlkOiBjb250YWluZXJJZFxuXHRcdFx0fSwgZXh0ZW5kKHtcblx0XHRcdFx0cG9zaXRpb246IFJFTEFUSVZFLFxuXHRcdFx0XHRvdmVyZmxvdzogSElEREVOLCAvLyBuZWVkZWQgZm9yIGNvbnRleHQgbWVudSAoYXZvaWQgc2Nyb2xsYmFycykgYW5kXG5cdFx0XHRcdFx0Ly8gY29udGVudCBvdmVyZmxvdyBpbiBJRVxuXHRcdFx0XHR3aWR0aDogY2hhcnRXaWR0aCArIFBYLFxuXHRcdFx0XHRoZWlnaHQ6IGNoYXJ0SGVpZ2h0ICsgUFgsXG5cdFx0XHRcdHRleHRBbGlnbjogJ2xlZnQnLFxuXHRcdFx0XHRsaW5lSGVpZ2h0OiAnbm9ybWFsJywgLy8gIzQyN1xuXHRcdFx0XHR6SW5kZXg6IDAsIC8vICMxMDcyXG5cdFx0XHRcdCctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InOiAncmdiYSgwLDAsMCwwKSdcblx0XHRcdH0sIG9wdGlvbnNDaGFydC5zdHlsZSksXG5cdFx0XHRjaGFydC5yZW5kZXJUb0Nsb25lIHx8IHJlbmRlclRvXG5cdFx0KTtcblxuXHRcdC8vIGNhY2hlIHRoZSBjdXJzb3IgKCMxNjUwKVxuXHRcdGNoYXJ0Ll9jdXJzb3IgPSBjb250YWluZXIuc3R5bGUuY3Vyc29yO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgcmVuZGVyZXJcblx0XHRSZW4gPSBIaWdoY2hhcnRzW29wdGlvbnNDaGFydC5yZW5kZXJlcl0gfHwgUmVuZGVyZXI7XG5cdFx0Y2hhcnQucmVuZGVyZXIgPSBuZXcgUmVuKFxuXHRcdFx0Y29udGFpbmVyLCBcblx0XHRcdGNoYXJ0V2lkdGgsIFxuXHRcdFx0Y2hhcnRIZWlnaHQsIFxuXHRcdFx0b3B0aW9uc0NoYXJ0LnN0eWxlLCBcblx0XHRcdG9wdGlvbnNDaGFydC5mb3JFeHBvcnQsIFxuXHRcdFx0b3B0aW9ucy5leHBvcnRpbmcgJiYgb3B0aW9ucy5leHBvcnRpbmcuYWxsb3dIVE1MXG5cdFx0KTtcblxuXHRcdGlmICh1c2VDYW5WRykge1xuXHRcdFx0Ly8gSWYgd2UgbmVlZCBjYW52ZyBsaWJyYXJ5LCBleHRlbmQgYW5kIGNvbmZpZ3VyZSB0aGUgcmVuZGVyZXJcblx0XHRcdC8vIHRvIGdldCB0aGUgdHJhY2tlciBmb3IgdHJhbnNsYXRpbmcgbW91c2UgZXZlbnRzXG5cdFx0XHRjaGFydC5yZW5kZXJlci5jcmVhdGUoY2hhcnQsIGNvbnRhaW5lciwgY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHQpO1xuXHRcdH1cblx0XHQvLyBBZGQgYSByZWZlcmVuY2UgdG8gdGhlIGNoYXJ0cyBpbmRleFxuXHRcdGNoYXJ0LnJlbmRlcmVyLmNoYXJ0SW5kZXggPSBjaGFydC5pbmRleDtcblx0fSxcblxuXHQvKipcblx0ICogQ2FsY3VsYXRlIG1hcmdpbnMgYnkgcmVuZGVyaW5nIGF4aXMgbGFiZWxzIGluIGEgcHJlbGltaW5hcnkgcG9zaXRpb24uIFRpdGxlLFxuXHQgKiBzdWJ0aXRsZSBhbmQgbGVnZW5kIGhhdmUgYWxyZWFkeSBiZWVuIHJlbmRlcmVkIGF0IHRoaXMgc3RhZ2UsIGJ1dCB3aWxsIGJlXG5cdCAqIG1vdmVkIGludG8gdGhlaXIgZmluYWwgcG9zaXRpb25zXG5cdCAqL1xuXHRnZXRNYXJnaW5zOiBmdW5jdGlvbiAoc2tpcEF4ZXMpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0c3BhY2luZyA9IGNoYXJ0LnNwYWNpbmcsXG5cdFx0XHRtYXJnaW4gPSBjaGFydC5tYXJnaW4sXG5cdFx0XHR0aXRsZU9mZnNldCA9IGNoYXJ0LnRpdGxlT2Zmc2V0O1xuXG5cdFx0Y2hhcnQucmVzZXRNYXJnaW5zKCk7XG5cblx0XHQvLyBBZGp1c3QgZm9yIHRpdGxlIGFuZCBzdWJ0aXRsZVxuXHRcdGlmICh0aXRsZU9mZnNldCAmJiAhZGVmaW5lZChtYXJnaW5bMF0pKSB7XG5cdFx0XHRjaGFydC5wbG90VG9wID0gbWF0aE1heChjaGFydC5wbG90VG9wLCB0aXRsZU9mZnNldCArIGNoYXJ0Lm9wdGlvbnMudGl0bGUubWFyZ2luICsgc3BhY2luZ1swXSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEFkanVzdCBmb3IgbGVnZW5kXG5cdFx0Y2hhcnQubGVnZW5kLmFkanVzdE1hcmdpbnMobWFyZ2luLCBzcGFjaW5nKTtcblxuXHRcdC8vIGFkanVzdCBmb3Igc2Nyb2xsZXJcblx0XHRpZiAoY2hhcnQuZXh0cmFCb3R0b21NYXJnaW4pIHtcblx0XHRcdGNoYXJ0Lm1hcmdpbkJvdHRvbSArPSBjaGFydC5leHRyYUJvdHRvbU1hcmdpbjtcblx0XHR9XG5cdFx0aWYgKGNoYXJ0LmV4dHJhVG9wTWFyZ2luKSB7XG5cdFx0XHRjaGFydC5wbG90VG9wICs9IGNoYXJ0LmV4dHJhVG9wTWFyZ2luO1xuXHRcdH1cblx0XHRpZiAoIXNraXBBeGVzKSB7XG5cdFx0XHR0aGlzLmdldEF4aXNNYXJnaW5zKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEF4aXNNYXJnaW5zOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0YXhpc09mZnNldCA9IGNoYXJ0LmF4aXNPZmZzZXQgPSBbMCwgMCwgMCwgMF0sIC8vIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFxuXHRcdFx0bWFyZ2luID0gY2hhcnQubWFyZ2luO1xuXHRcdFxuXHRcdC8vIHByZS1yZW5kZXIgYXhlcyB0byBnZXQgbGFiZWxzIG9mZnNldCB3aWR0aFxuXHRcdGlmIChjaGFydC5oYXNDYXJ0ZXNpYW5TZXJpZXMpIHtcblx0XHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0aWYgKGF4aXMudmlzaWJsZSkge1xuXHRcdFx0XHRcdGF4aXMuZ2V0T2Zmc2V0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgYXhpcyBvZmZzZXRzXG5cdFx0ZWFjaChtYXJnaW5OYW1lcywgZnVuY3Rpb24gKG0sIHNpZGUpIHtcblx0XHRcdGlmICghZGVmaW5lZChtYXJnaW5bc2lkZV0pKSB7XG5cdFx0XHRcdGNoYXJ0W21dICs9IGF4aXNPZmZzZXRbc2lkZV07XG5cdFx0XHR9XHRcdFxuXHRcdH0pO1xuXG5cdFx0Y2hhcnQuc2V0Q2hhcnRTaXplKCk7XG5cblx0fSxcblxuXHQvKipcblx0ICogUmVzaXplIHRoZSBjaGFydCB0byBpdHMgY29udGFpbmVyIGlmIHNpemUgaXMgbm90IGV4cGxpY2l0bHkgc2V0XG5cdCAqL1xuXHRyZWZsb3c6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHRyZW5kZXJUbyA9IGNoYXJ0LnJlbmRlclRvLFxuXHRcdFx0d2lkdGggPSBvcHRpb25zQ2hhcnQud2lkdGggfHwgYWRhcHRlclJ1bihyZW5kZXJUbywgJ3dpZHRoJyksXG5cdFx0XHRoZWlnaHQgPSBvcHRpb25zQ2hhcnQuaGVpZ2h0IHx8IGFkYXB0ZXJSdW4ocmVuZGVyVG8sICdoZWlnaHQnKSxcblx0XHRcdHRhcmdldCA9IGUgPyBlLnRhcmdldCA6IHdpbiwgLy8gIzgwNSAtIE1vb1Rvb2xzIGRvZXNuJ3Qgc3VwcGx5IGVcblx0XHRcdGRvUmVmbG93ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoY2hhcnQuY29udGFpbmVyKSB7IC8vIEl0IG1heSBoYXZlIGJlZW4gZGVzdHJveWVkIGluIHRoZSBtZWFudGltZSAoIzEyNTcpXG5cdFx0XHRcdFx0Y2hhcnQuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCBmYWxzZSk7XG5cdFx0XHRcdFx0Y2hhcnQuaGFzVXNlclNpemUgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0Ly8gV2lkdGggYW5kIGhlaWdodCBjaGVja3MgZm9yIGRpc3BsYXk6bm9uZS4gVGFyZ2V0IGlzIGRvYyBpbiBJRTggYW5kIE9wZXJhLFxuXHRcdC8vIHdpbiBpbiBGaXJlZm94LCBDaHJvbWUgYW5kIElFOS5cblx0XHRpZiAoIWNoYXJ0Lmhhc1VzZXJTaXplICYmICFjaGFydC5pc1ByaW50aW5nICYmIHdpZHRoICYmIGhlaWdodCAmJiAodGFyZ2V0ID09PSB3aW4gfHwgdGFyZ2V0ID09PSBkb2MpKSB7IC8vICMxMDkzXG5cdFx0XHRpZiAod2lkdGggIT09IGNoYXJ0LmNvbnRhaW5lcldpZHRoIHx8IGhlaWdodCAhPT0gY2hhcnQuY29udGFpbmVySGVpZ2h0KSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dChjaGFydC5yZWZsb3dUaW1lb3V0KTtcblx0XHRcdFx0aWYgKGUpIHsgLy8gQ2FsbGVkIGZyb20gd2luZG93LnJlc2l6ZVxuXHRcdFx0XHRcdGNoYXJ0LnJlZmxvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGRvUmVmbG93LCAxMDApO1xuXHRcdFx0XHR9IGVsc2UgeyAvLyBDYWxsZWQgZGlyZWN0bHkgKCMyMjI0KVxuXHRcdFx0XHRcdGRvUmVmbG93KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNoYXJ0LmNvbnRhaW5lcldpZHRoID0gd2lkdGg7XG5cdFx0XHRjaGFydC5jb250YWluZXJIZWlnaHQgPSBoZWlnaHQ7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGQgdGhlIGV2ZW50IGhhbmRsZXJzIG5lY2Vzc2FyeSBmb3IgYXV0byByZXNpemluZ1xuXHQgKi9cblx0aW5pdFJlZmxvdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRyZWZsb3cgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRjaGFydC5yZWZsb3coZSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XG5cdFx0YWRkRXZlbnQod2luLCAncmVzaXplJywgcmVmbG93KTtcblx0XHRhZGRFdmVudChjaGFydCwgJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVFdmVudCh3aW4sICdyZXNpemUnLCByZWZsb3cpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXNpemUgdGhlIGNoYXJ0IHRvIGEgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuXHQgKiBAcGFyYW0ge09iamVjdHxCb29sZWFufSBhbmltYXRpb25cblx0ICovXG5cdHNldFNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBhbmltYXRpb24pIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0Y2hhcnRXaWR0aCxcblx0XHRcdGNoYXJ0SGVpZ2h0LFxuXHRcdFx0ZmlyZUVuZFJlc2l6ZSxcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRnbG9iYWxBbmltYXRpb247XG5cblx0XHQvLyBIYW5kbGUgdGhlIGlzUmVzaXppbmcgY291bnRlclxuXHRcdGNoYXJ0LmlzUmVzaXppbmcgKz0gMTtcblx0XHRmaXJlRW5kUmVzaXplID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGNoYXJ0KSB7XG5cdFx0XHRcdGZpcmVFdmVudChjaGFydCwgJ2VuZFJlc2l6ZScsIG51bGwsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRjaGFydC5pc1Jlc2l6aW5nIC09IDE7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBzZXQgdGhlIGFuaW1hdGlvbiBmb3IgdGhlIGN1cnJlbnQgcHJvY2Vzc1xuXHRcdHNldEFuaW1hdGlvbihhbmltYXRpb24sIGNoYXJ0KTtcblxuXHRcdGNoYXJ0Lm9sZENoYXJ0SGVpZ2h0ID0gY2hhcnQuY2hhcnRIZWlnaHQ7XG5cdFx0Y2hhcnQub2xkQ2hhcnRXaWR0aCA9IGNoYXJ0LmNoYXJ0V2lkdGg7XG5cdFx0aWYgKGRlZmluZWQod2lkdGgpKSB7XG5cdFx0XHRjaGFydC5jaGFydFdpZHRoID0gY2hhcnRXaWR0aCA9IG1hdGhNYXgoMCwgbWF0aFJvdW5kKHdpZHRoKSk7XG5cdFx0XHRjaGFydC5oYXNVc2VyU2l6ZSA9ICEhY2hhcnRXaWR0aDtcblx0XHR9XG5cdFx0aWYgKGRlZmluZWQoaGVpZ2h0KSkge1xuXHRcdFx0Y2hhcnQuY2hhcnRIZWlnaHQgPSBjaGFydEhlaWdodCA9IG1hdGhNYXgoMCwgbWF0aFJvdW5kKGhlaWdodCkpO1xuXHRcdH1cblxuXHRcdC8vIFJlc2l6ZSB0aGUgY29udGFpbmVyIHdpdGggdGhlIGdsb2JhbCBhbmltYXRpb24gYXBwbGllZCBpZiBlbmFibGVkICgjMjUwMylcblx0XHRnbG9iYWxBbmltYXRpb24gPSByZW5kZXJlci5nbG9iYWxBbmltYXRpb247XG5cdFx0KGdsb2JhbEFuaW1hdGlvbiA/IGFuaW1hdGUgOiBjc3MpKGNoYXJ0LmNvbnRhaW5lciwge1xuXHRcdFx0d2lkdGg6IGNoYXJ0V2lkdGggKyBQWCxcblx0XHRcdGhlaWdodDogY2hhcnRIZWlnaHQgKyBQWFxuXHRcdH0sIGdsb2JhbEFuaW1hdGlvbik7XG5cblx0XHRjaGFydC5zZXRDaGFydFNpemUodHJ1ZSk7XG5cdFx0cmVuZGVyZXIuc2V0U2l6ZShjaGFydFdpZHRoLCBjaGFydEhlaWdodCwgYW5pbWF0aW9uKTtcblxuXHRcdC8vIGhhbmRsZSBheGVzXG5cdFx0Y2hhcnQubWF4VGlja3MgPSBudWxsO1xuXHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdGF4aXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRheGlzLnNldFNjYWxlKCk7XG5cdFx0fSk7XG5cblx0XHQvLyBtYWtlIHN1cmUgbm9uLWNhcnRlc2lhbiBzZXJpZXMgYXJlIGFsc28gaGFuZGxlZFxuXHRcdGVhY2goY2hhcnQuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWUpIHtcblx0XHRcdHNlcmllLmlzRGlydHkgPSB0cnVlO1xuXHRcdH0pO1xuXG5cdFx0Y2hhcnQuaXNEaXJ0eUxlZ2VuZCA9IHRydWU7IC8vIGZvcmNlIGxlZ2VuZCByZWRyYXdcblx0XHRjaGFydC5pc0RpcnR5Qm94ID0gdHJ1ZTsgLy8gZm9yY2UgcmVkcmF3IG9mIHBsb3QgYW5kIGNoYXJ0IGJvcmRlclxuXG5cdFx0Y2hhcnQubGF5T3V0VGl0bGVzKCk7IC8vICMyODU3XG5cdFx0Y2hhcnQuZ2V0TWFyZ2lucygpO1xuXG5cdFx0Y2hhcnQucmVkcmF3KGFuaW1hdGlvbik7XG5cblxuXHRcdGNoYXJ0Lm9sZENoYXJ0SGVpZ2h0ID0gbnVsbDtcblx0XHRmaXJlRXZlbnQoY2hhcnQsICdyZXNpemUnKTtcblxuXHRcdC8vIEZpcmUgZW5kUmVzaXplIGFuZCBzZXQgaXNSZXNpemluZyBiYWNrLiBJZiBhbmltYXRpb24gaXMgZGlzYWJsZWQsIGZpcmUgd2l0aG91dCBkZWxheVxuXHRcdGdsb2JhbEFuaW1hdGlvbiA9IHJlbmRlcmVyLmdsb2JhbEFuaW1hdGlvbjsgLy8gUmVhc3NpZ24gaXQgYmVmb3JlIHVzaW5nIGl0LCBpdCBtYXkgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSB0b3Agb2YgdGhpcyBmdW5jdGlvbi5cblx0XHRpZiAoZ2xvYmFsQW5pbWF0aW9uID09PSBmYWxzZSkge1xuXHRcdFx0ZmlyZUVuZFJlc2l6ZSgpO1xuXHRcdH0gZWxzZSB7IC8vIGVsc2Ugc2V0IGEgdGltZW91dCB3aXRoIHRoZSBhbmltYXRpb24gZHVyYXRpb25cblx0XHRcdHNldFRpbWVvdXQoZmlyZUVuZFJlc2l6ZSwgKGdsb2JhbEFuaW1hdGlvbiAmJiBnbG9iYWxBbmltYXRpb24uZHVyYXRpb24pIHx8IDUwMCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIHB1YmxpYyBjaGFydCBwcm9wZXJ0aWVzLiBUaGlzIGlzIGRvbmUgYmVmb3JlIGFuZCBhZnRlciB0aGUgcHJlLXJlbmRlclxuXHQgKiB0byBkZXRlcm1pbmUgbWFyZ2luIHNpemVzXG5cdCAqL1xuXHRzZXRDaGFydFNpemU6IGZ1bmN0aW9uIChza2lwQXhlcykge1xuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdGNoYXJ0V2lkdGggPSBjaGFydC5jaGFydFdpZHRoLFxuXHRcdFx0Y2hhcnRIZWlnaHQgPSBjaGFydC5jaGFydEhlaWdodCxcblx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHRzcGFjaW5nID0gY2hhcnQuc3BhY2luZyxcblx0XHRcdGNsaXBPZmZzZXQgPSBjaGFydC5jbGlwT2Zmc2V0LFxuXHRcdFx0Y2xpcFgsXG5cdFx0XHRjbGlwWSxcblx0XHRcdHBsb3RMZWZ0LFxuXHRcdFx0cGxvdFRvcCxcblx0XHRcdHBsb3RXaWR0aCxcblx0XHRcdHBsb3RIZWlnaHQsXG5cdFx0XHRwbG90Qm9yZGVyV2lkdGg7XG5cblx0XHRjaGFydC5wbG90TGVmdCA9IHBsb3RMZWZ0ID0gbWF0aFJvdW5kKGNoYXJ0LnBsb3RMZWZ0KTtcblx0XHRjaGFydC5wbG90VG9wID0gcGxvdFRvcCA9IG1hdGhSb3VuZChjaGFydC5wbG90VG9wKTtcblx0XHRjaGFydC5wbG90V2lkdGggPSBwbG90V2lkdGggPSBtYXRoTWF4KDAsIG1hdGhSb3VuZChjaGFydFdpZHRoIC0gcGxvdExlZnQgLSBjaGFydC5tYXJnaW5SaWdodCkpO1xuXHRcdGNoYXJ0LnBsb3RIZWlnaHQgPSBwbG90SGVpZ2h0ID0gbWF0aE1heCgwLCBtYXRoUm91bmQoY2hhcnRIZWlnaHQgLSBwbG90VG9wIC0gY2hhcnQubWFyZ2luQm90dG9tKSk7XG5cblx0XHRjaGFydC5wbG90U2l6ZVggPSBpbnZlcnRlZCA/IHBsb3RIZWlnaHQgOiBwbG90V2lkdGg7XG5cdFx0Y2hhcnQucGxvdFNpemVZID0gaW52ZXJ0ZWQgPyBwbG90V2lkdGggOiBwbG90SGVpZ2h0O1xuXHRcdFxuXHRcdGNoYXJ0LnBsb3RCb3JkZXJXaWR0aCA9IG9wdGlvbnNDaGFydC5wbG90Qm9yZGVyV2lkdGggfHwgMDtcblxuXHRcdC8vIFNldCBib3hlcyB1c2VkIGZvciBhbGlnbm1lbnRcblx0XHRjaGFydC5zcGFjaW5nQm94ID0gcmVuZGVyZXIuc3BhY2luZ0JveCA9IHtcblx0XHRcdHg6IHNwYWNpbmdbM10sXG5cdFx0XHR5OiBzcGFjaW5nWzBdLFxuXHRcdFx0d2lkdGg6IGNoYXJ0V2lkdGggLSBzcGFjaW5nWzNdIC0gc3BhY2luZ1sxXSxcblx0XHRcdGhlaWdodDogY2hhcnRIZWlnaHQgLSBzcGFjaW5nWzBdIC0gc3BhY2luZ1syXVxuXHRcdH07XG5cdFx0Y2hhcnQucGxvdEJveCA9IHJlbmRlcmVyLnBsb3RCb3ggPSB7XG5cdFx0XHR4OiBwbG90TGVmdCxcblx0XHRcdHk6IHBsb3RUb3AsXG5cdFx0XHR3aWR0aDogcGxvdFdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBwbG90SGVpZ2h0XG5cdFx0fTtcblxuXHRcdHBsb3RCb3JkZXJXaWR0aCA9IDIgKiBtYXRoRmxvb3IoY2hhcnQucGxvdEJvcmRlcldpZHRoIC8gMik7XG5cdFx0Y2xpcFggPSBtYXRoQ2VpbChtYXRoTWF4KHBsb3RCb3JkZXJXaWR0aCwgY2xpcE9mZnNldFszXSkgLyAyKTtcblx0XHRjbGlwWSA9IG1hdGhDZWlsKG1hdGhNYXgocGxvdEJvcmRlcldpZHRoLCBjbGlwT2Zmc2V0WzBdKSAvIDIpO1xuXHRcdGNoYXJ0LmNsaXBCb3ggPSB7XG5cdFx0XHR4OiBjbGlwWCwgXG5cdFx0XHR5OiBjbGlwWSwgXG5cdFx0XHR3aWR0aDogbWF0aEZsb29yKGNoYXJ0LnBsb3RTaXplWCAtIG1hdGhNYXgocGxvdEJvcmRlcldpZHRoLCBjbGlwT2Zmc2V0WzFdKSAvIDIgLSBjbGlwWCksIFxuXHRcdFx0aGVpZ2h0OiBtYXRoTWF4KDAsIG1hdGhGbG9vcihjaGFydC5wbG90U2l6ZVkgLSBtYXRoTWF4KHBsb3RCb3JkZXJXaWR0aCwgY2xpcE9mZnNldFsyXSkgLyAyIC0gY2xpcFkpKVxuXHRcdH07XG5cblx0XHRpZiAoIXNraXBBeGVzKSB7XG5cdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdGF4aXMuc2V0QXhpc1NpemUoKTtcblx0XHRcdFx0YXhpcy5zZXRBeGlzVHJhbnNsYXRpb24oKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogSW5pdGlhbCBtYXJnaW5zIGJlZm9yZSBhdXRvIHNpemUgbWFyZ2lucyBhcmUgYXBwbGllZFxuXHQgKi9cblx0cmVzZXRNYXJnaW5zOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcztcblxuXHRcdGVhY2gobWFyZ2luTmFtZXMsIGZ1bmN0aW9uIChtLCBzaWRlKSB7XG5cdFx0XHRjaGFydFttXSA9IHBpY2soY2hhcnQubWFyZ2luW3NpZGVdLCBjaGFydC5zcGFjaW5nW3NpZGVdKTtcblx0XHR9KTtcblx0XHRjaGFydC5heGlzT2Zmc2V0ID0gWzAsIDAsIDAsIDBdOyAvLyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcblx0XHRjaGFydC5jbGlwT2Zmc2V0ID0gWzAsIDAsIDAsIDBdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3IHRoZSBib3JkZXJzIGFuZCBiYWNrZ3JvdW5kcyBmb3IgY2hhcnQgYW5kIHBsb3QgYXJlYVxuXHQgKi9cblx0ZHJhd0NoYXJ0Qm94OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0Y2hhcnRXaWR0aCA9IGNoYXJ0LmNoYXJ0V2lkdGgsXG5cdFx0XHRjaGFydEhlaWdodCA9IGNoYXJ0LmNoYXJ0SGVpZ2h0LFxuXHRcdFx0Y2hhcnRCYWNrZ3JvdW5kID0gY2hhcnQuY2hhcnRCYWNrZ3JvdW5kLFxuXHRcdFx0cGxvdEJhY2tncm91bmQgPSBjaGFydC5wbG90QmFja2dyb3VuZCxcblx0XHRcdHBsb3RCb3JkZXIgPSBjaGFydC5wbG90Qm9yZGVyLFxuXHRcdFx0cGxvdEJHSW1hZ2UgPSBjaGFydC5wbG90QkdJbWFnZSxcblx0XHRcdGNoYXJ0Qm9yZGVyV2lkdGggPSBvcHRpb25zQ2hhcnQuYm9yZGVyV2lkdGggfHwgMCxcblx0XHRcdGNoYXJ0QmFja2dyb3VuZENvbG9yID0gb3B0aW9uc0NoYXJ0LmJhY2tncm91bmRDb2xvcixcblx0XHRcdHBsb3RCYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zQ2hhcnQucGxvdEJhY2tncm91bmRDb2xvcixcblx0XHRcdHBsb3RCYWNrZ3JvdW5kSW1hZ2UgPSBvcHRpb25zQ2hhcnQucGxvdEJhY2tncm91bmRJbWFnZSxcblx0XHRcdHBsb3RCb3JkZXJXaWR0aCA9IG9wdGlvbnNDaGFydC5wbG90Qm9yZGVyV2lkdGggfHwgMCxcblx0XHRcdG1nbixcblx0XHRcdGJnQXR0cixcblx0XHRcdHBsb3RMZWZ0ID0gY2hhcnQucGxvdExlZnQsXG5cdFx0XHRwbG90VG9wID0gY2hhcnQucGxvdFRvcCxcblx0XHRcdHBsb3RXaWR0aCA9IGNoYXJ0LnBsb3RXaWR0aCxcblx0XHRcdHBsb3RIZWlnaHQgPSBjaGFydC5wbG90SGVpZ2h0LFxuXHRcdFx0cGxvdEJveCA9IGNoYXJ0LnBsb3RCb3gsXG5cdFx0XHRjbGlwUmVjdCA9IGNoYXJ0LmNsaXBSZWN0LFxuXHRcdFx0Y2xpcEJveCA9IGNoYXJ0LmNsaXBCb3g7XG5cblx0XHQvLyBDaGFydCBhcmVhXG5cdFx0bWduID0gY2hhcnRCb3JkZXJXaWR0aCArIChvcHRpb25zQ2hhcnQuc2hhZG93ID8gOCA6IDApO1xuXG5cdFx0aWYgKGNoYXJ0Qm9yZGVyV2lkdGggfHwgY2hhcnRCYWNrZ3JvdW5kQ29sb3IpIHtcblx0XHRcdGlmICghY2hhcnRCYWNrZ3JvdW5kKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRiZ0F0dHIgPSB7XG5cdFx0XHRcdFx0ZmlsbDogY2hhcnRCYWNrZ3JvdW5kQ29sb3IgfHwgTk9ORVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoY2hhcnRCb3JkZXJXaWR0aCkgeyAvLyAjOTgwXG5cdFx0XHRcdFx0YmdBdHRyLnN0cm9rZSA9IG9wdGlvbnNDaGFydC5ib3JkZXJDb2xvcjtcblx0XHRcdFx0XHRiZ0F0dHJbJ3N0cm9rZS13aWR0aCddID0gY2hhcnRCb3JkZXJXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGFydC5jaGFydEJhY2tncm91bmQgPSByZW5kZXJlci5yZWN0KG1nbiAvIDIsIG1nbiAvIDIsIGNoYXJ0V2lkdGggLSBtZ24sIGNoYXJ0SGVpZ2h0IC0gbWduLFxuXHRcdFx0XHRcdFx0b3B0aW9uc0NoYXJ0LmJvcmRlclJhZGl1cywgY2hhcnRCb3JkZXJXaWR0aClcblx0XHRcdFx0XHQuYXR0cihiZ0F0dHIpXG5cdFx0XHRcdFx0LmFkZENsYXNzKFBSRUZJWCArICdiYWNrZ3JvdW5kJylcblx0XHRcdFx0XHQuYWRkKClcblx0XHRcdFx0XHQuc2hhZG93KG9wdGlvbnNDaGFydC5zaGFkb3cpO1xuXG5cdFx0XHR9IGVsc2UgeyAvLyByZXNpemVcblx0XHRcdFx0Y2hhcnRCYWNrZ3JvdW5kLmFuaW1hdGUoXG5cdFx0XHRcdFx0Y2hhcnRCYWNrZ3JvdW5kLmNyaXNwKHsgd2lkdGg6IGNoYXJ0V2lkdGggLSBtZ24sIGhlaWdodDogY2hhcnRIZWlnaHQgLSBtZ24gfSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdC8vIFBsb3QgYmFja2dyb3VuZFxuXHRcdGlmIChwbG90QmFja2dyb3VuZENvbG9yKSB7XG5cdFx0XHRpZiAoIXBsb3RCYWNrZ3JvdW5kKSB7XG5cdFx0XHRcdGNoYXJ0LnBsb3RCYWNrZ3JvdW5kID0gcmVuZGVyZXIucmVjdChwbG90TGVmdCwgcGxvdFRvcCwgcGxvdFdpZHRoLCBwbG90SGVpZ2h0LCAwKVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdGZpbGw6IHBsb3RCYWNrZ3JvdW5kQ29sb3Jcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGQoKVxuXHRcdFx0XHRcdC5zaGFkb3cob3B0aW9uc0NoYXJ0LnBsb3RTaGFkb3cpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGxvdEJhY2tncm91bmQuYW5pbWF0ZShwbG90Qm94KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHBsb3RCYWNrZ3JvdW5kSW1hZ2UpIHtcblx0XHRcdGlmICghcGxvdEJHSW1hZ2UpIHtcblx0XHRcdFx0Y2hhcnQucGxvdEJHSW1hZ2UgPSByZW5kZXJlci5pbWFnZShwbG90QmFja2dyb3VuZEltYWdlLCBwbG90TGVmdCwgcGxvdFRvcCwgcGxvdFdpZHRoLCBwbG90SGVpZ2h0KVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBsb3RCR0ltYWdlLmFuaW1hdGUocGxvdEJveCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFBsb3QgY2xpcFxuXHRcdGlmICghY2xpcFJlY3QpIHtcblx0XHRcdGNoYXJ0LmNsaXBSZWN0ID0gcmVuZGVyZXIuY2xpcFJlY3QoY2xpcEJveCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNsaXBSZWN0LmFuaW1hdGUoe1xuXHRcdFx0XHR3aWR0aDogY2xpcEJveC53aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBjbGlwQm94LmhlaWdodFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gUGxvdCBhcmVhIGJvcmRlclxuXHRcdGlmIChwbG90Qm9yZGVyV2lkdGgpIHtcblx0XHRcdGlmICghcGxvdEJvcmRlcikge1xuXHRcdFx0XHRjaGFydC5wbG90Qm9yZGVyID0gcmVuZGVyZXIucmVjdChwbG90TGVmdCwgcGxvdFRvcCwgcGxvdFdpZHRoLCBwbG90SGVpZ2h0LCAwLCAtcGxvdEJvcmRlcldpZHRoKVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdHN0cm9rZTogb3B0aW9uc0NoYXJ0LnBsb3RCb3JkZXJDb2xvcixcblx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBwbG90Qm9yZGVyV2lkdGgsXG5cdFx0XHRcdFx0XHRmaWxsOiBOT05FLFxuXHRcdFx0XHRcdFx0ekluZGV4OiAxXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwbG90Qm9yZGVyLmFuaW1hdGUoXG5cdFx0XHRcdFx0cGxvdEJvcmRlci5jcmlzcCh7IHg6IHBsb3RMZWZ0LCB5OiBwbG90VG9wLCB3aWR0aDogcGxvdFdpZHRoLCBoZWlnaHQ6IHBsb3RIZWlnaHQsIHN0cm9rZVdpZHRoOiAtcGxvdEJvcmRlcldpZHRoIH0pIC8vIzMyODIgcGxvdEJvcmRlciBzaG91bGQgYmUgbmVnYXRpdmVcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyByZXNldFxuXHRcdGNoYXJ0LmlzRGlydHlCb3ggPSBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogRGV0ZWN0IHdoZXRoZXIgYSBjZXJ0YWluIGNoYXJ0IHByb3BlcnR5IGlzIG5lZWRlZCBiYXNlZCBvbiBpbnNwZWN0aW5nIGl0cyBvcHRpb25zXG5cdCAqIGFuZCBzZXJpZXMuIFRoaXMgbWFpbmx5IGFwcGxpZXMgdG8gdGhlIGNoYXJ0LmludmVydCBwcm9wZXJ0eSwgYW5kIGluIGV4dGVuc2lvbnMgdG8gXG5cdCAqIHRoZSBjaGFydC5hbmd1bGFyIGFuZCBjaGFydC5wb2xhciBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0cHJvcEZyb21TZXJpZXM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdGtsYXNzLFxuXHRcdFx0c2VyaWVzT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuc2VyaWVzLFxuXHRcdFx0aSxcblx0XHRcdHZhbHVlO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRlYWNoKFsnaW52ZXJ0ZWQnLCAnYW5ndWxhcicsICdwb2xhciddLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcblx0XHRcdC8vIFRoZSBkZWZhdWx0IHNlcmllcyB0eXBlJ3MgY2xhc3Ncblx0XHRcdGtsYXNzID0gc2VyaWVzVHlwZXNbb3B0aW9uc0NoYXJ0LnR5cGUgfHwgb3B0aW9uc0NoYXJ0LmRlZmF1bHRTZXJpZXNUeXBlXTtcblx0XHRcdFxuXHRcdFx0Ly8gR2V0IHRoZSB2YWx1ZSBmcm9tIGF2YWlsYWJsZSBjaGFydC13aWRlIHByb3BlcnRpZXNcblx0XHRcdHZhbHVlID0gKFxuXHRcdFx0XHRjaGFydFtrZXldIHx8IC8vIDEuIGl0IGlzIHNldCBiZWZvcmVcblx0XHRcdFx0b3B0aW9uc0NoYXJ0W2tleV0gfHwgLy8gMi4gaXQgaXMgc2V0IGluIHRoZSBvcHRpb25zXG5cdFx0XHRcdChrbGFzcyAmJiBrbGFzcy5wcm90b3R5cGVba2V5XSkgLy8gMy4gaXQncyBkZWZhdWx0IHNlcmllcyBjbGFzcyByZXF1aXJlcyBpdFxuXHRcdFx0KTtcblx0XG5cdFx0XHQvLyA0LiBDaGVjayBpZiBhbnkgdGhlIGNoYXJ0J3Mgc2VyaWVzIHJlcXVpcmUgaXRcblx0XHRcdGkgPSBzZXJpZXNPcHRpb25zICYmIHNlcmllc09wdGlvbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCF2YWx1ZSAmJiBpLS0pIHtcblx0XHRcdFx0a2xhc3MgPSBzZXJpZXNUeXBlc1tzZXJpZXNPcHRpb25zW2ldLnR5cGVdO1xuXHRcdFx0XHRpZiAoa2xhc3MgJiYga2xhc3MucHJvdG90eXBlW2tleV0pIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyBTZXQgdGhlIGNoYXJ0IHByb3BlcnR5XG5cdFx0XHRjaGFydFtrZXldID0gdmFsdWU7XHRcblx0XHR9KTtcblx0XHRcblx0fSxcblxuXHQvKipcblx0ICogTGluayB0d28gb3IgbW9yZSBzZXJpZXMgdG9nZXRoZXIuIFRoaXMgaXMgZG9uZSBpbml0aWFsbHkgZnJvbSBDaGFydC5yZW5kZXIsXG5cdCAqIGFuZCBhZnRlciBDaGFydC5hZGRTZXJpZXMgYW5kIFNlcmllcy5yZW1vdmUuXG5cdCAqL1xuXHRsaW5rU2VyaWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdGNoYXJ0U2VyaWVzID0gY2hhcnQuc2VyaWVzO1xuXG5cdFx0Ly8gUmVzZXQgbGlua3Ncblx0XHRlYWNoKGNoYXJ0U2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRzZXJpZXMubGlua2VkU2VyaWVzLmxlbmd0aCA9IDA7XG5cdFx0fSk7XG5cblx0XHQvLyBBcHBseSBuZXcgbGlua3Ncblx0XHRlYWNoKGNoYXJ0U2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHR2YXIgbGlua2VkVG8gPSBzZXJpZXMub3B0aW9ucy5saW5rZWRUbztcblx0XHRcdGlmIChpc1N0cmluZyhsaW5rZWRUbykpIHtcblx0XHRcdFx0aWYgKGxpbmtlZFRvID09PSAnOnByZXZpb3VzJykge1xuXHRcdFx0XHRcdGxpbmtlZFRvID0gY2hhcnQuc2VyaWVzW3Nlcmllcy5pbmRleCAtIDFdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpbmtlZFRvID0gY2hhcnQuZ2V0KGxpbmtlZFRvKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobGlua2VkVG8pIHtcblx0XHRcdFx0XHRsaW5rZWRUby5saW5rZWRTZXJpZXMucHVzaChzZXJpZXMpO1xuXHRcdFx0XHRcdHNlcmllcy5saW5rZWRQYXJlbnQgPSBsaW5rZWRUbztcblx0XHRcdFx0XHRzZXJpZXMudmlzaWJsZSA9IHBpY2soc2VyaWVzLm9wdGlvbnMudmlzaWJsZSwgbGlua2VkVG8ub3B0aW9ucy52aXNpYmxlLCBzZXJpZXMudmlzaWJsZSk7IC8vICMzODc5XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogUmVuZGVyIHNlcmllcyBmb3IgdGhlIGNoYXJ0XG5cdCAqL1xuXHRyZW5kZXJTZXJpZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRlYWNoKHRoaXMuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWUpIHtcblx0XHRcdHNlcmllLnRyYW5zbGF0ZSgpO1xuXHRcdFx0c2VyaWUucmVuZGVyKCk7XG5cdFx0fSk7XG5cdH0sXG5cdFx0XG5cdC8qKlxuXHQgKiBSZW5kZXIgbGFiZWxzIGZvciB0aGUgY2hhcnRcblx0ICovXG5cdHJlbmRlckxhYmVsczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRsYWJlbHMgPSBjaGFydC5vcHRpb25zLmxhYmVscztcblx0XHRpZiAobGFiZWxzLml0ZW1zKSB7XG5cdFx0XHRlYWNoKGxhYmVscy5pdGVtcywgZnVuY3Rpb24gKGxhYmVsKSB7XG5cdFx0XHRcdHZhciBzdHlsZSA9IGV4dGVuZChsYWJlbHMuc3R5bGUsIGxhYmVsLnN0eWxlKSxcblx0XHRcdFx0XHR4ID0gcEludChzdHlsZS5sZWZ0KSArIGNoYXJ0LnBsb3RMZWZ0LFxuXHRcdFx0XHRcdHkgPSBwSW50KHN0eWxlLnRvcCkgKyBjaGFydC5wbG90VG9wICsgMTI7XG5cblx0XHRcdFx0Ly8gZGVsZXRlIHRvIHByZXZlbnQgcmV3cml0aW5nIGluIElFXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZS5sZWZ0O1xuXHRcdFx0XHRkZWxldGUgc3R5bGUudG9wO1xuXG5cdFx0XHRcdGNoYXJ0LnJlbmRlcmVyLnRleHQoXG5cdFx0XHRcdFx0bGFiZWwuaHRtbCxcblx0XHRcdFx0XHR4LFxuXHRcdFx0XHRcdHlcblx0XHRcdFx0KVxuXHRcdFx0XHQuYXR0cih7IHpJbmRleDogMiB9KVxuXHRcdFx0XHQuY3NzKHN0eWxlKVxuXHRcdFx0XHQuYWRkKCk7XG5cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmVuZGVyIGFsbCBncmFwaGljcyBmb3IgdGhlIGNoYXJ0XG5cdCAqL1xuXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0YXhlcyA9IGNoYXJ0LmF4ZXMsXG5cdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0b3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMsXG5cdFx0XHR0ZW1wV2lkdGgsXG5cdFx0XHR0ZW1wSGVpZ2h0LFxuXHRcdFx0cmVkb0hvcml6b250YWwsXG5cdFx0XHRyZWRvVmVydGljYWw7XG5cblx0XHQvLyBUaXRsZVxuXHRcdGNoYXJ0LnNldFRpdGxlKCk7XG5cblxuXHRcdC8vIExlZ2VuZFxuXHRcdGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoY2hhcnQsIG9wdGlvbnMubGVnZW5kKTtcblxuXHRcdC8vIEdldCBzdGFja3Ncblx0XHRpZiAoY2hhcnQuZ2V0U3RhY2tzKSB7XG5cdFx0XHRjaGFydC5nZXRTdGFja3MoKTtcblx0XHR9XG5cblx0XHQvLyBHZXQgY2hhcnQgbWFyZ2luc1xuXHRcdGNoYXJ0LmdldE1hcmdpbnModHJ1ZSk7XG5cdFx0Y2hhcnQuc2V0Q2hhcnRTaXplKCk7XG5cblx0XHQvLyBSZWNvcmQgcHJlbGltaW5hcnkgZGltZW5zaW9ucyBmb3IgbGF0ZXIgY29tcGFyaXNvblxuXHRcdHRlbXBXaWR0aCA9IGNoYXJ0LnBsb3RXaWR0aDtcblx0XHR0ZW1wSGVpZ2h0ID0gY2hhcnQucGxvdEhlaWdodCA9IGNoYXJ0LnBsb3RIZWlnaHQgLSAxMzsgLy8gMTMgaXMgdGhlIG1vc3QgY29tbW9uIGhlaWdodCBvZiBYIGF4aXMgbGFiZWxzXG5cblx0XHQvLyBHZXQgbWFyZ2lucyBieSBwcmUtcmVuZGVyaW5nIGF4ZXNcblx0XHRlYWNoKGF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRheGlzLnNldFNjYWxlKCk7XG5cdFx0fSk7XG5cdFx0Y2hhcnQuZ2V0QXhpc01hcmdpbnMoKTtcblxuXHRcdC8vIElmIHRoZSBwbG90IGFyZWEgc2l6ZSBoYXMgY2hhbmdlZCBzaWduaWZpY2FudGx5LCBjYWxjdWxhdGUgdGljayBwb3NpdGlvbnMgYWdhaW5cblx0XHRyZWRvSG9yaXpvbnRhbCA9IHRlbXBXaWR0aCAvIGNoYXJ0LnBsb3RXaWR0aCA+IDEuMTtcblx0XHRyZWRvVmVydGljYWwgPSB0ZW1wSGVpZ2h0IC8gY2hhcnQucGxvdEhlaWdodCA+IDEuMTtcblxuXHRcdGlmIChyZWRvSG9yaXpvbnRhbCB8fCByZWRvVmVydGljYWwpIHtcblxuXHRcdFx0Y2hhcnQubWF4VGlja3MgPSBudWxsOyAvLyByZXNldCBmb3Igc2Vjb25kIHBhc3Ncblx0XHRcdGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0aWYgKChheGlzLmhvcml6ICYmIHJlZG9Ib3Jpem9udGFsKSB8fCAoIWF4aXMuaG9yaXogJiYgcmVkb1ZlcnRpY2FsKSkge1xuXHRcdFx0XHRcdGF4aXMuc2V0VGlja0ludGVydmFsKHRydWUpOyAvLyB1cGRhdGUgdG8gcmVmbGVjdCB0aGUgbmV3IG1hcmdpbnNcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRjaGFydC5nZXRNYXJnaW5zKCk7IC8vIHNlY29uZCBwYXNzIHRvIGNoZWNrIGZvciBuZXcgbGFiZWxzXG5cdFx0fVxuXG5cdFx0Ly8gRHJhdyB0aGUgYm9yZGVycyBhbmQgYmFja2dyb3VuZHNcblx0XHRjaGFydC5kcmF3Q2hhcnRCb3goKTtcdFx0XG5cblxuXHRcdC8vIEF4ZXNcblx0XHRpZiAoY2hhcnQuaGFzQ2FydGVzaWFuU2VyaWVzKSB7XG5cdFx0XHRlYWNoKGF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdGlmIChheGlzLnZpc2libGUpIHtcblx0XHRcdFx0XHRheGlzLnJlbmRlcigpO1x0XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBzZXJpZXNcblx0XHRpZiAoIWNoYXJ0LnNlcmllc0dyb3VwKSB7XG5cdFx0XHRjaGFydC5zZXJpZXNHcm91cCA9IHJlbmRlcmVyLmcoJ3Nlcmllcy1ncm91cCcpXG5cdFx0XHRcdC5hdHRyKHsgekluZGV4OiAzIH0pXG5cdFx0XHRcdC5hZGQoKTtcblx0XHR9XG5cdFx0Y2hhcnQucmVuZGVyU2VyaWVzKCk7XG5cblx0XHQvLyBMYWJlbHNcblx0XHRjaGFydC5yZW5kZXJMYWJlbHMoKTtcblxuXHRcdC8vIENyZWRpdHNcblx0XHRjaGFydC5zaG93Q3JlZGl0cyhvcHRpb25zLmNyZWRpdHMpO1xuXG5cdFx0Ly8gU2V0IGZsYWdcblx0XHRjaGFydC5oYXNSZW5kZXJlZCA9IHRydWU7XG5cblx0fSxcblxuXHQvKipcblx0ICogU2hvdyBjaGFydCBjcmVkaXRzIGJhc2VkIG9uIGNvbmZpZyBvcHRpb25zXG5cdCAqL1xuXHRzaG93Q3JlZGl0czogZnVuY3Rpb24gKGNyZWRpdHMpIHtcblx0XHRpZiAoY3JlZGl0cy5lbmFibGVkICYmICF0aGlzLmNyZWRpdHMpIHtcblx0XHRcdHRoaXMuY3JlZGl0cyA9IHRoaXMucmVuZGVyZXIudGV4dChcblx0XHRcdFx0Y3JlZGl0cy50ZXh0LFxuXHRcdFx0XHQwLFxuXHRcdFx0XHQwXG5cdFx0XHQpXG5cdFx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoY3JlZGl0cy5ocmVmKSB7XG5cdFx0XHRcdFx0bG9jYXRpb24uaHJlZiA9IGNyZWRpdHMuaHJlZjtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5hdHRyKHtcblx0XHRcdFx0YWxpZ246IGNyZWRpdHMucG9zaXRpb24uYWxpZ24sXG5cdFx0XHRcdHpJbmRleDogOFxuXHRcdFx0fSlcblx0XHRcdC5jc3MoY3JlZGl0cy5zdHlsZSlcblx0XHRcdC5hZGQoKVxuXHRcdFx0LmFsaWduKGNyZWRpdHMucG9zaXRpb24pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQ2xlYW4gdXAgbWVtb3J5IHVzYWdlXG5cdCAqL1xuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdGF4ZXMgPSBjaGFydC5heGVzLFxuXHRcdFx0c2VyaWVzID0gY2hhcnQuc2VyaWVzLFxuXHRcdFx0Y29udGFpbmVyID0gY2hhcnQuY29udGFpbmVyLFxuXHRcdFx0aSxcblx0XHRcdHBhcmVudE5vZGUgPSBjb250YWluZXIgJiYgY29udGFpbmVyLnBhcmVudE5vZGU7XG5cdFx0XHRcblx0XHQvLyBmaXJlIHRoZSBjaGFydC5kZXN0b3kgZXZlbnRcblx0XHRmaXJlRXZlbnQoY2hhcnQsICdkZXN0cm95Jyk7XG5cdFx0XG5cdFx0Ly8gRGVsZXRlIHRoZSBjaGFydCBmcm9tIGNoYXJ0cyBsb29rdXAgYXJyYXlcblx0XHRjaGFydHNbY2hhcnQuaW5kZXhdID0gVU5ERUZJTkVEO1xuXHRcdGNoYXJ0Q291bnQtLTtcblx0XHRjaGFydC5yZW5kZXJUby5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaGlnaGNoYXJ0cy1jaGFydCcpO1xuXG5cdFx0Ly8gcmVtb3ZlIGV2ZW50c1xuXHRcdHJlbW92ZUV2ZW50KGNoYXJ0KTtcblxuXHRcdC8vID09PT0gRGVzdHJveSBjb2xsZWN0aW9uczpcblx0XHQvLyBEZXN0cm95IGF4ZXNcblx0XHRpID0gYXhlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0YXhlc1tpXSA9IGF4ZXNbaV0uZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdC8vIERlc3Ryb3kgZWFjaCBzZXJpZXNcblx0XHRpID0gc2VyaWVzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRzZXJpZXNbaV0gPSBzZXJpZXNbaV0uZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdC8vID09PT0gRGVzdHJveSBjaGFydCBwcm9wZXJ0aWVzOlxuXHRcdGVhY2goWyd0aXRsZScsICdzdWJ0aXRsZScsICdjaGFydEJhY2tncm91bmQnLCAncGxvdEJhY2tncm91bmQnLCAncGxvdEJHSW1hZ2UnLCBcblx0XHRcdFx0J3Bsb3RCb3JkZXInLCAnc2VyaWVzR3JvdXAnLCAnY2xpcFJlY3QnLCAnY3JlZGl0cycsICdwb2ludGVyJywgJ3Njcm9sbGVyJywgXG5cdFx0XHRcdCdyYW5nZVNlbGVjdG9yJywgJ2xlZ2VuZCcsICdyZXNldFpvb21CdXR0b24nLCAndG9vbHRpcCcsICdyZW5kZXJlciddLCBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0dmFyIHByb3AgPSBjaGFydFtuYW1lXTtcblxuXHRcdFx0aWYgKHByb3AgJiYgcHJvcC5kZXN0cm95KSB7XG5cdFx0XHRcdGNoYXJ0W25hbWVdID0gcHJvcC5kZXN0cm95KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyByZW1vdmUgY29udGFpbmVyIGFuZCBhbGwgU1ZHXG5cdFx0aWYgKGNvbnRhaW5lcikgeyAvLyBjYW4gYnJlYWsgaW4gSUUgd2hlbiBkZXN0cm95ZWQgYmVmb3JlIGZpbmlzaGVkIGxvYWRpbmdcblx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcblx0XHRcdHJlbW92ZUV2ZW50KGNvbnRhaW5lcik7XG5cdFx0XHRpZiAocGFyZW50Tm9kZSkge1xuXHRcdFx0XHRkaXNjYXJkRWxlbWVudChjb250YWluZXIpO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gY2xlYW4gaXQgYWxsIHVwXG5cdFx0Zm9yIChpIGluIGNoYXJ0KSB7XG5cdFx0XHRkZWxldGUgY2hhcnRbaV07XG5cdFx0fVxuXG5cdH0sXG5cblxuXHQvKipcblx0ICogVk1MIG5hbWVzcGFjZXMgY2FuJ3QgYmUgYWRkZWQgdW50aWwgYWZ0ZXIgY29tcGxldGUuIExpc3RlbmluZ1xuXHQgKiBmb3IgUGVyaW5pJ3MgZG9TY3JvbGwgaGFjayBpcyBub3QgZW5vdWdoLlxuXHQgKi9cblx0aXNSZWFkeVRvUmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcztcblxuXHRcdC8vIE5vdGU6IGluIHNwaXRlIG9mIEpTTGludCdzIGNvbXBsYWludHMsIHdpbiA9PSB3aW4udG9wIGlzIHJlcXVpcmVkXG5cdFx0Lypqc2xpbnQgZXFlcTogdHJ1ZSovXG5cdFx0aWYgKCghaGFzU1ZHICYmICh3aW4gPT0gd2luLnRvcCAmJiBkb2MucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykpIHx8ICh1c2VDYW5WRyAmJiAhd2luLmNhbnZnKSkge1xuXHRcdC8qanNsaW50IGVxZXE6IGZhbHNlKi9cblx0XHRcdGlmICh1c2VDYW5WRykge1xuXHRcdFx0XHQvLyBEZWxheSByZW5kZXJpbmcgdW50aWwgY2FudmcgbGlicmFyeSBpcyBkb3dubG9hZGVkIGFuZCByZWFkeVxuXHRcdFx0XHRDYW5WR0NvbnRyb2xsZXIucHVzaChmdW5jdGlvbiAoKSB7IGNoYXJ0LmZpcnN0UmVuZGVyKCk7IH0sIGNoYXJ0Lm9wdGlvbnMuZ2xvYmFsLmNhbnZhc1Rvb2xzVVJMKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvYy5hdHRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGRvYy5kZXRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgY2hhcnQuZmlyc3RSZW5kZXIpO1xuXHRcdFx0XHRcdGlmIChkb2MucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuXHRcdFx0XHRcdFx0Y2hhcnQuZmlyc3RSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUHJlcGFyZSBmb3IgZmlyc3QgcmVuZGVyaW5nIGFmdGVyIGFsbCBkYXRhIGFyZSBsb2FkZWRcblx0ICovXG5cdGZpcnN0UmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLFxuXHRcdFx0Y2FsbGJhY2sgPSBjaGFydC5jYWxsYmFjaztcblxuXHRcdC8vIENoZWNrIHdoZXRoZXIgdGhlIGNoYXJ0IGlzIHJlYWR5IHRvIHJlbmRlclxuXHRcdGlmICghY2hhcnQuaXNSZWFkeVRvUmVuZGVyKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgdGhlIGNvbnRhaW5lclxuXHRcdGNoYXJ0LmdldENvbnRhaW5lcigpO1xuXG5cdFx0Ly8gUnVuIGFuIGVhcmx5IGV2ZW50IGFmdGVyIHRoZSBjb250YWluZXIgYW5kIHJlbmRlcmVyIGFyZSBlc3RhYmxpc2hlZFxuXHRcdGZpcmVFdmVudChjaGFydCwgJ2luaXQnKTtcblxuXHRcdFxuXHRcdGNoYXJ0LnJlc2V0TWFyZ2lucygpO1xuXHRcdGNoYXJ0LnNldENoYXJ0U2l6ZSgpO1xuXG5cdFx0Ly8gU2V0IHRoZSBjb21tb24gY2hhcnQgcHJvcGVydGllcyAobWFpbmx5IGludmVydCkgZnJvbSB0aGUgZ2l2ZW4gc2VyaWVzXG5cdFx0Y2hhcnQucHJvcEZyb21TZXJpZXMoKTtcblxuXHRcdC8vIGdldCBheGVzXG5cdFx0Y2hhcnQuZ2V0QXhlcygpO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc2VyaWVzXG5cdFx0ZWFjaChvcHRpb25zLnNlcmllcyB8fCBbXSwgZnVuY3Rpb24gKHNlcmllT3B0aW9ucykge1xuXHRcdFx0Y2hhcnQuaW5pdFNlcmllcyhzZXJpZU9wdGlvbnMpO1xuXHRcdH0pO1xuXG5cdFx0Y2hhcnQubGlua1NlcmllcygpO1xuXG5cdFx0Ly8gUnVuIGFuIGV2ZW50IGFmdGVyIGF4ZXMgYW5kIHNlcmllcyBhcmUgaW5pdGlhbGl6ZWQsIGJ1dCBiZWZvcmUgcmVuZGVyLiBBdCB0aGlzIHN0YWdlLFxuXHRcdC8vIHRoZSBzZXJpZXMgZGF0YSBpcyBpbmRleGVkIGFuZCBjYWNoZWQgaW4gdGhlIHhEYXRhIGFuZCB5RGF0YSBhcnJheXMsIHNvIHdlIGNhbiBhY2Nlc3Ncblx0XHQvLyB0aG9zZSBiZWZvcmUgcmVuZGVyaW5nLiBVc2VkIGluIEhpZ2hzdG9jay4gXG5cdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnYmVmb3JlUmVuZGVyJyk7IFxuXG5cdFx0Ly8gZGVwZW5kcyBvbiBpbnZlcnRlZCBhbmQgb24gbWFyZ2lucyBiZWluZyBzZXRcblx0XHRpZiAoSGlnaGNoYXJ0cy5Qb2ludGVyKSB7XG5cdFx0XHRjaGFydC5wb2ludGVyID0gbmV3IFBvaW50ZXIoY2hhcnQsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGNoYXJ0LnJlbmRlcigpO1xuXG5cdFx0Ly8gYWRkIGNhbnZhc1xuXHRcdGNoYXJ0LnJlbmRlcmVyLmRyYXcoKTtcblx0XHQvLyBydW4gY2FsbGJhY2tzXG5cdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjay5hcHBseShjaGFydCwgW2NoYXJ0XSk7XG5cdFx0fVxuXHRcdGVhY2goY2hhcnQuY2FsbGJhY2tzLCBmdW5jdGlvbiAoZm4pIHtcblx0XHRcdGlmIChjaGFydC5pbmRleCAhPT0gVU5ERUZJTkVEKSB7IC8vIENoYXJ0IGRlc3Ryb3llZCBpbiBpdHMgb3duIGNhbGxiYWNrICgjMzYwMClcblx0XHRcdFx0Zm4uYXBwbHkoY2hhcnQsIFtjaGFydF0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdFxuXHRcdC8vIEZpcmUgdGhlIGxvYWQgZXZlbnRcblx0XHRmaXJlRXZlbnQoY2hhcnQsICdsb2FkJyk7XHRcdFxuXHRcdFxuXHRcdC8vIElmIHRoZSBjaGFydCB3YXMgcmVuZGVyZWQgb3V0c2lkZSB0aGUgdG9wIGNvbnRhaW5lciwgcHV0IGl0IGJhY2sgaW4gKCMzNjc5KVxuXHRcdGNoYXJ0LmNsb25lUmVuZGVyVG8odHJ1ZSk7XG5cblx0fSxcblxuXHQvKipcblx0KiBDcmVhdGVzIGFycmF5cyBmb3Igc3BhY2luZyBhbmQgbWFyZ2luIGZyb20gZ2l2ZW4gb3B0aW9ucy5cblx0Ki9cblx0c3BsYXNoQXJyYXk6IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcblx0XHR2YXIgb1ZhciA9IG9wdGlvbnNbdGFyZ2V0XSxcblx0XHRcdHRBcnJheSA9IGlzT2JqZWN0KG9WYXIpID8gb1ZhciA6IFtvVmFyLCBvVmFyLCBvVmFyLCBvVmFyXTtcblxuXHRcdHJldHVybiBbcGljayhvcHRpb25zW3RhcmdldCArICdUb3AnXSwgdEFycmF5WzBdKSxcblx0XHRcdFx0cGljayhvcHRpb25zW3RhcmdldCArICdSaWdodCddLCB0QXJyYXlbMV0pLFxuXHRcdFx0XHRwaWNrKG9wdGlvbnNbdGFyZ2V0ICsgJ0JvdHRvbSddLCB0QXJyYXlbMl0pLFxuXHRcdFx0XHRwaWNrKG9wdGlvbnNbdGFyZ2V0ICsgJ0xlZnQnXSwgdEFycmF5WzNdKV07XG5cdH1cbn07IC8vIGVuZCBDaGFydFxuXG52YXIgQ2VudGVyZWRTZXJpZXNNaXhpbiA9IEhpZ2hjaGFydHMuQ2VudGVyZWRTZXJpZXNNaXhpbiA9IHtcblx0LyoqXG5cdCAqIEdldCB0aGUgY2VudGVyIG9mIHRoZSBwaWUgYmFzZWQgb24gdGhlIHNpemUgYW5kIGNlbnRlciBvcHRpb25zIHJlbGF0aXZlIHRvIHRoZSAgXG5cdCAqIHBsb3QgYXJlYS4gQm9ycm93ZWQgYnkgdGhlIHBvbGFyIGFuZCBnYXVnZSBzZXJpZXMgdHlwZXMuXG5cdCAqL1xuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdHNsaWNpbmdSb29tID0gMiAqIChvcHRpb25zLnNsaWNlZE9mZnNldCB8fCAwKSxcblx0XHRcdGhhbmRsZVNsaWNpbmdSb29tLFxuXHRcdFx0cGxvdFdpZHRoID0gY2hhcnQucGxvdFdpZHRoIC0gMiAqIHNsaWNpbmdSb29tLFxuXHRcdFx0cGxvdEhlaWdodCA9IGNoYXJ0LnBsb3RIZWlnaHQgLSAyICogc2xpY2luZ1Jvb20sXG5cdFx0XHRjZW50ZXJPcHRpb24gPSBvcHRpb25zLmNlbnRlcixcblx0XHRcdHBvc2l0aW9ucyA9IFtwaWNrKGNlbnRlck9wdGlvblswXSwgJzUwJScpLCBwaWNrKGNlbnRlck9wdGlvblsxXSwgJzUwJScpLCBvcHRpb25zLnNpemUgfHwgJzEwMCUnLCBvcHRpb25zLmlubmVyU2l6ZSB8fCAwXSxcblx0XHRcdHNtYWxsZXN0U2l6ZSA9IG1hdGhNaW4ocGxvdFdpZHRoLCBwbG90SGVpZ2h0KSxcblx0XHRcdGksXG5cdFx0XHR2YWx1ZTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCA0OyArK2kpIHtcblx0XHRcdHZhbHVlID0gcG9zaXRpb25zW2ldO1xuXHRcdFx0aGFuZGxlU2xpY2luZ1Jvb20gPSBpIDwgMiB8fCAoaSA9PT0gMiAmJiAvJSQvLnRlc3QodmFsdWUpKTtcblx0XHRcdFxuXHRcdFx0Ly8gaSA9PSAwOiBjZW50ZXJYLCByZWxhdGl2ZSB0byB3aWR0aFxuXHRcdFx0Ly8gaSA9PSAxOiBjZW50ZXJZLCByZWxhdGl2ZSB0byBoZWlnaHRcblx0XHRcdC8vIGkgPT0gMjogc2l6ZSwgcmVsYXRpdmUgdG8gc21hbGxlc3RTaXplXG5cdFx0XHQvLyBpID09IDM6IGlubmVyU2l6ZSwgcmVsYXRpdmUgdG8gc2l6ZVxuXHRcdFx0cG9zaXRpb25zW2ldID0gcmVsYXRpdmVMZW5ndGgodmFsdWUsIFtwbG90V2lkdGgsIHBsb3RIZWlnaHQsIHNtYWxsZXN0U2l6ZSwgcG9zaXRpb25zWzJdXVtpXSkgK1xuXHRcdFx0XHQoaGFuZGxlU2xpY2luZ1Jvb20gPyBzbGljaW5nUm9vbSA6IDApO1xuXG5cdFx0fVxuXHRcdC8vIGlubmVyU2l6ZSBjYW5ub3QgYmUgbGFyZ2VyIHRoYW4gc2l6ZSAoIzM2MzIpXG5cdFx0aWYgKHBvc2l0aW9uc1szXSA+IHBvc2l0aW9uc1syXSkge1xuXHRcdFx0cG9zaXRpb25zWzNdID0gcG9zaXRpb25zWzJdO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9zaXRpb25zO1xuXHR9XG59O1xuXG4vKipcbiAqIFRoZSBQb2ludCBvYmplY3QgYW5kIHByb3RvdHlwZS4gSW5oZXJpdGFibGUgYW5kIHVzZWQgYXMgYmFzZSBmb3IgUGllUG9pbnRcbiAqL1xudmFyIFBvaW50ID0gZnVuY3Rpb24gKCkge307XG5Qb2ludC5wcm90b3R5cGUgPSB7XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIHBvaW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpZXMgVGhlIHNlcmllcyBvYmplY3QgY29udGFpbmluZyB0aGlzIHBvaW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBkYXRhIGluIGVpdGhlciBudW1iZXIsIGFycmF5IG9yIG9iamVjdCBmb3JtYXRcblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uIChzZXJpZXMsIG9wdGlvbnMsIHgpIHtcblxuXHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRjb2xvcnM7XG5cdFx0cG9pbnQuc2VyaWVzID0gc2VyaWVzO1xuXHRcdHBvaW50LmNvbG9yID0gc2VyaWVzLmNvbG9yOyAvLyAjMzQ0NVxuXHRcdHBvaW50LmFwcGx5T3B0aW9ucyhvcHRpb25zLCB4KTtcblx0XHRwb2ludC5wb2ludEF0dHIgPSB7fTtcblxuXHRcdGlmIChzZXJpZXMub3B0aW9ucy5jb2xvckJ5UG9pbnQpIHtcblx0XHRcdGNvbG9ycyA9IHNlcmllcy5vcHRpb25zLmNvbG9ycyB8fCBzZXJpZXMuY2hhcnQub3B0aW9ucy5jb2xvcnM7XG5cdFx0XHRwb2ludC5jb2xvciA9IHBvaW50LmNvbG9yIHx8IGNvbG9yc1tzZXJpZXMuY29sb3JDb3VudGVyKytdO1xuXHRcdFx0Ly8gbG9vcCBiYWNrIHRvIHplcm9cblx0XHRcdGlmIChzZXJpZXMuY29sb3JDb3VudGVyID09PSBjb2xvcnMubGVuZ3RoKSB7XG5cdFx0XHRcdHNlcmllcy5jb2xvckNvdW50ZXIgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlcmllcy5jaGFydC5wb2ludENvdW50Kys7XG5cdFx0cmV0dXJuIHBvaW50O1xuXHR9LFxuXHQvKipcblx0ICogQXBwbHkgdGhlIG9wdGlvbnMgY29udGFpbmluZyB0aGUgeCBhbmQgeSBkYXRhIGFuZCBwb3NzaWJsZSBzb21lIGV4dHJhIHByb3BlcnRpZXMuXG5cdCAqIFRoaXMgaXMgY2FsbGVkIG9uIHBvaW50IGluaXQgb3IgZnJvbSBwb2ludC51cGRhdGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHRhcHBseU9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zLCB4KSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdHBvaW50VmFsS2V5ID0gc2VyaWVzLm9wdGlvbnMucG9pbnRWYWxLZXkgfHwgc2VyaWVzLnBvaW50VmFsS2V5O1xuXG5cdFx0b3B0aW9ucyA9IFBvaW50LnByb3RvdHlwZS5vcHRpb25zVG9PYmplY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuXHRcdC8vIGNvcHkgb3B0aW9ucyBkaXJlY3RseSB0byBwb2ludFxuXHRcdGV4dGVuZChwb2ludCwgb3B0aW9ucyk7XG5cdFx0cG9pbnQub3B0aW9ucyA9IHBvaW50Lm9wdGlvbnMgPyBleHRlbmQocG9pbnQub3B0aW9ucywgb3B0aW9ucykgOiBvcHRpb25zO1xuXG5cdFx0Ly8gRm9yIGhpZ2hlciBkaW1lbnNpb24gc2VyaWVzIHR5cGVzLiBGb3IgaW5zdGFuY2UsIGZvciByYW5nZXMsIHBvaW50LnkgaXMgbWFwcGVkIHRvIHBvaW50Lmxvdy5cblx0XHRpZiAocG9pbnRWYWxLZXkpIHtcblx0XHRcdHBvaW50LnkgPSBwb2ludFtwb2ludFZhbEtleV07XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbm8geCBpcyBzZXQgYnkgbm93LCBnZXQgYXV0byBpbmNyZW1lbnRlZCB2YWx1ZS4gQWxsIHBvaW50cyBtdXN0IGhhdmUgYW5cblx0XHQvLyB4IHZhbHVlLCBob3dldmVyIHRoZSB5IHZhbHVlIGNhbiBiZSBudWxsIHRvIGNyZWF0ZSBhIGdhcCBpbiB0aGUgc2VyaWVzXG5cdFx0aWYgKHBvaW50LnggPT09IFVOREVGSU5FRCAmJiBzZXJpZXMpIHtcblx0XHRcdHBvaW50LnggPSB4ID09PSBVTkRFRklORUQgPyBzZXJpZXMuYXV0b0luY3JlbWVudCgpIDogeDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRyYW5zZm9ybSBudW1iZXIgb3IgYXJyYXkgY29uZmlncyBpbnRvIG9iamVjdHNcblx0ICovXG5cdG9wdGlvbnNUb09iamVjdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHR2YXIgcmV0ID0ge30sXG5cdFx0XHRzZXJpZXMgPSB0aGlzLnNlcmllcyxcblx0XHRcdGtleXMgPSBzZXJpZXMub3B0aW9ucy5rZXlzLFxuXHRcdFx0cG9pbnRBcnJheU1hcCA9IGtleXMgfHwgc2VyaWVzLnBvaW50QXJyYXlNYXAgfHwgWyd5J10sXG5cdFx0XHR2YWx1ZUNvdW50ID0gcG9pbnRBcnJheU1hcC5sZW5ndGgsXG5cdFx0XHRmaXJzdEl0ZW1UeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRqID0gMDtcblxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuXHRcdFx0cmV0W3BvaW50QXJyYXlNYXBbMF1dID0gb3B0aW9ucztcblxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheShvcHRpb25zKSkge1xuXHRcdFx0Ly8gd2l0aCBsZWFkaW5nIHggdmFsdWVcblx0XHRcdGlmICgha2V5cyAmJiBvcHRpb25zLmxlbmd0aCA+IHZhbHVlQ291bnQpIHtcblx0XHRcdFx0Zmlyc3RJdGVtVHlwZSA9IHR5cGVvZiBvcHRpb25zWzBdO1xuXHRcdFx0XHRpZiAoZmlyc3RJdGVtVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRyZXQubmFtZSA9IG9wdGlvbnNbMF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoZmlyc3RJdGVtVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRyZXQueCA9IG9wdGlvbnNbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aSsrO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGogPCB2YWx1ZUNvdW50KSB7XG5cdFx0XHRcdGlmICgha2V5cyB8fCBvcHRpb25zW2ldICE9PSB1bmRlZmluZWQpIHsgLy8gU2tpcCB1bmRlZmluZWQgcG9zaXRpb25zIGZvciBrZXlzXG5cdFx0XHRcdFx0cmV0W3BvaW50QXJyYXlNYXBbal1dID0gb3B0aW9uc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpKys7XG5cdFx0XHRcdGorKztcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuXHRcdFx0cmV0ID0gb3B0aW9ucztcblxuXHRcdFx0Ly8gVGhpcyBpcyB0aGUgZmFzdGVzdCB3YXkgdG8gZGV0ZWN0IGlmIHRoZXJlIGFyZSBpbmRpdmlkdWFsIHBvaW50IGRhdGFMYWJlbHMgdGhhdCBuZWVkXG5cdFx0XHQvLyB0byBiZSBjb25zaWRlcmVkIGluIGRyYXdEYXRhTGFiZWxzLiBUaGVzZSBjYW4gb25seSBvY2N1ciBpbiBvYmplY3QgY29uZmlncy5cblx0XHRcdGlmIChvcHRpb25zLmRhdGFMYWJlbHMpIHtcblx0XHRcdFx0c2VyaWVzLl9oYXNQb2ludExhYmVscyA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhbWUgYXBwcm9hY2ggYXMgYWJvdmUgZm9yIG1hcmtlcnNcblx0XHRcdGlmIChvcHRpb25zLm1hcmtlcikge1xuXHRcdFx0XHRzZXJpZXMuX2hhc1BvaW50TWFya2VycyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3Ryb3kgYSBwb2ludCB0byBjbGVhciBtZW1vcnkuIEl0cyByZWZlcmVuY2Ugc3RpbGwgc3RheXMgaW4gc2VyaWVzLmRhdGEuXG5cdCAqL1xuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0aG92ZXJQb2ludHMgPSBjaGFydC5ob3ZlclBvaW50cyxcblx0XHRcdHByb3A7XG5cblx0XHRjaGFydC5wb2ludENvdW50LS07XG5cblx0XHRpZiAoaG92ZXJQb2ludHMpIHtcblx0XHRcdHBvaW50LnNldFN0YXRlKCk7XG5cdFx0XHRlcmFzZShob3ZlclBvaW50cywgcG9pbnQpO1xuXHRcdFx0aWYgKCFob3ZlclBvaW50cy5sZW5ndGgpIHtcblx0XHRcdFx0Y2hhcnQuaG92ZXJQb2ludHMgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0fVxuXHRcdGlmIChwb2ludCA9PT0gY2hhcnQuaG92ZXJQb2ludCkge1xuXHRcdFx0cG9pbnQub25Nb3VzZU91dCgpO1xuXHRcdH1cblxuXHRcdC8vIHJlbW92ZSBhbGwgZXZlbnRzXG5cdFx0aWYgKHBvaW50LmdyYXBoaWMgfHwgcG9pbnQuZGF0YUxhYmVsKSB7IC8vIHJlbW92ZUV2ZW50IGFuZCBkZXN0cm95RWxlbWVudHMgYXJlIHBlcmZvcm1hbmNlIGV4cGVuc2l2ZVxuXHRcdFx0cmVtb3ZlRXZlbnQocG9pbnQpO1xuXHRcdFx0cG9pbnQuZGVzdHJveUVsZW1lbnRzKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHBvaW50LmxlZ2VuZEl0ZW0pIHsgLy8gcGllcyBoYXZlIGxlZ2VuZCBpdGVtc1xuXHRcdFx0Y2hhcnQubGVnZW5kLmRlc3Ryb3lJdGVtKHBvaW50KTtcblx0XHR9XG5cblx0XHRmb3IgKHByb3AgaW4gcG9pbnQpIHtcblx0XHRcdHBvaW50W3Byb3BdID0gbnVsbDtcblx0XHR9XG5cblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZXN0cm95IFNWRyBlbGVtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIHBvaW50XG5cdCAqL1xuXHRkZXN0cm95RWxlbWVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0cHJvcHMgPSBbJ2dyYXBoaWMnLCAnZGF0YUxhYmVsJywgJ2RhdGFMYWJlbFVwcGVyJywgJ2Nvbm5lY3RvcicsICdzaGFkb3dHcm91cCddLFxuXHRcdFx0cHJvcCxcblx0XHRcdGkgPSA2O1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdHByb3AgPSBwcm9wc1tpXTtcblx0XHRcdGlmIChwb2ludFtwcm9wXSkge1xuXHRcdFx0XHRwb2ludFtwcm9wXSA9IHBvaW50W3Byb3BdLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgY29uZmlndXJhdGlvbiBoYXNoIG5lZWRlZCBmb3IgdGhlIGRhdGEgbGFiZWwgYW5kIHRvb2x0aXAgZm9ybWF0dGVyc1xuXHQgKi9cblx0Z2V0TGFiZWxDb25maWc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdGhpcy5jYXRlZ29yeSxcblx0XHRcdHk6IHRoaXMueSxcblx0XHRcdGNvbG9yOiB0aGlzLmNvbG9yLFxuXHRcdFx0a2V5OiB0aGlzLm5hbWUgfHwgdGhpcy5jYXRlZ29yeSxcblx0XHRcdHNlcmllczogdGhpcy5zZXJpZXMsXG5cdFx0XHRwb2ludDogdGhpcyxcblx0XHRcdHBlcmNlbnRhZ2U6IHRoaXMucGVyY2VudGFnZSxcblx0XHRcdHRvdGFsOiB0aGlzLnRvdGFsIHx8IHRoaXMuc3RhY2tUb3RhbFxuXHRcdH07XG5cdH0sXHRcblxuXHQvKipcblx0ICogRXh0ZW5kYWJsZSBtZXRob2QgZm9yIGZvcm1hdHRpbmcgZWFjaCBwb2ludCdzIHRvb2x0aXAgbGluZVxuXHQgKlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHRvIGJlIGNvbmNhdGVuYXRlZCBpbiB0byB0aGUgY29tbW9uIHRvb2x0aXAgdGV4dFxuXHQgKi9cblx0dG9vbHRpcEZvcm1hdHRlcjogZnVuY3Rpb24gKHBvaW50Rm9ybWF0KSB7XG5cblx0XHQvLyBJbnNlcnQgb3B0aW9ucyBmb3IgdmFsdWVEZWNpbWFscywgdmFsdWVQcmVmaXgsIGFuZCB2YWx1ZVN1ZmZpeFxuXHRcdHZhciBzZXJpZXMgPSB0aGlzLnNlcmllcyxcblx0XHRcdHNlcmllc1Rvb2x0aXBPcHRpb25zID0gc2VyaWVzLnRvb2x0aXBPcHRpb25zLFxuXHRcdFx0dmFsdWVEZWNpbWFscyA9IHBpY2soc2VyaWVzVG9vbHRpcE9wdGlvbnMudmFsdWVEZWNpbWFscywgJycpLFxuXHRcdFx0dmFsdWVQcmVmaXggPSBzZXJpZXNUb29sdGlwT3B0aW9ucy52YWx1ZVByZWZpeCB8fCAnJyxcblx0XHRcdHZhbHVlU3VmZml4ID0gc2VyaWVzVG9vbHRpcE9wdGlvbnMudmFsdWVTdWZmaXggfHwgJyc7XG5cblx0XHQvLyBMb29wIG92ZXIgdGhlIHBvaW50IGFycmF5IG1hcCBhbmQgcmVwbGFjZSB1bmZvcm1hdHRlZCB2YWx1ZXMgd2l0aCBzcHJpbnRmIGZvcm1hdHRpbmcgbWFya3VwXG5cdFx0ZWFjaChzZXJpZXMucG9pbnRBcnJheU1hcCB8fCBbJ3knXSwgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0a2V5ID0gJ3twb2ludC4nICsga2V5OyAvLyB3aXRob3V0IHRoZSBjbG9zaW5nIGJyYWNrZXRcblx0XHRcdGlmICh2YWx1ZVByZWZpeCB8fCB2YWx1ZVN1ZmZpeCkge1xuXHRcdFx0XHRwb2ludEZvcm1hdCA9IHBvaW50Rm9ybWF0LnJlcGxhY2Uoa2V5ICsgJ30nLCB2YWx1ZVByZWZpeCArIGtleSArICd9JyArIHZhbHVlU3VmZml4KTtcblx0XHRcdH1cblx0XHRcdHBvaW50Rm9ybWF0ID0gcG9pbnRGb3JtYXQucmVwbGFjZShrZXkgKyAnfScsIGtleSArICc6LC4nICsgdmFsdWVEZWNpbWFscyArICdmfScpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGZvcm1hdChwb2ludEZvcm1hdCwge1xuXHRcdFx0cG9pbnQ6IHRoaXMsXG5cdFx0XHRzZXJpZXM6IHRoaXMuc2VyaWVzXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZpcmUgYW4gZXZlbnQgb24gdGhlIFBvaW50IG9iamVjdC4gTXVzdCBub3QgYmUgcmVuYW1lZCB0byBmaXJlRXZlbnQsIGFzIHRoaXNcblx0ICogY2F1c2VzIGEgbmFtZSBjbGFzaCBpbiBNb29Ub29sc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudEFyZ3MgQWRkaXRpb25hbCBldmVudCBhcmd1bWVudHNcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdEZ1bmN0aW9uIERlZmF1bHQgZXZlbnQgaGFuZGxlclxuXHQgKi9cblx0ZmlyZVBvaW50RXZlbnQ6IGZ1bmN0aW9uIChldmVudFR5cGUsIGV2ZW50QXJncywgZGVmYXVsdEZ1bmN0aW9uKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdHNlcmllcyA9IHRoaXMuc2VyaWVzLFxuXHRcdFx0c2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zO1xuXG5cdFx0Ly8gbG9hZCBldmVudCBoYW5kbGVycyBvbiBkZW1hbmQgdG8gc2F2ZSB0aW1lIG9uIG1vdXNlb3Zlci9vdXRcblx0XHRpZiAoc2VyaWVzT3B0aW9ucy5wb2ludC5ldmVudHNbZXZlbnRUeXBlXSB8fCAocG9pbnQub3B0aW9ucyAmJiBwb2ludC5vcHRpb25zLmV2ZW50cyAmJiBwb2ludC5vcHRpb25zLmV2ZW50c1tldmVudFR5cGVdKSkge1xuXHRcdFx0dGhpcy5pbXBvcnRFdmVudHMoKTtcblx0XHR9XG5cblx0XHQvLyBhZGQgZGVmYXVsdCBoYW5kbGVyIGlmIGluIHNlbGVjdGlvbiBtb2RlXG5cdFx0aWYgKGV2ZW50VHlwZSA9PT0gJ2NsaWNrJyAmJiBzZXJpZXNPcHRpb25zLmFsbG93UG9pbnRTZWxlY3QpIHtcblx0XHRcdGRlZmF1bHRGdW5jdGlvbiA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0XHQvLyBDb250cm9sIGtleSBpcyBmb3IgV2luZG93cywgbWV0YSAoPSBDbWQga2V5KSBmb3IgTWFjLCBTaGlmdCBmb3IgT3BlcmFcblx0XHRcdFx0aWYgKHBvaW50LnNlbGVjdCkgeyAvLyBDb3VsZCBiZSBkZXN0cm95ZWQgYnkgcHJpb3IgZXZlbnQgaGFuZGxlcnMgKCMyOTExKVxuXHRcdFx0XHRcdHBvaW50LnNlbGVjdChudWxsLCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGZpcmVFdmVudCh0aGlzLCBldmVudFR5cGUsIGV2ZW50QXJncywgZGVmYXVsdEZ1bmN0aW9uKTtcblx0fSxcblx0dmlzaWJsZTogdHJ1ZVxufTsvKipcbiAqIEBjbGFzc0Rlc2NyaXB0aW9uIFRoZSBiYXNlIGZ1bmN0aW9uIHdoaWNoIGFsbCBvdGhlciBzZXJpZXMgdHlwZXMgaW5oZXJpdCBmcm9tLiBUaGUgZGF0YSBpbiB0aGUgc2VyaWVzIGlzIHN0b3JlZFxuICogaW4gdmFyaW91cyBhcnJheXMuXG4gKlxuICogLSBGaXJzdCwgc2VyaWVzLm9wdGlvbnMuZGF0YSBjb250YWlucyBhbGwgdGhlIG9yaWdpbmFsIGNvbmZpZyBvcHRpb25zIGZvclxuICogZWFjaCBwb2ludCB3aGV0aGVyIGFkZGVkIGJ5IG9wdGlvbnMgb3IgbWV0aG9kcyBsaWtlIHNlcmllcy5hZGRQb2ludC5cbiAqIC0gTmV4dCwgc2VyaWVzLmRhdGEgY29udGFpbnMgdGhvc2UgdmFsdWVzIGNvbnZlcnRlZCB0byBwb2ludHMsIGJ1dCBpbiBjYXNlIHRoZSBzZXJpZXMgZGF0YSBsZW5ndGhcbiAqIGV4Y2VlZHMgdGhlIGNyb3BUaHJlc2hvbGQsIG9yIGlmIHRoZSBkYXRhIGlzIGdyb3VwZWQsIHNlcmllcy5kYXRhIGRvZXNuJ3QgY29udGFpbiBhbGwgdGhlIHBvaW50cy4gSXRcbiAqIG9ubHkgY29udGFpbnMgdGhlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBjcmVhdGVkIG9uIGRlbWFuZC5cbiAqIC0gVGhlbiB0aGVyZSdzIHNlcmllcy5wb2ludHMgdGhhdCBjb250YWlucyBhbGwgY3VycmVudGx5IHZpc2libGUgcG9pbnQgb2JqZWN0cy4gSW4gY2FzZSBvZiBjcm9wcGluZyxcbiAqIHRoZSBjcm9wcGVkLWF3YXkgcG9pbnRzIGFyZSBub3QgcGFydCBvZiB0aGlzIGFycmF5LiBUaGUgc2VyaWVzLnBvaW50cyBhcnJheSBzdGFydHMgYXQgc2VyaWVzLmNyb3BTdGFydFxuICogY29tcGFyZWQgdG8gc2VyaWVzLmRhdGEgYW5kIHNlcmllcy5vcHRpb25zLmRhdGEuIElmIGhvd2V2ZXIgdGhlIHNlcmllcyBkYXRhIGlzIGdyb3VwZWQsIHRoZXNlIGNhbid0XG4gKiBiZSBjb3JyZWxhdGVkIG9uZSB0byBvbmUuXG4gKiAtIHNlcmllcy54RGF0YSBhbmQgc2VyaWVzLnByb2Nlc3NlZFhEYXRhIGNvbnRhaW4gY2xlYW4geCB2YWx1ZXMsIGVxdWl2YWxlbnQgdG8gc2VyaWVzLmRhdGEgYW5kIHNlcmllcy5wb2ludHMuXG4gKiAtIHNlcmllcy55RGF0YSBhbmQgc2VyaWVzLnByb2Nlc3NlZFlEYXRhIGNvbnRhaW4gY2xlYW4geCB2YWx1ZXMsIGVxdWl2YWxlbnQgdG8gc2VyaWVzLmRhdGEgYW5kIHNlcmllcy5wb2ludHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG52YXIgU2VyaWVzID0gSGlnaGNoYXJ0cy5TZXJpZXMgPSBmdW5jdGlvbiAoKSB7fTtcblxuU2VyaWVzLnByb3RvdHlwZSA9IHtcblxuXHRpc0NhcnRlc2lhbjogdHJ1ZSxcblx0dHlwZTogJ2xpbmUnLFxuXHRwb2ludENsYXNzOiBQb2ludCxcblx0c29ydGVkOiB0cnVlLCAvLyByZXF1aXJlcyB0aGUgZGF0YSB0byBiZSBzb3J0ZWRcblx0cmVxdWlyZVNvcnRpbmc6IHRydWUsXG5cdHBvaW50QXR0clRvT3B0aW9uczogeyAvLyBtYXBwaW5nIGJldHdlZW4gU1ZHIGF0dHJpYnV0ZXMgYW5kIHRoZSBjb3JyZXNwb25kaW5nIG9wdGlvbnNcblx0XHRzdHJva2U6ICdsaW5lQ29sb3InLFxuXHRcdCdzdHJva2Utd2lkdGgnOiAnbGluZVdpZHRoJyxcblx0XHRmaWxsOiAnZmlsbENvbG9yJyxcblx0XHRyOiAncmFkaXVzJ1xuXHR9LFxuXHRkaXJlY3RUb3VjaDogZmFsc2UsXG5cdGF4aXNUeXBlczogWyd4QXhpcycsICd5QXhpcyddLFxuXHRjb2xvckNvdW50ZXI6IDAsXG5cdHBhcmFsbGVsQXJyYXlzOiBbJ3gnLCAneSddLCAvLyBlYWNoIHBvaW50J3MgeCBhbmQgeSB2YWx1ZXMgYXJlIHN0b3JlZCBpbiB0aGlzLnhEYXRhIGFuZCB0aGlzLnlEYXRhXG5cdGluaXQ6IGZ1bmN0aW9uIChjaGFydCwgb3B0aW9ucykge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0ZXZlbnRUeXBlLFxuXHRcdFx0ZXZlbnRzLFxuXHRcdFx0Y2hhcnRTZXJpZXMgPSBjaGFydC5zZXJpZXMsXG5cdFx0XHRzb3J0QnlJbmRleCA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBwaWNrKGEub3B0aW9ucy5pbmRleCwgYS5faSkgLSBwaWNrKGIub3B0aW9ucy5pbmRleCwgYi5faSk7XG5cdFx0XHR9O1xuXG5cdFx0c2VyaWVzLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0c2VyaWVzLm9wdGlvbnMgPSBvcHRpb25zID0gc2VyaWVzLnNldE9wdGlvbnMob3B0aW9ucyk7IC8vIG1lcmdlIHdpdGggcGxvdE9wdGlvbnNcblx0XHRzZXJpZXMubGlua2VkU2VyaWVzID0gW107XG5cblx0XHQvLyBiaW5kIHRoZSBheGVzXG5cdFx0c2VyaWVzLmJpbmRBeGVzKCk7XG5cblx0XHQvLyBzZXQgc29tZSB2YXJpYWJsZXNcblx0XHRleHRlbmQoc2VyaWVzLCB7XG5cdFx0XHRuYW1lOiBvcHRpb25zLm5hbWUsXG5cdFx0XHRzdGF0ZTogTk9STUFMX1NUQVRFLFxuXHRcdFx0cG9pbnRBdHRyOiB7fSxcblx0XHRcdHZpc2libGU6IG9wdGlvbnMudmlzaWJsZSAhPT0gZmFsc2UsIC8vIHRydWUgYnkgZGVmYXVsdFxuXHRcdFx0c2VsZWN0ZWQ6IG9wdGlvbnMuc2VsZWN0ZWQgPT09IHRydWUgLy8gZmFsc2UgYnkgZGVmYXVsdFxuXHRcdH0pO1xuXG5cdFx0Ly8gc3BlY2lhbFxuXHRcdGlmICh1c2VDYW5WRykge1xuXHRcdFx0b3B0aW9ucy5hbmltYXRpb24gPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyByZWdpc3RlciBldmVudCBsaXN0ZW5lcnNcblx0XHRldmVudHMgPSBvcHRpb25zLmV2ZW50cztcblx0XHRmb3IgKGV2ZW50VHlwZSBpbiBldmVudHMpIHtcblx0XHRcdGFkZEV2ZW50KHNlcmllcywgZXZlbnRUeXBlLCBldmVudHNbZXZlbnRUeXBlXSk7XG5cdFx0fVxuXHRcdGlmIChcblx0XHRcdChldmVudHMgJiYgZXZlbnRzLmNsaWNrKSB8fFxuXHRcdFx0KG9wdGlvbnMucG9pbnQgJiYgb3B0aW9ucy5wb2ludC5ldmVudHMgJiYgb3B0aW9ucy5wb2ludC5ldmVudHMuY2xpY2spIHx8XG5cdFx0XHRvcHRpb25zLmFsbG93UG9pbnRTZWxlY3Rcblx0XHQpIHtcblx0XHRcdGNoYXJ0LnJ1blRyYWNrZXJDbGljayA9IHRydWU7XG5cdFx0fVxuXG5cdFx0c2VyaWVzLmdldENvbG9yKCk7XG5cdFx0c2VyaWVzLmdldFN5bWJvbCgpO1xuXG5cdFx0Ly8gU2V0IHRoZSBkYXRhXG5cdFx0ZWFjaChzZXJpZXMucGFyYWxsZWxBcnJheXMsIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHNlcmllc1trZXkgKyAnRGF0YSddID0gW107XG5cdFx0fSk7XG5cdFx0c2VyaWVzLnNldERhdGEob3B0aW9ucy5kYXRhLCBmYWxzZSk7XG5cblx0XHQvLyBNYXJrIGNhcnRlc2lhblxuXHRcdGlmIChzZXJpZXMuaXNDYXJ0ZXNpYW4pIHtcblx0XHRcdGNoYXJ0Lmhhc0NhcnRlc2lhblNlcmllcyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gUmVnaXN0ZXIgaXQgaW4gdGhlIGNoYXJ0XG5cdFx0Y2hhcnRTZXJpZXMucHVzaChzZXJpZXMpO1xuXHRcdHNlcmllcy5faSA9IGNoYXJ0U2VyaWVzLmxlbmd0aCAtIDE7XG5cblx0XHQvLyBTb3J0IHNlcmllcyBhY2NvcmRpbmcgdG8gaW5kZXggb3B0aW9uICgjMjQ4LCAjMTEyMywgIzI0NTYpXG5cdFx0c3RhYmxlU29ydChjaGFydFNlcmllcywgc29ydEJ5SW5kZXgpO1xuXHRcdGlmICh0aGlzLnlBeGlzKSB7XG5cdFx0XHRzdGFibGVTb3J0KHRoaXMueUF4aXMuc2VyaWVzLCBzb3J0QnlJbmRleCk7XG5cdFx0fVxuXG5cdFx0ZWFjaChjaGFydFNlcmllcywgZnVuY3Rpb24gKHNlcmllcywgaSkge1xuXHRcdFx0c2VyaWVzLmluZGV4ID0gaTtcblx0XHRcdHNlcmllcy5uYW1lID0gc2VyaWVzLm5hbWUgfHwgJ1NlcmllcyAnICsgKGkgKyAxKTtcblx0XHR9KTtcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIHhBeGlzIGFuZCB5QXhpcyBwcm9wZXJ0aWVzIG9mIGNhcnRlc2lhbiBzZXJpZXMsIGFuZCByZWdpc3RlciB0aGUgc2VyaWVzXG5cdCAqIGluIHRoZSBheGlzLnNlcmllcyBhcnJheVxuXHQgKi9cblx0YmluZEF4ZXM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0YXhpc09wdGlvbnM7XG5cblx0XHRlYWNoKHNlcmllcy5heGlzVHlwZXMgfHwgW10sIGZ1bmN0aW9uIChBWElTKSB7IC8vIHJlcGVhdCBmb3IgeEF4aXMgYW5kIHlBeGlzXG5cblx0XHRcdGVhY2goY2hhcnRbQVhJU10sIGZ1bmN0aW9uIChheGlzKSB7IC8vIGxvb3AgdGhyb3VnaCB0aGUgY2hhcnQncyBheGlzIG9iamVjdHNcblx0XHRcdFx0YXhpc09wdGlvbnMgPSBheGlzLm9wdGlvbnM7XG5cblx0XHRcdFx0Ly8gYXBwbHkgaWYgdGhlIHNlcmllcyB4QXhpcyBvciB5QXhpcyBvcHRpb24gbWF0aGNoZXMgdGhlIG51bWJlciBvZiB0aGVcblx0XHRcdFx0Ly8gYXhpcywgb3IgaWYgdW5kZWZpbmVkLCB1c2UgdGhlIGZpcnN0IGF4aXNcblx0XHRcdFx0aWYgKChzZXJpZXNPcHRpb25zW0FYSVNdID09PSBheGlzT3B0aW9ucy5pbmRleCkgfHxcblx0XHRcdFx0XHRcdChzZXJpZXNPcHRpb25zW0FYSVNdICE9PSBVTkRFRklORUQgJiYgc2VyaWVzT3B0aW9uc1tBWElTXSA9PT0gYXhpc09wdGlvbnMuaWQpIHx8XG5cdFx0XHRcdFx0XHQoc2VyaWVzT3B0aW9uc1tBWElTXSA9PT0gVU5ERUZJTkVEICYmIGF4aXNPcHRpb25zLmluZGV4ID09PSAwKSkge1xuXG5cdFx0XHRcdFx0Ly8gcmVnaXN0ZXIgdGhpcyBzZXJpZXMgaW4gdGhlIGF4aXMuc2VyaWVzIGxvb2t1cFxuXHRcdFx0XHRcdGF4aXMuc2VyaWVzLnB1c2goc2VyaWVzKTtcblxuXHRcdFx0XHRcdC8vIHNldCB0aGlzIHNlcmllcy54QXhpcyBvciBzZXJpZXMueUF4aXMgcmVmZXJlbmNlXG5cdFx0XHRcdFx0c2VyaWVzW0FYSVNdID0gYXhpcztcblxuXHRcdFx0XHRcdC8vIG1hcmsgZGlydHkgZm9yIHJlZHJhd1xuXHRcdFx0XHRcdGF4aXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBUaGUgc2VyaWVzIG5lZWRzIGFuIFggYW5kIGFuIFkgYXhpc1xuXHRcdFx0aWYgKCFzZXJpZXNbQVhJU10gJiYgc2VyaWVzLm9wdGlvbmFsQXhpcyAhPT0gQVhJUykge1xuXHRcdFx0XHRlcnJvcigxOCwgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogRm9yIHNpbXBsZSBzZXJpZXMgdHlwZXMgbGlrZSBsaW5lIGFuZCBjb2x1bW4sIHRoZSBkYXRhIHZhbHVlcyBhcmUgaGVsZCBpbiBhcnJheXMgbGlrZVxuXHQgKiB4RGF0YSBhbmQgeURhdGEgZm9yIHF1aWNrIGxvb2t1cCB0byBmaW5kIGV4dHJlbWVzIGFuZCBtb3JlLiBGb3IgbXVsdGlkaW1lbnNpb25hbCBzZXJpZXNcblx0ICogbGlrZSBidWJibGUgYW5kIG1hcCwgdGhpcyBjYW4gYmUgZXh0ZW5kZWQgd2l0aCBhcnJheXMgbGlrZSB6RGF0YSBhbmQgdmFsdWVEYXRhIGJ5XG5cdCAqIGFkZGluZyB0byB0aGUgc2VyaWVzLnBhcmFsbGVsQXJyYXlzIGFycmF5LlxuXHQgKi9cblx0dXBkYXRlUGFyYWxsZWxBcnJheXM6IGZ1bmN0aW9uIChwb2ludCwgaSkge1xuXHRcdHZhciBzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0Zm4gPSB0eXBlb2YgaSA9PT0gJ251bWJlcicgP1xuXHRcdFx0XHQgLy8gSW5zZXJ0IHRoZSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gcG9zaXRpb25cblx0XHRcdFx0ZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBrZXkgPT09ICd5JyAmJiBzZXJpZXMudG9ZRGF0YSA/IHNlcmllcy50b1lEYXRhKHBvaW50KSA6IHBvaW50W2tleV07XG5cdFx0XHRcdFx0c2VyaWVzW2tleSArICdEYXRhJ11baV0gPSB2YWw7XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHQvLyBBcHBseSB0aGUgbWV0aG9kIHNwZWNpZmllZCBpbiBpIHdpdGggdGhlIGZvbGxvd2luZyBhcmd1bWVudHMgYXMgYXJndW1lbnRzXG5cdFx0XHRcdGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRBcnJheS5wcm90b3R5cGVbaV0uYXBwbHkoc2VyaWVzW2tleSArICdEYXRhJ10sIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDIpKTtcblx0XHRcdFx0fTtcblxuXHRcdGVhY2goc2VyaWVzLnBhcmFsbGVsQXJyYXlzLCBmbik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybiBhbiBhdXRvIGluY3JlbWVudGVkIHggdmFsdWUgYmFzZWQgb24gdGhlIHBvaW50U3RhcnQgYW5kIHBvaW50SW50ZXJ2YWwgb3B0aW9ucy5cblx0ICogVGhpcyBpcyBvbmx5IHVzZWQgaWYgYW4geCB2YWx1ZSBpcyBub3QgZ2l2ZW4gZm9yIHRoZSBwb2ludCB0aGF0IGNhbGxzIGF1dG9JbmNyZW1lbnQuXG5cdCAqL1xuXHRhdXRvSW5jcmVtZW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHhJbmNyZW1lbnQgPSB0aGlzLnhJbmNyZW1lbnQsXG5cdFx0XHRkYXRlLFxuXHRcdFx0cG9pbnRJbnRlcnZhbCxcblx0XHRcdHBvaW50SW50ZXJ2YWxVbml0ID0gb3B0aW9ucy5wb2ludEludGVydmFsVW5pdDtcblx0XHRcblx0XHR4SW5jcmVtZW50ID0gcGljayh4SW5jcmVtZW50LCBvcHRpb25zLnBvaW50U3RhcnQsIDApO1xuXHRcdFxuXHRcdHRoaXMucG9pbnRJbnRlcnZhbCA9IHBvaW50SW50ZXJ2YWwgPSBwaWNrKHRoaXMucG9pbnRJbnRlcnZhbCwgb3B0aW9ucy5wb2ludEludGVydmFsLCAxKTtcblx0XHRcblx0XHQvLyBBZGRlZCBjb2RlIGZvciBwb2ludEludGVydmFsIHN0cmluZ3Ncblx0XHRpZiAocG9pbnRJbnRlcnZhbFVuaXQgPT09ICdtb250aCcgfHwgcG9pbnRJbnRlcnZhbFVuaXQgPT09ICd5ZWFyJykge1xuXHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKHhJbmNyZW1lbnQpO1xuXHRcdFx0ZGF0ZSA9IChwb2ludEludGVydmFsVW5pdCA9PT0gJ21vbnRoJykgP1xuXHRcdFx0XHQrZGF0ZVtzZXRNb250aF0oZGF0ZVtnZXRNb250aF0oKSArIHBvaW50SW50ZXJ2YWwpIDpcblx0XHRcdFx0K2RhdGVbc2V0RnVsbFllYXJdKGRhdGVbZ2V0RnVsbFllYXJdKCkgKyBwb2ludEludGVydmFsKTtcblx0XHRcdHBvaW50SW50ZXJ2YWwgPSBkYXRlIC0geEluY3JlbWVudDtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy54SW5jcmVtZW50ID0geEluY3JlbWVudCArIHBvaW50SW50ZXJ2YWw7XG5cdFx0cmV0dXJuIHhJbmNyZW1lbnQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERpdmlkZSB0aGUgc2VyaWVzIGRhdGEgaW50byBzZWdtZW50cyBkaXZpZGVkIGJ5IG51bGwgdmFsdWVzLlxuXHQgKi9cblx0Z2V0U2VnbWVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdGxhc3ROdWxsID0gLTEsXG5cdFx0XHRzZWdtZW50cyA9IFtdLFxuXHRcdFx0aSxcblx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRwb2ludHNMZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKHBvaW50c0xlbmd0aCkgeyAvLyBubyBhY3Rpb24gcmVxdWlyZWQgZm9yIFtdXG5cblx0XHRcdC8vIGlmIGNvbm5lY3QgbnVsbHMsIGp1c3QgcmVtb3ZlIG51bGwgcG9pbnRzXG5cdFx0XHRpZiAoc2VyaWVzLm9wdGlvbnMuY29ubmVjdE51bGxzKSB7XG5cdFx0XHRcdGkgPSBwb2ludHNMZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRpZiAocG9pbnRzW2ldLnkgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHBvaW50cy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0c2VnbWVudHMgPSBbcG9pbnRzXTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBlbHNlLCBzcGxpdCBvbiBudWxsIHBvaW50c1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCwgaSkge1xuXHRcdFx0XHRcdGlmIChwb2ludC55ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRpZiAoaSA+IGxhc3ROdWxsICsgMSkge1xuXHRcdFx0XHRcdFx0XHRzZWdtZW50cy5wdXNoKHBvaW50cy5zbGljZShsYXN0TnVsbCArIDEsIGkpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGxhc3ROdWxsID0gaTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPT09IHBvaW50c0xlbmd0aCAtIDEpIHsgLy8gbGFzdCB2YWx1ZVxuXHRcdFx0XHRcdFx0c2VnbWVudHMucHVzaChwb2ludHMuc2xpY2UobGFzdE51bGwgKyAxLCBpICsgMSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcmVnaXN0ZXIgaXRcblx0XHRzZXJpZXMuc2VnbWVudHMgPSBzZWdtZW50cztcblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSBzZXJpZXMgb3B0aW9ucyBieSBtZXJnaW5nIGZyb20gdGhlIG9wdGlvbnMgdHJlZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbU9wdGlvbnNcblx0ICovXG5cdHNldE9wdGlvbnM6IGZ1bmN0aW9uIChpdGVtT3B0aW9ucykge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRjaGFydE9wdGlvbnMgPSBjaGFydC5vcHRpb25zLFxuXHRcdFx0cGxvdE9wdGlvbnMgPSBjaGFydE9wdGlvbnMucGxvdE9wdGlvbnMsXG5cdFx0XHR1c2VyT3B0aW9ucyA9IGNoYXJ0LnVzZXJPcHRpb25zIHx8IHt9LFxuXHRcdFx0dXNlclBsb3RPcHRpb25zID0gdXNlck9wdGlvbnMucGxvdE9wdGlvbnMgfHwge30sXG5cdFx0XHR0eXBlT3B0aW9ucyA9IHBsb3RPcHRpb25zW3RoaXMudHlwZV0sXG5cdFx0XHRvcHRpb25zLFxuXHRcdFx0em9uZXM7XG5cblx0XHR0aGlzLnVzZXJPcHRpb25zID0gaXRlbU9wdGlvbnM7XG5cblx0XHQvLyBHZW5lcmFsIHNlcmllcyBvcHRpb25zIHRha2UgcHJlY2VkZW5jZSBvdmVyIHR5cGUgb3B0aW9ucyBiZWNhdXNlIG90aGVyd2lzZSwgZGVmYXVsdFxuXHRcdC8vIHR5cGUgb3B0aW9ucyBsaWtlIGNvbHVtbi5hbmltYXRpb24gd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIGdlbmVyYWwgb3B0aW9uLlxuXHRcdC8vIEJ1dCBpc3N1ZXMgaGF2ZSBiZWVuIHJhaXNlZCBoZXJlICgjMzg4MSksIGFuZCB0aGUgc29sdXRpb24gbWF5IGJlIHRvIGRpc3Rpbmd1aXNoIFxuXHRcdC8vIGJldHdlZW4gZGVmYXVsdCBvcHRpb24gYW5kIHVzZXJPcHRpb25zIGxpa2UgaW4gdGhlIHRvb2x0aXAgYmVsb3cuXG5cdFx0b3B0aW9ucyA9IG1lcmdlKFxuXHRcdFx0dHlwZU9wdGlvbnMsXG5cdFx0XHRwbG90T3B0aW9ucy5zZXJpZXMsXG5cdFx0XHRpdGVtT3B0aW9uc1xuXHRcdCk7XG5cblx0XHQvLyBUaGUgdG9vbHRpcCBvcHRpb25zIGFyZSBtZXJnZWQgYmV0d2VlbiBnbG9iYWwgYW5kIHNlcmllcyBzcGVjaWZpYyBvcHRpb25zXG5cdFx0dGhpcy50b29sdGlwT3B0aW9ucyA9IG1lcmdlKFxuXHRcdFx0ZGVmYXVsdE9wdGlvbnMudG9vbHRpcCxcblx0XHRcdGRlZmF1bHRPcHRpb25zLnBsb3RPcHRpb25zW3RoaXMudHlwZV0udG9vbHRpcCxcblx0XHRcdHVzZXJPcHRpb25zLnRvb2x0aXAsXG5cdFx0XHR1c2VyUGxvdE9wdGlvbnMuc2VyaWVzICYmIHVzZXJQbG90T3B0aW9ucy5zZXJpZXMudG9vbHRpcCxcblx0XHRcdHVzZXJQbG90T3B0aW9uc1t0aGlzLnR5cGVdICYmIHVzZXJQbG90T3B0aW9uc1t0aGlzLnR5cGVdLnRvb2x0aXAsXG5cdFx0XHRpdGVtT3B0aW9ucy50b29sdGlwXG5cdFx0KTtcblxuXHRcdC8vIERlbGV0ZSBtYXJrZXIgb2JqZWN0IGlmIG5vdCBhbGxvd2VkICgjMTEyNSlcblx0XHRpZiAodHlwZU9wdGlvbnMubWFya2VyID09PSBudWxsKSB7XG5cdFx0XHRkZWxldGUgb3B0aW9ucy5tYXJrZXI7XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIGNvbG9yIHpvbmVzXG5cdFx0dGhpcy56b25lQXhpcyA9IG9wdGlvbnMuem9uZUF4aXM7XG5cdFx0em9uZXMgPSB0aGlzLnpvbmVzID0gKG9wdGlvbnMuem9uZXMgfHwgW10pLnNsaWNlKCk7XG5cdFx0aWYgKChvcHRpb25zLm5lZ2F0aXZlQ29sb3IgfHwgb3B0aW9ucy5uZWdhdGl2ZUZpbGxDb2xvcikgJiYgIW9wdGlvbnMuem9uZXMpIHtcblx0XHRcdHpvbmVzLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogb3B0aW9uc1t0aGlzLnpvbmVBeGlzICsgJ1RocmVzaG9sZCddIHx8IG9wdGlvbnMudGhyZXNob2xkIHx8IDAsXG5cdFx0XHRcdGNvbG9yOiBvcHRpb25zLm5lZ2F0aXZlQ29sb3IsXG5cdFx0XHRcdGZpbGxDb2xvcjogb3B0aW9ucy5uZWdhdGl2ZUZpbGxDb2xvclxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGlmICh6b25lcy5sZW5ndGgpIHsgLy8gUHVzaCBvbmUgZXh0cmEgem9uZSBmb3IgdGhlIHJlc3Rcblx0XHRcdGlmIChkZWZpbmVkKHpvbmVzW3pvbmVzLmxlbmd0aCAtIDFdLnZhbHVlKSkge1xuXHRcdFx0XHR6b25lcy5wdXNoKHtcblx0XHRcdFx0XHRjb2xvcjogdGhpcy5jb2xvcixcblx0XHRcdFx0XHRmaWxsQ29sb3I6IHRoaXMuZmlsbENvbG9yXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fSxcblxuXHRnZXRDeWNsaWM6IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSwgZGVmYXVsdHMpIHtcblx0XHR2YXIgaSxcblx0XHRcdHVzZXJPcHRpb25zID0gdGhpcy51c2VyT3B0aW9ucyxcblx0XHRcdGluZGV4TmFtZSA9ICdfJyArIHByb3AgKyAnSW5kZXgnLFxuXHRcdFx0Y291bnRlck5hbWUgPSBwcm9wICsgJ0NvdW50ZXInO1xuXG5cdFx0aWYgKCF2YWx1ZSkge1xuXHRcdFx0aWYgKGRlZmluZWQodXNlck9wdGlvbnNbaW5kZXhOYW1lXSkpIHsgLy8gYWZ0ZXIgU2VyaWVzLnVwZGF0ZSgpXG5cdFx0XHRcdGkgPSB1c2VyT3B0aW9uc1tpbmRleE5hbWVdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dXNlck9wdGlvbnNbaW5kZXhOYW1lXSA9IGkgPSB0aGlzLmNoYXJ0W2NvdW50ZXJOYW1lXSAlIGRlZmF1bHRzLmxlbmd0aDtcblx0XHRcdFx0dGhpcy5jaGFydFtjb3VudGVyTmFtZV0gKz0gMTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gZGVmYXVsdHNbaV07XG5cdFx0fVxuXHRcdHRoaXNbcHJvcF0gPSB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBzZXJpZXMnIGNvbG9yXG5cdCAqL1xuXHRnZXRDb2xvcjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuY29sb3JCeVBvaW50KSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuY29sb3IgPSBudWxsOyAvLyAjNDM1OSwgc2VsZWN0ZWQgc2xpY2UgZ290IHNlcmllcy5jb2xvciBldmVuIHdoZW4gY29sb3JCeVBvaW50IHdhcyBzZXQuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZ2V0Q3ljbGljKCdjb2xvcicsIHRoaXMub3B0aW9ucy5jb2xvciB8fCBkZWZhdWx0UGxvdE9wdGlvbnNbdGhpcy50eXBlXS5jb2xvciwgdGhpcy5jaGFydC5vcHRpb25zLmNvbG9ycyk7XG5cdFx0fVxuXHR9LFxuXHQvKipcblx0ICogR2V0IHRoZSBzZXJpZXMnIHN5bWJvbFxuXHQgKi9cblx0Z2V0U3ltYm9sOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllc01hcmtlck9wdGlvbiA9IHRoaXMub3B0aW9ucy5tYXJrZXI7XG5cblx0XHR0aGlzLmdldEN5Y2xpYygnc3ltYm9sJywgc2VyaWVzTWFya2VyT3B0aW9uLnN5bWJvbCwgdGhpcy5jaGFydC5vcHRpb25zLnN5bWJvbHMpO1xuXG5cdFx0Ly8gZG9uJ3Qgc3Vic3RyYWN0IHJhZGl1cyBpbiBpbWFnZSBzeW1ib2xzICgjNjA0KVxuXHRcdGlmICgvXnVybC8udGVzdCh0aGlzLnN5bWJvbCkpIHtcblx0XHRcdHNlcmllc01hcmtlck9wdGlvbi5yYWRpdXMgPSAwO1xuXHRcdH1cblx0fSxcblxuXHRkcmF3TGVnZW5kU3ltYm9sOiBMZWdlbmRTeW1ib2xNaXhpbi5kcmF3TGluZU1hcmtlcixcblxuXHQvKipcblx0ICogUmVwbGFjZSB0aGUgc2VyaWVzIGRhdGEgd2l0aCBhIG5ldyBzZXQgb2YgZGF0YVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmVkcmF3XG5cdCAqL1xuXHRzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSwgcmVkcmF3LCBhbmltYXRpb24sIHVwZGF0ZVBvaW50cykge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0b2xkRGF0YSA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRvbGREYXRhTGVuZ3RoID0gKG9sZERhdGEgJiYgb2xkRGF0YS5sZW5ndGgpIHx8IDAsXG5cdFx0XHRkYXRhTGVuZ3RoLFxuXHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRmaXJzdFBvaW50ID0gbnVsbCxcblx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0aGFzQ2F0ZWdvcmllcyA9IHhBeGlzICYmICEheEF4aXMuY2F0ZWdvcmllcyxcblx0XHRcdGksXG5cdFx0XHR0dXJib1RocmVzaG9sZCA9IG9wdGlvbnMudHVyYm9UaHJlc2hvbGQsXG5cdFx0XHRwdCxcblx0XHRcdHhEYXRhID0gdGhpcy54RGF0YSxcblx0XHRcdHlEYXRhID0gdGhpcy55RGF0YSxcblx0XHRcdHBvaW50QXJyYXlNYXAgPSBzZXJpZXMucG9pbnRBcnJheU1hcCxcblx0XHRcdHZhbHVlQ291bnQgPSBwb2ludEFycmF5TWFwICYmIHBvaW50QXJyYXlNYXAubGVuZ3RoO1xuXG5cdFx0ZGF0YSA9IGRhdGEgfHwgW107XG5cdFx0ZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXHRcdHJlZHJhdyA9IHBpY2socmVkcmF3LCB0cnVlKTtcblxuXHRcdC8vIElmIHRoZSBwb2ludCBjb3VudCBpcyB0aGUgc2FtZSBhcyBpcyB3YXMsIGp1c3QgcnVuIFBvaW50LnVwZGF0ZSB3aGljaCBpc1xuXHRcdC8vIGNoZWFwZXIsIGFsbG93cyBhbmltYXRpb24sIGFuZCBrZWVwcyByZWZlcmVuY2VzIHRvIHBvaW50cy5cblx0XHRpZiAodXBkYXRlUG9pbnRzICE9PSBmYWxzZSAmJiBkYXRhTGVuZ3RoICYmIG9sZERhdGFMZW5ndGggPT09IGRhdGFMZW5ndGggJiYgIXNlcmllcy5jcm9wcGVkICYmICFzZXJpZXMuaGFzR3JvdXBlZERhdGEgJiYgc2VyaWVzLnZpc2libGUpIHtcblx0XHRcdGVhY2goZGF0YSwgZnVuY3Rpb24gKHBvaW50LCBpKSB7XG5cdFx0XHRcdGlmIChvbGREYXRhW2ldLnVwZGF0ZSkgeyAvLyBMaW5rZWQsIHByZXZpb3VzbHkgaGlkZGVuIHNlcmllcyAoIzM3MDkpXG5cdFx0XHRcdFx0b2xkRGF0YVtpXS51cGRhdGUocG9pbnQsIGZhbHNlLCBudWxsLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gUmVzZXQgcHJvcGVydGllc1xuXHRcdFx0c2VyaWVzLnhJbmNyZW1lbnQgPSBudWxsO1xuXHRcdFx0c2VyaWVzLnBvaW50UmFuZ2UgPSBoYXNDYXRlZ29yaWVzID8gMSA6IG9wdGlvbnMucG9pbnRSYW5nZTtcblxuXHRcdFx0c2VyaWVzLmNvbG9yQ291bnRlciA9IDA7IC8vIGZvciBzZXJpZXMgd2l0aCBjb2xvckJ5UG9pbnQgKCMxNTQ3KVxuXHRcdFx0XG5cdFx0XHQvLyBVcGRhdGUgcGFyYWxsZWwgYXJyYXlzXG5cdFx0XHRlYWNoKHRoaXMucGFyYWxsZWxBcnJheXMsIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0c2VyaWVzW2tleSArICdEYXRhJ10ubGVuZ3RoID0gMDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJbiB0dXJibyBtb2RlLCBvbmx5IG9uZS0gb3IgdHdvZGltZW5zaW9uYWwgYXJyYXlzIG9mIG51bWJlcnMgYXJlIGFsbG93ZWQuIFRoZVxuXHRcdFx0Ly8gZmlyc3QgdmFsdWUgaXMgdGVzdGVkLCBhbmQgd2UgYXNzdW1lIHRoYXQgYWxsIHRoZSByZXN0IGFyZSBkZWZpbmVkIHRoZSBzYW1lXG5cdFx0XHQvLyB3YXkuIEFsdGhvdWdoIHRoZSAnZm9yJyBsb29wcyBhcmUgc2ltaWxhciwgdGhleSBhcmUgcmVwZWF0ZWQgaW5zaWRlIGVhY2hcblx0XHRcdC8vIGlmLWVsc2UgY29uZGl0aW9uYWwgZm9yIG1heCBwZXJmb3JtYW5jZS5cblx0XHRcdGlmICh0dXJib1RocmVzaG9sZCAmJiBkYXRhTGVuZ3RoID4gdHVyYm9UaHJlc2hvbGQpIHtcblxuXHRcdFx0XHQvLyBmaW5kIHRoZSBmaXJzdCBub24tbnVsbCBwb2ludFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0d2hpbGUgKGZpcnN0UG9pbnQgPT09IG51bGwgJiYgaSA8IGRhdGFMZW5ndGgpIHtcblx0XHRcdFx0XHRmaXJzdFBvaW50ID0gZGF0YVtpXTtcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGlmIChpc051bWJlcihmaXJzdFBvaW50KSkgeyAvLyBhc3N1bWUgYWxsIHBvaW50cyBhcmUgbnVtYmVyc1xuXHRcdFx0XHRcdHZhciB4ID0gcGljayhvcHRpb25zLnBvaW50U3RhcnQsIDApLFxuXHRcdFx0XHRcdFx0cG9pbnRJbnRlcnZhbCA9IHBpY2sob3B0aW9ucy5wb2ludEludGVydmFsLCAxKTtcblxuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHhEYXRhW2ldID0geDtcblx0XHRcdFx0XHRcdHlEYXRhW2ldID0gZGF0YVtpXTtcblx0XHRcdFx0XHRcdHggKz0gcG9pbnRJbnRlcnZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VyaWVzLnhJbmNyZW1lbnQgPSB4O1xuXHRcdFx0XHR9IGVsc2UgaWYgKGlzQXJyYXkoZmlyc3RQb2ludCkpIHsgLy8gYXNzdW1lIGFsbCBwb2ludHMgYXJlIGFycmF5c1xuXHRcdFx0XHRcdGlmICh2YWx1ZUNvdW50KSB7IC8vIFt4LCBsb3csIGhpZ2hdIG9yIFt4LCBvLCBoLCBsLCBjXVxuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRwdCA9IGRhdGFbaV07XG5cdFx0XHRcdFx0XHRcdHhEYXRhW2ldID0gcHRbMF07XG5cdFx0XHRcdFx0XHRcdHlEYXRhW2ldID0gcHQuc2xpY2UoMSwgdmFsdWVDb3VudCArIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7IC8vIFt4LCB5XVxuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRwdCA9IGRhdGFbaV07XG5cdFx0XHRcdFx0XHRcdHhEYXRhW2ldID0gcHRbMF07XG5cdFx0XHRcdFx0XHRcdHlEYXRhW2ldID0gcHRbMV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVycm9yKDEyKTsgLy8gSGlnaGNoYXJ0cyBleHBlY3RzIGNvbmZpZ3MgdG8gYmUgbnVtYmVycyBvciBhcnJheXMgaW4gdHVyYm8gbW9kZVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGRhdGFbaV0gIT09IFVOREVGSU5FRCkgeyAvLyBzdHJheSBjb21tYXMgaW4gb2xkSUVcblx0XHRcdFx0XHRcdHB0ID0geyBzZXJpZXM6IHNlcmllcyB9O1xuXHRcdFx0XHRcdFx0c2VyaWVzLnBvaW50Q2xhc3MucHJvdG90eXBlLmFwcGx5T3B0aW9ucy5hcHBseShwdCwgW2RhdGFbaV1dKTtcblx0XHRcdFx0XHRcdHNlcmllcy51cGRhdGVQYXJhbGxlbEFycmF5cyhwdCwgaSk7XG5cdFx0XHRcdFx0XHRpZiAoaGFzQ2F0ZWdvcmllcyAmJiBkZWZpbmVkKHB0Lm5hbWUpKSB7IC8vICM0NDAxXG5cdFx0XHRcdFx0XHRcdHhBeGlzLm5hbWVzW3B0LnhdID0gcHQubmFtZTsgLy8gIzIwNDZcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0dGluZyB0byBjYXN0IHN0cmluZ3MgdG8gbnVtYmVycyBpcyBhIGNvbW1vbiBjYXZlYXQgd2hlbiBoYW5kbGluZyBDU1Ygb3IgSlNPTlxuXHRcdFx0aWYgKGlzU3RyaW5nKHlEYXRhWzBdKSkge1xuXHRcdFx0XHRlcnJvcigxNCwgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHNlcmllcy5kYXRhID0gW107XG5cdFx0XHRzZXJpZXMub3B0aW9ucy5kYXRhID0gZGF0YTtcblx0XHRcdC8vc2VyaWVzLnpEYXRhID0gekRhdGE7XG5cblx0XHRcdC8vIGRlc3Ryb3kgb2xkIHBvaW50c1xuXHRcdFx0aSA9IG9sZERhdGFMZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdGlmIChvbGREYXRhW2ldICYmIG9sZERhdGFbaV0uZGVzdHJveSkge1xuXHRcdFx0XHRcdG9sZERhdGFbaV0uZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlc2V0IG1pblJhbmdlICgjODc4KVxuXHRcdFx0aWYgKHhBeGlzKSB7XG5cdFx0XHRcdHhBeGlzLm1pblJhbmdlID0geEF4aXMudXNlck1pblJhbmdlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWRyYXdcblx0XHRcdHNlcmllcy5pc0RpcnR5ID0gc2VyaWVzLmlzRGlydHlEYXRhID0gY2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cdFx0XHRhbmltYXRpb24gPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBUeXBpY2FsbHkgZm9yIHBpZSBzZXJpZXMsIHBvaW50cyBuZWVkIHRvIGJlIHByb2Nlc3NlZCBhbmQgZ2VuZXJhdGVkIFxuXHRcdC8vIHByaW9yIHRvIHJlbmRlcmluZyB0aGUgbGVnZW5kXG5cdFx0aWYgKG9wdGlvbnMubGVnZW5kVHlwZSA9PT0gJ3BvaW50JykgeyAvLyBkb2NzOiBsZWdlbmRUeXBlIG5vdyBzdXBwb3J0ZWQgb24gbW9yZSBzZXJpZXMgdHlwZXMgKGF0IGxlYXN0IGNvbHVtbiBhbmQgcGllKVxuXHRcdFx0dGhpcy5wcm9jZXNzRGF0YSgpO1xuXHRcdFx0dGhpcy5nZW5lcmF0ZVBvaW50cygpO1xuXHRcdH1cblxuXHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdGNoYXJ0LnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUHJvY2VzcyB0aGUgZGF0YSBieSBjcm9wcGluZyBhd2F5IHVudXNlZCBkYXRhIHBvaW50cyBpZiB0aGUgc2VyaWVzIGlzIGxvbmdlclxuXHQgKiB0aGFuIHRoZSBjcm9wIHRocmVzaG9sZC4gVGhpcyBzYXZlcyBjb21wdXRpbmcgdGltZSBmb3IgbGFnZSBzZXJpZXMuXG5cdCAqL1xuXHRwcm9jZXNzRGF0YTogZnVuY3Rpb24gKGZvcmNlKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRwcm9jZXNzZWRYRGF0YSA9IHNlcmllcy54RGF0YSwgLy8gY29waWVkIGR1cmluZyBzbGljZSBvcGVyYXRpb24gYmVsb3dcblx0XHRcdHByb2Nlc3NlZFlEYXRhID0gc2VyaWVzLnlEYXRhLFxuXHRcdFx0ZGF0YUxlbmd0aCA9IHByb2Nlc3NlZFhEYXRhLmxlbmd0aCxcblx0XHRcdGNyb3BwZWREYXRhLFxuXHRcdFx0Y3JvcFN0YXJ0ID0gMCxcblx0XHRcdGNyb3BwZWQsXG5cdFx0XHRkaXN0YW5jZSxcblx0XHRcdGNsb3Nlc3RQb2ludFJhbmdlLFxuXHRcdFx0eEF4aXMgPSBzZXJpZXMueEF4aXMsXG5cdFx0XHRpLCAvLyBsb29wIHZhcmlhYmxlXG5cdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRjcm9wVGhyZXNob2xkID0gb3B0aW9ucy5jcm9wVGhyZXNob2xkLFxuXHRcdFx0Z2V0RXh0cmVtZXNGcm9tQWxsID0gc2VyaWVzLmdldEV4dHJlbWVzRnJvbUFsbCB8fCBvcHRpb25zLmdldEV4dHJlbWVzRnJvbUFsbCwgLy8gIzQ1OTlcblx0XHRcdGlzQ2FydGVzaWFuID0gc2VyaWVzLmlzQ2FydGVzaWFuLFxuXHRcdFx0eEV4dHJlbWVzLFxuXHRcdFx0bWluLFxuXHRcdFx0bWF4O1xuXG5cdFx0Ly8gSWYgdGhlIHNlcmllcyBkYXRhIG9yIGF4ZXMgaGF2ZW4ndCBjaGFuZ2VkLCBkb24ndCBnbyB0aHJvdWdoIHRoaXMuIFJldHVybiBmYWxzZSB0byBwYXNzXG5cdFx0Ly8gdGhlIG1lc3NhZ2Ugb24gdG8gb3ZlcnJpZGUgbWV0aG9kcyBsaWtlIGluIGRhdGEgZ3JvdXBpbmcuXG5cdFx0aWYgKGlzQ2FydGVzaWFuICYmICFzZXJpZXMuaXNEaXJ0eSAmJiAheEF4aXMuaXNEaXJ0eSAmJiAhc2VyaWVzLnlBeGlzLmlzRGlydHkgJiYgIWZvcmNlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKHhBeGlzKSB7XG5cdFx0XHR4RXh0cmVtZXMgPSB4QXhpcy5nZXRFeHRyZW1lcygpOyAvLyBjb3JyZWN0ZWQgZm9yIGxvZyBheGlzICgjMzA1Mylcblx0XHRcdG1pbiA9IHhFeHRyZW1lcy5taW47XG5cdFx0XHRtYXggPSB4RXh0cmVtZXMubWF4O1xuXHRcdH1cblxuXHRcdC8vIG9wdGlvbmFsbHkgZmlsdGVyIG91dCBwb2ludHMgb3V0c2lkZSB0aGUgcGxvdCBhcmVhXG5cdFx0aWYgKGlzQ2FydGVzaWFuICYmIHNlcmllcy5zb3J0ZWQgJiYgIWdldEV4dHJlbWVzRnJvbUFsbCAmJiAoIWNyb3BUaHJlc2hvbGQgfHwgZGF0YUxlbmd0aCA+IGNyb3BUaHJlc2hvbGQgfHwgc2VyaWVzLmZvcmNlQ3JvcCkpIHtcblx0XHRcdFxuXHRcdFx0Ly8gaXQncyBvdXRzaWRlIGN1cnJlbnQgZXh0cmVtZXNcblx0XHRcdGlmIChwcm9jZXNzZWRYRGF0YVtkYXRhTGVuZ3RoIC0gMV0gPCBtaW4gfHwgcHJvY2Vzc2VkWERhdGFbMF0gPiBtYXgpIHtcblx0XHRcdFx0cHJvY2Vzc2VkWERhdGEgPSBbXTtcblx0XHRcdFx0cHJvY2Vzc2VkWURhdGEgPSBbXTtcblxuXHRcdFx0Ly8gb25seSBjcm9wIGlmIGl0J3MgYWN0dWFsbHkgc3BpbGxpbmcgb3V0XG5cdFx0XHR9IGVsc2UgaWYgKHByb2Nlc3NlZFhEYXRhWzBdIDwgbWluIHx8IHByb2Nlc3NlZFhEYXRhW2RhdGFMZW5ndGggLSAxXSA+IG1heCkge1xuXHRcdFx0XHRjcm9wcGVkRGF0YSA9IHRoaXMuY3JvcERhdGEoc2VyaWVzLnhEYXRhLCBzZXJpZXMueURhdGEsIG1pbiwgbWF4KTtcblx0XHRcdFx0cHJvY2Vzc2VkWERhdGEgPSBjcm9wcGVkRGF0YS54RGF0YTtcblx0XHRcdFx0cHJvY2Vzc2VkWURhdGEgPSBjcm9wcGVkRGF0YS55RGF0YTtcblx0XHRcdFx0Y3JvcFN0YXJ0ID0gY3JvcHBlZERhdGEuc3RhcnQ7XG5cdFx0XHRcdGNyb3BwZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0Ly8gRmluZCB0aGUgY2xvc2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHByb2Nlc3NlZCBwb2ludHNcblx0XHRmb3IgKGkgPSBwcm9jZXNzZWRYRGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0ZGlzdGFuY2UgPSBwcm9jZXNzZWRYRGF0YVtpXSAtIHByb2Nlc3NlZFhEYXRhW2kgLSAxXTtcblx0XHRcdFxuXHRcdFx0aWYgKGRpc3RhbmNlID4gMCAmJiAoY2xvc2VzdFBvaW50UmFuZ2UgPT09IFVOREVGSU5FRCB8fCBkaXN0YW5jZSA8IGNsb3Nlc3RQb2ludFJhbmdlKSkge1xuXHRcdFx0XHRjbG9zZXN0UG9pbnRSYW5nZSA9IGRpc3RhbmNlO1xuXG5cdFx0XHQvLyBVbnNvcnRlZCBkYXRhIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGxpbmUgdG9vbHRpcCwgYXMgd2VsbCBhcyBkYXRhIGdyb3VwaW5nIGFuZFxuXHRcdFx0Ly8gbmF2aWdhdGlvbiBpbiBTdG9jayBjaGFydHMgKCM3MjUpIGFuZCB3aWR0aCBjYWxjdWxhdGlvbiBvZiBjb2x1bW5zICgjMTkwMClcblx0XHRcdH0gZWxzZSBpZiAoZGlzdGFuY2UgPCAwICYmIHNlcmllcy5yZXF1aXJlU29ydGluZykge1xuXHRcdFx0XHRlcnJvcigxNSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVjb3JkIHRoZSBwcm9wZXJ0aWVzXG5cdFx0c2VyaWVzLmNyb3BwZWQgPSBjcm9wcGVkOyAvLyB1bmRlZmluZWQgb3IgdHJ1ZVxuXHRcdHNlcmllcy5jcm9wU3RhcnQgPSBjcm9wU3RhcnQ7XG5cdFx0c2VyaWVzLnByb2Nlc3NlZFhEYXRhID0gcHJvY2Vzc2VkWERhdGE7XG5cdFx0c2VyaWVzLnByb2Nlc3NlZFlEYXRhID0gcHJvY2Vzc2VkWURhdGE7XG5cblx0XHRpZiAob3B0aW9ucy5wb2ludFJhbmdlID09PSBudWxsKSB7IC8vIG51bGwgbWVhbnMgYXV0bywgYXMgZm9yIGNvbHVtbnMsIGNhbmRsZXN0aWNrcyBhbmQgT0hMQ1xuXHRcdFx0c2VyaWVzLnBvaW50UmFuZ2UgPSBjbG9zZXN0UG9pbnRSYW5nZSB8fCAxO1xuXHRcdH1cblx0XHRzZXJpZXMuY2xvc2VzdFBvaW50UmFuZ2UgPSBjbG9zZXN0UG9pbnRSYW5nZTtcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBJdGVyYXRlIG92ZXIgeERhdGEgYW5kIGNyb3AgdmFsdWVzIGJldHdlZW4gbWluIGFuZCBtYXguIFJldHVybnMgb2JqZWN0IGNvbnRhaW5pbmcgY3JvcCBzdGFydC9lbmRcblx0ICogY3JvcHBlZCB4RGF0YSB3aXRoIGNvcnJlc3BvbmRpbmcgcGFydCBvZiB5RGF0YSwgZGF0YU1pbiBhbmQgZGF0YU1heCB3aXRoaW4gdGhlIGNyb3BwZWQgcmFuZ2Vcblx0ICovXG5cdGNyb3BEYXRhOiBmdW5jdGlvbiAoeERhdGEsIHlEYXRhLCBtaW4sIG1heCkge1xuXHRcdHZhciBkYXRhTGVuZ3RoID0geERhdGEubGVuZ3RoLFxuXHRcdFx0Y3JvcFN0YXJ0ID0gMCxcblx0XHRcdGNyb3BFbmQgPSBkYXRhTGVuZ3RoLFxuXHRcdFx0Y3JvcFNob3VsZGVyID0gcGljayh0aGlzLmNyb3BTaG91bGRlciwgMSksIC8vIGxpbmUtdHlwZSBzZXJpZXMgbmVlZCBvbmUgcG9pbnQgb3V0c2lkZVxuXHRcdFx0aTtcblxuXHRcdC8vIGl0ZXJhdGUgdXAgdG8gZmluZCBzbGljZSBzdGFydFxuXHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh4RGF0YVtpXSA+PSBtaW4pIHtcblx0XHRcdFx0Y3JvcFN0YXJ0ID0gbWF0aE1heCgwLCBpIC0gY3JvcFNob3VsZGVyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcHJvY2VlZCB0byBmaW5kIHNsaWNlIGVuZFxuXHRcdGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoeERhdGFbaV0gPiBtYXgpIHtcblx0XHRcdFx0Y3JvcEVuZCA9IGkgKyBjcm9wU2hvdWxkZXI7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR4RGF0YTogeERhdGEuc2xpY2UoY3JvcFN0YXJ0LCBjcm9wRW5kKSxcblx0XHRcdHlEYXRhOiB5RGF0YS5zbGljZShjcm9wU3RhcnQsIGNyb3BFbmQpLFxuXHRcdFx0c3RhcnQ6IGNyb3BTdGFydCxcblx0XHRcdGVuZDogY3JvcEVuZFxuXHRcdH07XG5cdH0sXG5cblxuXHQvKipcblx0ICogR2VuZXJhdGUgdGhlIGRhdGEgcG9pbnQgYWZ0ZXIgdGhlIGRhdGEgaGFzIGJlZW4gcHJvY2Vzc2VkIGJ5IGNyb3BwaW5nIGF3YXlcblx0ICogdW51c2VkIHBvaW50cyBhbmQgb3B0aW9uYWxseSBncm91cGVkIGluIEhpZ2hjaGFydHMgU3RvY2suXG5cdCAqL1xuXHRnZW5lcmF0ZVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0ZGF0YU9wdGlvbnMgPSBvcHRpb25zLmRhdGEsXG5cdFx0XHRkYXRhID0gc2VyaWVzLmRhdGEsXG5cdFx0XHRkYXRhTGVuZ3RoLFxuXHRcdFx0cHJvY2Vzc2VkWERhdGEgPSBzZXJpZXMucHJvY2Vzc2VkWERhdGEsXG5cdFx0XHRwcm9jZXNzZWRZRGF0YSA9IHNlcmllcy5wcm9jZXNzZWRZRGF0YSxcblx0XHRcdHBvaW50Q2xhc3MgPSBzZXJpZXMucG9pbnRDbGFzcyxcblx0XHRcdHByb2Nlc3NlZERhdGFMZW5ndGggPSBwcm9jZXNzZWRYRGF0YS5sZW5ndGgsXG5cdFx0XHRjcm9wU3RhcnQgPSBzZXJpZXMuY3JvcFN0YXJ0IHx8IDAsXG5cdFx0XHRjdXJzb3IsXG5cdFx0XHRoYXNHcm91cGVkRGF0YSA9IHNlcmllcy5oYXNHcm91cGVkRGF0YSxcblx0XHRcdHBvaW50LFxuXHRcdFx0cG9pbnRzID0gW10sXG5cdFx0XHRpO1xuXG5cdFx0aWYgKCFkYXRhICYmICFoYXNHcm91cGVkRGF0YSkge1xuXHRcdFx0dmFyIGFyciA9IFtdO1xuXHRcdFx0YXJyLmxlbmd0aCA9IGRhdGFPcHRpb25zLmxlbmd0aDtcblx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSA9IGFycjtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgcHJvY2Vzc2VkRGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjdXJzb3IgPSBjcm9wU3RhcnQgKyBpO1xuXHRcdFx0aWYgKCFoYXNHcm91cGVkRGF0YSkge1xuXHRcdFx0XHRpZiAoZGF0YVtjdXJzb3JdKSB7XG5cdFx0XHRcdFx0cG9pbnQgPSBkYXRhW2N1cnNvcl07XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGF0YU9wdGlvbnNbY3Vyc29yXSAhPT0gVU5ERUZJTkVEKSB7IC8vICM5NzBcblx0XHRcdFx0XHRkYXRhW2N1cnNvcl0gPSBwb2ludCA9IChuZXcgcG9pbnRDbGFzcygpKS5pbml0KHNlcmllcywgZGF0YU9wdGlvbnNbY3Vyc29yXSwgcHJvY2Vzc2VkWERhdGFbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBvaW50c1tpXSA9IHBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gc3BsYXQgdGhlIHkgZGF0YSBpbiBjYXNlIG9mIG9obGMgZGF0YSBhcnJheVxuXHRcdFx0XHRwb2ludHNbaV0gPSAobmV3IHBvaW50Q2xhc3MoKSkuaW5pdChzZXJpZXMsIFtwcm9jZXNzZWRYRGF0YVtpXV0uY29uY2F0KHNwbGF0KHByb2Nlc3NlZFlEYXRhW2ldKSkpO1xuXHRcdFx0fVxuXHRcdFx0cG9pbnRzW2ldLmluZGV4ID0gY3Vyc29yOyAvLyBGb3IgZmFzdGVyIGFjY2VzcyBpbiBQb2ludC51cGRhdGVcblx0XHR9XG5cblx0XHQvLyBIaWRlIGNyb3BwZWQtYXdheSBwb2ludHMgLSB0aGlzIG9ubHkgcnVucyB3aGVuIHRoZSBudW1iZXIgb2YgcG9pbnRzIGlzIGFib3ZlIGNyb3BUaHJlc2hvbGQsIG9yIHdoZW5cblx0XHQvLyBzd2l0aGNoaW5nIHZpZXcgZnJvbSBub24tZ3JvdXBlZCBkYXRhIHRvIGdyb3VwZWQgZGF0YSAoIzYzNylcblx0XHRpZiAoZGF0YSAmJiAocHJvY2Vzc2VkRGF0YUxlbmd0aCAhPT0gKGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCkgfHwgaGFzR3JvdXBlZERhdGEpKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChpID09PSBjcm9wU3RhcnQgJiYgIWhhc0dyb3VwZWREYXRhKSB7IC8vIHdoZW4gaGFzIGdyb3VwZWQgZGF0YSwgY2xlYXIgYWxsIHBvaW50c1xuXHRcdFx0XHRcdGkgKz0gcHJvY2Vzc2VkRGF0YUxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZGF0YVtpXSkge1xuXHRcdFx0XHRcdGRhdGFbaV0uZGVzdHJveUVsZW1lbnRzKCk7XG5cdFx0XHRcdFx0ZGF0YVtpXS5wbG90WCA9IFVOREVGSU5FRDsgLy8gIzEwMDNcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlcmllcy5kYXRhID0gZGF0YTtcblx0XHRzZXJpZXMucG9pbnRzID0gcG9pbnRzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgWSBleHRyZW1lcyBmb3IgdmlzaWJsZSBkYXRhXG5cdCAqL1xuXHRnZXRFeHRyZW1lczogZnVuY3Rpb24gKHlEYXRhKSB7XG5cdFx0dmFyIHhBeGlzID0gdGhpcy54QXhpcyxcblx0XHRcdHlBeGlzID0gdGhpcy55QXhpcyxcblx0XHRcdHhEYXRhID0gdGhpcy5wcm9jZXNzZWRYRGF0YSxcblx0XHRcdHlEYXRhTGVuZ3RoLFxuXHRcdFx0YWN0aXZlWURhdGEgPSBbXSxcblx0XHRcdGFjdGl2ZUNvdW50ZXIgPSAwLFxuXHRcdFx0eEV4dHJlbWVzID0geEF4aXMuZ2V0RXh0cmVtZXMoKSwgLy8gIzIxMTcsIG5lZWQgdG8gY29tcGVuc2F0ZSBmb3IgbG9nIFggYXhpc1xuXHRcdFx0eE1pbiA9IHhFeHRyZW1lcy5taW4sXG5cdFx0XHR4TWF4ID0geEV4dHJlbWVzLm1heCxcblx0XHRcdHZhbGlkVmFsdWUsXG5cdFx0XHR3aXRoaW5SYW5nZSxcblx0XHRcdHgsXG5cdFx0XHR5LFxuXHRcdFx0aSxcblx0XHRcdGo7XG5cblx0XHR5RGF0YSA9IHlEYXRhIHx8IHRoaXMuc3RhY2tlZFlEYXRhIHx8IHRoaXMucHJvY2Vzc2VkWURhdGE7XG5cdFx0eURhdGFMZW5ndGggPSB5RGF0YS5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgeURhdGFMZW5ndGg7IGkrKykge1xuXG5cdFx0XHR4ID0geERhdGFbaV07XG5cdFx0XHR5ID0geURhdGFbaV07XG5cblx0XHRcdC8vIEZvciBwb2ludHMgd2l0aGluIHRoZSB2aXNpYmxlIHJhbmdlLCBpbmNsdWRpbmcgdGhlIGZpcnN0IHBvaW50IG91dHNpZGUgdGhlXG5cdFx0XHQvLyB2aXNpYmxlIHJhbmdlLCBjb25zaWRlciB5IGV4dHJlbWVzXG5cdFx0XHR2YWxpZFZhbHVlID0geSAhPT0gbnVsbCAmJiB5ICE9PSBVTkRFRklORUQgJiYgKCF5QXhpcy5pc0xvZyB8fCAoeS5sZW5ndGggfHwgeSA+IDApKTtcblx0XHRcdHdpdGhpblJhbmdlID0gdGhpcy5nZXRFeHRyZW1lc0Zyb21BbGwgfHwgdGhpcy5vcHRpb25zLmdldEV4dHJlbWVzRnJvbUFsbCB8fCB0aGlzLmNyb3BwZWQgfHxcblx0XHRcdFx0KCh4RGF0YVtpICsgMV0gfHwgeCkgPj0geE1pbiAmJlx0KHhEYXRhW2kgLSAxXSB8fCB4KSA8PSB4TWF4KTtcblxuXHRcdFx0aWYgKHZhbGlkVmFsdWUgJiYgd2l0aGluUmFuZ2UpIHtcblxuXHRcdFx0XHRqID0geS5sZW5ndGg7XG5cdFx0XHRcdGlmIChqKSB7IC8vIGFycmF5LCBsaWtlIG9obGMgb3IgcmFuZ2UgZGF0YVxuXHRcdFx0XHRcdHdoaWxlIChqLS0pIHtcblx0XHRcdFx0XHRcdGlmICh5W2pdICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGFjdGl2ZVlEYXRhW2FjdGl2ZUNvdW50ZXIrK10gPSB5W2pdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhY3RpdmVZRGF0YVthY3RpdmVDb3VudGVyKytdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmRhdGFNaW4gPSBhcnJheU1pbihhY3RpdmVZRGF0YSk7XG5cdFx0dGhpcy5kYXRhTWF4ID0gYXJyYXlNYXgoYWN0aXZlWURhdGEpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUcmFuc2xhdGUgZGF0YSBwb2ludHMgZnJvbSByYXcgZGF0YSB2YWx1ZXMgdG8gY2hhcnQgc3BlY2lmaWMgcG9zaXRpb25pbmcgZGF0YVxuXHQgKiBuZWVkZWQgbGF0ZXIgaW4gZHJhd1BvaW50cywgZHJhd0dyYXBoIGFuZCBkcmF3VHJhY2tlci5cblx0ICovXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5wcm9jZXNzZWRYRGF0YSkgeyAvLyBoaWRkZW4gc2VyaWVzXG5cdFx0XHR0aGlzLnByb2Nlc3NEYXRhKCk7XG5cdFx0fVxuXHRcdHRoaXMuZ2VuZXJhdGVQb2ludHMoKTtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdHN0YWNraW5nID0gb3B0aW9ucy5zdGFja2luZyxcblx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0Y2F0ZWdvcmllcyA9IHhBeGlzLmNhdGVnb3JpZXMsXG5cdFx0XHR5QXhpcyA9IHNlcmllcy55QXhpcyxcblx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRkYXRhTGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdGhhc01vZGlmeVZhbHVlID0gISFzZXJpZXMubW9kaWZ5VmFsdWUsXG5cdFx0XHRpLFxuXHRcdFx0cG9pbnRQbGFjZW1lbnQgPSBvcHRpb25zLnBvaW50UGxhY2VtZW50LFxuXHRcdFx0ZHluYW1pY2FsbHlQbGFjZWQgPSBwb2ludFBsYWNlbWVudCA9PT0gJ2JldHdlZW4nIHx8IGlzTnVtYmVyKHBvaW50UGxhY2VtZW50KSxcblx0XHRcdHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkLFxuXHRcdFx0c3RhY2tUaHJlc2hvbGQgPSBvcHRpb25zLnN0YXJ0RnJvbVRocmVzaG9sZCA/IHRocmVzaG9sZCA6IDAsXG5cdFx0XHRwbG90WCxcblx0XHRcdHBsb3RZLFxuXHRcdFx0bGFzdFBsb3RYLFxuXHRcdFx0c3RhY2tJbmRpY2F0b3IsXG5cdFx0XHRjbG9zZXN0UG9pbnRSYW5nZVB4ID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuXHRcdC8vIFRyYW5zbGF0ZSBlYWNoIHBvaW50XG5cdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHBvaW50ID0gcG9pbnRzW2ldLFxuXHRcdFx0XHR4VmFsdWUgPSBwb2ludC54LFxuXHRcdFx0XHR5VmFsdWUgPSBwb2ludC55LFxuXHRcdFx0XHR5Qm90dG9tID0gcG9pbnQubG93LFxuXHRcdFx0XHRzdGFjayA9IHN0YWNraW5nICYmIHlBeGlzLnN0YWNrc1soc2VyaWVzLm5lZ1N0YWNrcyAmJiB5VmFsdWUgPCAoc3RhY2tUaHJlc2hvbGQgPyAwIDogdGhyZXNob2xkKSA/ICctJyA6ICcnKSArIHNlcmllcy5zdGFja0tleV0sXG5cdFx0XHRcdHBvaW50U3RhY2ssXG5cdFx0XHRcdHN0YWNrVmFsdWVzO1xuXG5cdFx0XHQvLyBEaXNjYXJkIGRpc2FsbG93ZWQgeSB2YWx1ZXMgZm9yIGxvZyBheGVzICgjMzQzNClcblx0XHRcdGlmICh5QXhpcy5pc0xvZyAmJiB5VmFsdWUgIT09IG51bGwgJiYgeVZhbHVlIDw9IDApIHtcblx0XHRcdFx0cG9pbnQueSA9IHlWYWx1ZSA9IG51bGw7XG5cdFx0XHRcdGVycm9yKDEwKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IHRoZSBwbG90WCB0cmFuc2xhdGlvblxuXHRcdFx0cG9pbnQucGxvdFggPSBwbG90WCA9IG1hdGhNaW4obWF0aE1heCgtMWU1LCB4QXhpcy50cmFuc2xhdGUoeFZhbHVlLCAwLCAwLCAwLCAxLCBwb2ludFBsYWNlbWVudCwgdGhpcy50eXBlID09PSAnZmxhZ3MnKSksIDFlNSk7IC8vICMzOTIzXG5cblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBib3R0b20geSB2YWx1ZSBmb3Igc3RhY2tlZCBzZXJpZXNcblx0XHRcdGlmIChzdGFja2luZyAmJiBzZXJpZXMudmlzaWJsZSAmJiBzdGFjayAmJiBzdGFja1t4VmFsdWVdKSB7XG5cdFx0XHRcdHN0YWNrSW5kaWNhdG9yID0gc2VyaWVzLmdldFN0YWNrSW5kaWNhdG9yKHN0YWNrSW5kaWNhdG9yLCB4VmFsdWUsIHNlcmllcy5pbmRleCk7XG5cdFx0XHRcdHBvaW50U3RhY2sgPSBzdGFja1t4VmFsdWVdO1xuXHRcdFx0XHRzdGFja1ZhbHVlcyA9IHBvaW50U3RhY2sucG9pbnRzW3N0YWNrSW5kaWNhdG9yLmtleV07XG5cdFx0XHRcdHlCb3R0b20gPSBzdGFja1ZhbHVlc1swXTtcblx0XHRcdFx0eVZhbHVlID0gc3RhY2tWYWx1ZXNbMV07XG5cblx0XHRcdFx0aWYgKHlCb3R0b20gPT09IHN0YWNrVGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0eUJvdHRvbSA9IHBpY2sodGhyZXNob2xkLCB5QXhpcy5taW4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh5QXhpcy5pc0xvZyAmJiB5Qm90dG9tIDw9IDApIHsgLy8gIzEyMDAsICMxMjMyXG5cdFx0XHRcdFx0eUJvdHRvbSA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwb2ludC50b3RhbCA9IHBvaW50LnN0YWNrVG90YWwgPSBwb2ludFN0YWNrLnRvdGFsO1xuXHRcdFx0XHRwb2ludC5wZXJjZW50YWdlID0gcG9pbnRTdGFjay50b3RhbCAmJiAocG9pbnQueSAvIHBvaW50U3RhY2sudG90YWwgKiAxMDApO1xuXHRcdFx0XHRwb2ludC5zdGFja1kgPSB5VmFsdWU7XG5cblx0XHRcdFx0Ly8gUGxhY2UgdGhlIHN0YWNrIGxhYmVsXG5cdFx0XHRcdHBvaW50U3RhY2suc2V0T2Zmc2V0KHNlcmllcy5wb2ludFhPZmZzZXQgfHwgMCwgc2VyaWVzLmJhclcgfHwgMCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRyYW5zbGF0ZWQgeUJvdHRvbSBvciByZW1vdmUgaXRcblx0XHRcdHBvaW50LnlCb3R0b20gPSBkZWZpbmVkKHlCb3R0b20pID9cblx0XHRcdFx0eUF4aXMudHJhbnNsYXRlKHlCb3R0b20sIDAsIDEsIDAsIDEpIDpcblx0XHRcdFx0bnVsbDtcblxuXHRcdFx0Ly8gZ2VuZXJhbCBob29rLCB1c2VkIGZvciBIaWdoc3RvY2sgY29tcGFyZSBtb2RlXG5cdFx0XHRpZiAoaGFzTW9kaWZ5VmFsdWUpIHtcblx0XHRcdFx0eVZhbHVlID0gc2VyaWVzLm1vZGlmeVZhbHVlKHlWYWx1ZSwgcG9pbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIHRoZSBwbG90WSB2YWx1ZSwgcmVzZXQgaXQgZm9yIHJlZHJhd3Ncblx0XHRcdHBvaW50LnBsb3RZID0gcGxvdFkgPSAodHlwZW9mIHlWYWx1ZSA9PT0gJ251bWJlcicgJiYgeVZhbHVlICE9PSBJbmZpbml0eSkgP1xuXHRcdFx0XHRtYXRoTWluKG1hdGhNYXgoLTFlNSwgeUF4aXMudHJhbnNsYXRlKHlWYWx1ZSwgMCwgMSwgMCwgMSkpLCAxZTUpIDogLy8gIzMyMDFcblx0XHRcdFx0VU5ERUZJTkVEO1xuXHRcdFx0cG9pbnQuaXNJbnNpZGUgPSBwbG90WSAhPT0gVU5ERUZJTkVEICYmIHBsb3RZID49IDAgJiYgcGxvdFkgPD0geUF4aXMubGVuICYmIC8vICMzNTE5XG5cdFx0XHRcdHBsb3RYID49IDAgJiYgcGxvdFggPD0geEF4aXMubGVuO1xuXG5cblx0XHRcdC8vIFNldCBjbGllbnQgcmVsYXRlZCBwb3NpdGlvbnMgZm9yIG1vdXNlIHRyYWNraW5nXG5cdFx0XHRwb2ludC5jbGllbnRYID0gZHluYW1pY2FsbHlQbGFjZWQgPyB4QXhpcy50cmFuc2xhdGUoeFZhbHVlLCAwLCAwLCAwLCAxKSA6IHBsb3RYOyAvLyAjMTUxNFxuXG5cdFx0XHRwb2ludC5uZWdhdGl2ZSA9IHBvaW50LnkgPCAodGhyZXNob2xkIHx8IDApO1xuXG5cdFx0XHQvLyBzb21lIEFQSSBkYXRhXG5cdFx0XHRwb2ludC5jYXRlZ29yeSA9IGNhdGVnb3JpZXMgJiYgY2F0ZWdvcmllc1twb2ludC54XSAhPT0gVU5ERUZJTkVEID9cblx0XHRcdFx0Y2F0ZWdvcmllc1twb2ludC54XSA6IHBvaW50Lng7XG5cblx0XHRcdC8vIERldGVybWluZSBhdXRvIGVuYWJsaW5nIG9mIG1hcmtlcnMgKCMzNjM1KVxuXHRcdFx0aWYgKGkpIHtcblx0XHRcdFx0Y2xvc2VzdFBvaW50UmFuZ2VQeCA9IG1hdGhNaW4oY2xvc2VzdFBvaW50UmFuZ2VQeCwgbWF0aEFicyhwbG90WCAtIGxhc3RQbG90WCkpO1xuXHRcdFx0fVxuXHRcdFx0bGFzdFBsb3RYID0gcGxvdFg7XG5cblx0XHR9XG5cblx0XHRzZXJpZXMuY2xvc2VzdFBvaW50UmFuZ2VQeCA9IGNsb3Nlc3RQb2ludFJhbmdlUHg7XG5cblx0XHQvLyBub3cgdGhhdCB3ZSBoYXZlIHRoZSBjcm9wcGVkIGRhdGEsIGJ1aWxkIHRoZSBzZWdtZW50c1xuXHRcdHNlcmllcy5nZXRTZWdtZW50cygpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGNsaXBwaW5nIGZvciB0aGUgc2VyaWVzLiBGb3IgYW5pbWF0ZWQgc2VyaWVzIGl0IGlzIGNhbGxlZCB0d2ljZSwgZmlyc3QgdG8gaW5pdGlhdGVcblx0ICogYW5pbWF0aW5nIHRoZSBjbGlwIHRoZW4gdGhlIHNlY29uZCB0aW1lIHdpdGhvdXQgdGhlIGFuaW1hdGlvbiB0byBzZXQgdGhlIGZpbmFsIGNsaXAuXG5cdCAqL1xuXHRzZXRDbGlwOiBmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZCxcblx0XHRcdHNlcmllc0NsaXBCb3ggPSB0aGlzLmNsaXBCb3gsXG5cdFx0XHRjbGlwQm94ID0gc2VyaWVzQ2xpcEJveCB8fCBjaGFydC5jbGlwQm94LFxuXHRcdFx0c2hhcmVkQ2xpcEtleSA9IHRoaXMuc2hhcmVkQ2xpcEtleSB8fCBbJ19zaGFyZWRDbGlwJywgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5kdXJhdGlvbiwgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5lYXNpbmcsIGNsaXBCb3guaGVpZ2h0LCBvcHRpb25zLnhBeGlzLCBvcHRpb25zLnlBeGlzXS5qb2luKCcsJyksIC8vICM0NTI2XG5cdFx0XHRjbGlwUmVjdCA9IGNoYXJ0W3NoYXJlZENsaXBLZXldLFxuXHRcdFx0bWFya2VyQ2xpcFJlY3QgPSBjaGFydFtzaGFyZWRDbGlwS2V5ICsgJ20nXTtcblxuXHRcdC8vIElmIGEgY2xpcHBpbmcgcmVjdGFuZ2xlIHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBpcyBjdXJyZW50bHkgcHJlc2VudCBpbiB0aGUgY2hhcnQsIHVzZSB0aGF0LlxuXHRcdGlmICghY2xpcFJlY3QpIHtcblxuXHRcdFx0Ly8gV2hlbiBhbmltYXRpb24gaXMgc2V0LCBwcmVwYXJlIHRoZSBpbml0aWFsIHBvc2l0aW9uc1xuXHRcdFx0aWYgKGFuaW1hdGlvbikgeyBcblx0XHRcdFx0Y2xpcEJveC53aWR0aCA9IDA7XG5cblx0XHRcdFx0Y2hhcnRbc2hhcmVkQ2xpcEtleSArICdtJ10gPSBtYXJrZXJDbGlwUmVjdCA9IHJlbmRlcmVyLmNsaXBSZWN0KFxuXHRcdFx0XHRcdC05OSwgLy8gaW5jbHVkZSB0aGUgd2lkdGggb2YgdGhlIGZpcnN0IG1hcmtlclxuXHRcdFx0XHRcdGludmVydGVkID8gLWNoYXJ0LnBsb3RMZWZ0IDogLWNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdFx0OTksXG5cdFx0XHRcdFx0aW52ZXJ0ZWQgPyBjaGFydC5jaGFydFdpZHRoIDogY2hhcnQuY2hhcnRIZWlnaHRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdGNoYXJ0W3NoYXJlZENsaXBLZXldID0gY2xpcFJlY3QgPSByZW5kZXJlci5jbGlwUmVjdChjbGlwQm94KTtcblx0XHRcdFxuXHRcdH1cblx0XHRpZiAoYW5pbWF0aW9uKSB7XG5cdFx0XHRjbGlwUmVjdC5jb3VudCArPSAxO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmNsaXAgIT09IGZhbHNlKSB7XG5cdFx0XHR0aGlzLmdyb3VwLmNsaXAoYW5pbWF0aW9uIHx8IHNlcmllc0NsaXBCb3ggPyBjbGlwUmVjdCA6IGNoYXJ0LmNsaXBSZWN0KTtcblx0XHRcdHRoaXMubWFya2VyR3JvdXAuY2xpcChtYXJrZXJDbGlwUmVjdCk7XG5cdFx0XHR0aGlzLnNoYXJlZENsaXBLZXkgPSBzaGFyZWRDbGlwS2V5O1xuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgc2hhcmVkIGNsaXBwaW5nIHJlY3RhbmdsZSB3aGVuIGFsbCBzZXJpZXMgYXJlIHNob3duXG5cdFx0aWYgKCFhbmltYXRpb24pIHtcblx0XHRcdGNsaXBSZWN0LmNvdW50IC09IDE7XG5cdFx0XHRpZiAoY2xpcFJlY3QuY291bnQgPD0gMCAmJiBzaGFyZWRDbGlwS2V5ICYmIGNoYXJ0W3NoYXJlZENsaXBLZXldKSB7XG5cdFx0XHRcdGlmICghc2VyaWVzQ2xpcEJveCkge1xuXHRcdFx0XHRcdGNoYXJ0W3NoYXJlZENsaXBLZXldID0gY2hhcnRbc2hhcmVkQ2xpcEtleV0uZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjaGFydFtzaGFyZWRDbGlwS2V5ICsgJ20nXSkge1xuXHRcdFx0XHRcdGNoYXJ0W3NoYXJlZENsaXBLZXkgKyAnbSddID0gY2hhcnRbc2hhcmVkQ2xpcEtleSArICdtJ10uZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBBbmltYXRlIGluIHRoZSBzZXJpZXNcblx0ICovXG5cdGFuaW1hdGU6IGZ1bmN0aW9uIChpbml0KSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdGNsaXBSZWN0LFxuXHRcdFx0YW5pbWF0aW9uID0gc2VyaWVzLm9wdGlvbnMuYW5pbWF0aW9uLFxuXHRcdFx0c2hhcmVkQ2xpcEtleTtcblxuXHRcdC8vIEFuaW1hdGlvbiBvcHRpb24gaXMgc2V0IHRvIHRydWVcblx0XHRpZiAoYW5pbWF0aW9uICYmICFpc09iamVjdChhbmltYXRpb24pKSB7XG5cdFx0XHRhbmltYXRpb24gPSBkZWZhdWx0UGxvdE9wdGlvbnNbc2VyaWVzLnR5cGVdLmFuaW1hdGlvbjtcblx0XHR9XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBhbmltYXRpb24uIFNldCB1cCB0aGUgY2xpcHBpbmcgcmVjdGFuZ2xlLlxuXHRcdGlmIChpbml0KSB7XG5cblx0XHRcdHNlcmllcy5zZXRDbGlwKGFuaW1hdGlvbik7XG5cblx0XHQvLyBSdW4gdGhlIGFuaW1hdGlvblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzaGFyZWRDbGlwS2V5ID0gdGhpcy5zaGFyZWRDbGlwS2V5O1xuXHRcdFx0Y2xpcFJlY3QgPSBjaGFydFtzaGFyZWRDbGlwS2V5XTtcblx0XHRcdGlmIChjbGlwUmVjdCkge1xuXHRcdFx0XHRjbGlwUmVjdC5hbmltYXRlKHtcblx0XHRcdFx0XHR3aWR0aDogY2hhcnQucGxvdFNpemVYXG5cdFx0XHRcdH0sIGFuaW1hdGlvbik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2hhcnRbc2hhcmVkQ2xpcEtleSArICdtJ10pIHtcblx0XHRcdFx0Y2hhcnRbc2hhcmVkQ2xpcEtleSArICdtJ10uYW5pbWF0ZSh7XG5cdFx0XHRcdFx0d2lkdGg6IGNoYXJ0LnBsb3RTaXplWCArIDk5XG5cdFx0XHRcdH0sIGFuaW1hdGlvbik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlbGV0ZSB0aGlzIGZ1bmN0aW9uIHRvIGFsbG93IGl0IG9ubHkgb25jZVxuXHRcdFx0c2VyaWVzLmFuaW1hdGUgPSBudWxsO1xuIFxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBydW5zIGFmdGVyIGFuaW1hdGlvbiB0byBsYW5kIG9uIHRoZSBmaW5hbCBwbG90IGNsaXBwaW5nXG5cdCAqL1xuXHRhZnRlckFuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNldENsaXAoKTtcblx0XHRmaXJlRXZlbnQodGhpcywgJ2FmdGVyQW5pbWF0ZScpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3IHRoZSBtYXJrZXJzXG5cdCAqL1xuXHRkcmF3UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRwb2ludEF0dHIsXG5cdFx0XHRwb2ludHMgPSBzZXJpZXMucG9pbnRzLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRwbG90WCxcblx0XHRcdHBsb3RZLFxuXHRcdFx0aSxcblx0XHRcdHBvaW50LFxuXHRcdFx0cmFkaXVzLFxuXHRcdFx0c3ltYm9sLFxuXHRcdFx0aXNJbWFnZSxcblx0XHRcdGdyYXBoaWMsXG5cdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRzZXJpZXNNYXJrZXJPcHRpb25zID0gb3B0aW9ucy5tYXJrZXIsXG5cdFx0XHRzZXJpZXNQb2ludEF0dHIgPSBzZXJpZXMucG9pbnRBdHRyWycnXSxcblx0XHRcdHBvaW50TWFya2VyT3B0aW9ucyxcblx0XHRcdGhhc1BvaW50TWFya2VyLFxuXHRcdFx0ZW5hYmxlZCxcblx0XHRcdGlzSW5zaWRlLFxuXHRcdFx0bWFya2VyR3JvdXAgPSBzZXJpZXMubWFya2VyR3JvdXAsXG5cdFx0XHR4QXhpcyA9IHNlcmllcy54QXhpcyxcblx0XHRcdGdsb2JhbGx5RW5hYmxlZCA9IHBpY2soXG5cdFx0XHRcdHNlcmllc01hcmtlck9wdGlvbnMuZW5hYmxlZCwgXG5cdFx0XHRcdHhBeGlzLmlzUmFkaWFsLFxuXHRcdFx0XHRzZXJpZXMuY2xvc2VzdFBvaW50UmFuZ2VQeCA+IDIgKiBzZXJpZXNNYXJrZXJPcHRpb25zLnJhZGl1c1xuXHRcdFx0KTtcblxuXHRcdGlmIChzZXJpZXNNYXJrZXJPcHRpb25zLmVuYWJsZWQgIT09IGZhbHNlIHx8IHNlcmllcy5faGFzUG9pbnRNYXJrZXJzKSB7XG5cblx0XHRcdGkgPSBwb2ludHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRwb2ludCA9IHBvaW50c1tpXTtcblx0XHRcdFx0cGxvdFggPSBtYXRoRmxvb3IocG9pbnQucGxvdFgpOyAvLyAjMTg0M1xuXHRcdFx0XHRwbG90WSA9IHBvaW50LnBsb3RZO1xuXHRcdFx0XHRncmFwaGljID0gcG9pbnQuZ3JhcGhpYztcblx0XHRcdFx0cG9pbnRNYXJrZXJPcHRpb25zID0gcG9pbnQubWFya2VyIHx8IHt9O1xuXHRcdFx0XHRoYXNQb2ludE1hcmtlciA9ICEhcG9pbnQubWFya2VyO1xuXHRcdFx0XHRlbmFibGVkID0gKGdsb2JhbGx5RW5hYmxlZCAmJiBwb2ludE1hcmtlck9wdGlvbnMuZW5hYmxlZCA9PT0gVU5ERUZJTkVEKSB8fCBwb2ludE1hcmtlck9wdGlvbnMuZW5hYmxlZDtcblx0XHRcdFx0aXNJbnNpZGUgPSBwb2ludC5pc0luc2lkZTtcblxuXHRcdFx0XHQvLyBvbmx5IGRyYXcgdGhlIHBvaW50IGlmIHkgaXMgZGVmaW5lZFxuXHRcdFx0XHRpZiAoZW5hYmxlZCAmJiBwbG90WSAhPT0gVU5ERUZJTkVEICYmICFpc05hTihwbG90WSkgJiYgcG9pbnQueSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdFx0Ly8gc2hvcnRjdXRzXG5cdFx0XHRcdFx0cG9pbnRBdHRyID0gcG9pbnQucG9pbnRBdHRyW3BvaW50LnNlbGVjdGVkID8gU0VMRUNUX1NUQVRFIDogTk9STUFMX1NUQVRFXSB8fCBzZXJpZXNQb2ludEF0dHI7XG5cdFx0XHRcdFx0cmFkaXVzID0gcG9pbnRBdHRyLnI7XG5cdFx0XHRcdFx0c3ltYm9sID0gcGljayhwb2ludE1hcmtlck9wdGlvbnMuc3ltYm9sLCBzZXJpZXMuc3ltYm9sKTtcblx0XHRcdFx0XHRpc0ltYWdlID0gc3ltYm9sLmluZGV4T2YoJ3VybCcpID09PSAwO1xuXG5cdFx0XHRcdFx0aWYgKGdyYXBoaWMpIHsgLy8gdXBkYXRlXG5cdFx0XHRcdFx0XHRncmFwaGljW2lzSW5zaWRlID8gJ3Nob3cnIDogJ2hpZGUnXSh0cnVlKSAvLyBTaW5jZSB0aGUgbWFya2VyIGdyb3VwIGlzbid0IGNsaXBwZWQsIGVhY2ggaW5kaXZpZHVhbCBtYXJrZXIgbXVzdCBiZSB0b2dnbGVkXG5cdFx0XHRcdFx0XHRcdC5hbmltYXRlKGV4dGVuZCh7XG5cdFx0XHRcdFx0XHRcdFx0eDogcGxvdFggLSByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0eTogcGxvdFkgLSByYWRpdXNcblx0XHRcdFx0XHRcdFx0fSwgZ3JhcGhpYy5zeW1ib2xOYW1lID8geyAvLyBkb24ndCBhcHBseSB0byBpbWFnZSBzeW1ib2xzICM1MDdcblx0XHRcdFx0XHRcdFx0XHR3aWR0aDogMiAqIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ6IDIgKiByYWRpdXNcblx0XHRcdFx0XHRcdFx0fSA6IHt9KSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpc0luc2lkZSAmJiAocmFkaXVzID4gMCB8fCBpc0ltYWdlKSkge1xuXHRcdFx0XHRcdFx0cG9pbnQuZ3JhcGhpYyA9IGdyYXBoaWMgPSBjaGFydC5yZW5kZXJlci5zeW1ib2woXG5cdFx0XHRcdFx0XHRcdHN5bWJvbCxcblx0XHRcdFx0XHRcdFx0cGxvdFggLSByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdHBsb3RZIC0gcmFkaXVzLFxuXHRcdFx0XHRcdFx0XHQyICogcmFkaXVzLFxuXHRcdFx0XHRcdFx0XHQyICogcmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRoYXNQb2ludE1hcmtlciA/IHBvaW50TWFya2VyT3B0aW9ucyA6IHNlcmllc01hcmtlck9wdGlvbnNcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdC5hdHRyKHBvaW50QXR0cilcblx0XHRcdFx0XHRcdC5hZGQobWFya2VyR3JvdXApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKGdyYXBoaWMpIHtcblx0XHRcdFx0XHRwb2ludC5ncmFwaGljID0gZ3JhcGhpYy5kZXN0cm95KCk7IC8vICMxMjY5XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0fSxcblxuXHQvKipcblx0ICogQ29udmVydCBzdGF0ZSBwcm9wZXJ0aWVzIGZyb20gQVBJIG5hbWluZyBjb252ZW50aW9ucyB0byBTVkcgYXR0cmlidXRlc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBUEkgb3B0aW9ucyBvYmplY3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IGJhc2UxIFNWRyBhdHRyaWJ1dGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbVxuXHQgKiBAcGFyYW0ge09iamVjdH0gYmFzZTIgU2Vjb25kIGxldmVsIFNWRyBhdHRyaWJ1dGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbVxuXHQgKi9cblx0Y29udmVydEF0dHJpYnM6IGZ1bmN0aW9uIChvcHRpb25zLCBiYXNlMSwgYmFzZTIsIGJhc2UzKSB7XG5cdFx0dmFyIGNvbnZlcnNpb24gPSB0aGlzLnBvaW50QXR0clRvT3B0aW9ucyxcblx0XHRcdGF0dHIsXG5cdFx0XHRvcHRpb24sXG5cdFx0XHRvYmogPSB7fTtcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGJhc2UxID0gYmFzZTEgfHwge307XG5cdFx0YmFzZTIgPSBiYXNlMiB8fCB7fTtcblx0XHRiYXNlMyA9IGJhc2UzIHx8IHt9O1xuXG5cdFx0Zm9yIChhdHRyIGluIGNvbnZlcnNpb24pIHtcblx0XHRcdG9wdGlvbiA9IGNvbnZlcnNpb25bYXR0cl07XG5cdFx0XHRvYmpbYXR0cl0gPSBwaWNrKG9wdGlvbnNbb3B0aW9uXSwgYmFzZTFbYXR0cl0sIGJhc2UyW2F0dHJdLCBiYXNlM1thdHRyXSk7XG5cdFx0fVxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgc3RhdGUgYXR0cmlidXRlcy4gRWFjaCBzZXJpZXMgdHlwZSBoYXMgaXRzIG93biBzZXQgb2YgYXR0cmlidXRlc1xuXHQgKiB0aGF0IGFyZSBhbGxvd2VkIHRvIGNoYW5nZSBvbiBhIHBvaW50J3Mgc3RhdGUgY2hhbmdlLiBTZXJpZXMgd2lkZSBhdHRyaWJ1dGVzIGFyZSBzdG9yZWQgZm9yXG5cdCAqIGFsbCBzZXJpZXMsIGFuZCBhZGRpdGlvbmFsbHkgcG9pbnQgc3BlY2lmaWMgYXR0cmlidXRlcyBhcmUgc3RvcmVkIGZvciBhbGxcblx0ICogcG9pbnRzIHdpdGggaW5kaXZpZHVhbCBtYXJrZXIgb3B0aW9ucy4gSWYgc3VjaCBvcHRpb25zIGFyZSBub3QgZGVmaW5lZCBmb3IgdGhlIHBvaW50LFxuXHQgKiBhIHJlZmVyZW5jZSB0byB0aGUgc2VyaWVzIHdpZGUgYXR0cmlidXRlcyBpcyBzdG9yZWQgaW4gcG9pbnQucG9pbnRBdHRyLlxuXHQgKi9cblx0Z2V0QXR0cmliczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0c2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0bm9ybWFsT3B0aW9ucyA9IGRlZmF1bHRQbG90T3B0aW9uc1tzZXJpZXMudHlwZV0ubWFya2VyID8gc2VyaWVzT3B0aW9ucy5tYXJrZXIgOiBzZXJpZXNPcHRpb25zLFxuXHRcdFx0c3RhdGVPcHRpb25zID0gbm9ybWFsT3B0aW9ucy5zdGF0ZXMsXG5cdFx0XHRzdGF0ZU9wdGlvbnNIb3ZlciA9IHN0YXRlT3B0aW9uc1tIT1ZFUl9TVEFURV0sXG5cdFx0XHRwb2ludFN0YXRlT3B0aW9uc0hvdmVyLFxuXHRcdFx0c2VyaWVzQ29sb3IgPSBzZXJpZXMuY29sb3IsXG5cdFx0XHRzZXJpZXNOZWdhdGl2ZUNvbG9yID0gc2VyaWVzLm9wdGlvbnMubmVnYXRpdmVDb2xvcixcblx0XHRcdG5vcm1hbERlZmF1bHRzID0ge1xuXHRcdFx0XHRzdHJva2U6IHNlcmllc0NvbG9yLFxuXHRcdFx0XHRmaWxsOiBzZXJpZXNDb2xvclxuXHRcdFx0fSxcblx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMgfHwgW10sIC8vICM5Mjdcblx0XHRcdGksXG5cdFx0XHRqLFxuXHRcdFx0dGhyZXNob2xkLFxuXHRcdFx0cG9pbnQsXG5cdFx0XHRzZXJpZXNQb2ludEF0dHIgPSBbXSxcblx0XHRcdHBvaW50QXR0cixcblx0XHRcdHBvaW50QXR0clRvT3B0aW9ucyA9IHNlcmllcy5wb2ludEF0dHJUb09wdGlvbnMsXG5cdFx0XHRoYXNQb2ludFNwZWNpZmljT3B0aW9ucyA9IHNlcmllcy5oYXNQb2ludFNwZWNpZmljT3B0aW9ucyxcblx0XHRcdGRlZmF1bHRMaW5lQ29sb3IgPSBub3JtYWxPcHRpb25zLmxpbmVDb2xvcixcblx0XHRcdGRlZmF1bHRGaWxsQ29sb3IgPSBub3JtYWxPcHRpb25zLmZpbGxDb2xvcixcblx0XHRcdHR1cmJvVGhyZXNob2xkID0gc2VyaWVzT3B0aW9ucy50dXJib1RocmVzaG9sZCxcblx0XHRcdHpvbmVzID0gc2VyaWVzLnpvbmVzLFxuXHRcdFx0em9uZUF4aXMgPSBzZXJpZXMuem9uZUF4aXMgfHwgJ3knLFxuXHRcdFx0YXR0cixcblx0XHRcdGtleTtcblxuXHRcdC8vIHNlcmllcyB0eXBlIHNwZWNpZmljIG1vZGlmaWNhdGlvbnNcblx0XHRpZiAoc2VyaWVzT3B0aW9ucy5tYXJrZXIpIHsgLy8gbGluZSwgc3BsaW5lLCBhcmVhLCBhcmVhc3BsaW5lLCBzY2F0dGVyXG5cblx0XHRcdC8vIGlmIG5vIGhvdmVyIHJhZGl1cyBpcyBnaXZlbiwgZGVmYXVsdCB0byBub3JtYWwgcmFkaXVzICsgMlxuXHRcdFx0c3RhdGVPcHRpb25zSG92ZXIucmFkaXVzID0gc3RhdGVPcHRpb25zSG92ZXIucmFkaXVzIHx8IG5vcm1hbE9wdGlvbnMucmFkaXVzICsgc3RhdGVPcHRpb25zSG92ZXIucmFkaXVzUGx1cztcblx0XHRcdHN0YXRlT3B0aW9uc0hvdmVyLmxpbmVXaWR0aCA9IHN0YXRlT3B0aW9uc0hvdmVyLmxpbmVXaWR0aCB8fCBub3JtYWxPcHRpb25zLmxpbmVXaWR0aCArIHN0YXRlT3B0aW9uc0hvdmVyLmxpbmVXaWR0aFBsdXM7XG5cblx0XHR9IGVsc2UgeyAvLyBjb2x1bW4sIGJhciwgcGllXG5cblx0XHRcdC8vIGlmIG5vIGhvdmVyIGNvbG9yIGlzIGdpdmVuLCBicmlnaHRlbiB0aGUgbm9ybWFsIGNvbG9yXG5cdFx0XHRzdGF0ZU9wdGlvbnNIb3Zlci5jb2xvciA9IHN0YXRlT3B0aW9uc0hvdmVyLmNvbG9yIHx8XG5cdFx0XHRcdENvbG9yKHN0YXRlT3B0aW9uc0hvdmVyLmNvbG9yIHx8IHNlcmllc0NvbG9yKVxuXHRcdFx0XHRcdC5icmlnaHRlbihzdGF0ZU9wdGlvbnNIb3Zlci5icmlnaHRuZXNzKS5nZXQoKTtcblxuXHRcdFx0Ly8gaWYgbm8gaG92ZXIgbmVnYXRpdmVDb2xvciBpcyBnaXZlbiwgYnJpZ2h0ZW4gdGhlIG5vcm1hbCBuZWdhdGl2ZUNvbG9yXG5cdFx0XHRzdGF0ZU9wdGlvbnNIb3Zlci5uZWdhdGl2ZUNvbG9yID0gc3RhdGVPcHRpb25zSG92ZXIubmVnYXRpdmVDb2xvciB8fFxuXHRcdFx0XHRDb2xvcihzdGF0ZU9wdGlvbnNIb3Zlci5uZWdhdGl2ZUNvbG9yIHx8IHNlcmllc05lZ2F0aXZlQ29sb3IpXG5cdFx0XHRcdFx0LmJyaWdodGVuKHN0YXRlT3B0aW9uc0hvdmVyLmJyaWdodG5lc3MpLmdldCgpO1xuXHRcdH1cblxuXHRcdC8vIGdlbmVyYWwgcG9pbnQgYXR0cmlidXRlcyBmb3IgdGhlIHNlcmllcyBub3JtYWwgc3RhdGVcblx0XHRzZXJpZXNQb2ludEF0dHJbTk9STUFMX1NUQVRFXSA9IHNlcmllcy5jb252ZXJ0QXR0cmlicyhub3JtYWxPcHRpb25zLCBub3JtYWxEZWZhdWx0cyk7XG5cblx0XHQvLyBIT1ZFUl9TVEFURSBhbmQgU0VMRUNUX1NUQVRFIHN0YXRlcyBpbmhlcml0IGZyb20gbm9ybWFsIHN0YXRlIGV4Y2VwdCB0aGUgZGVmYXVsdCByYWRpdXNcblx0XHRlYWNoKFtIT1ZFUl9TVEFURSwgU0VMRUNUX1NUQVRFXSwgZnVuY3Rpb24gKHN0YXRlKSB7XG5cdFx0XHRzZXJpZXNQb2ludEF0dHJbc3RhdGVdID1cblx0XHRcdFx0XHRzZXJpZXMuY29udmVydEF0dHJpYnMoc3RhdGVPcHRpb25zW3N0YXRlXSwgc2VyaWVzUG9pbnRBdHRyW05PUk1BTF9TVEFURV0pO1xuXHRcdH0pO1xuXG5cdFx0Ly8gc2V0IGl0XG5cdFx0c2VyaWVzLnBvaW50QXR0ciA9IHNlcmllc1BvaW50QXR0cjtcblxuXG5cdFx0Ly8gR2VuZXJhdGUgdGhlIHBvaW50LXNwZWNpZmljIGF0dHJpYnV0ZSBjb2xsZWN0aW9ucyBpZiBzcGVjaWZpYyBwb2ludFxuXHRcdC8vIG9wdGlvbnMgYXJlIGdpdmVuLiBJZiBub3QsIGNyZWF0ZSBhIHJlZmVyYW5jZSB0byB0aGUgc2VyaWVzIHdpZGUgcG9pbnRcblx0XHQvLyBhdHRyaWJ1dGVzXG5cdFx0aSA9IHBvaW50cy5sZW5ndGg7XG5cdFx0aWYgKCF0dXJib1RocmVzaG9sZCB8fCBpIDwgdHVyYm9UaHJlc2hvbGQgfHwgaGFzUG9pbnRTcGVjaWZpY09wdGlvbnMpIHtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRcdG5vcm1hbE9wdGlvbnMgPSAocG9pbnQub3B0aW9ucyAmJiBwb2ludC5vcHRpb25zLm1hcmtlcikgfHwgcG9pbnQub3B0aW9ucztcblx0XHRcdFx0aWYgKG5vcm1hbE9wdGlvbnMgJiYgbm9ybWFsT3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdG5vcm1hbE9wdGlvbnMucmFkaXVzID0gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh6b25lcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR0aHJlc2hvbGQgPSB6b25lc1tqXTtcblx0XHRcdFx0XHR3aGlsZSAocG9pbnRbem9uZUF4aXNdID49IHRocmVzaG9sZC52YWx1ZSkge1x0XHRcdFx0XG5cdFx0XHRcdFx0XHR0aHJlc2hvbGQgPSB6b25lc1srK2pdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRwb2ludC5jb2xvciA9IHBvaW50LmZpbGxDb2xvciA9IHBpY2sodGhyZXNob2xkLmNvbG9yLCBzZXJpZXMuY29sb3IpOyAvLyAjMzYzNiwgIzQyNjcsICM0NDMwIC0gaW5oZXJpdCBjb2xvciBmcm9tIHNlcmllcywgd2hlbiBjb2xvciBpcyB1bmRlZmluZWRcblx0XHRcdFx0XHRcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGhhc1BvaW50U3BlY2lmaWNPcHRpb25zID0gc2VyaWVzT3B0aW9ucy5jb2xvckJ5UG9pbnQgfHwgcG9pbnQuY29sb3I7IC8vICM4NjhcblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgcG9pbnQgaGFzIHNwZWNpZmljIHZpc3VhbCBvcHRpb25zXG5cdFx0XHRcdGlmIChwb2ludC5vcHRpb25zKSB7XG5cdFx0XHRcdFx0Zm9yIChrZXkgaW4gcG9pbnRBdHRyVG9PcHRpb25zKSB7XG5cdFx0XHRcdFx0XHRpZiAoZGVmaW5lZChub3JtYWxPcHRpb25zW3BvaW50QXR0clRvT3B0aW9uc1trZXldXSkpIHtcblx0XHRcdFx0XHRcdFx0aGFzUG9pbnRTcGVjaWZpY09wdGlvbnMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGEgc3BlY2lmaWMgbWFya2VyIGNvbmZpZyBvYmplY3QgaXMgZGVmaW5lZCBmb3IgdGhlIGluZGl2aWR1YWwgcG9pbnQ6XG5cdFx0XHRcdC8vIGNyZWF0ZSBpdCdzIG93biBhdHRyaWJ1dGUgY29sbGVjdGlvblxuXHRcdFx0XHRpZiAoaGFzUG9pbnRTcGVjaWZpY09wdGlvbnMpIHtcblx0XHRcdFx0XHRub3JtYWxPcHRpb25zID0gbm9ybWFsT3B0aW9ucyB8fCB7fTtcblx0XHRcdFx0XHRwb2ludEF0dHIgPSBbXTtcblx0XHRcdFx0XHRzdGF0ZU9wdGlvbnMgPSBub3JtYWxPcHRpb25zLnN0YXRlcyB8fCB7fTsgLy8gcmVhc3NpZ24gZm9yIGluZGl2aWR1YWwgcG9pbnRcblx0XHRcdFx0XHRwb2ludFN0YXRlT3B0aW9uc0hvdmVyID0gc3RhdGVPcHRpb25zW0hPVkVSX1NUQVRFXSA9IHN0YXRlT3B0aW9uc1tIT1ZFUl9TVEFURV0gfHwge307XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgY29sb3JzIGZvciBjb2x1bW4gYW5kIHBpZXNcblx0XHRcdFx0XHRpZiAoIXNlcmllc09wdGlvbnMubWFya2VyIHx8IChwb2ludC5uZWdhdGl2ZSAmJiAhcG9pbnRTdGF0ZU9wdGlvbnNIb3Zlci5maWxsQ29sb3IgJiYgIXN0YXRlT3B0aW9uc0hvdmVyLmZpbGxDb2xvcikpIHsgLy8gY29sdW1uLCBiYXIsIHBvaW50IG9yIG5lZ2F0aXZlIHRocmVzaG9sZCBmb3Igc2VyaWVzIHdpdGggbWFya2VycyAoIzM2MzYpXG5cdFx0XHRcdFx0XHQvLyBJZiBubyBob3ZlciBjb2xvciBpcyBnaXZlbiwgYnJpZ2h0ZW4gdGhlIG5vcm1hbCBjb2xvci4gIzE2MTksICMyNTc5XG5cdFx0XHRcdFx0XHRwb2ludFN0YXRlT3B0aW9uc0hvdmVyW3Nlcmllcy5wb2ludEF0dHJUb09wdGlvbnMuZmlsbF0gPSBwb2ludFN0YXRlT3B0aW9uc0hvdmVyLmNvbG9yIHx8ICghcG9pbnQub3B0aW9ucy5jb2xvciAmJiBzdGF0ZU9wdGlvbnNIb3ZlclsocG9pbnQubmVnYXRpdmUgJiYgc2VyaWVzTmVnYXRpdmVDb2xvciA/ICduZWdhdGl2ZUNvbG9yJyA6ICdjb2xvcicpXSkgfHxcblx0XHRcdFx0XHRcdFx0Q29sb3IocG9pbnQuY29sb3IpXG5cdFx0XHRcdFx0XHRcdFx0LmJyaWdodGVuKHBvaW50U3RhdGVPcHRpb25zSG92ZXIuYnJpZ2h0bmVzcyB8fCBzdGF0ZU9wdGlvbnNIb3Zlci5icmlnaHRuZXNzKVxuXHRcdFx0XHRcdFx0XHRcdC5nZXQoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBub3JtYWwgcG9pbnQgc3RhdGUgaW5oZXJpdHMgc2VyaWVzIHdpZGUgbm9ybWFsIHN0YXRlXG5cdFx0XHRcdFx0YXR0ciA9IHsgY29sb3I6IHBvaW50LmNvbG9yIH07IC8vICM4Njhcblx0XHRcdFx0XHRpZiAoIWRlZmF1bHRGaWxsQ29sb3IpIHsgLy8gSW5kaXZpZHVhbCBwb2ludCBjb2xvciBvciBuZWdhdGl2ZSBjb2xvciBtYXJrZXJzICgjMjIxOSlcblx0XHRcdFx0XHRcdGF0dHIuZmlsbENvbG9yID0gcG9pbnQuY29sb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghZGVmYXVsdExpbmVDb2xvcikge1xuXHRcdFx0XHRcdFx0YXR0ci5saW5lQ29sb3IgPSBwb2ludC5jb2xvcjsgLy8gQnViYmxlcyB0YWtlIHBvaW50IGNvbG9yLCBsaW5lIG1hcmtlcnMgdXNlIHdoaXRlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIENvbG9yIGlzIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkICgjMTI4OCwgIzQwNjgpXG5cdFx0XHRcdFx0aWYgKG5vcm1hbE9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2NvbG9yJykgJiYgIW5vcm1hbE9wdGlvbnMuY29sb3IpIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSBub3JtYWxPcHRpb25zLmNvbG9yO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb2ludEF0dHJbTk9STUFMX1NUQVRFXSA9IHNlcmllcy5jb252ZXJ0QXR0cmlicyhleHRlbmQoYXR0ciwgbm9ybWFsT3B0aW9ucyksIHNlcmllc1BvaW50QXR0cltOT1JNQUxfU1RBVEVdKTtcblxuXHRcdFx0XHRcdC8vIGluaGVyaXQgZnJvbSBwb2ludCBub3JtYWwgYW5kIHNlcmllcyBob3ZlclxuXHRcdFx0XHRcdHBvaW50QXR0cltIT1ZFUl9TVEFURV0gPSBzZXJpZXMuY29udmVydEF0dHJpYnMoXG5cdFx0XHRcdFx0XHRzdGF0ZU9wdGlvbnNbSE9WRVJfU1RBVEVdLFxuXHRcdFx0XHRcdFx0c2VyaWVzUG9pbnRBdHRyW0hPVkVSX1NUQVRFXSxcblx0XHRcdFx0XHRcdHBvaW50QXR0cltOT1JNQUxfU1RBVEVdXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdC8vIGluaGVyaXQgZnJvbSBwb2ludCBub3JtYWwgYW5kIHNlcmllcyBob3ZlclxuXHRcdFx0XHRcdHBvaW50QXR0cltTRUxFQ1RfU1RBVEVdID0gc2VyaWVzLmNvbnZlcnRBdHRyaWJzKFxuXHRcdFx0XHRcdFx0c3RhdGVPcHRpb25zW1NFTEVDVF9TVEFURV0sXG5cdFx0XHRcdFx0XHRzZXJpZXNQb2ludEF0dHJbU0VMRUNUX1NUQVRFXSxcblx0XHRcdFx0XHRcdHBvaW50QXR0cltOT1JNQUxfU1RBVEVdXG5cdFx0XHRcdFx0KTtcblxuXG5cdFx0XHRcdC8vIG5vIG1hcmtlciBjb25maWcgb2JqZWN0IGlzIGNyZWF0ZWQ6IGNvcHkgYSByZWZlcmVuY2UgdG8gdGhlIHNlcmllcy13aWRlXG5cdFx0XHRcdC8vIGF0dHJpYnV0ZSBjb2xsZWN0aW9uXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cG9pbnRBdHRyID0gc2VyaWVzUG9pbnRBdHRyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cG9pbnQucG9pbnRBdHRyID0gcG9pbnRBdHRyO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQ2xlYXIgRE9NIG9iamVjdHMgYW5kIGZyZWUgdXAgbWVtb3J5XG5cdCAqL1xuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdGlzc3VlMTM0ID0gL0FwcGxlV2ViS2l0XFwvNTMzLy50ZXN0KHVzZXJBZ2VudCksXG5cdFx0XHRkZXN0cm95LFxuXHRcdFx0aSxcblx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSB8fCBbXSxcblx0XHRcdHBvaW50LFxuXHRcdFx0cHJvcCxcblx0XHRcdGF4aXM7XG5cblx0XHQvLyBhZGQgZXZlbnQgaG9va1xuXHRcdGZpcmVFdmVudChzZXJpZXMsICdkZXN0cm95Jyk7XG5cblx0XHQvLyByZW1vdmUgYWxsIGV2ZW50c1xuXHRcdHJlbW92ZUV2ZW50KHNlcmllcyk7XG5cblx0XHQvLyBlcmFzZSBmcm9tIGF4ZXNcblx0XHRlYWNoKHNlcmllcy5heGlzVHlwZXMgfHwgW10sIGZ1bmN0aW9uIChBWElTKSB7XG5cdFx0XHRheGlzID0gc2VyaWVzW0FYSVNdO1xuXHRcdFx0aWYgKGF4aXMpIHtcblx0XHRcdFx0ZXJhc2UoYXhpcy5zZXJpZXMsIHNlcmllcyk7XG5cdFx0XHRcdGF4aXMuaXNEaXJ0eSA9IGF4aXMuZm9yY2VSZWRyYXcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gcmVtb3ZlIGxlZ2VuZCBpdGVtc1xuXHRcdGlmIChzZXJpZXMubGVnZW5kSXRlbSkge1xuXHRcdFx0c2VyaWVzLmNoYXJ0LmxlZ2VuZC5kZXN0cm95SXRlbShzZXJpZXMpO1xuXHRcdH1cblxuXHRcdC8vIGRlc3Ryb3kgYWxsIHBvaW50cyB3aXRoIHRoZWlyIGVsZW1lbnRzXG5cdFx0aSA9IGRhdGEubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdHBvaW50ID0gZGF0YVtpXTtcblx0XHRcdGlmIChwb2ludCAmJiBwb2ludC5kZXN0cm95KSB7XG5cdFx0XHRcdHBvaW50LmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0c2VyaWVzLnBvaW50cyA9IG51bGw7XG5cblx0XHQvLyBDbGVhciB0aGUgYW5pbWF0aW9uIHRpbWVvdXQgaWYgd2UgYXJlIGRlc3Ryb3lpbmcgdGhlIHNlcmllcyBkdXJpbmcgaW5pdGlhbCBhbmltYXRpb25cblx0XHRjbGVhclRpbWVvdXQoc2VyaWVzLmFuaW1hdGlvblRpbWVvdXQpO1xuXG5cdFx0Ly8gRGVzdHJveSBhbGwgU1ZHRWxlbWVudHMgYXNzb2NpYXRlZCB0byB0aGUgc2VyaWVzXG5cdFx0Zm9yIChwcm9wIGluIHNlcmllcykge1xuXHRcdFx0aWYgKHNlcmllc1twcm9wXSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQgJiYgIXNlcmllc1twcm9wXS5zdXJ2aXZlKSB7IC8vIFN1cnZpdmUgcHJvdmlkZXMgYSBob29rIGZvciBub3QgZGVzdHJveWluZ1xuXG5cdFx0XHRcdC8vIGlzc3VlIDEzNCB3b3JrYXJvdW5kXG5cdFx0XHRcdGRlc3Ryb3kgPSBpc3N1ZTEzNCAmJiBwcm9wID09PSAnZ3JvdXAnID9cblx0XHRcdFx0XHQnaGlkZScgOlxuXHRcdFx0XHRcdCdkZXN0cm95JztcblxuXHRcdFx0XHRzZXJpZXNbcHJvcF1bZGVzdHJveV0oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyByZW1vdmUgZnJvbSBob3ZlclNlcmllc1xuXHRcdGlmIChjaGFydC5ob3ZlclNlcmllcyA9PT0gc2VyaWVzKSB7XG5cdFx0XHRjaGFydC5ob3ZlclNlcmllcyA9IG51bGw7XG5cdFx0fVxuXHRcdGVyYXNlKGNoYXJ0LnNlcmllcywgc2VyaWVzKTtcblxuXHRcdC8vIGNsZWFyIGFsbCBtZW1iZXJzXG5cdFx0Zm9yIChwcm9wIGluIHNlcmllcykge1xuXHRcdFx0ZGVsZXRlIHNlcmllc1twcm9wXTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgZ3JhcGggcGF0aCBvZiBhIHNlZ21lbnRcblx0ICovXG5cdGdldFNlZ21lbnRQYXRoOiBmdW5jdGlvbiAoc2VnbWVudCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0c2VnbWVudFBhdGggPSBbXSxcblx0XHRcdHN0ZXAgPSBzZXJpZXMub3B0aW9ucy5zdGVwO1xuXG5cdFx0Ly8gYnVpbGQgdGhlIHNlZ21lbnQgbGluZVxuXHRcdGVhY2goc2VnbWVudCwgZnVuY3Rpb24gKHBvaW50LCBpKSB7XG5cblx0XHRcdHZhciBwbG90WCA9IHBvaW50LnBsb3RYLFxuXHRcdFx0XHRwbG90WSA9IHBvaW50LnBsb3RZLFxuXHRcdFx0XHRsYXN0UG9pbnQ7XG5cblx0XHRcdGlmIChzZXJpZXMuZ2V0UG9pbnRTcGxpbmUpIHsgLy8gZ2VuZXJhdGUgdGhlIHNwbGluZSBhcyBkZWZpbmVkIGluIHRoZSBTcGxpbmVTZXJpZXMgb2JqZWN0XG5cdFx0XHRcdHNlZ21lbnRQYXRoLnB1c2guYXBwbHkoc2VnbWVudFBhdGgsIHNlcmllcy5nZXRQb2ludFNwbGluZShzZWdtZW50LCBwb2ludCwgaSkpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIG1vdmVUbyBvciBsaW5lVG9cblx0XHRcdFx0c2VnbWVudFBhdGgucHVzaChpID8gTCA6IE0pO1xuXG5cdFx0XHRcdC8vIHN0ZXAgbGluZT9cblx0XHRcdFx0aWYgKHN0ZXAgJiYgaSkge1xuXHRcdFx0XHRcdGxhc3RQb2ludCA9IHNlZ21lbnRbaSAtIDFdO1xuXHRcdFx0XHRcdGlmIChzdGVwID09PSAncmlnaHQnKSB7XG5cdFx0XHRcdFx0XHRzZWdtZW50UGF0aC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRsYXN0UG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0XHRcdHBsb3RZLFxuXHRcdFx0XHRcdFx0XHRMXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzdGVwID09PSAnY2VudGVyJykge1xuXHRcdFx0XHRcdFx0c2VnbWVudFBhdGgucHVzaChcblx0XHRcdFx0XHRcdFx0KGxhc3RQb2ludC5wbG90WCArIHBsb3RYKSAvIDIsXG5cdFx0XHRcdFx0XHRcdGxhc3RQb2ludC5wbG90WSxcblx0XHRcdFx0XHRcdFx0TCxcblx0XHRcdFx0XHRcdFx0KGxhc3RQb2ludC5wbG90WCArIHBsb3RYKSAvIDIsXG5cdFx0XHRcdFx0XHRcdHBsb3RZLFxuXHRcdFx0XHRcdFx0XHRMXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlZ21lbnRQYXRoLnB1c2goXG5cdFx0XHRcdFx0XHRcdHBsb3RYLFxuXHRcdFx0XHRcdFx0XHRsYXN0UG9pbnQucGxvdFksXG5cdFx0XHRcdFx0XHRcdExcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbm9ybWFsIGxpbmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRzZWdtZW50UGF0aC5wdXNoKFxuXHRcdFx0XHRcdHBvaW50LnBsb3RYLFxuXHRcdFx0XHRcdHBvaW50LnBsb3RZXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gc2VnbWVudFBhdGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgZ3JhcGggcGF0aFxuXHQgKi9cblx0Z2V0R3JhcGhQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRncmFwaFBhdGggPSBbXSxcblx0XHRcdHNlZ21lbnRQYXRoLFxuXHRcdFx0c2luZ2xlUG9pbnRzID0gW107IC8vIHVzZWQgaW4gZHJhd1RyYWNrZXJcblxuXHRcdC8vIERpdmlkZSBpbnRvIHNlZ21lbnRzIGFuZCBidWlsZCBncmFwaCBhbmQgYXJlYSBwYXRoc1xuXHRcdGVhY2goc2VyaWVzLnNlZ21lbnRzLCBmdW5jdGlvbiAoc2VnbWVudCkge1xuXG5cdFx0XHRzZWdtZW50UGF0aCA9IHNlcmllcy5nZXRTZWdtZW50UGF0aChzZWdtZW50KTtcblxuXHRcdFx0Ly8gYWRkIHRoZSBzZWdtZW50IHRvIHRoZSBncmFwaCwgb3IgYSBzaW5nbGUgcG9pbnQgZm9yIHRyYWNraW5nXG5cdFx0XHRpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdGdyYXBoUGF0aCA9IGdyYXBoUGF0aC5jb25jYXQoc2VnbWVudFBhdGgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2luZ2xlUG9pbnRzLnB1c2goc2VnbWVudFswXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBSZWNvcmQgaXQgZm9yIHVzZSBpbiBkcmF3R3JhcGggYW5kIGRyYXdUcmFja2VyLCBhbmQgcmV0dXJuIGdyYXBoUGF0aFxuXHRcdHNlcmllcy5zaW5nbGVQb2ludHMgPSBzaW5nbGVQb2ludHM7XG5cdFx0c2VyaWVzLmdyYXBoUGF0aCA9IGdyYXBoUGF0aDtcblxuXHRcdHJldHVybiBncmFwaFBhdGg7XG5cblx0fSxcblxuXHQvKipcblx0ICogRHJhdyB0aGUgYWN0dWFsIGdyYXBoXG5cdCAqL1xuXHRkcmF3R3JhcGg6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRwcm9wcyA9IFtbJ2dyYXBoJywgb3B0aW9ucy5saW5lQ29sb3IgfHwgdGhpcy5jb2xvciwgb3B0aW9ucy5kYXNoU3R5bGVdXSxcblx0XHRcdGxpbmVXaWR0aCA9IG9wdGlvbnMubGluZVdpZHRoLFxuXHRcdFx0cm91bmRDYXAgPSBvcHRpb25zLmxpbmVjYXAgIT09ICdzcXVhcmUnLFxuXHRcdFx0Z3JhcGhQYXRoID0gdGhpcy5nZXRHcmFwaFBhdGgoKSxcblx0XHRcdGZpbGxDb2xvciA9ICh0aGlzLmZpbGxHcmFwaCAmJiB0aGlzLmNvbG9yKSB8fCBOT05FLCAvLyBwb2x5Z29uIHNlcmllcyB1c2UgZmlsbGVkIGdyYXBoXG5cdFx0XHR6b25lcyA9IHRoaXMuem9uZXM7XG5cblx0XHRlYWNoKHpvbmVzLCBmdW5jdGlvbiAodGhyZXNob2xkLCBpKSB7XG5cdFx0XHRwcm9wcy5wdXNoKFsnem9uZUdyYXBoJyArIGksIHRocmVzaG9sZC5jb2xvciB8fCBzZXJpZXMuY29sb3IsIHRocmVzaG9sZC5kYXNoU3R5bGUgfHwgb3B0aW9ucy5kYXNoU3R5bGVdKTtcblx0XHR9KTtcblx0XHRcblx0XHQvLyBEcmF3IHRoZSBncmFwaFxuXHRcdGVhY2gocHJvcHMsIGZ1bmN0aW9uIChwcm9wLCBpKSB7XG5cdFx0XHR2YXIgZ3JhcGhLZXkgPSBwcm9wWzBdLFxuXHRcdFx0XHRncmFwaCA9IHNlcmllc1tncmFwaEtleV0sXG5cdFx0XHRcdGF0dHJpYnM7XG5cblx0XHRcdGlmIChncmFwaCkge1xuXHRcdFx0XHRncmFwaC5hbmltYXRlKHsgZDogZ3JhcGhQYXRoIH0pO1xuXG5cdFx0XHR9IGVsc2UgaWYgKChsaW5lV2lkdGggfHwgZmlsbENvbG9yKSAmJiBncmFwaFBhdGgubGVuZ3RoKSB7IC8vICMxNDg3XG5cdFx0XHRcdGF0dHJpYnMgPSB7XG5cdFx0XHRcdFx0c3Ryb2tlOiBwcm9wWzFdLFxuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBsaW5lV2lkdGgsXG5cdFx0XHRcdFx0ZmlsbDogZmlsbENvbG9yLFxuXHRcdFx0XHRcdHpJbmRleDogMSAvLyAjMTA2OVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAocHJvcFsyXSkge1xuXHRcdFx0XHRcdGF0dHJpYnMuZGFzaHN0eWxlID0gcHJvcFsyXTtcblx0XHRcdFx0fSBlbHNlIGlmIChyb3VuZENhcCkge1xuXHRcdFx0XHRcdGF0dHJpYnNbJ3N0cm9rZS1saW5lY2FwJ10gPSBhdHRyaWJzWydzdHJva2UtbGluZWpvaW4nXSA9ICdyb3VuZCc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZXJpZXNbZ3JhcGhLZXldID0gc2VyaWVzLmNoYXJ0LnJlbmRlcmVyLnBhdGgoZ3JhcGhQYXRoKVxuXHRcdFx0XHRcdC5hdHRyKGF0dHJpYnMpXG5cdFx0XHRcdFx0LmFkZChzZXJpZXMuZ3JvdXApXG5cdFx0XHRcdFx0LnNoYWRvdygoaSA8IDIpICYmIG9wdGlvbnMuc2hhZG93KTsgLy8gYWRkIHNoYWRvdyB0byBub3JtYWwgc2VyaWVzICgwKSBvciB0byBmaXJzdCB6b25lICgxKSAjMzkzMlxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDbGlwIHRoZSBncmFwaHMgaW50byB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGNvbG91cmVkIGdyYXBoc1xuXHQgKi9cblx0YXBwbHlab25lczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdHpvbmVzID0gdGhpcy56b25lcyxcblx0XHRcdHRyYW5zbGF0ZWRGcm9tLFxuXHRcdFx0dHJhbnNsYXRlZFRvLFxuXHRcdFx0Y2xpcHMgPSB0aGlzLmNsaXBzIHx8IFtdLFxuXHRcdFx0Y2xpcEF0dHIsXG5cdFx0XHRncmFwaCA9IHRoaXMuZ3JhcGgsXG5cdFx0XHRhcmVhID0gdGhpcy5hcmVhLFxuXHRcdFx0Y2hhcnRTaXplTWF4ID0gbWF0aE1heChjaGFydC5jaGFydFdpZHRoLCBjaGFydC5jaGFydEhlaWdodCksXG5cdFx0XHRheGlzID0gdGhpc1sodGhpcy56b25lQXhpcyB8fCAneScpICsgJ0F4aXMnXSxcblx0XHRcdGV4dHJlbWVzLFxuXHRcdFx0cmV2ZXJzZWQgPSBheGlzLnJldmVyc2VkLFxuXHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZCxcblx0XHRcdGhvcml6ID0gYXhpcy5ob3Jpeixcblx0XHRcdHB4UmFuZ2UsXG5cdFx0XHRweFBvc01pbixcblx0XHRcdHB4UG9zTWF4LFxuXHRcdFx0aWdub3JlWm9uZXMgPSBmYWxzZTtcblxuXHRcdGlmICh6b25lcy5sZW5ndGggJiYgKGdyYXBoIHx8IGFyZWEpICYmIGF4aXMubWluICE9PSBVTkRFRklORUQpIHtcblx0XHRcdC8vIFRoZSB1c2Ugb2YgdGhlIENvbG9yIFRocmVzaG9sZCBhc3N1bWVzIHRoZXJlIGFyZSBubyBnYXBzXG5cdFx0XHQvLyBzbyBpdCBpcyBzYWZlIHRvIGhpZGUgdGhlIG9yaWdpbmFsIGdyYXBoIGFuZCBhcmVhXG5cdFx0XHRpZiAoZ3JhcGgpIHtcblx0XHRcdFx0Z3JhcGguaGlkZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZWEpIHsgXG5cdFx0XHRcdGFyZWEuaGlkZSgpOyBcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBjbGlwc1xuXHRcdFx0ZXh0cmVtZXMgPSBheGlzLmdldEV4dHJlbWVzKCk7XG5cdFx0XHRlYWNoKHpvbmVzLCBmdW5jdGlvbiAodGhyZXNob2xkLCBpKSB7XG5cblx0XHRcdFx0dHJhbnNsYXRlZEZyb20gPSByZXZlcnNlZCA/IFxuXHRcdFx0XHRcdChob3JpeiA/IGNoYXJ0LnBsb3RXaWR0aCA6IDApIDogXG5cdFx0XHRcdFx0KGhvcml6ID8gMCA6IGF4aXMudG9QaXhlbHMoZXh0cmVtZXMubWluKSk7XG5cdFx0XHRcdHRyYW5zbGF0ZWRGcm9tID0gbWF0aE1pbihtYXRoTWF4KHBpY2sodHJhbnNsYXRlZFRvLCB0cmFuc2xhdGVkRnJvbSksIDApLCBjaGFydFNpemVNYXgpO1xuXHRcdFx0XHR0cmFuc2xhdGVkVG8gPSBtYXRoTWluKG1hdGhNYXgobWF0aFJvdW5kKGF4aXMudG9QaXhlbHMocGljayh0aHJlc2hvbGQudmFsdWUsIGV4dHJlbWVzLm1heCksIHRydWUpKSwgMCksIGNoYXJ0U2l6ZU1heCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoaWdub3JlWm9uZXMpIHtcblx0XHRcdFx0XHR0cmFuc2xhdGVkRnJvbSA9IHRyYW5zbGF0ZWRUbyA9IGF4aXMudG9QaXhlbHMoZXh0cmVtZXMubWF4KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHB4UmFuZ2UgPSBNYXRoLmFicyh0cmFuc2xhdGVkRnJvbSAtIHRyYW5zbGF0ZWRUbyk7XG5cdFx0XHRcdHB4UG9zTWluID0gbWF0aE1pbih0cmFuc2xhdGVkRnJvbSwgdHJhbnNsYXRlZFRvKTtcblx0XHRcdFx0cHhQb3NNYXggPSBtYXRoTWF4KHRyYW5zbGF0ZWRGcm9tLCB0cmFuc2xhdGVkVG8pO1xuXHRcdFx0XHRpZiAoYXhpcy5pc1hBeGlzKSB7XG5cdFx0XHRcdFx0Y2xpcEF0dHIgPSB7XG5cdFx0XHRcdFx0XHR4OiBpbnZlcnRlZCA/IHB4UG9zTWF4IDogcHhQb3NNaW4sXG5cdFx0XHRcdFx0XHR5OiAwLFxuXHRcdFx0XHRcdFx0d2lkdGg6IHB4UmFuZ2UsIFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBjaGFydFNpemVNYXhcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGlmICghaG9yaXopIHtcblx0XHRcdFx0XHRcdGNsaXBBdHRyLnggPSBjaGFydC5wbG90SGVpZ2h0IC0gY2xpcEF0dHIueDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2xpcEF0dHIgPSB7XG5cdFx0XHRcdFx0XHR4OiAwLFxuXHRcdFx0XHRcdFx0eTogaW52ZXJ0ZWQgPyBweFBvc01heCA6IHB4UG9zTWluLFxuXHRcdFx0XHRcdFx0d2lkdGg6IGNoYXJ0U2l6ZU1heCwgXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IHB4UmFuZ2Vcblx0XHRcdFx0XHR9O1x0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoaG9yaXopIHtcblx0XHRcdFx0XHRcdGNsaXBBdHRyLnkgPSBjaGFydC5wbG90V2lkdGggLSBjbGlwQXR0ci55O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vLyBWTUwgU1VQUFBPUlRcblx0XHRcdFx0aWYgKGNoYXJ0LmludmVydGVkICYmIHJlbmRlcmVyLmlzVk1MKSB7XG5cdFx0XHRcdFx0aWYgKGF4aXMuaXNYQXhpcykge1x0XHRcdFxuXHRcdFx0XHRcdFx0Y2xpcEF0dHIgPSB7XG5cdFx0XHRcdFx0XHRcdHg6IDAsXG5cdFx0XHRcdFx0XHRcdHk6IHJldmVyc2VkID8gcHhQb3NNaW4gOiBweFBvc01heCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBjbGlwQXR0ci53aWR0aCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IGNoYXJ0LmNoYXJ0V2lkdGhcblx0XHRcdFx0XHRcdH07XHRcdFxuXHRcdFx0XHRcdH0gZWxzZSB7XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNsaXBBdHRyID0ge1xuXHRcdFx0XHRcdFx0XHR4OiBjbGlwQXR0ci55IC0gY2hhcnQucGxvdExlZnQgLSBjaGFydC5zcGFjaW5nQm94LngsXG5cdFx0XHRcdFx0XHRcdHk6IDAsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBjbGlwQXR0ci5oZWlnaHQsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogY2hhcnQuY2hhcnRIZWlnaHRcblx0XHRcdFx0XHRcdH07XHRcblx0XHRcdFx0XHR9XHRcdFx0XHRcblx0XHRcdFx0fVxuXHRcdFx0XHQvLy8gRU5EIE9GIFZNTCBTVVBQT1JUXG5cblx0XHRcdFx0aWYgKGNsaXBzW2ldKSB7XG5cdFx0XHRcdFx0Y2xpcHNbaV0uYW5pbWF0ZShjbGlwQXR0cik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2xpcHNbaV0gPSByZW5kZXJlci5jbGlwUmVjdChjbGlwQXR0cik7XG5cblx0XHRcdFx0XHRpZiAoZ3JhcGgpIHtcblx0XHRcdFx0XHRcdHNlcmllc1snem9uZUdyYXBoJyArIGldLmNsaXAoY2xpcHNbaV0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChhcmVhKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXNbJ3pvbmVBcmVhJyArIGldLmNsaXAoY2xpcHNbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiB0aGlzIHpvbmUgZXh0ZW5kcyBvdXQgb2YgdGhlIGF4aXMsIGlnbm9yZSB0aGUgb3RoZXJzXG5cdFx0XHRcdGlnbm9yZVpvbmVzID0gdGhyZXNob2xkLnZhbHVlID4gZXh0cmVtZXMubWF4O1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmNsaXBzID0gY2xpcHM7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGFuZCBwZXJmb3JtIGdyb3VwIGludmVyc2lvbiBvbiBzZXJpZXMuZ3JvdXAgYW5kIHNlcmllcy5tYXJrZXJHcm91cFxuXHQgKi9cblx0aW52ZXJ0R3JvdXBzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydDtcblxuXHRcdC8vIFBpZSwgZ28gYXdheSAoIzE3MzYpXG5cdFx0aWYgKCFzZXJpZXMueEF4aXMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBBIGZpeGVkIHNpemUgaXMgbmVlZGVkIGZvciBpbnZlcnNpb24gdG8gd29ya1xuXHRcdGZ1bmN0aW9uIHNldEludmVydCgpIHtcblx0XHRcdHZhciBzaXplID0ge1xuXHRcdFx0XHR3aWR0aDogc2VyaWVzLnlBeGlzLmxlbixcblx0XHRcdFx0aGVpZ2h0OiBzZXJpZXMueEF4aXMubGVuXG5cdFx0XHR9O1xuXG5cdFx0XHRlYWNoKFsnZ3JvdXAnLCAnbWFya2VyR3JvdXAnXSwgZnVuY3Rpb24gKGdyb3VwTmFtZSkge1xuXHRcdFx0XHRpZiAoc2VyaWVzW2dyb3VwTmFtZV0pIHtcblx0XHRcdFx0XHRzZXJpZXNbZ3JvdXBOYW1lXS5hdHRyKHNpemUpLmludmVydCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRhZGRFdmVudChjaGFydCwgJ3Jlc2l6ZScsIHNldEludmVydCk7IC8vIGRvIGl0IG9uIHJlc2l6ZVxuXHRcdGFkZEV2ZW50KHNlcmllcywgJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVFdmVudChjaGFydCwgJ3Jlc2l6ZScsIHNldEludmVydCk7XG5cdFx0fSk7XG5cblx0XHQvLyBEbyBpdCBub3dcblx0XHRzZXRJbnZlcnQoKTsgLy8gZG8gaXQgbm93XG5cblx0XHQvLyBPbiBzdWJzZXF1ZW50IHJlbmRlciBhbmQgcmVkcmF3LCBqdXN0IGRvIHNldEludmVydCB3aXRob3V0IHNldHRpbmcgdXAgZXZlbnRzIGFnYWluXG5cdFx0c2VyaWVzLmludmVydEdyb3VwcyA9IHNldEludmVydDtcblx0fSxcblxuXHQvKipcblx0ICogR2VuZXJhbCBhYnN0cmFjdGlvbiBmb3IgY3JlYXRpbmcgcGxvdCBncm91cHMgbGlrZSBzZXJpZXMuZ3JvdXAsIHNlcmllcy5kYXRhTGFiZWxzR3JvdXAgYW5kXG5cdCAqIHNlcmllcy5tYXJrZXJHcm91cC4gT24gc3Vic2VxdWVudCBjYWxscywgdGhlIGdyb3VwIHdpbGwgb25seSBiZSBhZGp1c3RlZCB0byB0aGUgdXBkYXRlZCBwbG90IHNpemUuXG5cdCAqL1xuXHRwbG90R3JvdXA6IGZ1bmN0aW9uIChwcm9wLCBuYW1lLCB2aXNpYmlsaXR5LCB6SW5kZXgsIHBhcmVudCkge1xuXHRcdHZhciBncm91cCA9IHRoaXNbcHJvcF0sXG5cdFx0XHRpc05ldyA9ICFncm91cDtcblxuXHRcdC8vIEdlbmVyYXRlIGl0IG9uIGZpcnN0IGNhbGxcblx0XHRpZiAoaXNOZXcpIHtcblx0XHRcdHRoaXNbcHJvcF0gPSBncm91cCA9IHRoaXMuY2hhcnQucmVuZGVyZXIuZyhuYW1lKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0dmlzaWJpbGl0eTogdmlzaWJpbGl0eSxcblx0XHRcdFx0XHR6SW5kZXg6IHpJbmRleCB8fCAwLjEgLy8gSUU4IG5lZWRzIHRoaXNcblx0XHRcdFx0fSlcblx0XHRcdFx0LmFkZChwYXJlbnQpO1xuXG5cdFx0XHRncm91cC5hZGRDbGFzcygnaGlnaGNoYXJ0cy1zZXJpZXMtJyArIHRoaXMuaW5kZXgpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBQbGFjZSBpdCBvbiBmaXJzdCBhbmQgc3Vic2VxdWVudCAocmVkcmF3KSBjYWxsc1xuXHRcdGdyb3VwW2lzTmV3ID8gJ2F0dHInIDogJ2FuaW1hdGUnXSh0aGlzLmdldFBsb3RCb3goKSk7XG5cdFx0cmV0dXJuIGdyb3VwO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHRyYW5zbGF0aW9uIGFuZCBzY2FsZSBmb3IgdGhlIHBsb3QgYXJlYSBvZiB0aGlzIHNlcmllc1xuXHQgKi9cblx0Z2V0UGxvdEJveDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHR4QXhpcyA9IHRoaXMueEF4aXMsXG5cdFx0XHR5QXhpcyA9IHRoaXMueUF4aXM7XG5cblx0XHQvLyBTd2FwIGF4ZXMgZm9yIGludmVydGVkICgjMjMzOSlcblx0XHRpZiAoY2hhcnQuaW52ZXJ0ZWQpIHtcblx0XHRcdHhBeGlzID0geUF4aXM7XG5cdFx0XHR5QXhpcyA9IHRoaXMueEF4aXM7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHR0cmFuc2xhdGVYOiB4QXhpcyA/IHhBeGlzLmxlZnQgOiBjaGFydC5wbG90TGVmdCxcblx0XHRcdHRyYW5zbGF0ZVk6IHlBeGlzID8geUF4aXMudG9wIDogY2hhcnQucGxvdFRvcCxcblx0XHRcdHNjYWxlWDogMSwgLy8gIzE2MjNcblx0XHRcdHNjYWxlWTogMVxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbmRlciB0aGUgZ3JhcGggYW5kIG1hcmtlcnNcblx0ICovXG5cdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRncm91cCxcblx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdGFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLFxuXHRcdFx0Ly8gQW5pbWF0aW9uIGRvZXNuJ3Qgd29yayBpbiBJRTggcXVpcmtzIHdoZW4gdGhlIGdyb3VwIGRpdiBpcyBoaWRkZW4sXG5cdFx0XHQvLyBhbmQgbG9va3MgYmFkIGluIG90aGVyIG9sZElFXG5cdFx0XHRhbmltRHVyYXRpb24gPSAoYW5pbWF0aW9uICYmICEhc2VyaWVzLmFuaW1hdGUgJiYgY2hhcnQucmVuZGVyZXIuaXNTVkcgJiYgcGljayhhbmltYXRpb24uZHVyYXRpb24sIDUwMCkpIHx8IDAsXG5cdFx0XHR2aXNpYmlsaXR5ID0gc2VyaWVzLnZpc2libGUgPyBWSVNJQkxFIDogSElEREVOLFxuXHRcdFx0ekluZGV4ID0gb3B0aW9ucy56SW5kZXgsXG5cdFx0XHRoYXNSZW5kZXJlZCA9IHNlcmllcy5oYXNSZW5kZXJlZCxcblx0XHRcdGNoYXJ0U2VyaWVzR3JvdXAgPSBjaGFydC5zZXJpZXNHcm91cDtcblxuXHRcdC8vIHRoZSBncm91cFxuXHRcdGdyb3VwID0gc2VyaWVzLnBsb3RHcm91cChcblx0XHRcdCdncm91cCcsXG5cdFx0XHQnc2VyaWVzJyxcblx0XHRcdHZpc2liaWxpdHksXG5cdFx0XHR6SW5kZXgsXG5cdFx0XHRjaGFydFNlcmllc0dyb3VwXG5cdFx0KTtcblxuXHRcdHNlcmllcy5tYXJrZXJHcm91cCA9IHNlcmllcy5wbG90R3JvdXAoXG5cdFx0XHQnbWFya2VyR3JvdXAnLFxuXHRcdFx0J21hcmtlcnMnLFxuXHRcdFx0dmlzaWJpbGl0eSxcblx0XHRcdHpJbmRleCxcblx0XHRcdGNoYXJ0U2VyaWVzR3JvdXBcblx0XHQpO1xuXG5cdFx0Ly8gaW5pdGlhdGUgdGhlIGFuaW1hdGlvblxuXHRcdGlmIChhbmltRHVyYXRpb24pIHtcblx0XHRcdHNlcmllcy5hbmltYXRlKHRydWUpO1xuXHRcdH1cblxuXHRcdC8vIGNhY2hlIGF0dHJpYnV0ZXMgZm9yIHNoYXBlc1xuXHRcdHNlcmllcy5nZXRBdHRyaWJzKCk7XG5cblx0XHQvLyBTVkdSZW5kZXJlciBuZWVkcyB0byBrbm93IHRoaXMgYmVmb3JlIGRyYXdpbmcgZWxlbWVudHMgKCMxMDg5LCAjMTc5NSlcblx0XHRncm91cC5pbnZlcnRlZCA9IHNlcmllcy5pc0NhcnRlc2lhbiA/IGNoYXJ0LmludmVydGVkIDogZmFsc2U7XG5cblx0XHQvLyBkcmF3IHRoZSBncmFwaCBpZiBhbnlcblx0XHRpZiAoc2VyaWVzLmRyYXdHcmFwaCkge1xuXHRcdFx0c2VyaWVzLmRyYXdHcmFwaCgpO1xuXHRcdFx0c2VyaWVzLmFwcGx5Wm9uZXMoKTtcblx0XHR9XG5cblx0XHRlYWNoKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0aWYgKHBvaW50LnJlZHJhdykge1xuXHRcdFx0XHRwb2ludC5yZWRyYXcoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGRyYXcgdGhlIGRhdGEgbGFiZWxzIChpbm4gcGllcyB0aGV5IGdvIGJlZm9yZSB0aGUgcG9pbnRzKVxuXHRcdGlmIChzZXJpZXMuZHJhd0RhdGFMYWJlbHMpIHtcblx0XHRcdHNlcmllcy5kcmF3RGF0YUxhYmVscygpO1xuXHRcdH1cblxuXHRcdC8vIGRyYXcgdGhlIHBvaW50c1xuXHRcdGlmIChzZXJpZXMudmlzaWJsZSkge1xuXHRcdFx0c2VyaWVzLmRyYXdQb2ludHMoKTtcblx0XHR9XG5cblxuXHRcdC8vIGRyYXcgdGhlIG1vdXNlIHRyYWNraW5nIGFyZWFcblx0XHRpZiAoc2VyaWVzLmRyYXdUcmFja2VyICYmIHNlcmllcy5vcHRpb25zLmVuYWJsZU1vdXNlVHJhY2tpbmcgIT09IGZhbHNlKSB7XG5cdFx0XHRzZXJpZXMuZHJhd1RyYWNrZXIoKTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgaW52ZXJ0ZWQgc2VyaWVzIGFuZCB0cmFja2VyIGdyb3Vwc1xuXHRcdGlmIChjaGFydC5pbnZlcnRlZCkge1xuXHRcdFx0c2VyaWVzLmludmVydEdyb3VwcygpO1xuXHRcdH1cblxuXHRcdC8vIEluaXRpYWwgY2xpcHBpbmcsIG11c3QgYmUgZGVmaW5lZCBhZnRlciBpbnZlcnRpbmcgZ3JvdXBzIGZvciBWTUwuIEFwcGxpZXMgdG8gY29sdW1ucyBldGMuICgjMzgzOSkuXG5cdFx0aWYgKG9wdGlvbnMuY2xpcCAhPT0gZmFsc2UgJiYgIXNlcmllcy5zaGFyZWRDbGlwS2V5ICYmICFoYXNSZW5kZXJlZCkge1xuXHRcdFx0Z3JvdXAuY2xpcChjaGFydC5jbGlwUmVjdCk7XG5cdFx0fVxuXG5cdFx0Ly8gUnVuIHRoZSBhbmltYXRpb25cblx0XHRpZiAoYW5pbUR1cmF0aW9uKSB7XG5cdFx0XHRzZXJpZXMuYW5pbWF0ZSgpO1xuXHRcdH0gXG5cblx0XHQvLyBDYWxsIHRoZSBhZnRlckFuaW1hdGUgZnVuY3Rpb24gb24gYW5pbWF0aW9uIGNvbXBsZXRlIChidXQgZG9uJ3Qgb3ZlcndyaXRlIHRoZSBhbmltYXRpb24uY29tcGxldGUgb3B0aW9uXG5cdFx0Ly8gd2hpY2ggc2hvdWxkIGJlIGF2YWlsYWJsZSB0byB0aGUgdXNlcikuXG5cdFx0aWYgKCFoYXNSZW5kZXJlZCkge1xuXHRcdFx0aWYgKGFuaW1EdXJhdGlvbikge1xuXHRcdFx0XHRzZXJpZXMuYW5pbWF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHNlcmllcy5hZnRlckFuaW1hdGUoKTtcblx0XHRcdFx0fSwgYW5pbUR1cmF0aW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlcmllcy5hZnRlckFuaW1hdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXJpZXMuaXNEaXJ0eSA9IHNlcmllcy5pc0RpcnR5RGF0YSA9IGZhbHNlOyAvLyBtZWFucyBkYXRhIGlzIGluIGFjY29yZGFuY2Ugd2l0aCB3aGF0IHlvdSBzZWVcblx0XHQvLyAoU2VlICMzMjIpIHNlcmllcy5pc0RpcnR5ID0gc2VyaWVzLmlzRGlydHlEYXRhID0gZmFsc2U7IC8vIG1lYW5zIGRhdGEgaXMgaW4gYWNjb3JkYW5jZSB3aXRoIHdoYXQgeW91IHNlZVxuXHRcdHNlcmllcy5oYXNSZW5kZXJlZCA9IHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZHJhdyB0aGUgc2VyaWVzIGFmdGVyIGFuIHVwZGF0ZSBpbiB0aGUgYXhlcy5cblx0ICovXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHR3YXNEaXJ0eURhdGEgPSBzZXJpZXMuaXNEaXJ0eURhdGEsIC8vIGNhY2hlIGl0IGhlcmUgYXMgaXQgaXMgc2V0IHRvIGZhbHNlIGluIHJlbmRlciwgYnV0IHVzZWQgYWZ0ZXJcblx0XHRcdHdhc0RpcnR5ID0gc2VyaWVzLmlzRGlydHksXG5cdFx0XHRncm91cCA9IHNlcmllcy5ncm91cCxcblx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0eUF4aXMgPSBzZXJpZXMueUF4aXM7XG5cblx0XHQvLyByZXBvc2l0aW9uIG9uIHJlc2l6ZVxuXHRcdGlmIChncm91cCkge1xuXHRcdFx0aWYgKGNoYXJ0LmludmVydGVkKSB7XG5cdFx0XHRcdGdyb3VwLmF0dHIoe1xuXHRcdFx0XHRcdHdpZHRoOiBjaGFydC5wbG90V2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBjaGFydC5wbG90SGVpZ2h0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRncm91cC5hbmltYXRlKHtcblx0XHRcdFx0dHJhbnNsYXRlWDogcGljayh4QXhpcyAmJiB4QXhpcy5sZWZ0LCBjaGFydC5wbG90TGVmdCksXG5cdFx0XHRcdHRyYW5zbGF0ZVk6IHBpY2soeUF4aXMgJiYgeUF4aXMudG9wLCBjaGFydC5wbG90VG9wKVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0c2VyaWVzLnRyYW5zbGF0ZSgpO1xuXHRcdHNlcmllcy5yZW5kZXIoKTtcblx0XHRpZiAod2FzRGlydHlEYXRhKSB7XG5cdFx0XHRmaXJlRXZlbnQoc2VyaWVzLCAndXBkYXRlZERhdGEnKTtcblx0XHR9XG5cdFx0aWYgKHdhc0RpcnR5IHx8IHdhc0RpcnR5RGF0YSkge1x0XHRcdC8vICMzOTQ1IHJlY2FsY3VsYXRlIHRoZSBrZHRyZWUgd2hlbiBkaXJ0eVxuXHRcdFx0ZGVsZXRlIHRoaXMua2RUcmVlOyAvLyAjMzg2OCByZWNhbGN1bGF0ZSB0aGUga2R0cmVlIHdpdGggZGlydHkgZGF0YVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogS0QgVHJlZSAmJiBQb2ludFNlYXJjaGluZyBJbXBsZW1lbnRhdGlvblxuXHQgKi9cblxuXHRrZERpbWVuc2lvbnM6IDEsXG5cdGtkQXhpc0FycmF5OiBbJ2NsaWVudFgnLCAncGxvdFknXSxcblxuXHRzZWFyY2hQb2ludDogZnVuY3Rpb24gKGUsIGNvbXBhcmVYKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHR4QXhpcyA9IHNlcmllcy54QXhpcyxcblx0XHRcdHlBeGlzID0gc2VyaWVzLnlBeGlzLFxuXHRcdFx0aW52ZXJ0ZWQgPSBzZXJpZXMuY2hhcnQuaW52ZXJ0ZWQ7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuc2VhcmNoS0RUcmVlKHtcblx0XHRcdGNsaWVudFg6IGludmVydGVkID8geEF4aXMubGVuIC0gZS5jaGFydFkgKyB4QXhpcy5wb3MgOiBlLmNoYXJ0WCAtIHhBeGlzLnBvcyxcblx0XHRcdHBsb3RZOiBpbnZlcnRlZCA/IHlBeGlzLmxlbiAtIGUuY2hhcnRYICsgeUF4aXMucG9zIDogZS5jaGFydFkgLSB5QXhpcy5wb3Ncblx0XHR9LCBjb21wYXJlWCk7XG5cdH0sXG5cblx0YnVpbGRLRFRyZWU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdGRpbWVuc2lvbnMgPSBzZXJpZXMua2REaW1lbnNpb25zO1xuXG5cdFx0Ly8gSW50ZXJuYWwgZnVuY3Rpb25cblx0XHRmdW5jdGlvbiBfa2R0cmVlKHBvaW50cywgZGVwdGgsIGRpbWVuc2lvbnMpIHtcblx0XHRcdHZhciBheGlzLCBtZWRpYW4sIGxlbmd0aCA9IHBvaW50cyAmJiBwb2ludHMubGVuZ3RoO1xuXG5cdFx0XHRpZiAobGVuZ3RoKSB7XG5cblx0XHRcdFx0Ly8gYWx0ZXJuYXRlIGJldHdlZW4gdGhlIGF4aXNcblx0XHRcdFx0YXhpcyA9IHNlcmllcy5rZEF4aXNBcnJheVtkZXB0aCAlIGRpbWVuc2lvbnNdO1xuXG5cdFx0XHRcdC8vIHNvcnQgcG9pbnQgYXJyYXlcblx0XHRcdFx0cG9pbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdHJldHVybiBhW2F4aXNdIC0gYltheGlzXTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdFx0bWVkaWFuID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGJ1aWxkIGFuZCByZXR1cm4gbm9kXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0cG9pbnQ6IHBvaW50c1ttZWRpYW5dLFxuXHRcdFx0XHRcdGxlZnQ6IF9rZHRyZWUocG9pbnRzLnNsaWNlKDAsIG1lZGlhbiksIGRlcHRoICsgMSwgZGltZW5zaW9ucyksXG5cdFx0XHRcdFx0cmlnaHQ6IF9rZHRyZWUocG9pbnRzLnNsaWNlKG1lZGlhbiArIDEpLCBkZXB0aCArIDEsIGRpbWVuc2lvbnMpXG5cdFx0XHRcdH07XG5cdFx0XHRcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdGFydCB0aGUgcmVjdXJzaXZlIGJ1aWxkIHByb2Nlc3Mgd2l0aCBhIGNsb25lIG9mIHRoZSBwb2ludHMgYXJyYXkgYW5kIG51bGwgcG9pbnRzIGZpbHRlcmVkIG91dCAoIzM4NzMpXG5cdFx0ZnVuY3Rpb24gc3RhcnRSZWN1cnNpdmUoKSB7XG5cdFx0XHR2YXIgcG9pbnRzID0gZ3JlcChzZXJpZXMucG9pbnRzIHx8IFtdLCBmdW5jdGlvbiAocG9pbnQpIHsgLy8gIzQzOTBcblx0XHRcdFx0cmV0dXJuIHBvaW50LnkgIT09IG51bGw7XG5cdFx0XHR9KTtcblxuXHRcdFx0c2VyaWVzLmtkVHJlZSA9IF9rZHRyZWUocG9pbnRzLCBkaW1lbnNpb25zLCBkaW1lbnNpb25zKTtcblx0XHR9XG5cdFx0ZGVsZXRlIHNlcmllcy5rZFRyZWU7XG5cdFx0XG5cdFx0aWYgKHNlcmllcy5vcHRpb25zLmtkU3luYykgeyAgLy8gRm9yIHRlc3RpbmcgdG9vbHRpcHMsIGRvbid0IGJ1aWxkIGFzeW5jXG5cdFx0XHRzdGFydFJlY3Vyc2l2ZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZXRUaW1lb3V0KHN0YXJ0UmVjdXJzaXZlKTtcblx0XHR9XG5cdH0sXG5cblx0c2VhcmNoS0RUcmVlOiBmdW5jdGlvbiAocG9pbnQsIGNvbXBhcmVYKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRrZFggPSB0aGlzLmtkQXhpc0FycmF5WzBdLFxuXHRcdFx0a2RZID0gdGhpcy5rZEF4aXNBcnJheVsxXSxcblx0XHRcdGtkQ29tcGFyZXIgPSBjb21wYXJlWCA/ICdkaXN0WCcgOiAnZGlzdCc7XG5cblx0XHQvLyBTZXQgdGhlIG9uZSBhbmQgdHdvIGRpbWVuc2lvbmFsIGRpc3RhbmNlIG9uIHRoZSBwb2ludCBvYmplY3Rcblx0XHRmdW5jdGlvbiBzZXREaXN0YW5jZShwMSwgcDIpIHtcblx0XHRcdHZhciB4ID0gKGRlZmluZWQocDFba2RYXSkgJiYgZGVmaW5lZChwMltrZFhdKSkgPyBNYXRoLnBvdyhwMVtrZFhdIC0gcDJba2RYXSwgMikgOiBudWxsLFxuXHRcdFx0XHR5ID0gKGRlZmluZWQocDFba2RZXSkgJiYgZGVmaW5lZChwMltrZFldKSkgPyBNYXRoLnBvdyhwMVtrZFldIC0gcDJba2RZXSwgMikgOiBudWxsLFxuXHRcdFx0XHRyID0gKHggfHwgMCkgKyAoeSB8fCAwKTtcblxuXHRcdFx0cDIuZGlzdCA9IGRlZmluZWQocikgPyBNYXRoLnNxcnQocikgOiBOdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdFx0cDIuZGlzdFggPSBkZWZpbmVkKHgpID8gTWF0aC5zcXJ0KHgpIDogTnVtYmVyLk1BWF9WQUxVRTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gX3NlYXJjaChzZWFyY2gsIHRyZWUsIGRlcHRoLCBkaW1lbnNpb25zKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0cmVlLnBvaW50LFxuXHRcdFx0XHRheGlzID0gc2VyaWVzLmtkQXhpc0FycmF5W2RlcHRoICUgZGltZW5zaW9uc10sXG5cdFx0XHRcdHRkaXN0LFxuXHRcdFx0XHRzaWRlQSxcblx0XHRcdFx0c2lkZUIsXG5cdFx0XHRcdHJldCA9IHBvaW50LFxuXHRcdFx0XHRuUG9pbnQxLFxuXHRcdFx0XHRuUG9pbnQyO1xuXHRcdFx0XG5cdFx0XHRzZXREaXN0YW5jZShzZWFyY2gsIHBvaW50KTtcblxuXHRcdFx0Ly8gUGljayBzaWRlIGJhc2VkIG9uIGRpc3RhbmNlIHRvIHNwbGl0dGluZyBwb2ludFxuXHRcdFx0dGRpc3QgPSBzZWFyY2hbYXhpc10gLSBwb2ludFtheGlzXTtcblx0XHRcdHNpZGVBID0gdGRpc3QgPCAwID8gJ2xlZnQnIDogJ3JpZ2h0Jztcblx0XHRcdHNpZGVCID0gdGRpc3QgPCAwID8gJ3JpZ2h0JyA6ICdsZWZ0JztcblxuXHRcdFx0Ly8gRW5kIG9mIHRyZWVcblx0XHRcdGlmICh0cmVlW3NpZGVBXSkge1xuXHRcdFx0XHRuUG9pbnQxID1fc2VhcmNoKHNlYXJjaCwgdHJlZVtzaWRlQV0sIGRlcHRoICsgMSwgZGltZW5zaW9ucyk7XG5cblx0XHRcdFx0cmV0ID0gKG5Qb2ludDFba2RDb21wYXJlcl0gPCByZXRba2RDb21wYXJlcl0gPyBuUG9pbnQxIDogcG9pbnQpO1xuXHRcdFx0fSBcblx0XHRcdGlmICh0cmVlW3NpZGVCXSkge1xuXHRcdFx0XHQvLyBjb21wYXJlIGRpc3RhbmNlIHRvIGN1cnJlbnQgYmVzdCB0byBzcGxpdHRpbmcgcG9pbnQgdG8gZGVjaWRlIHdldGhlciB0byBjaGVjayBzaWRlIEIgb3Igbm90XG5cdFx0XHRcdGlmIChNYXRoLnNxcnQodGRpc3QgKiB0ZGlzdCkgPCByZXRba2RDb21wYXJlcl0pIHtcblx0XHRcdFx0XHRuUG9pbnQyID0gX3NlYXJjaChzZWFyY2gsIHRyZWVbc2lkZUJdLCBkZXB0aCArIDEsIGRpbWVuc2lvbnMpO1xuXHRcdFx0XHRcdHJldCA9IChuUG9pbnQyW2tkQ29tcGFyZXJdIDwgcmV0W2tkQ29tcGFyZXJdID8gblBvaW50MiA6IHJldCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMua2RUcmVlKSB7XG5cdFx0XHR0aGlzLmJ1aWxkS0RUcmVlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMua2RUcmVlKSB7XG5cdFx0XHRyZXR1cm4gX3NlYXJjaChwb2ludCwgXG5cdFx0XHRcdHRoaXMua2RUcmVlLCB0aGlzLmtkRGltZW5zaW9ucywgdGhpcy5rZERpbWVuc2lvbnMpO1xuXHRcdH1cblx0fVxuXG59OyAvLyBlbmQgU2VyaWVzIHByb3RvdHlwZVxuXG4vKipcbiAqIFRoZSBjbGFzcyBmb3Igc3RhY2sgaXRlbXNcbiAqL1xuZnVuY3Rpb24gU3RhY2tJdGVtKGF4aXMsIG9wdGlvbnMsIGlzTmVnYXRpdmUsIHgsIHN0YWNrT3B0aW9uKSB7XG5cdFxuXHR2YXIgaW52ZXJ0ZWQgPSBheGlzLmNoYXJ0LmludmVydGVkO1xuXG5cdHRoaXMuYXhpcyA9IGF4aXM7XG5cblx0Ly8gVGVsbHMgaWYgdGhlIHN0YWNrIGlzIG5lZ2F0aXZlXG5cdHRoaXMuaXNOZWdhdGl2ZSA9IGlzTmVnYXRpdmU7XG5cblx0Ly8gU2F2ZSB0aGUgb3B0aW9ucyB0byBiZSBhYmxlIHRvIHN0eWxlIHRoZSBsYWJlbFxuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5cdC8vIFNhdmUgdGhlIHggdmFsdWUgdG8gYmUgYWJsZSB0byBwb3NpdGlvbiB0aGUgbGFiZWwgbGF0ZXJcblx0dGhpcy54ID0geDtcblxuXHQvLyBJbml0aWFsaXplIHRvdGFsIHZhbHVlXG5cdHRoaXMudG90YWwgPSBudWxsO1xuXG5cdC8vIFRoaXMgd2lsbCBrZWVwIGVhY2ggcG9pbnRzJyBleHRyZW1lcyBzdG9yZWQgYnkgc2VyaWVzLmluZGV4IGFuZCBwb2ludCBpbmRleFxuXHR0aGlzLnBvaW50cyA9IHt9O1xuXG5cdC8vIFNhdmUgdGhlIHN0YWNrIG9wdGlvbiBvbiB0aGUgc2VyaWVzIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBhbmQgd2hldGhlciB0byB0cmVhdCBpdCBhcyBwZXJjZW50XG5cdHRoaXMuc3RhY2sgPSBzdGFja09wdGlvbjtcblxuXHQvLyBUaGUgYWxpZ24gb3B0aW9ucyBhbmQgdGV4dCBhbGlnbiB2YXJpZXMgb24gd2hldGhlciB0aGUgc3RhY2sgaXMgbmVnYXRpdmUgYW5kXG5cdC8vIGlmIHRoZSBjaGFydCBpcyBpbnZlcnRlZCBvciBub3QuXG5cdC8vIEZpcnN0IHRlc3QgdGhlIHVzZXIgc3VwcGxpZWQgdmFsdWUsIHRoZW4gdXNlIHRoZSBkeW5hbWljLlxuXHR0aGlzLmFsaWduT3B0aW9ucyA9IHtcblx0XHRhbGlnbjogb3B0aW9ucy5hbGlnbiB8fCAoaW52ZXJ0ZWQgPyAoaXNOZWdhdGl2ZSA/ICdsZWZ0JyA6ICdyaWdodCcpIDogJ2NlbnRlcicpLFxuXHRcdHZlcnRpY2FsQWxpZ246IG9wdGlvbnMudmVydGljYWxBbGlnbiB8fCAoaW52ZXJ0ZWQgPyAnbWlkZGxlJyA6IChpc05lZ2F0aXZlID8gJ2JvdHRvbScgOiAndG9wJykpLFxuXHRcdHk6IHBpY2sob3B0aW9ucy55LCBpbnZlcnRlZCA/IDQgOiAoaXNOZWdhdGl2ZSA/IDE0IDogLTYpKSxcblx0XHR4OiBwaWNrKG9wdGlvbnMueCwgaW52ZXJ0ZWQgPyAoaXNOZWdhdGl2ZSA/IC02IDogNikgOiAwKVxuXHR9O1xuXG5cdHRoaXMudGV4dEFsaWduID0gb3B0aW9ucy50ZXh0QWxpZ24gfHwgKGludmVydGVkID8gKGlzTmVnYXRpdmUgPyAncmlnaHQnIDogJ2xlZnQnKSA6ICdjZW50ZXInKTtcbn1cblxuU3RhY2tJdGVtLnByb3RvdHlwZSA9IHtcblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHRoaXMsIHRoaXMuYXhpcyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbmRlcnMgdGhlIHN0YWNrIHRvdGFsIGxhYmVsIGFuZCBhZGRzIGl0IHRvIHRoZSBzdGFjayBsYWJlbCBncm91cC5cblx0ICovXG5cdHJlbmRlcjogZnVuY3Rpb24gKGdyb3VwKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRmb3JtYXRPcHRpb24gPSBvcHRpb25zLmZvcm1hdCxcblx0XHRcdHN0ciA9IGZvcm1hdE9wdGlvbiA/XG5cdFx0XHRcdGZvcm1hdChmb3JtYXRPcHRpb24sIHRoaXMpIDogXG5cdFx0XHRcdG9wdGlvbnMuZm9ybWF0dGVyLmNhbGwodGhpcyk7ICAvLyBmb3JtYXQgdGhlIHRleHQgaW4gdGhlIGxhYmVsXG5cblx0XHQvLyBDaGFuZ2UgdGhlIHRleHQgdG8gcmVmbGVjdCB0aGUgbmV3IHRvdGFsIGFuZCBzZXQgdmlzaWJpbGl0eSB0byBoaWRkZW4gaW4gY2FzZSB0aGUgc2VyaWUgaXMgaGlkZGVuXG5cdFx0aWYgKHRoaXMubGFiZWwpIHtcblx0XHRcdHRoaXMubGFiZWwuYXR0cih7dGV4dDogc3RyLCB2aXNpYmlsaXR5OiBISURERU59KTtcblx0XHQvLyBDcmVhdGUgbmV3IGxhYmVsXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubGFiZWwgPVxuXHRcdFx0XHR0aGlzLmF4aXMuY2hhcnQucmVuZGVyZXIudGV4dChzdHIsIG51bGwsIG51bGwsIG9wdGlvbnMudXNlSFRNTClcdFx0Ly8gZHVtbXkgcG9zaXRpb25zLCBhY3R1YWwgcG9zaXRpb24gdXBkYXRlZCB3aXRoIHNldE9mZnNldCBtZXRob2QgaW4gY29sdW1uc2VyaWVzXG5cdFx0XHRcdFx0LmNzcyhvcHRpb25zLnN0eWxlKVx0XHRcdFx0Ly8gYXBwbHkgc3R5bGVcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRhbGlnbjogdGhpcy50ZXh0QWxpZ24sXHRcdFx0XHQvLyBmaXggdGhlIHRleHQtYW5jaG9yXG5cdFx0XHRcdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcdC8vIHJvdGF0aW9uXG5cdFx0XHRcdFx0XHR2aXNpYmlsaXR5OiBISURERU5cdFx0XHRcdFx0Ly8gaGlkZGVuIHVudGlsIHNldE9mZnNldCBpcyBjYWxsZWRcblx0XHRcdFx0XHR9KVx0XHRcdFx0XG5cdFx0XHRcdFx0LmFkZChncm91cCk7XHRcdFx0XHRcdFx0XHQvLyBhZGQgdG8gdGhlIGxhYmVscy1ncm91cFxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0cyB0aGUgb2Zmc2V0IHRoYXQgdGhlIHN0YWNrIGhhcyBmcm9tIHRoZSB4IHZhbHVlIGFuZCByZXBvc2l0aW9ucyB0aGUgbGFiZWwuXG5cdCAqL1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uICh4T2Zmc2V0LCB4V2lkdGgpIHtcblx0XHR2YXIgc3RhY2tJdGVtID0gdGhpcyxcblx0XHRcdGF4aXMgPSBzdGFja0l0ZW0uYXhpcyxcblx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdGludmVydGVkID0gY2hhcnQuaW52ZXJ0ZWQsXG5cdFx0XHRyZXZlcnNlZCA9IGF4aXMucmV2ZXJzZWQsXG5cdFx0XHRuZWcgPSAodGhpcy5pc05lZ2F0aXZlICYmICFyZXZlcnNlZCkgfHwgKCF0aGlzLmlzTmVnYXRpdmUgJiYgcmV2ZXJzZWQpLCAvLyAjNDA1NlxuXHRcdFx0eSA9IGF4aXMudHJhbnNsYXRlKGF4aXMudXNlUGVyY2VudGFnZSA/IDEwMCA6IHRoaXMudG90YWwsIDAsIDAsIDAsIDEpLCAvLyBzdGFjayB2YWx1ZSB0cmFuc2xhdGVkIG1hcHBlZCB0byBjaGFydCBjb29yZGluYXRlc1xuXHRcdFx0eVplcm8gPSBheGlzLnRyYW5zbGF0ZSgwKSxcdFx0XHRcdFx0XHQvLyBzdGFjayBvcmlnaW5cblx0XHRcdGggPSBtYXRoQWJzKHkgLSB5WmVybyksXHRcdFx0XHRcdFx0XHQvLyBzdGFjayBoZWlnaHRcblx0XHRcdHggPSBjaGFydC54QXhpc1swXS50cmFuc2xhdGUodGhpcy54KSArIHhPZmZzZXQsXHQvLyBzdGFjayB4IHBvc2l0aW9uXG5cdFx0XHRwbG90SGVpZ2h0ID0gY2hhcnQucGxvdEhlaWdodCxcblx0XHRcdHN0YWNrQm94ID0ge1x0Ly8gdGhpcyBpcyB0aGUgYm94IGZvciB0aGUgY29tcGxldGUgc3RhY2tcblx0XHRcdFx0eDogaW52ZXJ0ZWQgPyAobmVnID8geSA6IHkgLSBoKSA6IHgsXG5cdFx0XHRcdHk6IGludmVydGVkID8gcGxvdEhlaWdodCAtIHggLSB4V2lkdGggOiAobmVnID8gKHBsb3RIZWlnaHQgLSB5IC0gaCkgOiBwbG90SGVpZ2h0IC0geSksXG5cdFx0XHRcdHdpZHRoOiBpbnZlcnRlZCA/IGggOiB4V2lkdGgsXG5cdFx0XHRcdGhlaWdodDogaW52ZXJ0ZWQgPyB4V2lkdGggOiBoXG5cdFx0XHR9LFxuXHRcdFx0bGFiZWwgPSB0aGlzLmxhYmVsLFxuXHRcdFx0YWxpZ25BdHRyO1xuXHRcdFxuXHRcdGlmIChsYWJlbCkge1xuXHRcdFx0bGFiZWwuYWxpZ24odGhpcy5hbGlnbk9wdGlvbnMsIG51bGwsIHN0YWNrQm94KTtcdC8vIGFsaWduIHRoZSBsYWJlbCB0byB0aGUgYm94XG5cdFx0XHRcdFxuXHRcdFx0Ly8gU2V0IHZpc2liaWxpdHkgKCM2NzgpXG5cdFx0XHRhbGlnbkF0dHIgPSBsYWJlbC5hbGlnbkF0dHI7XG5cdFx0XHRsYWJlbFt0aGlzLm9wdGlvbnMuY3JvcCA9PT0gZmFsc2UgfHwgY2hhcnQuaXNJbnNpZGVQbG90KGFsaWduQXR0ci54LCBhbGlnbkF0dHIueSkgPyAnc2hvdycgOiAnaGlkZSddKHRydWUpO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBzdGFja3MgZm9yIGVhY2ggc2VyaWVzIGFuZCBjYWxjdWxhdGUgc3RhY2tzIHRvdGFsIHZhbHVlc1xuICovXG5DaGFydC5wcm90b3R5cGUuZ2V0U3RhY2tzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgY2hhcnQgPSB0aGlzO1xuXG5cdC8vIHJlc2V0IHN0YWNrcyBmb3IgZWFjaCB5QXhpc1xuXHRlYWNoKGNoYXJ0LnlBeGlzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdGlmIChheGlzLnN0YWNrcyAmJiBheGlzLmhhc1Zpc2libGVTZXJpZXMpIHtcblx0XHRcdGF4aXMub2xkU3RhY2tzID0gYXhpcy5zdGFja3M7XG5cdFx0fVxuXHR9KTtcblxuXHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdGlmIChzZXJpZXMub3B0aW9ucy5zdGFja2luZyAmJiAoc2VyaWVzLnZpc2libGUgPT09IHRydWUgfHwgY2hhcnQub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMgPT09IGZhbHNlKSkge1xuXHRcdFx0c2VyaWVzLnN0YWNrS2V5ID0gc2VyaWVzLnR5cGUgKyBwaWNrKHNlcmllcy5vcHRpb25zLnN0YWNrLCAnJyk7XG5cdFx0fVxuXHR9KTtcbn07XG5cblxuLy8gU3RhY2tpbmcgbWV0aG9kcyBkZWZpbmVkIG9uIHRoZSBBeGlzIHByb3RvdHlwZVxuXG4vKipcbiAqIEJ1aWxkIHRoZSBzdGFja3MgZnJvbSB0b3AgZG93blxuICovXG5BeGlzLnByb3RvdHlwZS5idWlsZFN0YWNrcyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlcmllcyA9IHRoaXMuc2VyaWVzLFxuXHRcdHJldmVyc2VkU3RhY2tzID0gcGljayh0aGlzLm9wdGlvbnMucmV2ZXJzZWRTdGFja3MsIHRydWUpLFxuXHRcdGkgPSBzZXJpZXMubGVuZ3RoO1xuXHRpZiAoIXRoaXMuaXNYQXhpcykge1xuXHRcdHRoaXMudXNlUGVyY2VudGFnZSA9IGZhbHNlO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdHNlcmllc1tyZXZlcnNlZFN0YWNrcyA/IGkgOiBzZXJpZXMubGVuZ3RoIC0gaSAtIDFdLnNldFN0YWNrZWRQb2ludHMoKTtcblx0XHR9XG5cdFx0Ly8gTG9vcCB1cCBhZ2FpbiB0byBjb21wdXRlIHBlcmNlbnQgc3RhY2tcblx0XHRpZiAodGhpcy51c2VQZXJjZW50YWdlKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNlcmllc1tpXS5zZXRQZXJjZW50U3RhY2tzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5BeGlzLnByb3RvdHlwZS5yZW5kZXJTdGFja1RvdGFscyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdHN0YWNrcyA9IGF4aXMuc3RhY2tzLFxuXHRcdHN0YWNrS2V5LCBcblx0XHRvbmVTdGFjaywgXG5cdFx0c3RhY2tDYXRlZ29yeSxcblx0XHRzdGFja1RvdGFsR3JvdXAgPSBheGlzLnN0YWNrVG90YWxHcm91cDtcblxuXHQvLyBDcmVhdGUgYSBzZXBhcmF0ZSBncm91cCBmb3IgdGhlIHN0YWNrIHRvdGFsIGxhYmVsc1xuXHRpZiAoIXN0YWNrVG90YWxHcm91cCkge1xuXHRcdGF4aXMuc3RhY2tUb3RhbEdyb3VwID0gc3RhY2tUb3RhbEdyb3VwID1cblx0XHRcdHJlbmRlcmVyLmcoJ3N0YWNrLWxhYmVscycpXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHR2aXNpYmlsaXR5OiBWSVNJQkxFLFxuXHRcdFx0XHRcdHpJbmRleDogNlxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYWRkKCk7XG5cdH1cblxuXHQvLyBwbG90TGVmdC9Ub3Agd2lsbCBjaGFuZ2Ugd2hlbiB5IGF4aXMgZ2V0cyB3aWRlciBzbyB3ZSBuZWVkIHRvIHRyYW5zbGF0ZSB0aGVcblx0Ly8gc3RhY2tUb3RhbEdyb3VwIGF0IGV2ZXJ5IHJlbmRlciBjYWxsLiBTZWUgYnVnICM1MDYgYW5kICM1MTZcblx0c3RhY2tUb3RhbEdyb3VwLnRyYW5zbGF0ZShjaGFydC5wbG90TGVmdCwgY2hhcnQucGxvdFRvcCk7XG5cblx0Ly8gUmVuZGVyIGVhY2ggc3RhY2sgdG90YWxcblx0Zm9yIChzdGFja0tleSBpbiBzdGFja3MpIHtcblx0XHRvbmVTdGFjayA9IHN0YWNrc1tzdGFja0tleV07XG5cdFx0Zm9yIChzdGFja0NhdGVnb3J5IGluIG9uZVN0YWNrKSB7XG5cdFx0XHRvbmVTdGFja1tzdGFja0NhdGVnb3J5XS5yZW5kZXIoc3RhY2tUb3RhbEdyb3VwKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogU2V0IGFsbCB0aGUgc3RhY2tzIHRvIGluaXRpYWwgc3RhdGVzIGFuZCBkZXN0cm95IHVudXNlZCBvbmVzLlxuICovXG5BeGlzLnByb3RvdHlwZS5yZXNldFN0YWNrcyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHN0YWNrcyA9IHRoaXMuc3RhY2tzLFxuXHRcdHR5cGUsXG5cdFx0aTtcblx0aWYgKCF0aGlzLmlzWEF4aXMpIHtcblx0XHRmb3IgKHR5cGUgaW4gc3RhY2tzKSB7XG5cdFx0XHRmb3IgKGkgaW4gc3RhY2tzW3R5cGVdKSB7XG5cblx0XHRcdFx0Ly8gQ2xlYW4gdXAgbWVtb3J5IGFmdGVyIHBvaW50IGRlbGV0aW9uICgjMTA0NCwgIzQzMjApXG5cdFx0XHRcdGlmIChzdGFja3NbdHlwZV1baV0udG91Y2hlZCA8IHRoaXMuc3RhY2tzVG91Y2hlZCkge1xuXHRcdFx0XHRcdHN0YWNrc1t0eXBlXVtpXS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0ZGVsZXRlIHN0YWNrc1t0eXBlXVtpXTtcblxuXHRcdFx0XHQvLyBSZXNldCBzdGFja3Ncblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGFja3NbdHlwZV1baV0udG90YWwgPSBudWxsO1xuXHRcdFx0XHRcdHN0YWNrc1t0eXBlXVtpXS5jdW0gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5BeGlzLnByb3RvdHlwZS5jbGVhblN0YWNrcyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHN0YWNrcywgdHlwZSwgaTtcblxuXHRpZiAoIXRoaXMuaXNYQXhpcykge1xuXHRcdGlmICh0aGlzLm9sZFN0YWNrcykge1xuXHRcdFx0c3RhY2tzID0gdGhpcy5zdGFja3MgPSB0aGlzLm9sZFN0YWNrcztcblx0XHR9XG5cblx0XHQvLyByZXNldCBzdGFja3Ncblx0XHRmb3IgKHR5cGUgaW4gc3RhY2tzKSB7XG5cdFx0XHRmb3IgKGkgaW4gc3RhY2tzW3R5cGVdKSB7XG5cdFx0XHRcdHN0YWNrc1t0eXBlXVtpXS5jdW0gPSBzdGFja3NbdHlwZV1baV0udG90YWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5cbi8vIFN0YWNraW5nIG1ldGhvZHMgZGVmbmllZCBmb3IgU2VyaWVzIHByb3RvdHlwZVxuXG4vKipcbiAqIEFkZHMgc2VyaWVzJyBwb2ludHMgdmFsdWUgdG8gY29ycmVzcG9uZGluZyBzdGFja1xuICovXG5TZXJpZXMucHJvdG90eXBlLnNldFN0YWNrZWRQb2ludHMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICghdGhpcy5vcHRpb25zLnN0YWNraW5nIHx8ICh0aGlzLnZpc2libGUgIT09IHRydWUgJiYgdGhpcy5jaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyAhPT0gZmFsc2UpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0eERhdGEgPSBzZXJpZXMucHJvY2Vzc2VkWERhdGEsXG5cdFx0eURhdGEgPSBzZXJpZXMucHJvY2Vzc2VkWURhdGEsXG5cdFx0c3RhY2tlZFlEYXRhID0gW10sXG5cdFx0eURhdGFMZW5ndGggPSB5RGF0YS5sZW5ndGgsXG5cdFx0c2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdHRocmVzaG9sZCA9IHNlcmllc09wdGlvbnMudGhyZXNob2xkLFxuXHRcdHN0YWNrVGhyZXNob2xkID0gc2VyaWVzT3B0aW9ucy5zdGFydEZyb21UaHJlc2hvbGQgPyB0aHJlc2hvbGQgOiAwLFxuXHRcdHN0YWNrT3B0aW9uID0gc2VyaWVzT3B0aW9ucy5zdGFjayxcblx0XHRzdGFja2luZyA9IHNlcmllc09wdGlvbnMuc3RhY2tpbmcsXG5cdFx0c3RhY2tLZXkgPSBzZXJpZXMuc3RhY2tLZXksXG5cdFx0bmVnS2V5ID0gJy0nICsgc3RhY2tLZXksXG5cdFx0bmVnU3RhY2tzID0gc2VyaWVzLm5lZ1N0YWNrcyxcblx0XHR5QXhpcyA9IHNlcmllcy55QXhpcyxcblx0XHRzdGFja3MgPSB5QXhpcy5zdGFja3MsXG5cdFx0b2xkU3RhY2tzID0geUF4aXMub2xkU3RhY2tzLFxuXHRcdHN0YWNrSW5kaWNhdG9yLFxuXHRcdGlzTmVnYXRpdmUsXG5cdFx0c3RhY2ssXG5cdFx0b3RoZXIsXG5cdFx0a2V5LFxuXHRcdHBvaW50S2V5LFxuXHRcdGksXG5cdFx0eCxcblx0XHR5O1xuXG5cblx0eUF4aXMuc3RhY2tzVG91Y2hlZCArPSAxO1xuXG5cdC8vIGxvb3Agb3ZlciB0aGUgbm9uLW51bGwgeSB2YWx1ZXMgYW5kIHJlYWQgdGhlbSBpbnRvIGEgbG9jYWwgYXJyYXlcblx0Zm9yIChpID0gMDsgaSA8IHlEYXRhTGVuZ3RoOyBpKyspIHtcblx0XHR4ID0geERhdGFbaV07XG5cdFx0eSA9IHlEYXRhW2ldO1xuXHRcdHN0YWNrSW5kaWNhdG9yID0gc2VyaWVzLmdldFN0YWNrSW5kaWNhdG9yKHN0YWNrSW5kaWNhdG9yLCB4LCBzZXJpZXMuaW5kZXgpO1xuXHRcdHBvaW50S2V5ID0gc3RhY2tJbmRpY2F0b3Iua2V5O1xuXHRcdC8vIFJlYWQgc3RhY2tlZCB2YWx1ZXMgaW50byBhIHN0YWNrIGJhc2VkIG9uIHRoZSB4IHZhbHVlLFxuXHRcdC8vIHRoZSBzaWduIG9mIHkgYW5kIHRoZSBzdGFjayBrZXkuIFN0YWNraW5nIGlzIGFsc28gaGFuZGxlZCBmb3IgbnVsbCB2YWx1ZXMgKCM3MzkpXG5cdFx0aXNOZWdhdGl2ZSA9IG5lZ1N0YWNrcyAmJiB5IDwgKHN0YWNrVGhyZXNob2xkID8gMCA6IHRocmVzaG9sZCk7XG5cdFx0a2V5ID0gaXNOZWdhdGl2ZSA/IG5lZ0tleSA6IHN0YWNrS2V5O1xuXG5cdFx0Ly8gQ3JlYXRlIGVtcHR5IG9iamVjdCBmb3IgdGhpcyBzdGFjayBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldFxuXHRcdGlmICghc3RhY2tzW2tleV0pIHtcblx0XHRcdHN0YWNrc1trZXldID0ge307XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdGlhbGl6ZSBTdGFja0l0ZW0gZm9yIHRoaXMgeFxuXHRcdGlmICghc3RhY2tzW2tleV1beF0pIHtcblx0XHRcdGlmIChvbGRTdGFja3Nba2V5XSAmJiBvbGRTdGFja3Nba2V5XVt4XSkge1xuXHRcdFx0XHRzdGFja3Nba2V5XVt4XSA9IG9sZFN0YWNrc1trZXldW3hdO1xuXHRcdFx0XHRzdGFja3Nba2V5XVt4XS50b3RhbCA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdGFja3Nba2V5XVt4XSA9IG5ldyBTdGFja0l0ZW0oeUF4aXMsIHlBeGlzLm9wdGlvbnMuc3RhY2tMYWJlbHMsIGlzTmVnYXRpdmUsIHgsIHN0YWNrT3B0aW9uKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgU3RhY2tJdGVtIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdCBmaXJzdFxuXHRcdHN0YWNrID0gc3RhY2tzW2tleV1beF07XG5cdFx0Ly9zdGFjay5wb2ludHNbcG9pbnRLZXldID0gW3N0YWNrLmN1bSB8fCBzdGFja1RocmVzaG9sZF07XG5cdFx0c3RhY2sucG9pbnRzW3BvaW50S2V5XSA9IFtwaWNrKHN0YWNrLmN1bSwgc3RhY2tUaHJlc2hvbGQpXTtcblx0XHRzdGFjay50b3VjaGVkID0geUF4aXMuc3RhY2tzVG91Y2hlZDtcblx0XHRcblxuXHRcdC8vIEFkZCB2YWx1ZSB0byB0aGUgc3RhY2sgdG90YWxcblx0XHRpZiAoc3RhY2tpbmcgPT09ICdwZXJjZW50Jykge1xuXG5cdFx0XHQvLyBQZXJjZW50IHN0YWNrZWQgY29sdW1uLCB0b3RhbHMgYXJlIHRoZSBzYW1lIGZvciB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHN0YWNrc1xuXHRcdFx0b3RoZXIgPSBpc05lZ2F0aXZlID8gc3RhY2tLZXkgOiBuZWdLZXk7XG5cdFx0XHRpZiAobmVnU3RhY2tzICYmIHN0YWNrc1tvdGhlcl0gJiYgc3RhY2tzW290aGVyXVt4XSkge1xuXHRcdFx0XHRvdGhlciA9IHN0YWNrc1tvdGhlcl1beF07XG5cdFx0XHRcdHN0YWNrLnRvdGFsID0gb3RoZXIudG90YWwgPSBtYXRoTWF4KG90aGVyLnRvdGFsLCBzdGFjay50b3RhbCkgKyBtYXRoQWJzKHkpIHx8IDA7XG5cblx0XHRcdC8vIFBlcmNlbnQgc3RhY2tlZCBhcmVhc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3RhY2sudG90YWwgPSBjb3JyZWN0RmxvYXQoc3RhY2sudG90YWwgKyAobWF0aEFicyh5KSB8fCAwKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YWNrLnRvdGFsID0gY29ycmVjdEZsb2F0KHN0YWNrLnRvdGFsICsgKHkgfHwgMCkpO1xuXHRcdH1cblxuXHRcdHN0YWNrLmN1bSA9IHBpY2soc3RhY2suY3VtLCBzdGFja1RocmVzaG9sZCkgKyAoeSB8fCAwKTtcblxuXHRcdHN0YWNrLnBvaW50c1twb2ludEtleV0ucHVzaChzdGFjay5jdW0pO1xuXHRcdHN0YWNrZWRZRGF0YVtpXSA9IHN0YWNrLmN1bTtcblxuXHR9XG5cblx0aWYgKHN0YWNraW5nID09PSAncGVyY2VudCcpIHtcblx0XHR5QXhpcy51c2VQZXJjZW50YWdlID0gdHJ1ZTtcblx0fVxuXG5cdHRoaXMuc3RhY2tlZFlEYXRhID0gc3RhY2tlZFlEYXRhOyAvLyBUbyBiZSB1c2VkIGluIGdldEV4dHJlbWVzXG5cblx0Ly8gUmVzZXQgb2xkIHN0YWNrc1xuXHR5QXhpcy5vbGRTdGFja3MgPSB7fTtcbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCBzdGFja3MgYW5kIGNvbXB1dGUgdGhlIGFic29sdXRlIHZhbHVlcyB0byBwZXJjZW50XG4gKi9cblNlcmllcy5wcm90b3R5cGUuc2V0UGVyY2VudFN0YWNrcyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0c3RhY2tLZXkgPSBzZXJpZXMuc3RhY2tLZXksXG5cdFx0c3RhY2tzID0gc2VyaWVzLnlBeGlzLnN0YWNrcyxcblx0XHRwcm9jZXNzZWRYRGF0YSA9IHNlcmllcy5wcm9jZXNzZWRYRGF0YSxcblx0XHRzdGFja0luZGljYXRvcjtcblxuXHRlYWNoKFtzdGFja0tleSwgJy0nICsgc3RhY2tLZXldLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGkgPSBwcm9jZXNzZWRYRGF0YS5sZW5ndGgsXG5cdFx0XHR4LFxuXHRcdFx0c3RhY2ssXG5cdFx0XHRwb2ludEV4dHJlbWVzLFxuXHRcdFx0dG90YWxGYWN0b3I7XG5cblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHR4ID0gcHJvY2Vzc2VkWERhdGFbaV07XG5cdFx0XHRzdGFja0luZGljYXRvciA9IHNlcmllcy5nZXRTdGFja0luZGljYXRvcihzdGFja0luZGljYXRvciwgeCwgc2VyaWVzLmluZGV4KTtcblx0XHRcdHN0YWNrID0gc3RhY2tzW2tleV0gJiYgc3RhY2tzW2tleV1beF07XG5cdFx0XHRwb2ludEV4dHJlbWVzID0gc3RhY2sgJiYgc3RhY2sucG9pbnRzW3N0YWNrSW5kaWNhdG9yLmtleV07XG5cdFx0XHRpZiAocG9pbnRFeHRyZW1lcykge1xuXHRcdFx0XHR0b3RhbEZhY3RvciA9IHN0YWNrLnRvdGFsID8gMTAwIC8gc3RhY2sudG90YWwgOiAwO1xuXHRcdFx0XHRwb2ludEV4dHJlbWVzWzBdID0gY29ycmVjdEZsb2F0KHBvaW50RXh0cmVtZXNbMF0gKiB0b3RhbEZhY3Rvcik7IC8vIFkgYm90dG9tIHZhbHVlXG5cdFx0XHRcdHBvaW50RXh0cmVtZXNbMV0gPSBjb3JyZWN0RmxvYXQocG9pbnRFeHRyZW1lc1sxXSAqIHRvdGFsRmFjdG9yKTsgLy8gWSB2YWx1ZVxuXHRcdFx0XHRzZXJpZXMuc3RhY2tlZFlEYXRhW2ldID0gcG9pbnRFeHRyZW1lc1sxXTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufTtcblxuLyoqXG4qIEdldCBzdGFjayBpbmRpY2F0b3IsIGFjY29yZGluZyB0byBpdCdzIHgtdmFsdWUsIHRvIGRldGVybWluZSBwb2ludHMgd2l0aCB0aGUgc2FtZSB4LXZhbHVlXG4qL1xuU2VyaWVzLnByb3RvdHlwZS5nZXRTdGFja0luZGljYXRvciA9IGZ1bmN0aW9uKHN0YWNrSW5kaWNhdG9yLCB4LCBpbmRleCkge1xuXHRpZiAoIWRlZmluZWQoc3RhY2tJbmRpY2F0b3IpIHx8IHN0YWNrSW5kaWNhdG9yLnggIT09IHgpIHtcblx0XHRzdGFja0luZGljYXRvciA9IHtcblx0XHRcdHg6IHgsXG5cdFx0XHRpbmRleDogMFxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3RhY2tJbmRpY2F0b3IuaW5kZXgrKztcblx0fVxuXHRcblx0c3RhY2tJbmRpY2F0b3Iua2V5ID0gW2luZGV4LCB4LCBzdGFja0luZGljYXRvci5pbmRleF0uam9pbignLCcpO1xuXG5cdHJldHVybiBzdGFja0luZGljYXRvcjtcbn07XG5cbi8vIEV4dGVuZCB0aGUgQ2hhcnQgcHJvdG90eXBlIGZvciBkeW5hbWljIG1ldGhvZHNcbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblxuXHQvKipcblx0ICogQWRkIGEgc2VyaWVzIGR5bmFtaWNhbGx5IGFmdGVyICB0aW1lXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBjb25maWcgb3B0aW9uc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhdyBXaGV0aGVyIHRvIHJlZHJhdyB0aGUgY2hhcnQgYWZ0ZXIgYWRkaW5nLiBEZWZhdWx0cyB0byB0cnVlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBhbmltYXRpb24gV2hldGhlciB0byBhcHBseSBhbmltYXRpb24sIGFuZCBvcHRpb25hbGx5IGFuaW1hdGlvblxuXHQgKiAgICBjb25maWd1cmF0aW9uXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gc2VyaWVzIFRoZSBuZXdseSBjcmVhdGVkIHNlcmllcyBvYmplY3Rcblx0ICovXG5cdGFkZFNlcmllczogZnVuY3Rpb24gKG9wdGlvbnMsIHJlZHJhdywgYW5pbWF0aW9uKSB7XG5cdFx0dmFyIHNlcmllcyxcblx0XHRcdGNoYXJ0ID0gdGhpcztcblxuXHRcdGlmIChvcHRpb25zKSB7XG5cdFx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgdHJ1ZSk7IC8vIGRlZmF1bHRzIHRvIHRydWVcblxuXHRcdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnYWRkU2VyaWVzJywgeyBvcHRpb25zOiBvcHRpb25zIH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VyaWVzID0gY2hhcnQuaW5pdFNlcmllcyhvcHRpb25zKTtcblxuXHRcdFx0XHRjaGFydC5pc0RpcnR5TGVnZW5kID0gdHJ1ZTsgLy8gdGhlIHNlcmllcyBhcnJheSBpcyBvdXQgb2Ygc3luYyB3aXRoIHRoZSBkaXNwbGF5XG5cdFx0XHRcdGNoYXJ0LmxpbmtTZXJpZXMoKTtcblx0XHRcdFx0aWYgKHJlZHJhdykge1xuXHRcdFx0XHRcdGNoYXJ0LnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2VyaWVzO1xuXHR9LFxuXG5cdC8qKlxuICAgICAqIEFkZCBhbiBheGlzIHRvIHRoZSBjaGFydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBheGlzIG9wdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNYIFdoZXRoZXIgaXQgaXMgYW4gWCBheGlzIG9yIGEgdmFsdWUgYXhpc1xuICAgICAqL1xuXHRhZGRBeGlzOiBmdW5jdGlvbiAob3B0aW9ucywgaXNYLCByZWRyYXcsIGFuaW1hdGlvbikge1xuXHRcdHZhciBrZXkgPSBpc1ggPyAneEF4aXMnIDogJ3lBeGlzJyxcblx0XHRcdGNoYXJ0T3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGF4aXM7XG5cblx0XHQvKmpzbGludCB1bnVzZWQ6IGZhbHNlKi9cblx0XHRheGlzID0gbmV3IEF4aXModGhpcywgbWVyZ2Uob3B0aW9ucywge1xuXHRcdFx0aW5kZXg6IHRoaXNba2V5XS5sZW5ndGgsXG5cdFx0XHRpc1g6IGlzWFxuXHRcdH0pKTtcblx0XHQvKmpzbGludCB1bnVzZWQ6IHRydWUqL1xuXG5cdFx0Ly8gUHVzaCB0aGUgbmV3IGF4aXMgb3B0aW9ucyB0byB0aGUgY2hhcnQgb3B0aW9uc1xuXHRcdGNoYXJ0T3B0aW9uc1trZXldID0gc3BsYXQoY2hhcnRPcHRpb25zW2tleV0gfHwge30pO1xuXHRcdGNoYXJ0T3B0aW9uc1trZXldLnB1c2gob3B0aW9ucyk7XG5cblx0XHRpZiAocGljayhyZWRyYXcsIHRydWUpKSB7XG5cdFx0XHR0aGlzLnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogRGltIHRoZSBjaGFydCBhbmQgc2hvdyBhIGxvYWRpbmcgdGV4dCBvciBzeW1ib2xcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBbiBvcHRpb25hbCB0ZXh0IHRvIHNob3cgaW4gdGhlIGxvYWRpbmcgbGFiZWwgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBvbmVcblx0ICovXG5cdHNob3dMb2FkaW5nOiBmdW5jdGlvbiAoc3RyKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLFxuXHRcdFx0bG9hZGluZ0RpdiA9IGNoYXJ0LmxvYWRpbmdEaXYsXG5cdFx0XHRsb2FkaW5nT3B0aW9ucyA9IG9wdGlvbnMubG9hZGluZyxcblx0XHRcdHNldExvYWRpbmdTaXplID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAobG9hZGluZ0Rpdikge1xuXHRcdFx0XHRcdGNzcyhsb2FkaW5nRGl2LCB7XG5cdFx0XHRcdFx0XHRsZWZ0OiBjaGFydC5wbG90TGVmdCArIFBYLFxuXHRcdFx0XHRcdFx0dG9wOiBjaGFydC5wbG90VG9wICsgUFgsXG5cdFx0XHRcdFx0XHR3aWR0aDogY2hhcnQucGxvdFdpZHRoICsgUFgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGNoYXJ0LnBsb3RIZWlnaHQgKyBQWFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gY3JlYXRlIHRoZSBsYXllciBhdCB0aGUgZmlyc3QgY2FsbFxuXHRcdGlmICghbG9hZGluZ0Rpdikge1xuXHRcdFx0Y2hhcnQubG9hZGluZ0RpdiA9IGxvYWRpbmdEaXYgPSBjcmVhdGVFbGVtZW50KERJViwge1xuXHRcdFx0XHRjbGFzc05hbWU6IFBSRUZJWCArICdsb2FkaW5nJ1xuXHRcdFx0fSwgZXh0ZW5kKGxvYWRpbmdPcHRpb25zLnN0eWxlLCB7XG5cdFx0XHRcdHpJbmRleDogMTAsXG5cdFx0XHRcdGRpc3BsYXk6IE5PTkVcblx0XHRcdH0pLCBjaGFydC5jb250YWluZXIpO1xuXG5cdFx0XHRjaGFydC5sb2FkaW5nU3BhbiA9IGNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdCdzcGFuJyxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bG9hZGluZ09wdGlvbnMubGFiZWxTdHlsZSxcblx0XHRcdFx0bG9hZGluZ0RpdlxuXHRcdFx0KTtcblx0XHRcdGFkZEV2ZW50KGNoYXJ0LCAncmVkcmF3Jywgc2V0TG9hZGluZ1NpemUpOyAvLyAjMTA4MFxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSB0ZXh0XG5cdFx0Y2hhcnQubG9hZGluZ1NwYW4uaW5uZXJIVE1MID0gc3RyIHx8IG9wdGlvbnMubGFuZy5sb2FkaW5nO1xuXG5cdFx0Ly8gc2hvdyBpdFxuXHRcdGlmICghY2hhcnQubG9hZGluZ1Nob3duKSB7XG5cdFx0XHRjc3MobG9hZGluZ0Rpdiwge1xuXHRcdFx0XHRvcGFjaXR5OiAwLFxuXHRcdFx0XHRkaXNwbGF5OiAnJ1x0XHRcdFx0XG5cdFx0XHR9KTtcblx0XHRcdGFuaW1hdGUobG9hZGluZ0Rpdiwge1xuXHRcdFx0XHRvcGFjaXR5OiBsb2FkaW5nT3B0aW9ucy5zdHlsZS5vcGFjaXR5XG5cdFx0XHR9LCB7XG5cdFx0XHRcdGR1cmF0aW9uOiBsb2FkaW5nT3B0aW9ucy5zaG93RHVyYXRpb24gfHwgMFxuXHRcdFx0fSk7XG5cdFx0XHRjaGFydC5sb2FkaW5nU2hvd24gPSB0cnVlO1xuXHRcdH1cblx0XHRzZXRMb2FkaW5nU2l6ZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIaWRlIHRoZSBsb2FkaW5nIGxheWVyXG5cdCAqL1xuXHRoaWRlTG9hZGluZzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0bG9hZGluZ0RpdiA9IHRoaXMubG9hZGluZ0RpdjtcblxuXHRcdGlmIChsb2FkaW5nRGl2KSB7XG5cdFx0XHRhbmltYXRlKGxvYWRpbmdEaXYsIHtcblx0XHRcdFx0b3BhY2l0eTogMFxuXHRcdFx0fSwge1xuXHRcdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5sb2FkaW5nLmhpZGVEdXJhdGlvbiB8fCAxMDAsXG5cdFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Y3NzKGxvYWRpbmdEaXYsIHsgZGlzcGxheTogTk9ORSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHRoaXMubG9hZGluZ1Nob3duID0gZmFsc2U7XG5cdH1cbn0pO1xuXG4vLyBleHRlbmQgdGhlIFBvaW50IHByb3RvdHlwZSBmb3IgZHluYW1pYyBtZXRob2RzXG5leHRlbmQoUG9pbnQucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIHBvaW50IHdpdGggbmV3IG9wdGlvbnMgKHR5cGljYWxseSB4L3kgZGF0YSkgYW5kIG9wdGlvbmFsbHkgcmVkcmF3IHRoZSBzZXJpZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBvaW50IG9wdGlvbnMgYXMgZGVmaW5lZCBpbiB0aGUgc2VyaWVzLmRhdGEgYXJyYXlcblx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXcgV2hldGhlciB0byByZWRyYXcgdGhlIGNoYXJ0IG9yIHdhaXQgZm9yIGFuIGV4cGxpY2l0IGNhbGxcblx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0ICogICAgY29uZmlndXJhdGlvblxuXHQgKlxuXHQgKi9cblx0dXBkYXRlOiBmdW5jdGlvbiAob3B0aW9ucywgcmVkcmF3LCBhbmltYXRpb24sIHJ1bkV2ZW50KSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdGdyYXBoaWMgPSBwb2ludC5ncmFwaGljLFxuXHRcdFx0aSxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0c2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0bmFtZXMgPSBzZXJpZXMueEF4aXMgJiYgc2VyaWVzLnhBeGlzLm5hbWVzO1xuXG5cdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpO1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0XHRwb2ludC5hcHBseU9wdGlvbnMob3B0aW9ucyk7XG5cblx0XHRcdC8vIFVwZGF0ZSB2aXN1YWxzXG5cdFx0XHRpZiAocG9pbnQueSA9PT0gbnVsbCAmJiBncmFwaGljKSB7IC8vICM0MTQ2XG5cdFx0XHRcdHBvaW50LmdyYXBoaWMgPSBncmFwaGljLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHRcdGlmIChpc09iamVjdChvcHRpb25zKSAmJiAhaXNBcnJheShvcHRpb25zKSkge1xuXHRcdFx0XHQvLyBEZWZlciB0aGUgYWN0dWFsIHJlZHJhdyB1bnRpbCBnZXRBdHRyaWJzIGhhcyBiZWVuIGNhbGxlZCAoIzMyNjApXG5cdFx0XHRcdHBvaW50LnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoZ3JhcGhpYyAmJiBncmFwaGljLmVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMubWFya2VyICYmIG9wdGlvbnMubWFya2VyLnN5bWJvbCkge1xuXHRcdFx0XHRcdFx0XHRwb2ludC5ncmFwaGljID0gZ3JhcGhpYy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGF0YUxhYmVscyAmJiBwb2ludC5kYXRhTGFiZWwpIHsgLy8gIzI0Njhcblx0XHRcdFx0XHRcdHBvaW50LmRhdGFMYWJlbCA9IHBvaW50LmRhdGFMYWJlbC5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvaW50LnJlZHJhdyA9IG51bGw7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlY29yZCBjaGFuZ2VzIGluIHRoZSBwYXJhbGxlbCBhcnJheXNcblx0XHRcdGkgPSBwb2ludC5pbmRleDtcblx0XHRcdHNlcmllcy51cGRhdGVQYXJhbGxlbEFycmF5cyhwb2ludCwgaSk7XG5cdFx0XHRpZiAobmFtZXMgJiYgcG9pbnQubmFtZSkge1xuXHRcdFx0XHRuYW1lc1twb2ludC54XSA9IHBvaW50Lm5hbWU7XG5cdFx0XHR9XG5cblx0XHRcdHNlcmllc09wdGlvbnMuZGF0YVtpXSA9IHBvaW50Lm9wdGlvbnM7XG5cblx0XHRcdC8vIHJlZHJhd1xuXHRcdFx0c2VyaWVzLmlzRGlydHkgPSBzZXJpZXMuaXNEaXJ0eURhdGEgPSB0cnVlO1xuXHRcdFx0aWYgKCFzZXJpZXMuZml4ZWRCb3ggJiYgc2VyaWVzLmhhc0NhcnRlc2lhblNlcmllcykgeyAvLyAjMTkwNiwgIzIzMjBcblx0XHRcdFx0Y2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzZXJpZXNPcHRpb25zLmxlZ2VuZFR5cGUgPT09ICdwb2ludCcpIHsgLy8gIzE4MzEsICMxODg1XG5cdFx0XHRcdGNoYXJ0LmlzRGlydHlMZWdlbmQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJlZHJhdykge1xuXHRcdFx0XHRjaGFydC5yZWRyYXcoYW5pbWF0aW9uKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIHRoZSBldmVudCB3aXRoIGEgZGVmYXVsdCBoYW5kbGVyIG9mIGRvaW5nIHRoZSB1cGRhdGVcblx0XHRpZiAocnVuRXZlbnQgPT09IGZhbHNlKSB7IC8vIFdoZW4gY2FsbGVkIGZyb20gc2V0RGF0YVxuXHRcdFx0dXBkYXRlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBvaW50LmZpcmVQb2ludEV2ZW50KCd1cGRhdGUnLCB7IG9wdGlvbnM6IG9wdGlvbnMgfSwgdXBkYXRlKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIHBvaW50IGFuZCBvcHRpb25hbGx5IHJlZHJhdyB0aGUgc2VyaWVzIGFuZCBpZiBuZWNlc3NhcnkgdGhlIGF4ZXNcblx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXcgV2hldGhlciB0byByZWRyYXcgdGhlIGNoYXJ0IG9yIHdhaXQgZm9yIGFuIGV4cGxpY2l0IGNhbGxcblx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0ICogICAgY29uZmlndXJhdGlvblxuXHQgKi9cblx0cmVtb3ZlOiBmdW5jdGlvbiAocmVkcmF3LCBhbmltYXRpb24pIHtcblx0XHR0aGlzLnNlcmllcy5yZW1vdmVQb2ludChpbkFycmF5KHRoaXMsIHRoaXMuc2VyaWVzLmRhdGEpLCByZWRyYXcsIGFuaW1hdGlvbik7XG5cdH1cbn0pO1xuXG4vLyBFeHRlbmQgdGhlIHNlcmllcyBwcm90b3R5cGUgZm9yIGR5bmFtaWMgbWV0aG9kc1xuZXh0ZW5kKFNlcmllcy5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIEFkZCBhIHBvaW50IGR5bmFtaWNhbGx5IGFmdGVyIGNoYXJ0IGxvYWQgdGltZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQb2ludCBvcHRpb25zIGFzIGdpdmVuIGluIHNlcmllcy5kYXRhXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3IFdoZXRoZXIgdG8gcmVkcmF3IHRoZSBjaGFydCBvciB3YWl0IGZvciBhbiBleHBsaWNpdCBjYWxsXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hpZnQgSWYgc2hpZnQgaXMgdHJ1ZSwgYSBwb2ludCBpcyBzaGlmdGVkIG9mZiB0aGUgc3RhcnRcblx0ICogICAgb2YgdGhlIHNlcmllcyBhcyBvbmUgaXMgYXBwZW5kZWQgdG8gdGhlIGVuZC5cblx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0ICogICAgY29uZmlndXJhdGlvblxuXHQgKi9cblx0YWRkUG9pbnQ6IGZ1bmN0aW9uIChvcHRpb25zLCByZWRyYXcsIHNoaWZ0LCBhbmltYXRpb24pIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSxcblx0XHRcdGdyYXBoID0gc2VyaWVzLmdyYXBoLFxuXHRcdFx0YXJlYSA9IHNlcmllcy5hcmVhLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRuYW1lcyA9IHNlcmllcy54QXhpcyAmJiBzZXJpZXMueEF4aXMubmFtZXMsXG5cdFx0XHRjdXJyZW50U2hpZnQgPSAoZ3JhcGggJiYgZ3JhcGguc2hpZnQpIHx8IDAsXG5cdFx0XHRzaGlmdFNoYXBlcyA9IFsnZ3JhcGgnLCAnYXJlYSddLFxuXHRcdFx0ZGF0YU9wdGlvbnMgPSBzZXJpZXNPcHRpb25zLmRhdGEsXG5cdFx0XHRwb2ludCxcblx0XHRcdGlzSW5UaGVNaWRkbGUsXG5cdFx0XHR4RGF0YSA9IHNlcmllcy54RGF0YSxcblx0XHRcdGksXG5cdFx0XHR4O1xuXG5cdFx0c2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgY2hhcnQpO1xuXG5cdFx0Ly8gTWFrZSBncmFwaCBhbmltYXRlIHNpZGV3YXlzXG5cdFx0aWYgKHNoaWZ0KSB7XG5cdFx0XHRpID0gc2VyaWVzLnpvbmVzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0c2hpZnRTaGFwZXMucHVzaCgnem9uZUdyYXBoJyArIGksICd6b25lQXJlYScgKyBpKTtcblx0XHRcdH1cblx0XHRcdGVhY2goc2hpZnRTaGFwZXMsIGZ1bmN0aW9uIChzaGFwZSkge1xuXHRcdFx0XHRpZiAoc2VyaWVzW3NoYXBlXSkge1xuXHRcdFx0XHRcdHNlcmllc1tzaGFwZV0uc2hpZnQgPSBjdXJyZW50U2hpZnQgKyAoc2VyaWVzT3B0aW9ucy5zdGVwID8gMiA6IDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0aWYgKGFyZWEpIHtcblx0XHRcdGFyZWEuaXNBcmVhID0gdHJ1ZTsgLy8gbmVlZGVkIGluIGFuaW1hdGlvbiwgYm90aCB3aXRoIGFuZCB3aXRob3V0IHNoaWZ0XG5cdFx0fVxuXG5cdFx0Ly8gT3B0aW9uYWwgcmVkcmF3LCBkZWZhdWx0cyB0byB0cnVlXG5cdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpO1xuXG5cdFx0Ly8gR2V0IG9wdGlvbnMgYW5kIHB1c2ggdGhlIHBvaW50IHRvIHhEYXRhLCB5RGF0YSBhbmQgc2VyaWVzLm9wdGlvbnMuIEluIHNlcmllcy5nZW5lcmF0ZVBvaW50c1xuXHRcdC8vIHRoZSBQb2ludCBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQgb24gZGVtYW5kIGFuZCBwdXNoZWQgdG8gdGhlIHNlcmllcy5kYXRhIGFycmF5LlxuXHRcdHBvaW50ID0geyBzZXJpZXM6IHNlcmllcyB9O1xuXHRcdHNlcmllcy5wb2ludENsYXNzLnByb3RvdHlwZS5hcHBseU9wdGlvbnMuYXBwbHkocG9pbnQsIFtvcHRpb25zXSk7XG5cdFx0eCA9IHBvaW50Lng7XG5cblx0XHQvLyBHZXQgdGhlIGluc2VydGlvbiBwb2ludFxuXHRcdGkgPSB4RGF0YS5sZW5ndGg7XG5cdFx0aWYgKHNlcmllcy5yZXF1aXJlU29ydGluZyAmJiB4IDwgeERhdGFbaSAtIDFdKSB7XG5cdFx0XHRpc0luVGhlTWlkZGxlID0gdHJ1ZTtcblx0XHRcdHdoaWxlIChpICYmIHhEYXRhW2kgLSAxXSA+IHgpIHtcblx0XHRcdFx0aS0tO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlcmllcy51cGRhdGVQYXJhbGxlbEFycmF5cyhwb2ludCwgJ3NwbGljZScsIGksIDAsIDApOyAvLyBpbnNlcnQgdW5kZWZpbmVkIGl0ZW1cblx0XHRzZXJpZXMudXBkYXRlUGFyYWxsZWxBcnJheXMocG9pbnQsIGkpOyAvLyB1cGRhdGUgaXRcblxuXHRcdGlmIChuYW1lcyAmJiBwb2ludC5uYW1lKSB7XG5cdFx0XHRuYW1lc1t4XSA9IHBvaW50Lm5hbWU7XG5cdFx0fVxuXHRcdGRhdGFPcHRpb25zLnNwbGljZShpLCAwLCBvcHRpb25zKTtcblxuXHRcdGlmIChpc0luVGhlTWlkZGxlKSB7XG5cdFx0XHRzZXJpZXMuZGF0YS5zcGxpY2UoaSwgMCwgbnVsbCk7XG5cdFx0XHRzZXJpZXMucHJvY2Vzc0RhdGEoKTtcblx0XHR9XG5cblx0XHQvLyBHZW5lcmF0ZSBwb2ludHMgdG8gYmUgYWRkZWQgdG8gdGhlIGxlZ2VuZCAoIzEzMjkpXG5cdFx0aWYgKHNlcmllc09wdGlvbnMubGVnZW5kVHlwZSA9PT0gJ3BvaW50Jykge1xuXHRcdFx0c2VyaWVzLmdlbmVyYXRlUG9pbnRzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU2hpZnQgdGhlIGZpcnN0IHBvaW50IG9mZiB0aGUgcGFyYWxsZWwgYXJyYXlzXG5cdFx0Ly8gdG9kbzogY29uc2lkZXIgc2VyaWVzLnJlbW92ZVBvaW50KGkpIG1ldGhvZFxuXHRcdGlmIChzaGlmdCkge1xuXHRcdFx0aWYgKGRhdGFbMF0gJiYgZGF0YVswXS5yZW1vdmUpIHtcblx0XHRcdFx0ZGF0YVswXS5yZW1vdmUoZmFsc2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YS5zaGlmdCgpO1xuXHRcdFx0XHRzZXJpZXMudXBkYXRlUGFyYWxsZWxBcnJheXMocG9pbnQsICdzaGlmdCcpO1xuXG5cdFx0XHRcdGRhdGFPcHRpb25zLnNoaWZ0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcmVkcmF3XG5cdFx0c2VyaWVzLmlzRGlydHkgPSB0cnVlO1xuXHRcdHNlcmllcy5pc0RpcnR5RGF0YSA9IHRydWU7XG5cdFx0aWYgKHJlZHJhdykge1xuXHRcdFx0c2VyaWVzLmdldEF0dHJpYnMoKTsgLy8gIzE5Mzdcblx0XHRcdGNoYXJ0LnJlZHJhdygpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIGEgcG9pbnQgKHJlbmRlcmVkIG9yIG5vdCksIGJ5IGluZGV4XG5cdCAqL1xuXHRyZW1vdmVQb2ludDogZnVuY3Rpb24gKGksIHJlZHJhdywgYW5pbWF0aW9uKSB7XG5cblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSxcblx0XHRcdHBvaW50ID0gZGF0YVtpXSxcblx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRpZiAoZGF0YS5sZW5ndGggPT09IHBvaW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRwb2ludHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRzZXJpZXMub3B0aW9ucy5kYXRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0c2VyaWVzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHBvaW50IHx8IHsgc2VyaWVzOiBzZXJpZXMgfSwgJ3NwbGljZScsIGksIDEpO1xuXG5cdFx0XHRcdGlmIChwb2ludCkge1xuXHRcdFx0XHRcdHBvaW50LmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlZHJhd1xuXHRcdFx0XHRzZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHNlcmllcy5pc0RpcnR5RGF0YSA9IHRydWU7XG5cdFx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0XHRjaGFydC5yZWRyYXcoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdHNldEFuaW1hdGlvbihhbmltYXRpb24sIGNoYXJ0KTtcblx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgdHJ1ZSk7XG5cblx0XHQvLyBGaXJlIHRoZSBldmVudCB3aXRoIGEgZGVmYXVsdCBoYW5kbGVyIG9mIHJlbW92aW5nIHRoZSBwb2ludFxuXHRcdGlmIChwb2ludCkge1xuXHRcdFx0cG9pbnQuZmlyZVBvaW50RXZlbnQoJ3JlbW92ZScsIG51bGwsIHJlbW92ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIGEgc2VyaWVzIGFuZCBvcHRpb25hbGx5IHJlZHJhdyB0aGUgY2hhcnRcblx0ICpcblx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXcgV2hldGhlciB0byByZWRyYXcgdGhlIGNoYXJ0IG9yIHdhaXQgZm9yIGFuIGV4cGxpY2l0IGNhbGxcblx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0ICogICAgY29uZmlndXJhdGlvblxuXHQgKi9cblxuXHRyZW1vdmU6IGZ1bmN0aW9uIChyZWRyYXcsIGFuaW1hdGlvbikge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQ7XG5cdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpO1xuXG5cdFx0aWYgKCFzZXJpZXMuaXNSZW1vdmluZykgeyAgLyogcHJldmVudCB0cmlnZ2VyaW5nIG5hdGl2ZSBldmVudCBpbiBqUXVlcnlcblx0XHRcdFx0KGNhbGxpbmcgdGhlIHJlbW92ZSBmdW5jdGlvbiBmcm9tIHRoZSByZW1vdmUgZXZlbnQpICovXG5cdFx0XHRzZXJpZXMuaXNSZW1vdmluZyA9IHRydWU7XG5cblx0XHRcdC8vIGZpcmUgdGhlIGV2ZW50IHdpdGggYSBkZWZhdWx0IGhhbmRsZXIgb2YgcmVtb3ZpbmcgdGhlIHBvaW50XG5cdFx0XHRmaXJlRXZlbnQoc2VyaWVzLCAncmVtb3ZlJywgbnVsbCwgZnVuY3Rpb24gKCkge1xuXG5cblx0XHRcdFx0Ly8gZGVzdHJveSBlbGVtZW50c1xuXHRcdFx0XHRzZXJpZXMuZGVzdHJveSgpO1xuXG5cblx0XHRcdFx0Ly8gcmVkcmF3XG5cdFx0XHRcdGNoYXJ0LmlzRGlydHlMZWdlbmQgPSBjaGFydC5pc0RpcnR5Qm94ID0gdHJ1ZTtcblx0XHRcdFx0Y2hhcnQubGlua1NlcmllcygpO1xuXG5cdFx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0XHRjaGFydC5yZWRyYXcoYW5pbWF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR9XG5cdFx0c2VyaWVzLmlzUmVtb3ZpbmcgPSBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBzZXJpZXMgd2l0aCBhIG5ldyBzZXQgb2Ygb3B0aW9uc1xuXHQgKi9cblx0dXBkYXRlOiBmdW5jdGlvbiAobmV3T3B0aW9ucywgcmVkcmF3KSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHQvLyBtdXN0IHVzZSB1c2VyIG9wdGlvbnMgd2hlbiBjaGFuZ2luZyB0eXBlIGJlY2F1c2UgdGhpcy5vcHRpb25zIGlzIG1lcmdlZFxuXHRcdFx0Ly8gaW4gd2l0aCB0eXBlIHNwZWNpZmljIHBsb3RPcHRpb25zXG5cdFx0XHRvbGRPcHRpb25zID0gdGhpcy51c2VyT3B0aW9ucyxcblx0XHRcdG9sZFR5cGUgPSB0aGlzLnR5cGUsXG5cdFx0XHRwcm90byA9IHNlcmllc1R5cGVzW29sZFR5cGVdLnByb3RvdHlwZSxcblx0XHRcdHByZXNlcnZlID0gWydncm91cCcsICdtYXJrZXJHcm91cCcsICdkYXRhTGFiZWxzR3JvdXAnXSxcblx0XHRcdG47XG5cblx0XHQvLyBJZiB3ZSdyZSBjaGFuZ2luZyB0eXBlIG9yIHpJbmRleCwgY3JlYXRlIG5ldyBncm91cHMgKCMzMzgwLCAjMzQwNClcblx0XHRpZiAoKG5ld09wdGlvbnMudHlwZSAmJiBuZXdPcHRpb25zLnR5cGUgIT09IG9sZFR5cGUpIHx8IG5ld09wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHByZXNlcnZlLmxlbmd0aCA9IDA7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIGdyb3VwcyBhcmUgbm90IGRlc3Ryb3llZCAoIzMwOTQpXG5cdFx0ZWFjaChwcmVzZXJ2ZSwgZnVuY3Rpb24gKHByb3ApIHtcblx0XHRcdHByZXNlcnZlW3Byb3BdID0gc2VyaWVzW3Byb3BdO1xuXHRcdFx0ZGVsZXRlIHNlcmllc1twcm9wXTtcblx0XHR9KTtcblxuXHRcdC8vIERvIHRoZSBtZXJnZSwgd2l0aCBzb21lIGZvcmNlZCBvcHRpb25zXG5cdFx0bmV3T3B0aW9ucyA9IG1lcmdlKG9sZE9wdGlvbnMsIHtcblx0XHRcdGFuaW1hdGlvbjogZmFsc2UsXG5cdFx0XHRpbmRleDogdGhpcy5pbmRleCxcblx0XHRcdHBvaW50U3RhcnQ6IHRoaXMueERhdGFbMF0gLy8gd2hlbiB1cGRhdGluZyBhZnRlciBhZGRQb2ludFxuXHRcdH0sIHsgZGF0YTogdGhpcy5vcHRpb25zLmRhdGEgfSwgbmV3T3B0aW9ucyk7XG5cblx0XHQvLyBEZXN0cm95IHRoZSBzZXJpZXMgYW5kIGRlbGV0ZSBhbGwgcHJvcGVydGllcy4gUmVpbnNlcnQgYWxsIG1ldGhvZHMgXG5cdFx0Ly8gYW5kIHByb3BlcnRpZXMgZnJvbSB0aGUgbmV3IHR5cGUgcHJvdG90eXBlICgjMjI3MCwgIzM3MTkpXG5cdFx0dGhpcy5yZW1vdmUoZmFsc2UpO1xuXHRcdGZvciAobiBpbiBwcm90bykge1xuXHRcdFx0dGhpc1tuXSA9IFVOREVGSU5FRDtcblx0XHR9XG5cdFx0ZXh0ZW5kKHRoaXMsIHNlcmllc1R5cGVzW25ld09wdGlvbnMudHlwZSB8fCBvbGRUeXBlXS5wcm90b3R5cGUpO1xuXG5cdFx0Ly8gUmUtcmVnaXN0ZXIgZ3JvdXBzICgjMzA5NClcblx0XHRlYWNoKHByZXNlcnZlLCBmdW5jdGlvbiAocHJvcCkge1xuXHRcdFx0c2VyaWVzW3Byb3BdID0gcHJlc2VydmVbcHJvcF07XG5cdFx0fSk7XG5cblx0XHR0aGlzLmluaXQoY2hhcnQsIG5ld09wdGlvbnMpO1xuXHRcdGNoYXJ0LmxpbmtTZXJpZXMoKTsgLy8gTGlua3MgYXJlIGxvc3QgaW4gdGhpcy5yZW1vdmUgKCMzMDI4KVxuXHRcdGlmIChwaWNrKHJlZHJhdywgdHJ1ZSkpIHtcblx0XHRcdGNoYXJ0LnJlZHJhdyhmYWxzZSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gRXh0ZW5kIHRoZSBBeGlzLnByb3RvdHlwZSBmb3IgZHluYW1pYyBtZXRob2RzXG5leHRlbmQoQXhpcy5wcm90b3R5cGUsIHtcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBheGlzIHdpdGggYSBuZXcgb3B0aW9ucyBzdHJ1Y3R1cmVcblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24gKG5ld09wdGlvbnMsIHJlZHJhdykge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cblx0XHRuZXdPcHRpb25zID0gY2hhcnQub3B0aW9uc1t0aGlzLmNvbGxdW3RoaXMub3B0aW9ucy5pbmRleF0gPSBtZXJnZSh0aGlzLnVzZXJPcHRpb25zLCBuZXdPcHRpb25zKTtcblxuXHRcdHRoaXMuZGVzdHJveSh0cnVlKTtcblx0XHR0aGlzLl9hZGRlZFBsb3RMQiA9IHRoaXMuY2hhcnQuX2xhYmVsUGFuZXMgPSBVTkRFRklORUQ7IC8vICMxNjExLCAjMjg4NywgIzQzMTRcblxuXHRcdHRoaXMuaW5pdChjaGFydCwgZXh0ZW5kKG5ld09wdGlvbnMsIHsgZXZlbnRzOiBVTkRFRklORUQgfSkpO1xuXG5cdFx0Y2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cdFx0aWYgKHBpY2socmVkcmF3LCB0cnVlKSkge1xuXHRcdFx0Y2hhcnQucmVkcmF3KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuICAgICAqIFJlbW92ZSB0aGUgYXhpcyBmcm9tIHRoZSBjaGFydFxuICAgICAqL1xuXHRyZW1vdmU6IGZ1bmN0aW9uIChyZWRyYXcpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0a2V5ID0gdGhpcy5jb2xsLCAvLyB4QXhpcyBvciB5QXhpc1xuXHRcdFx0YXhpc1NlcmllcyA9IHRoaXMuc2VyaWVzLFxuXHRcdFx0aSA9IGF4aXNTZXJpZXMubGVuZ3RoO1xuXG5cdFx0Ly8gUmVtb3ZlIGFzc29jaWF0ZWQgc2VyaWVzICgjMjY4Nylcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAoYXhpc1Nlcmllc1tpXSkge1xuXHRcdFx0XHRheGlzU2VyaWVzW2ldLnJlbW92ZShmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBheGlzXG5cdFx0ZXJhc2UoY2hhcnQuYXhlcywgdGhpcyk7XG5cdFx0ZXJhc2UoY2hhcnRba2V5XSwgdGhpcyk7XG5cdFx0Y2hhcnQub3B0aW9uc1trZXldLnNwbGljZSh0aGlzLm9wdGlvbnMuaW5kZXgsIDEpO1xuXHRcdGVhY2goY2hhcnRba2V5XSwgZnVuY3Rpb24gKGF4aXMsIGkpIHsgLy8gUmUtaW5kZXgsICMxNzA2XG5cdFx0XHRheGlzLm9wdGlvbnMuaW5kZXggPSBpO1xuXHRcdH0pO1xuXHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdGNoYXJ0LmlzRGlydHlCb3ggPSB0cnVlO1xuXG5cdFx0aWYgKHBpY2socmVkcmF3LCB0cnVlKSkge1xuXHRcdFx0Y2hhcnQucmVkcmF3KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGF4aXMgdGl0bGUgYnkgb3B0aW9uc1xuXHQgKi9cblx0c2V0VGl0bGU6IGZ1bmN0aW9uIChuZXdUaXRsZU9wdGlvbnMsIHJlZHJhdykge1xuXHRcdHRoaXMudXBkYXRlKHsgdGl0bGU6IG5ld1RpdGxlT3B0aW9ucyB9LCByZWRyYXcpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgbmV3IGF4aXMgY2F0ZWdvcmllcyBhbmQgb3B0aW9uYWxseSByZWRyYXdcblx0ICogQHBhcmFtIHtBcnJheX0gY2F0ZWdvcmllc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhd1xuXHQgKi9cblx0c2V0Q2F0ZWdvcmllczogZnVuY3Rpb24gKGNhdGVnb3JpZXMsIHJlZHJhdykge1xuXHRcdHRoaXMudXBkYXRlKHsgY2F0ZWdvcmllczogY2F0ZWdvcmllcyB9LCByZWRyYXcpO1xuXHR9XG5cbn0pO1xuXG5cbi8qKlxuICogTGluZVNlcmllcyBvYmplY3RcbiAqL1xudmFyIExpbmVTZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMpO1xuc2VyaWVzVHlwZXMubGluZSA9IExpbmVTZXJpZXM7XG5cbi8qKlxuICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGFyZWFcbiAqL1xuZGVmYXVsdFBsb3RPcHRpb25zLmFyZWEgPSBtZXJnZShkZWZhdWx0U2VyaWVzT3B0aW9ucywge1xuXHRzb2Z0VGhyZXNob2xkOiBmYWxzZSxcblx0dGhyZXNob2xkOiAwXG5cdC8vIHRyYWNrQnlBcmVhOiBmYWxzZSxcblx0Ly8gbGluZUNvbG9yOiBudWxsLCAvLyBvdmVycmlkZXMgY29sb3IsIGJ1dCBsZXRzIGZpbGxDb2xvciBiZSB1bmFsdGVyZWRcblx0Ly8gZmlsbE9wYWNpdHk6IDAuNzUsXG5cdC8vIGZpbGxDb2xvcjogbnVsbFxufSk7XG5cbi8qKlxuICogQXJlYVNlcmllcyBvYmplY3RcbiAqL1xudmFyIEFyZWFTZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMsIHtcblx0dHlwZTogJ2FyZWEnLFxuXHQvKipcblx0ICogRm9yIHN0YWNrcywgZG9uJ3Qgc3BsaXQgc2VnbWVudHMgb24gbnVsbCB2YWx1ZXMuIEluc3RlYWQsIGRyYXcgbnVsbCB2YWx1ZXMgd2l0aCBcblx0ICogbm8gbWFya2VyLiBBbHNvIGluc2VydCBkdW1teSBwb2ludHMgZm9yIGFueSBYIHBvc2l0aW9uIHRoYXQgZXhpc3RzIGluIG90aGVyIHNlcmllc1xuXHQgKiBpbiB0aGUgc3RhY2suXG5cdCAqLyBcblx0Z2V0U2VnbWVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRzZWdtZW50ID0gW10sXG5cdFx0XHRrZXlzID0gW10sXG5cdFx0XHR4QXhpcyA9IHRoaXMueEF4aXMsXG5cdFx0XHR5QXhpcyA9IHRoaXMueUF4aXMsXG5cdFx0XHRzdGFjayA9IHlBeGlzLnN0YWNrc1t0aGlzLnN0YWNrS2V5XSxcblx0XHRcdHBvaW50TWFwID0ge30sXG5cdFx0XHRwbG90WCxcblx0XHRcdHBsb3RZLFxuXHRcdFx0cG9pbnRzID0gdGhpcy5wb2ludHMsXG5cdFx0XHRjb25uZWN0TnVsbHMgPSB0aGlzLm9wdGlvbnMuY29ubmVjdE51bGxzLFxuXHRcdFx0c3RhY2tJbmRpY2F0b3IsXG5cdFx0XHRpLFxuXHRcdFx0eDtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc3RhY2tpbmcgJiYgIXRoaXMuY3JvcHBlZCkgeyAvLyBjcm9wcGVkIGNhdXNlcyBhcnRlZmFjdHMgaW4gU3RvY2ssIGFuZCBwZXJmIGlzc3VlXG5cdFx0XHQvLyBDcmVhdGUgYSBtYXAgd2hlcmUgd2UgY2FuIHF1aWNrbHkgbG9vayB1cCB0aGUgcG9pbnRzIGJ5IHRoZWlyIFggdmFsdWUuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHBvaW50TWFwW3BvaW50c1tpXS54XSA9IHBvaW50c1tpXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU29ydCB0aGUga2V5cyAoIzE2NTEpXG5cdFx0XHRmb3IgKHggaW4gc3RhY2spIHtcblx0XHRcdFx0aWYgKHN0YWNrW3hdLnRvdGFsICE9PSBudWxsKSB7IC8vIG51bGxlZCBhZnRlciBzd2l0Y2hpbmcgYmV0d2VlbiBncm91cGluZyBhbmQgbm90ICgjMTY1MSwgIzIzMzYpXG5cdFx0XHRcdFx0a2V5cy5wdXNoKCt4KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0a2V5cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhIC0gYjtcblx0XHRcdH0pO1xuXG5cdFx0XHRlYWNoKGtleXMsIGZ1bmN0aW9uICh4KSB7XG5cdFx0XHRcdHZhciB0aHJlc2hvbGQgPSBudWxsLFxuXHRcdFx0XHRcdHN0YWNrUG9pbnQ7XG5cblx0XHRcdFx0aWYgKGNvbm5lY3ROdWxscyAmJiAoIXBvaW50TWFwW3hdIHx8IHBvaW50TWFwW3hdLnkgPT09IG51bGwpKSB7IC8vICMxODM2XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdC8vIFRoZSBwb2ludCBleGlzdHMsIHB1c2ggaXQgdG8gdGhlIHNlZ21lbnRcblx0XHRcdFx0fSBlbHNlIGlmIChwb2ludE1hcFt4XSkge1xuXHRcdFx0XHRcdHNlZ21lbnQucHVzaChwb2ludE1hcFt4XSk7XG5cblx0XHRcdFx0Ly8gVGhlcmUgaXMgbm8gcG9pbnQgZm9yIHRoaXMgWCB2YWx1ZSBpbiB0aGlzIHNlcmllcywgc28gd2UgXG5cdFx0XHRcdC8vIGluc2VydCBhIGR1bW15IHBvaW50IGluIG9yZGVyIGZvciB0aGUgYXJlYXMgdG8gYmUgZHJhd25cblx0XHRcdFx0Ly8gY29ycmVjdGx5LlxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gTG9vcCBkb3duIHRoZSBzdGFjayB0byBmaW5kIHRoZSBzZXJpZXMgYmVsb3cgdGhpcyBvbmUgdGhhdCBoYXNcblx0XHRcdFx0XHQvLyBhIHZhbHVlICgjMTk5MSlcblx0XHRcdFx0XHRmb3IgKGkgPSBzZXJpZXMuaW5kZXg7IGkgPD0geUF4aXMuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XHRcdFxuXHRcdFx0XHRcdFx0c3RhY2tJbmRpY2F0b3IgPSBzZXJpZXMuZ2V0U3RhY2tJbmRpY2F0b3IobnVsbCwgeCwgaSk7XG5cdFx0XHRcdFx0XHRzdGFja1BvaW50ID0gc3RhY2tbeF0ucG9pbnRzW3N0YWNrSW5kaWNhdG9yLmtleV07XG5cdFx0XHRcdFx0XHRpZiAoc3RhY2tQb2ludCkge1xuXHRcdFx0XHRcdFx0XHR0aHJlc2hvbGQgPSBzdGFja1BvaW50WzFdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwbG90WCA9IHhBeGlzLnRyYW5zbGF0ZSh4KTtcblx0XHRcdFx0XHRwbG90WSA9IHlBeGlzLmdldFRocmVzaG9sZCh0aHJlc2hvbGQpO1xuXHRcdFx0XHRcdHNlZ21lbnQucHVzaCh7IFxuXHRcdFx0XHRcdFx0eTogbnVsbCwgXG5cdFx0XHRcdFx0XHRwbG90WDogcGxvdFgsXG5cdFx0XHRcdFx0XHRjbGllbnRYOiBwbG90WCwgXG5cdFx0XHRcdFx0XHRwbG90WTogcGxvdFksIFxuXHRcdFx0XHRcdFx0eUJvdHRvbTogcGxvdFksXG5cdFx0XHRcdFx0XHRvbk1vdXNlT3Zlcjogbm9vcFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHNlZ21lbnQubGVuZ3RoKSB7XG5cdFx0XHRcdHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0U2VyaWVzLnByb3RvdHlwZS5nZXRTZWdtZW50cy5jYWxsKHRoaXMpO1xuXHRcdFx0c2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuXHRcdH1cblxuXHRcdHRoaXMuc2VnbWVudHMgPSBzZWdtZW50cztcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBFeHRlbmQgdGhlIGJhc2UgU2VyaWVzIGdldFNlZ21lbnRQYXRoIG1ldGhvZCBieSBhZGRpbmcgdGhlIHBhdGggZm9yIHRoZSBhcmVhLlxuXHQgKiBUaGlzIHBhdGggaXMgcHVzaGVkIHRvIHRoZSBzZXJpZXMuYXJlYVBhdGggcHJvcGVydHkuXG5cdCAqL1xuXHRnZXRTZWdtZW50UGF0aDogZnVuY3Rpb24gKHNlZ21lbnQpIHtcblx0XHRcblx0XHR2YXIgc2VnbWVudFBhdGggPSBTZXJpZXMucHJvdG90eXBlLmdldFNlZ21lbnRQYXRoLmNhbGwodGhpcywgc2VnbWVudCksIC8vIGNhbGwgYmFzZSBtZXRob2Rcblx0XHRcdGFyZWFTZWdtZW50UGF0aCA9IFtdLmNvbmNhdChzZWdtZW50UGF0aCksIC8vIHdvcmsgb24gYSBjb3B5IGZvciB0aGUgYXJlYSBwYXRoXG5cdFx0XHRpLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHNlZ0xlbmd0aCA9IHNlZ21lbnRQYXRoLmxlbmd0aCxcblx0XHRcdHRyYW5zbGF0ZWRUaHJlc2hvbGQgPSB0aGlzLnlBeGlzLmdldFRocmVzaG9sZChvcHRpb25zLnRocmVzaG9sZCksIC8vICMyMTgxXG5cdFx0XHR5Qm90dG9tO1xuXHRcdFxuXHRcdGlmIChzZWdMZW5ndGggPT09IDMpIHsgLy8gZm9yIGFuaW1hdGlvbiBmcm9tIDEgdG8gdHdvIHBvaW50c1xuXHRcdFx0YXJlYVNlZ21lbnRQYXRoLnB1c2goTCwgc2VnbWVudFBhdGhbMV0sIHNlZ21lbnRQYXRoWzJdKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuc3RhY2tpbmcgJiYgIXRoaXMuY2xvc2VkU3RhY2tzKSB7XG5cdFx0XHRcblx0XHRcdC8vIEZvbGxvdyBzdGFjayBiYWNrLiBUb2RvOiBpbXBsZW1lbnQgYXJlYXNwbGluZS4gQSBnZW5lcmFsIHNvbHV0aW9uIGNvdWxkIGJlIHRvIFxuXHRcdFx0Ly8gcmV2ZXJzZSB0aGUgZW50aXJlIGdyYXBoUGF0aCBvZiB0aGUgcHJldmlvdXMgc2VyaWVzLCB0aG91Z2ggbWF5IGJlIGhhcmQgd2l0aFxuXHRcdFx0Ly8gc3BsaW5lcyBhbmQgd2l0aCBzZXJpZXMgd2l0aCBkaWZmZXJlbnQgZXh0cmVtZXNcblx0XHRcdGZvciAoaSA9IHNlZ21lbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblxuXHRcdFx0XHR5Qm90dG9tID0gcGljayhzZWdtZW50W2ldLnlCb3R0b20sIHRyYW5zbGF0ZWRUaHJlc2hvbGQpO1xuXHRcdFx0XG5cdFx0XHRcdC8vIHN0ZXAgbGluZT9cblx0XHRcdFx0aWYgKGkgPCBzZWdtZW50Lmxlbmd0aCAtIDEgJiYgb3B0aW9ucy5zdGVwKSB7XG5cdFx0XHRcdFx0YXJlYVNlZ21lbnRQYXRoLnB1c2goc2VnbWVudFtpICsgMV0ucGxvdFgsIHlCb3R0b20pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRhcmVhU2VnbWVudFBhdGgucHVzaChzZWdtZW50W2ldLnBsb3RYLCB5Qm90dG9tKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7IC8vIGZvbGxvdyB6ZXJvIGxpbmUgYmFja1xuXHRcdFx0dGhpcy5jbG9zZVNlZ21lbnQoYXJlYVNlZ21lbnRQYXRoLCBzZWdtZW50LCB0cmFuc2xhdGVkVGhyZXNob2xkKTtcblx0XHR9XG5cdFx0dGhpcy5hcmVhUGF0aCA9IHRoaXMuYXJlYVBhdGguY29uY2F0KGFyZWFTZWdtZW50UGF0aCk7XG5cdFx0cmV0dXJuIHNlZ21lbnRQYXRoO1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIEV4dGVuZGFibGUgbWV0aG9kIHRvIGNsb3NlIHRoZSBzZWdtZW50IHBhdGggb2YgYW4gYXJlYS4gVGhpcyBpcyBvdmVycmlkZGVuIGluIHBvbGFyIFxuXHQgKiBjaGFydHMuXG5cdCAqL1xuXHRjbG9zZVNlZ21lbnQ6IGZ1bmN0aW9uIChwYXRoLCBzZWdtZW50LCB0cmFuc2xhdGVkVGhyZXNob2xkKSB7XG5cdFx0cGF0aC5wdXNoKFxuXHRcdFx0TCxcblx0XHRcdHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSAxXS5wbG90WCxcblx0XHRcdHRyYW5zbGF0ZWRUaHJlc2hvbGQsXG5cdFx0XHRMLFxuXHRcdFx0c2VnbWVudFswXS5wbG90WCxcblx0XHRcdHRyYW5zbGF0ZWRUaHJlc2hvbGRcblx0XHQpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIERyYXcgdGhlIGdyYXBoIGFuZCB0aGUgdW5kZXJseWluZyBhcmVhLiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgU2VyaWVzIGJhc2Vcblx0ICogZnVuY3Rpb24gYW5kIGFkZHMgdGhlIGFyZWEuIFRoZSBhcmVhUGF0aCBpcyBjYWxjdWxhdGVkIGluIHRoZSBnZXRTZWdtZW50UGF0aFxuXHQgKiBtZXRob2QgY2FsbGVkIGZyb20gU2VyaWVzLnByb3RvdHlwZS5kcmF3R3JhcGguXG5cdCAqL1xuXHRkcmF3R3JhcGg6IGZ1bmN0aW9uICgpIHtcblx0XHRcblx0XHQvLyBEZWZpbmUgb3IgcmVzZXQgYXJlYVBhdGhcblx0XHR0aGlzLmFyZWFQYXRoID0gW107XG5cdFx0XG5cdFx0Ly8gQ2FsbCB0aGUgYmFzZSBtZXRob2Rcblx0XHRTZXJpZXMucHJvdG90eXBlLmRyYXdHcmFwaC5hcHBseSh0aGlzKTtcblx0XHRcblx0XHQvLyBEZWZpbmUgbG9jYWwgdmFyaWFibGVzXG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRhcmVhUGF0aCA9IHRoaXMuYXJlYVBhdGgsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0em9uZXMgPSB0aGlzLnpvbmVzLFxuXHRcdFx0cHJvcHMgPSBbWydhcmVhJywgdGhpcy5jb2xvciwgb3B0aW9ucy5maWxsQ29sb3JdXTsgLy8gYXJlYSBuYW1lLCBtYWluIGNvbG9yLCBmaWxsIGNvbG9yXG5cdFx0XG5cdFx0ZWFjaCh6b25lcywgZnVuY3Rpb24gKHRocmVzaG9sZCwgaSkge1xuXHRcdFx0cHJvcHMucHVzaChbJ3pvbmVBcmVhJyArIGksIHRocmVzaG9sZC5jb2xvciB8fCBzZXJpZXMuY29sb3IsIHRocmVzaG9sZC5maWxsQ29sb3IgfHwgb3B0aW9ucy5maWxsQ29sb3JdKTtcblx0XHR9KTtcblx0XHRlYWNoKHByb3BzLCBmdW5jdGlvbiAocHJvcCkge1xuXHRcdFx0dmFyIGFyZWFLZXkgPSBwcm9wWzBdLFxuXHRcdFx0XHRhcmVhID0gc2VyaWVzW2FyZWFLZXldO1xuXHRcdFx0XHRcblx0XHRcdC8vIENyZWF0ZSBvciB1cGRhdGUgdGhlIGFyZWFcblx0XHRcdGlmIChhcmVhKSB7IC8vIHVwZGF0ZVxuXHRcdFx0XHRhcmVhLmFuaW1hdGUoeyBkOiBhcmVhUGF0aCB9KTtcblx0XG5cdFx0XHR9IGVsc2UgeyAvLyBjcmVhdGVcblx0XHRcdFx0c2VyaWVzW2FyZWFLZXldID0gc2VyaWVzLmNoYXJ0LnJlbmRlcmVyLnBhdGgoYXJlYVBhdGgpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0ZmlsbDogcGljayhcblx0XHRcdFx0XHRcdFx0cHJvcFsyXSxcblx0XHRcdFx0XHRcdFx0Q29sb3IocHJvcFsxXSkuc2V0T3BhY2l0eShwaWNrKG9wdGlvbnMuZmlsbE9wYWNpdHksIDAuNzUpKS5nZXQoKVxuXHRcdFx0XHRcdFx0KSxcblx0XHRcdFx0XHRcdHpJbmRleDogMCAvLyAjMTA2OVxuXHRcdFx0XHRcdH0pLmFkZChzZXJpZXMuZ3JvdXApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGRyYXdMZWdlbmRTeW1ib2w6IExlZ2VuZFN5bWJvbE1peGluLmRyYXdSZWN0YW5nbGVcbn0pO1xuXG5zZXJpZXNUeXBlcy5hcmVhID0gQXJlYVNlcmllcztcbi8qKlxuICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHNwbGluZVxuICovXG5kZWZhdWx0UGxvdE9wdGlvbnMuc3BsaW5lID0gbWVyZ2UoZGVmYXVsdFNlcmllc09wdGlvbnMpO1xuXG4vKipcbiAqIFNwbGluZVNlcmllcyBvYmplY3RcbiAqL1xudmFyIFNwbGluZVNlcmllcyA9IGV4dGVuZENsYXNzKFNlcmllcywge1xuXHR0eXBlOiAnc3BsaW5lJyxcblxuXHQvKipcblx0ICogR2V0IHRoZSBzcGxpbmUgc2VnbWVudCBmcm9tIGEgZ2l2ZW4gcG9pbnQncyBwcmV2aW91cyBuZWlnaGJvdXIgdG8gdGhlIGdpdmVuIHBvaW50XG5cdCAqL1xuXHRnZXRQb2ludFNwbGluZTogZnVuY3Rpb24gKHNlZ21lbnQsIHBvaW50LCBpKSB7XG5cdFx0dmFyIHNtb290aGluZyA9IDEuNSwgLy8gMSBtZWFucyBjb250cm9sIHBvaW50cyBtaWR3YXkgYmV0d2VlbiBwb2ludHMsIDIgbWVhbnMgMS8zIGZyb20gdGhlIHBvaW50LCAzIGlzIDEvNCBldGNcblx0XHRcdGRlbm9tID0gc21vb3RoaW5nICsgMSxcblx0XHRcdHBsb3RYID0gcG9pbnQucGxvdFgsXG5cdFx0XHRwbG90WSA9IHBvaW50LnBsb3RZLFxuXHRcdFx0bGFzdFBvaW50ID0gc2VnbWVudFtpIC0gMV0sXG5cdFx0XHRuZXh0UG9pbnQgPSBzZWdtZW50W2kgKyAxXSxcblx0XHRcdGxlZnRDb250WCxcblx0XHRcdGxlZnRDb250WSxcblx0XHRcdHJpZ2h0Q29udFgsXG5cdFx0XHRyaWdodENvbnRZLFxuXHRcdFx0cmV0O1xuXG5cdFx0Ly8gZmluZCBjb250cm9sIHBvaW50c1xuXHRcdGlmIChsYXN0UG9pbnQgJiYgbmV4dFBvaW50KSB7XG5cdFx0XG5cdFx0XHR2YXIgbGFzdFggPSBsYXN0UG9pbnQucGxvdFgsXG5cdFx0XHRcdGxhc3RZID0gbGFzdFBvaW50LnBsb3RZLFxuXHRcdFx0XHRuZXh0WCA9IG5leHRQb2ludC5wbG90WCxcblx0XHRcdFx0bmV4dFkgPSBuZXh0UG9pbnQucGxvdFksXG5cdFx0XHRcdGNvcnJlY3Rpb247XG5cblx0XHRcdGxlZnRDb250WCA9IChzbW9vdGhpbmcgKiBwbG90WCArIGxhc3RYKSAvIGRlbm9tO1xuXHRcdFx0bGVmdENvbnRZID0gKHNtb290aGluZyAqIHBsb3RZICsgbGFzdFkpIC8gZGVub207XG5cdFx0XHRyaWdodENvbnRYID0gKHNtb290aGluZyAqIHBsb3RYICsgbmV4dFgpIC8gZGVub207XG5cdFx0XHRyaWdodENvbnRZID0gKHNtb290aGluZyAqIHBsb3RZICsgbmV4dFkpIC8gZGVub207XG5cblx0XHRcdC8vIGhhdmUgdGhlIHR3byBjb250cm9sIHBvaW50cyBtYWtlIGEgc3RyYWlnaHQgbGluZSB0aHJvdWdoIG1haW4gcG9pbnRcblx0XHRcdGNvcnJlY3Rpb24gPSAoKHJpZ2h0Q29udFkgLSBsZWZ0Q29udFkpICogKHJpZ2h0Q29udFggLSBwbG90WCkpIC9cblx0XHRcdFx0KHJpZ2h0Q29udFggLSBsZWZ0Q29udFgpICsgcGxvdFkgLSByaWdodENvbnRZO1xuXG5cdFx0XHRsZWZ0Q29udFkgKz0gY29ycmVjdGlvbjtcblx0XHRcdHJpZ2h0Q29udFkgKz0gY29ycmVjdGlvbjtcblxuXHRcdFx0Ly8gdG8gcHJldmVudCBmYWxzZSBleHRyZW1lcywgY2hlY2sgdGhhdCBjb250cm9sIHBvaW50cyBhcmUgYmV0d2VlblxuXHRcdFx0Ly8gbmVpZ2hib3VyaW5nIHBvaW50cycgeSB2YWx1ZXNcblx0XHRcdGlmIChsZWZ0Q29udFkgPiBsYXN0WSAmJiBsZWZ0Q29udFkgPiBwbG90WSkge1xuXHRcdFx0XHRsZWZ0Q29udFkgPSBtYXRoTWF4KGxhc3RZLCBwbG90WSk7XG5cdFx0XHRcdHJpZ2h0Q29udFkgPSAyICogcGxvdFkgLSBsZWZ0Q29udFk7IC8vIG1pcnJvciBvZiBsZWZ0IGNvbnRyb2wgcG9pbnRcblx0XHRcdH0gZWxzZSBpZiAobGVmdENvbnRZIDwgbGFzdFkgJiYgbGVmdENvbnRZIDwgcGxvdFkpIHtcblx0XHRcdFx0bGVmdENvbnRZID0gbWF0aE1pbihsYXN0WSwgcGxvdFkpO1xuXHRcdFx0XHRyaWdodENvbnRZID0gMiAqIHBsb3RZIC0gbGVmdENvbnRZO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJpZ2h0Q29udFkgPiBuZXh0WSAmJiByaWdodENvbnRZID4gcGxvdFkpIHtcblx0XHRcdFx0cmlnaHRDb250WSA9IG1hdGhNYXgobmV4dFksIHBsb3RZKTtcblx0XHRcdFx0bGVmdENvbnRZID0gMiAqIHBsb3RZIC0gcmlnaHRDb250WTtcblx0XHRcdH0gZWxzZSBpZiAocmlnaHRDb250WSA8IG5leHRZICYmIHJpZ2h0Q29udFkgPCBwbG90WSkge1xuXHRcdFx0XHRyaWdodENvbnRZID0gbWF0aE1pbihuZXh0WSwgcGxvdFkpO1xuXHRcdFx0XHRsZWZ0Q29udFkgPSAyICogcGxvdFkgLSByaWdodENvbnRZO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWNvcmQgZm9yIGRyYXdpbmcgaW4gbmV4dCBwb2ludFxuXHRcdFx0cG9pbnQucmlnaHRDb250WCA9IHJpZ2h0Q29udFg7XG5cdFx0XHRwb2ludC5yaWdodENvbnRZID0gcmlnaHRDb250WTtcblxuXHRcdH1cblx0XHRcblx0XHQvLyBWaXN1YWxpemUgY29udHJvbCBwb2ludHMgZm9yIGRlYnVnZ2luZ1xuXHRcdC8qXG5cdFx0aWYgKGxlZnRDb250WCkge1xuXHRcdFx0dGhpcy5jaGFydC5yZW5kZXJlci5jaXJjbGUobGVmdENvbnRYICsgdGhpcy5jaGFydC5wbG90TGVmdCwgbGVmdENvbnRZICsgdGhpcy5jaGFydC5wbG90VG9wLCAyKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0c3Ryb2tlOiAncmVkJyxcblx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogMSxcblx0XHRcdFx0XHRmaWxsOiAnbm9uZSdcblx0XHRcdFx0fSlcblx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0dGhpcy5jaGFydC5yZW5kZXJlci5wYXRoKFsnTScsIGxlZnRDb250WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIGxlZnRDb250WSArIHRoaXMuY2hhcnQucGxvdFRvcCxcblx0XHRcdFx0J0wnLCBwbG90WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIHBsb3RZICsgdGhpcy5jaGFydC5wbG90VG9wXSlcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdHN0cm9rZTogJ3JlZCcsXG5cdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IDFcblx0XHRcdFx0fSlcblx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0dGhpcy5jaGFydC5yZW5kZXJlci5jaXJjbGUocmlnaHRDb250WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIHJpZ2h0Q29udFkgKyB0aGlzLmNoYXJ0LnBsb3RUb3AsIDIpXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRzdHJva2U6ICdncmVlbicsXG5cdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IDEsXG5cdFx0XHRcdFx0ZmlsbDogJ25vbmUnXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGQoKTtcblx0XHRcdHRoaXMuY2hhcnQucmVuZGVyZXIucGF0aChbJ00nLCByaWdodENvbnRYICsgdGhpcy5jaGFydC5wbG90TGVmdCwgcmlnaHRDb250WSArIHRoaXMuY2hhcnQucGxvdFRvcCxcblx0XHRcdFx0J0wnLCBwbG90WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIHBsb3RZICsgdGhpcy5jaGFydC5wbG90VG9wXSlcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdHN0cm9rZTogJ2dyZWVuJyxcblx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogMVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYWRkKCk7XG5cdFx0fVxuXHRcdCovXG5cblx0XHQvLyBtb3ZlVG8gb3IgbGluZVRvXG5cdFx0aWYgKCFpKSB7XG5cdFx0XHRyZXQgPSBbTSwgcGxvdFgsIHBsb3RZXTtcblx0XHR9IGVsc2UgeyAvLyBjdXJ2ZSBmcm9tIGxhc3QgcG9pbnQgdG8gdGhpc1xuXHRcdFx0cmV0ID0gW1xuXHRcdFx0XHQnQycsXG5cdFx0XHRcdGxhc3RQb2ludC5yaWdodENvbnRYIHx8IGxhc3RQb2ludC5wbG90WCxcblx0XHRcdFx0bGFzdFBvaW50LnJpZ2h0Q29udFkgfHwgbGFzdFBvaW50LnBsb3RZLFxuXHRcdFx0XHRsZWZ0Q29udFggfHwgcGxvdFgsXG5cdFx0XHRcdGxlZnRDb250WSB8fCBwbG90WSxcblx0XHRcdFx0cGxvdFgsXG5cdFx0XHRcdHBsb3RZXG5cdFx0XHRdO1xuXHRcdFx0bGFzdFBvaW50LnJpZ2h0Q29udFggPSBsYXN0UG9pbnQucmlnaHRDb250WSA9IG51bGw7IC8vIHJlc2V0IGZvciB1cGRhdGluZyBzZXJpZXMgbGF0ZXJcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fVxufSk7XG5zZXJpZXNUeXBlcy5zcGxpbmUgPSBTcGxpbmVTZXJpZXM7XG5cbi8qKlxuICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGFyZWFzcGxpbmVcbiAqL1xuZGVmYXVsdFBsb3RPcHRpb25zLmFyZWFzcGxpbmUgPSBtZXJnZShkZWZhdWx0UGxvdE9wdGlvbnMuYXJlYSk7XG5cbi8qKlxuICogQXJlYVNwbGluZVNlcmllcyBvYmplY3RcbiAqL1xudmFyIGFyZWFQcm90byA9IEFyZWFTZXJpZXMucHJvdG90eXBlLFxuXHRBcmVhU3BsaW5lU2VyaWVzID0gZXh0ZW5kQ2xhc3MoU3BsaW5lU2VyaWVzLCB7XG5cdFx0dHlwZTogJ2FyZWFzcGxpbmUnLFxuXHRcdGNsb3NlZFN0YWNrczogdHJ1ZSwgLy8gaW5zdGVhZCBvZiBmb2xsb3dpbmcgdGhlIHByZXZpb3VzIGdyYXBoIGJhY2ssIGZvbGxvdyB0aGUgdGhyZXNob2xkIGJhY2tcblx0XHRcblx0XHQvLyBNaXggaW4gbWV0aG9kcyBmcm9tIHRoZSBhcmVhIHNlcmllc1xuXHRcdGdldFNlZ21lbnRQYXRoOiBhcmVhUHJvdG8uZ2V0U2VnbWVudFBhdGgsXG5cdFx0Y2xvc2VTZWdtZW50OiBhcmVhUHJvdG8uY2xvc2VTZWdtZW50LFxuXHRcdGRyYXdHcmFwaDogYXJlYVByb3RvLmRyYXdHcmFwaCxcblx0XHRkcmF3TGVnZW5kU3ltYm9sOiBMZWdlbmRTeW1ib2xNaXhpbi5kcmF3UmVjdGFuZ2xlXG5cdH0pO1xuXG5zZXJpZXNUeXBlcy5hcmVhc3BsaW5lID0gQXJlYVNwbGluZVNlcmllcztcblxuLyoqXG4gKiBTZXQgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgY29sdW1uXG4gKi9cbmRlZmF1bHRQbG90T3B0aW9ucy5jb2x1bW4gPSBtZXJnZShkZWZhdWx0U2VyaWVzT3B0aW9ucywge1xuXHRib3JkZXJDb2xvcjogJyNGRkZGRkYnLFxuXHQvL2JvcmRlcldpZHRoOiAxLFxuXHRib3JkZXJSYWRpdXM6IDAsXG5cdC8vY29sb3JCeVBvaW50OiB1bmRlZmluZWQsXG5cdGdyb3VwUGFkZGluZzogMC4yLFxuXHQvL2dyb3VwaW5nOiB0cnVlLFxuXHRtYXJrZXI6IG51bGwsIC8vIHBvaW50IG9wdGlvbnMgYXJlIHNwZWNpZmllZCBpbiB0aGUgYmFzZSBvcHRpb25zXG5cdHBvaW50UGFkZGluZzogMC4xLFxuXHQvL3BvaW50V2lkdGg6IG51bGwsXG5cdG1pblBvaW50TGVuZ3RoOiAwLFxuXHRjcm9wVGhyZXNob2xkOiA1MCwgLy8gd2hlbiB0aGVyZSBhcmUgbW9yZSBwb2ludHMsIHRoZXkgd2lsbCBub3QgYW5pbWF0ZSBvdXQgb2YgdGhlIGNoYXJ0IG9uIHhBeGlzLnNldEV4dHJlbWVzXG5cdHBvaW50UmFuZ2U6IG51bGwsIC8vIG51bGwgbWVhbnMgYXV0bywgbWVhbmluZyAxIGluIGEgY2F0ZWdvcml6ZWQgYXhpcyBhbmQgbGVhc3QgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgaWYgbm90IGNhdGVnb3JpZXNcblx0c3RhdGVzOiB7XG5cdFx0aG92ZXI6IHtcblx0XHRcdGJyaWdodG5lc3M6IDAuMSxcblx0XHRcdHNoYWRvdzogZmFsc2UsXG5cdFx0XHRoYWxvOiBmYWxzZVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRjb2xvcjogJyNDMEMwQzAnLFxuXHRcdFx0Ym9yZGVyQ29sb3I6ICcjMDAwMDAwJyxcblx0XHRcdHNoYWRvdzogZmFsc2Vcblx0XHR9XG5cdH0sXG5cdGRhdGFMYWJlbHM6IHtcblx0XHRhbGlnbjogbnVsbCwgLy8gYXV0b1xuXHRcdHZlcnRpY2FsQWxpZ246IG51bGwsIC8vIGF1dG9cblx0XHR5OiBudWxsXG5cdH0sXG5cdHNvZnRUaHJlc2hvbGQ6IGZhbHNlLFxuXHRzdGFydEZyb21UaHJlc2hvbGQ6IHRydWUsIC8vIGRvY3MgKGJ1dCBmYWxzZSBkb2Vzbid0IHdvcmsgd2VsbCk6IGh0dHA6Ly9qc2ZpZGRsZS5uZXQvaGlnaGNoYXJ0cy9oejhmb3Bhbi8xNC9cblx0c3RpY2t5VHJhY2tpbmc6IGZhbHNlLFxuXHR0b29sdGlwOiB7XG5cdFx0ZGlzdGFuY2U6IDZcblx0fSxcblx0dGhyZXNob2xkOiAwXG59KTtcblxuLyoqXG4gKiBDb2x1bW5TZXJpZXMgb2JqZWN0XG4gKi9cbnZhciBDb2x1bW5TZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMsIHtcblx0dHlwZTogJ2NvbHVtbicsXG5cdHBvaW50QXR0clRvT3B0aW9uczogeyAvLyBtYXBwaW5nIGJldHdlZW4gU1ZHIGF0dHJpYnV0ZXMgYW5kIHRoZSBjb3JyZXNwb25kaW5nIG9wdGlvbnNcblx0XHRzdHJva2U6ICdib3JkZXJDb2xvcicsXG5cdFx0ZmlsbDogJ2NvbG9yJyxcblx0XHRyOiAnYm9yZGVyUmFkaXVzJ1xuXHR9LFxuXHRjcm9wU2hvdWxkZXI6IDAsXG5cdGRpcmVjdFRvdWNoOiB0cnVlLCAvLyBXaGVuIHRvb2x0aXAgaXMgbm90IHNoYXJlZCwgdGhpcyBzZXJpZXMgKGFuZCBkZXJpdmF0aXZlcykgcmVxdWlyZXMgZGlyZWN0IHRvdWNoL2hvdmVyLiBLRC10cmVlIGRvZXMgbm90IGFwcGx5LlxuXHR0cmFja2VyR3JvdXBzOiBbJ2dyb3VwJywgJ2RhdGFMYWJlbHNHcm91cCddLFxuXHRuZWdTdGFja3M6IHRydWUsIC8vIHVzZSBzZXBhcmF0ZSBuZWdhdGl2ZSBzdGFja3MsIHVubGlrZSBhcmVhIHN0YWNrcyB3aGVyZSBhIG5lZ2F0aXZlIFxuXHRcdC8vIHBvaW50IGlzIHN1YnN0cmFjdGVkIGZyb20gcHJldmlvdXMgKCMxOTEwKVxuXHRcblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIHNlcmllc1xuXHQgKi9cblx0aW5pdDogZnVuY3Rpb24gKCkge1xuXHRcdFNlcmllcy5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydDtcblxuXHRcdC8vIGlmIHRoZSBzZXJpZXMgaXMgYWRkZWQgZHluYW1pY2FsbHksIGZvcmNlIHJlZHJhdyBvZiBvdGhlclxuXHRcdC8vIHNlcmllcyBhZmZlY3RlZCBieSBhIG5ldyBjb2x1bW5cblx0XHRpZiAoY2hhcnQuaGFzUmVuZGVyZWQpIHtcblx0XHRcdGVhY2goY2hhcnQuc2VyaWVzLCBmdW5jdGlvbiAob3RoZXJTZXJpZXMpIHtcblx0XHRcdFx0aWYgKG90aGVyU2VyaWVzLnR5cGUgPT09IHNlcmllcy50eXBlKSB7XG5cdFx0XHRcdFx0b3RoZXJTZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSB3aWR0aCBhbmQgeCBvZmZzZXQgb2YgdGhlIGNvbHVtbnMgYWRqdXN0ZWQgZm9yIGdyb3VwaW5nLCBncm91cFBhZGRpbmcsIHBvaW50UGFkZGluZyxcblx0ICogcG9pbnRXaWR0aCBldGMuIFxuXHQgKi9cblx0Z2V0Q29sdW1uTWV0cmljczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHR4QXhpcyA9IHNlcmllcy54QXhpcyxcblx0XHRcdHlBeGlzID0gc2VyaWVzLnlBeGlzLFxuXHRcdFx0cmV2ZXJzZWRYQXhpcyA9IHhBeGlzLnJldmVyc2VkLFxuXHRcdFx0c3RhY2tLZXksXG5cdFx0XHRzdGFja0dyb3VwcyA9IHt9LFxuXHRcdFx0Y29sdW1uSW5kZXgsXG5cdFx0XHRjb2x1bW5Db3VudCA9IDA7XG5cblx0XHQvLyBHZXQgdGhlIHRvdGFsIG51bWJlciBvZiBjb2x1bW4gdHlwZSBzZXJpZXMuXG5cdFx0Ly8gVGhpcyBpcyBjYWxsZWQgb24gZXZlcnkgc2VyaWVzLiBDb25zaWRlciBtb3ZpbmcgdGhpcyBsb2dpYyB0byBhXG5cdFx0Ly8gY2hhcnQub3JkZXJTdGFja3MoKSBmdW5jdGlvbiBhbmQgY2FsbCBpdCBvbiBpbml0LCBhZGRTZXJpZXMgYW5kIHJlbW92ZVNlcmllc1xuXHRcdGlmIChvcHRpb25zLmdyb3VwaW5nID09PSBmYWxzZSkge1xuXHRcdFx0Y29sdW1uQ291bnQgPSAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlYWNoKHNlcmllcy5jaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChvdGhlclNlcmllcykge1xuXHRcdFx0XHR2YXIgb3RoZXJPcHRpb25zID0gb3RoZXJTZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0XHRvdGhlcllBeGlzID0gb3RoZXJTZXJpZXMueUF4aXM7XG5cdFx0XHRcdGlmIChvdGhlclNlcmllcy50eXBlID09PSBzZXJpZXMudHlwZSAmJiBvdGhlclNlcmllcy52aXNpYmxlICYmXG5cdFx0XHRcdFx0XHR5QXhpcy5sZW4gPT09IG90aGVyWUF4aXMubGVuICYmIHlBeGlzLnBvcyA9PT0gb3RoZXJZQXhpcy5wb3MpIHsgIC8vICM2NDIsICMyMDg2XG5cdFx0XHRcdFx0aWYgKG90aGVyT3B0aW9ucy5zdGFja2luZykge1xuXHRcdFx0XHRcdFx0c3RhY2tLZXkgPSBvdGhlclNlcmllcy5zdGFja0tleTtcblx0XHRcdFx0XHRcdGlmIChzdGFja0dyb3Vwc1tzdGFja0tleV0gPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0XHRzdGFja0dyb3Vwc1tzdGFja0tleV0gPSBjb2x1bW5Db3VudCsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29sdW1uSW5kZXggPSBzdGFja0dyb3Vwc1tzdGFja0tleV07XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChvdGhlck9wdGlvbnMuZ3JvdXBpbmcgIT09IGZhbHNlKSB7IC8vICMxMTYyXG5cdFx0XHRcdFx0XHRjb2x1bW5JbmRleCA9IGNvbHVtbkNvdW50Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG90aGVyU2VyaWVzLmNvbHVtbkluZGV4ID0gY29sdW1uSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBjYXRlZ29yeVdpZHRoID0gbWF0aE1pbihcblx0XHRcdFx0bWF0aEFicyh4QXhpcy50cmFuc0EpICogKHhBeGlzLm9yZGluYWxTbG9wZSB8fCBvcHRpb25zLnBvaW50UmFuZ2UgfHwgeEF4aXMuY2xvc2VzdFBvaW50UmFuZ2UgfHwgeEF4aXMudGlja0ludGVydmFsIHx8IDEpLCAvLyAjMjYxMFxuXHRcdFx0XHR4QXhpcy5sZW4gLy8gIzE1MzVcblx0XHRcdCksXG5cdFx0XHRncm91cFBhZGRpbmcgPSBjYXRlZ29yeVdpZHRoICogb3B0aW9ucy5ncm91cFBhZGRpbmcsXG5cdFx0XHRncm91cFdpZHRoID0gY2F0ZWdvcnlXaWR0aCAtIDIgKiBncm91cFBhZGRpbmcsXG5cdFx0XHRwb2ludE9mZnNldFdpZHRoID0gZ3JvdXBXaWR0aCAvIGNvbHVtbkNvdW50LFxuXHRcdFx0cG9pbnRXaWR0aCA9IG1hdGhNaW4oXG5cdFx0XHRcdG9wdGlvbnMubWF4UG9pbnRXaWR0aCB8fCB4QXhpcy5sZW4sXG5cdFx0XHRcdHBpY2sob3B0aW9ucy5wb2ludFdpZHRoLCBwb2ludE9mZnNldFdpZHRoICogKDEgLSAyICogb3B0aW9ucy5wb2ludFBhZGRpbmcpKVxuXHRcdFx0KSxcblx0XHRcdHBvaW50UGFkZGluZyA9IChwb2ludE9mZnNldFdpZHRoIC0gcG9pbnRXaWR0aCkgLyAyLFxuXHRcdFx0Y29sSW5kZXggPSAocmV2ZXJzZWRYQXhpcyA/IFxuXHRcdFx0XHRjb2x1bW5Db3VudCAtIChzZXJpZXMuY29sdW1uSW5kZXggfHwgMCkgOiAvLyAjMTI1MVxuXHRcdFx0XHRzZXJpZXMuY29sdW1uSW5kZXgpIHx8IDAsXG5cdFx0XHRwb2ludFhPZmZzZXQgPSBwb2ludFBhZGRpbmcgKyAoZ3JvdXBQYWRkaW5nICsgY29sSW5kZXggKlxuXHRcdFx0XHRwb2ludE9mZnNldFdpZHRoIC0gKGNhdGVnb3J5V2lkdGggLyAyKSkgKlxuXHRcdFx0XHQocmV2ZXJzZWRYQXhpcyA/IC0xIDogMSk7XG5cblx0XHQvLyBTYXZlIGl0IGZvciByZWFkaW5nIGluIGxpbmtlZCBzZXJpZXMgKEVycm9yIGJhcnMgcGFydGljdWxhcmx5KVxuXHRcdHJldHVybiAoc2VyaWVzLmNvbHVtbk1ldHJpY3MgPSB7IFxuXHRcdFx0d2lkdGg6IHBvaW50V2lkdGgsIFxuXHRcdFx0b2Zmc2V0OiBwb2ludFhPZmZzZXQgXG5cdFx0fSk7XG5cdFx0XHRcblx0fSxcblxuXHQvKipcblx0ICogTWFrZSB0aGUgY29sdW1ucyBjcmlzcC4gVGhlIGVkZ2VzIGFyZSByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IGZ1bGwgcGl4ZWwuXG5cdCAqL1xuXHRjcmlzcENvbDogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0Ym9yZGVyV2lkdGggPSB0aGlzLmJvcmRlcldpZHRoLFxuXHRcdFx0eENyaXNwID0gLShib3JkZXJXaWR0aCAlIDIgPyAwLjUgOiAwKSxcblx0XHRcdHlDcmlzcCA9IGJvcmRlcldpZHRoICUgMiA/IDAuNSA6IDEsXG5cdFx0XHRyaWdodCxcblx0XHRcdGJvdHRvbSxcblx0XHRcdGZyb21Ub3A7XG5cblx0XHRpZiAoY2hhcnQuaW52ZXJ0ZWQgJiYgY2hhcnQucmVuZGVyZXIuaXNWTUwpIHtcblx0XHRcdHlDcmlzcCArPSAxO1xuXHRcdH1cblx0XHRcblx0XHQvLyBIb3Jpem9udGFsLiBXZSBuZWVkIHRvIGZpcnN0IGNvbXB1dGUgdGhlIGV4YWN0IHJpZ2h0IGVkZ2UsIHRoZW4gcm91bmQgaXRcblx0XHQvLyBhbmQgY29tcHV0ZSB0aGUgd2lkdGggZnJvbSB0aGVyZS5cblx0XHRyaWdodCA9IE1hdGgucm91bmQoeCArIHcpICsgeENyaXNwO1xuXHRcdHggPSBNYXRoLnJvdW5kKHgpICsgeENyaXNwO1xuXHRcdHcgPSByaWdodCAtIHg7XG5cblx0XHQvLyBWZXJ0aWNhbFxuXHRcdGZyb21Ub3AgPSBtYXRoQWJzKHkpIDw9IDAuNTsgLy8gIzQ1MDRcblx0XHRib3R0b20gPSBNYXRoLnJvdW5kKHkgKyBoKSArIHlDcmlzcDtcblx0XHR5ID0gTWF0aC5yb3VuZCh5KSArIHlDcmlzcDtcblx0XHRoID0gYm90dG9tIC0geTtcblxuXHRcdC8vIFRvcCBlZGdlcyBhcmUgZXhjZXB0aW9uc1xuXHRcdGlmIChmcm9tVG9wKSB7XG5cdFx0XHR5IC09IDE7XG5cdFx0XHRoICs9IDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHgsXG5cdFx0XHR5OiB5LFxuXHRcdFx0d2lkdGg6IHcsXG5cdFx0XHRoZWlnaHQ6IGhcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUcmFuc2xhdGUgZWFjaCBwb2ludCB0byB0aGUgcGxvdCBhcmVhIGNvb3JkaW5hdGUgc3lzdGVtIGFuZCBmaW5kIHNoYXBlIHBvc2l0aW9uc1xuXHQgKi9cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdGJvcmRlcldpZHRoID0gc2VyaWVzLmJvcmRlcldpZHRoID0gcGljayhcblx0XHRcdFx0b3B0aW9ucy5ib3JkZXJXaWR0aCwgXG5cdFx0XHRcdHNlcmllcy5jbG9zZXN0UG9pbnRSYW5nZSAqIHNlcmllcy54QXhpcy50cmFuc0EgPCAyID8gMCA6IDEgLy8gIzM2MzVcblx0XHRcdCksXG5cdFx0XHR5QXhpcyA9IHNlcmllcy55QXhpcyxcblx0XHRcdHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkLFxuXHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZCA9IHNlcmllcy50cmFuc2xhdGVkVGhyZXNob2xkID0geUF4aXMuZ2V0VGhyZXNob2xkKHRocmVzaG9sZCksXG5cdFx0XHRtaW5Qb2ludExlbmd0aCA9IHBpY2sob3B0aW9ucy5taW5Qb2ludExlbmd0aCwgNSksXG5cdFx0XHRtZXRyaWNzID0gc2VyaWVzLmdldENvbHVtbk1ldHJpY3MoKSxcblx0XHRcdHBvaW50V2lkdGggPSBtZXRyaWNzLndpZHRoLFxuXHRcdFx0c2VyaWVzQmFyVyA9IHNlcmllcy5iYXJXID0gbWF0aE1heChwb2ludFdpZHRoLCAxICsgMiAqIGJvcmRlcldpZHRoKSwgLy8gcG9zdHByb2Nlc3NlZCBmb3IgYm9yZGVyIHdpZHRoXG5cdFx0XHRwb2ludFhPZmZzZXQgPSBzZXJpZXMucG9pbnRYT2Zmc2V0ID0gbWV0cmljcy5vZmZzZXQ7XG5cblx0XHRpZiAoY2hhcnQuaW52ZXJ0ZWQpIHtcblx0XHRcdHRyYW5zbGF0ZWRUaHJlc2hvbGQgLT0gMC41OyAvLyAjMzM1NVxuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIHBvaW50UGFkZGluZyBpcyAwLCB3ZSB3YW50IHRoZSBjb2x1bW5zIHRvIGJlIHBhY2tlZCB0aWdodGx5LCBzbyB3ZSBhbGxvdyBpbmRpdmlkdWFsXG5cdFx0Ly8gY29sdW1ucyB0byBoYXZlIGluZGl2aWR1YWwgc2l6ZXMuIFdoZW4gcG9pbnRQYWRkaW5nIGlzIGdyZWF0ZXIsIHdlIHN0cml2ZSBmb3IgZXF1YWwtd2lkdGhcblx0XHQvLyBjb2x1bW5zICgjMjY5NCkuXG5cdFx0aWYgKG9wdGlvbnMucG9pbnRQYWRkaW5nKSB7XG5cdFx0XHRzZXJpZXNCYXJXID0gbWF0aENlaWwoc2VyaWVzQmFyVyk7XG5cdFx0fVxuXG5cdFx0U2VyaWVzLnByb3RvdHlwZS50cmFuc2xhdGUuYXBwbHkoc2VyaWVzKTtcblxuXHRcdC8vIFJlY29yZCB0aGUgbmV3IHZhbHVlc1xuXHRcdGVhY2goc2VyaWVzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHR2YXIgeUJvdHRvbSA9IG1hdGhNaW4ocGljayhwb2ludC55Qm90dG9tLCB0cmFuc2xhdGVkVGhyZXNob2xkKSwgOWU0KSwgLy8gIzM1NzVcblx0XHRcdFx0c2FmZURpc3RhbmNlID0gOTk5ICsgbWF0aEFicyh5Qm90dG9tKSxcblx0XHRcdFx0cGxvdFkgPSBtYXRoTWluKG1hdGhNYXgoLXNhZmVEaXN0YW5jZSwgcG9pbnQucGxvdFkpLCB5QXhpcy5sZW4gKyBzYWZlRGlzdGFuY2UpLCAvLyBEb24ndCBkcmF3IHRvbyBmYXIgb3V0c2lkZSBwbG90IGFyZWEgKCMxMzAzLCAjMjI0MSwgIzQyNjQpXG5cdFx0XHRcdGJhclggPSBwb2ludC5wbG90WCArIHBvaW50WE9mZnNldCxcblx0XHRcdFx0YmFyVyA9IHNlcmllc0JhclcsXG5cdFx0XHRcdGJhclkgPSBtYXRoTWluKHBsb3RZLCB5Qm90dG9tKSxcblx0XHRcdFx0dXAsXG5cdFx0XHRcdGJhckggPSBtYXRoTWF4KHBsb3RZLCB5Qm90dG9tKSAtIGJhclk7XG5cblx0XHRcdC8vIEhhbmRsZSBvcHRpb25zLm1pblBvaW50TGVuZ3RoXG5cdFx0XHRpZiAobWF0aEFicyhiYXJIKSA8IG1pblBvaW50TGVuZ3RoKSB7XG5cdFx0XHRcdGlmIChtaW5Qb2ludExlbmd0aCkge1xuXHRcdFx0XHRcdGJhckggPSBtaW5Qb2ludExlbmd0aDtcblx0XHRcdFx0XHR1cCA9ICgheUF4aXMucmV2ZXJzZWQgJiYgIXBvaW50Lm5lZ2F0aXZlKSB8fCAoeUF4aXMucmV2ZXJzZWQgJiYgcG9pbnQubmVnYXRpdmUpO1xuXHRcdFx0XHRcdGJhclkgPSBtYXRoQWJzKGJhclkgLSB0cmFuc2xhdGVkVGhyZXNob2xkKSA+IG1pblBvaW50TGVuZ3RoID8gLy8gc3RhY2tlZFxuXHRcdFx0XHRcdFx0XHR5Qm90dG9tIC0gbWluUG9pbnRMZW5ndGggOiAvLyBrZWVwIHBvc2l0aW9uXG5cdFx0XHRcdFx0XHRcdHRyYW5zbGF0ZWRUaHJlc2hvbGQgLSAodXAgPyBtaW5Qb2ludExlbmd0aCA6IDApOyAvLyAjMTQ4NSwgIzQwNTFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWNoZSBmb3IgYWNjZXNzIGluIHBvbGFyXG5cdFx0XHRwb2ludC5iYXJYID0gYmFyWDtcblx0XHRcdHBvaW50LnBvaW50V2lkdGggPSBwb2ludFdpZHRoO1xuXG5cdFx0XHQvLyBGaXggdGhlIHRvb2x0aXAgb24gY2VudGVyIG9mIGdyb3VwZWQgY29sdW1ucyAoIzEyMTYsICM0MjQsICMzNjQ4KVxuXHRcdFx0cG9pbnQudG9vbHRpcFBvcyA9IGNoYXJ0LmludmVydGVkID8gXG5cdFx0XHRcdFt5QXhpcy5sZW4gKyB5QXhpcy5wb3MgLSBjaGFydC5wbG90TGVmdCAtIHBsb3RZLCBzZXJpZXMueEF4aXMubGVuIC0gYmFyWCAtIGJhclcgLyAyLCBiYXJIXSA6IFxuXHRcdFx0XHRbYmFyWCArIGJhclcgLyAyLCBwbG90WSArIHlBeGlzLnBvcyAtIGNoYXJ0LnBsb3RUb3AsIGJhckhdO1xuXG5cdFx0XHQvLyBSZWdpc3RlciBzaGFwZSB0eXBlIGFuZCBhcmd1bWVudHMgdG8gYmUgdXNlZCBpbiBkcmF3UG9pbnRzXG5cdFx0XHRwb2ludC5zaGFwZVR5cGUgPSAncmVjdCc7XG5cdFx0XHRwb2ludC5zaGFwZUFyZ3MgPSBzZXJpZXMuY3Jpc3BDb2woYmFyWCwgYmFyWSwgYmFyVywgYmFySCk7XG5cdFx0fSk7XG5cblx0fSxcblxuXHRnZXRTeW1ib2w6IG5vb3AsXG5cdFxuXHQvKipcblx0ICogVXNlIGEgc29saWQgcmVjdGFuZ2xlIGxpa2UgdGhlIGFyZWEgc2VyaWVzIHR5cGVzXG5cdCAqL1xuXHRkcmF3TGVnZW5kU3ltYm9sOiBMZWdlbmRTeW1ib2xNaXhpbi5kcmF3UmVjdGFuZ2xlLFxuXHRcblx0XG5cdC8qKlxuXHQgKiBDb2x1bW5zIGhhdmUgbm8gZ3JhcGhcblx0ICovXG5cdGRyYXdHcmFwaDogbm9vcCxcblxuXHQvKipcblx0ICogRHJhdyB0aGUgY29sdW1ucy4gRm9yIGJhcnMsIHRoZSBzZXJpZXMuZ3JvdXAgaXMgcm90YXRlZCwgc28gdGhlIHNhbWUgY29vcmRpbmF0ZXNcblx0ICogYXBwbHkgZm9yIGNvbHVtbnMgYW5kIGJhcnMuIFRoaXMgbWV0aG9kIGlzIGluaGVyaXRlZCBieSBzY2F0dGVyIHNlcmllcy5cblx0ICpcblx0ICovXG5cdGRyYXdQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRhbmltYXRpb25MaW1pdCA9IG9wdGlvbnMuYW5pbWF0aW9uTGltaXQgfHwgMjUwLFxuXHRcdFx0c2hhcGVBcmdzLFxuXHRcdFx0cG9pbnRBdHRyO1xuXG5cdFx0Ly8gZHJhdyB0aGUgY29sdW1uc1xuXHRcdGVhY2goc2VyaWVzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHR2YXIgcGxvdFkgPSBwb2ludC5wbG90WSxcblx0XHRcdFx0Z3JhcGhpYyA9IHBvaW50LmdyYXBoaWMsXG5cdFx0XHRcdGJvcmRlckF0dHI7XG5cblx0XHRcdGlmIChwbG90WSAhPT0gVU5ERUZJTkVEICYmICFpc05hTihwbG90WSkgJiYgcG9pbnQueSAhPT0gbnVsbCkge1xuXHRcdFx0XHRzaGFwZUFyZ3MgPSBwb2ludC5zaGFwZUFyZ3M7XG5cblx0XHRcdFx0Ym9yZGVyQXR0ciA9IGRlZmluZWQoc2VyaWVzLmJvcmRlcldpZHRoKSA/IHtcblx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogc2VyaWVzLmJvcmRlcldpZHRoXG5cdFx0XHRcdH0gOiB7fTtcblxuXHRcdFx0XHRwb2ludEF0dHIgPSBwb2ludC5wb2ludEF0dHJbcG9pbnQuc2VsZWN0ZWQgPyBTRUxFQ1RfU1RBVEUgOiBOT1JNQUxfU1RBVEVdIHx8IHNlcmllcy5wb2ludEF0dHJbTk9STUFMX1NUQVRFXTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChncmFwaGljKSB7IC8vIHVwZGF0ZVxuXHRcdFx0XHRcdHN0b3AoZ3JhcGhpYyk7XG5cdFx0XHRcdFx0Z3JhcGhpYy5hdHRyKGJvcmRlckF0dHIpW2NoYXJ0LnBvaW50Q291bnQgPCBhbmltYXRpb25MaW1pdCA/ICdhbmltYXRlJyA6ICdhdHRyJ10obWVyZ2Uoc2hhcGVBcmdzKSk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwb2ludC5ncmFwaGljID0gZ3JhcGhpYyA9IHJlbmRlcmVyW3BvaW50LnNoYXBlVHlwZV0oc2hhcGVBcmdzKVxuXHRcdFx0XHRcdFx0LmF0dHIoYm9yZGVyQXR0cilcblx0XHRcdFx0XHRcdC5hdHRyKHBvaW50QXR0cilcblx0XHRcdFx0XHRcdC5hZGQocG9pbnQuZ3JvdXAgfHwgc2VyaWVzLmdyb3VwKVxuXHRcdFx0XHRcdFx0LnNoYWRvdyhvcHRpb25zLnNoYWRvdywgbnVsbCwgb3B0aW9ucy5zdGFja2luZyAmJiAhb3B0aW9ucy5ib3JkZXJSYWRpdXMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoZ3JhcGhpYykge1xuXHRcdFx0XHRwb2ludC5ncmFwaGljID0gZ3JhcGhpYy5kZXN0cm95KCk7IC8vICMxMjY5XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFuaW1hdGUgdGhlIGNvbHVtbiBoZWlnaHRzIG9uZSBieSBvbmUgZnJvbSB6ZXJvXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdCBXaGV0aGVyIHRvIGluaXRpYWxpemUgdGhlIGFuaW1hdGlvbiBvciBydW4gaXRcblx0ICovXG5cdGFuaW1hdGU6IGZ1bmN0aW9uIChpbml0KSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHR5QXhpcyA9IHRoaXMueUF4aXMsXG5cdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRpbnZlcnRlZCA9IHRoaXMuY2hhcnQuaW52ZXJ0ZWQsXG5cdFx0XHRhdHRyID0ge30sXG5cdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkO1xuXG5cdFx0aWYgKGhhc1NWRykgeyAvLyBWTUwgaXMgdG9vIHNsb3cgYW55d2F5XG5cdFx0XHRpZiAoaW5pdCkge1xuXHRcdFx0XHRhdHRyLnNjYWxlWSA9IDAuMDAxO1xuXHRcdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkID0gbWF0aE1pbih5QXhpcy5wb3MgKyB5QXhpcy5sZW4sIG1hdGhNYXgoeUF4aXMucG9zLCB5QXhpcy50b1BpeGVscyhvcHRpb25zLnRocmVzaG9sZCkpKTtcblx0XHRcdFx0aWYgKGludmVydGVkKSB7XG5cdFx0XHRcdFx0YXR0ci50cmFuc2xhdGVYID0gdHJhbnNsYXRlZFRocmVzaG9sZCAtIHlBeGlzLmxlbjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhdHRyLnRyYW5zbGF0ZVkgPSB0cmFuc2xhdGVkVGhyZXNob2xkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlcmllcy5ncm91cC5hdHRyKGF0dHIpO1xuXG5cdFx0XHR9IGVsc2UgeyAvLyBydW4gdGhlIGFuaW1hdGlvblxuXHRcdFx0XHRcblx0XHRcdFx0YXR0ci5zY2FsZVkgPSAxO1xuXHRcdFx0XHRhdHRyW2ludmVydGVkID8gJ3RyYW5zbGF0ZVgnIDogJ3RyYW5zbGF0ZVknXSA9IHlBeGlzLnBvcztcblx0XHRcdFx0c2VyaWVzLmdyb3VwLmFuaW1hdGUoYXR0ciwgc2VyaWVzLm9wdGlvbnMuYW5pbWF0aW9uKTtcblxuXHRcdFx0XHQvLyBkZWxldGUgdGhpcyBmdW5jdGlvbiB0byBhbGxvdyBpdCBvbmx5IG9uY2Vcblx0XHRcdFx0c2VyaWVzLmFuaW1hdGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQgKiBSZW1vdmUgdGhpcyBzZXJpZXMgZnJvbSB0aGUgY2hhcnRcblx0ICovXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQ7XG5cblx0XHQvLyBjb2x1bW4gYW5kIGJhciBzZXJpZXMgYWZmZWN0cyBvdGhlciBzZXJpZXMgb2YgdGhlIHNhbWUgdHlwZVxuXHRcdC8vIGFzIHRoZXkgYXJlIGVpdGhlciBzdGFja2VkIG9yIGdyb3VwZWRcblx0XHRpZiAoY2hhcnQuaGFzUmVuZGVyZWQpIHtcblx0XHRcdGVhY2goY2hhcnQuc2VyaWVzLCBmdW5jdGlvbiAob3RoZXJTZXJpZXMpIHtcblx0XHRcdFx0aWYgKG90aGVyU2VyaWVzLnR5cGUgPT09IHNlcmllcy50eXBlKSB7XG5cdFx0XHRcdFx0b3RoZXJTZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdFNlcmllcy5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHNlcmllcywgYXJndW1lbnRzKTtcblx0fVxufSk7XG5zZXJpZXNUeXBlcy5jb2x1bW4gPSBDb2x1bW5TZXJpZXM7XG4vKipcbiAqIFNldCB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciBiYXJcbiAqL1xuZGVmYXVsdFBsb3RPcHRpb25zLmJhciA9IG1lcmdlKGRlZmF1bHRQbG90T3B0aW9ucy5jb2x1bW4pO1xuLyoqXG4gKiBUaGUgQmFyIHNlcmllcyBjbGFzc1xuICovXG52YXIgQmFyU2VyaWVzID0gZXh0ZW5kQ2xhc3MoQ29sdW1uU2VyaWVzLCB7XG5cdHR5cGU6ICdiYXInLFxuXHRpbnZlcnRlZDogdHJ1ZVxufSk7XG5zZXJpZXNUeXBlcy5iYXIgPSBCYXJTZXJpZXM7XG5cbi8qKlxuICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHNjYXR0ZXJcbiAqL1xuZGVmYXVsdFBsb3RPcHRpb25zLnNjYXR0ZXIgPSBtZXJnZShkZWZhdWx0U2VyaWVzT3B0aW9ucywge1xuXHRsaW5lV2lkdGg6IDAsXG5cdG1hcmtlcjoge1xuXHRcdGVuYWJsZWQ6IHRydWUgLy8gT3ZlcnJpZGVzIGF1dG8tZW5hYmxpbmcgaW4gbGluZSBzZXJpZXMgKCMzNjQ3KVxuXHR9LFxuXHR0b29sdGlwOiB7XG5cdFx0aGVhZGVyRm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJjb2xvcjp7cG9pbnQuY29sb3J9XCI+XFx1MjVDRjwvc3Bhbj4gPHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDEwcHg7XCI+IHtzZXJpZXMubmFtZX08L3NwYW4+PGJyLz4nLFxuXHRcdHBvaW50Rm9ybWF0OiAneDogPGI+e3BvaW50Lnh9PC9iPjxici8+eTogPGI+e3BvaW50Lnl9PC9iPjxici8+J1xuXHR9XG59KTtcblxuLyoqXG4gKiBUaGUgc2NhdHRlciBzZXJpZXMgY2xhc3NcbiAqL1xudmFyIFNjYXR0ZXJTZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMsIHtcblx0dHlwZTogJ3NjYXR0ZXInLFxuXHRzb3J0ZWQ6IGZhbHNlLFxuXHRyZXF1aXJlU29ydGluZzogZmFsc2UsXG5cdG5vU2hhcmVkVG9vbHRpcDogdHJ1ZSxcblx0dHJhY2tlckdyb3VwczogWydncm91cCcsICdtYXJrZXJHcm91cCcsICdkYXRhTGFiZWxzR3JvdXAnXSxcblx0dGFrZU9yZGluYWxQb3NpdGlvbjogZmFsc2UsIC8vICMyMzQyXG5cdGtkRGltZW5zaW9uczogMixcblx0ZHJhd0dyYXBoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5saW5lV2lkdGgpIHtcblx0XHRcdFNlcmllcy5wcm90b3R5cGUuZHJhd0dyYXBoLmNhbGwodGhpcyk7XG5cdFx0fVxuXHR9XG59KTtcblxuc2VyaWVzVHlwZXMuc2NhdHRlciA9IFNjYXR0ZXJTZXJpZXM7XG5cbi8qKlxuICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHBpZVxuICovXG5kZWZhdWx0UGxvdE9wdGlvbnMucGllID0gbWVyZ2UoZGVmYXVsdFNlcmllc09wdGlvbnMsIHtcblx0Ym9yZGVyQ29sb3I6ICcjRkZGRkZGJyxcblx0Ym9yZGVyV2lkdGg6IDEsXG5cdGNlbnRlcjogW251bGwsIG51bGxdLFxuXHRjbGlwOiBmYWxzZSxcblx0Y29sb3JCeVBvaW50OiB0cnVlLCAvLyBhbHdheXMgdHJ1ZSBmb3IgcGllc1xuXHRkYXRhTGFiZWxzOiB7XG5cdFx0Ly8gYWxpZ246IG51bGwsXG5cdFx0Ly8gY29ubmVjdG9yV2lkdGg6IDEsXG5cdFx0Ly8gY29ubmVjdG9yQ29sb3I6IHBvaW50LmNvbG9yLFxuXHRcdC8vIGNvbm5lY3RvclBhZGRpbmc6IDUsXG5cdFx0ZGlzdGFuY2U6IDMwLFxuXHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0Zm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7IC8vICMyOTQ1XG5cdFx0XHRyZXR1cm4gdGhpcy55ID09PSBudWxsID8gdW5kZWZpbmVkIDogdGhpcy5wb2ludC5uYW1lO1xuXHRcdH0sXG5cdFx0Ly8gc29mdENvbm5lY3RvcjogdHJ1ZSxcblx0XHR4OiAwXG5cdFx0Ly8geTogMFxuXHR9LFxuXHRpZ25vcmVIaWRkZW5Qb2ludDogdHJ1ZSxcblx0Ly9pbm5lclNpemU6IDAsXG5cdGxlZ2VuZFR5cGU6ICdwb2ludCcsXG5cdG1hcmtlcjogbnVsbCwgLy8gcG9pbnQgb3B0aW9ucyBhcmUgc3BlY2lmaWVkIGluIHRoZSBiYXNlIG9wdGlvbnNcblx0c2l6ZTogbnVsbCxcblx0c2hvd0luTGVnZW5kOiBmYWxzZSxcblx0c2xpY2VkT2Zmc2V0OiAxMCxcblx0c3RhdGVzOiB7XG5cdFx0aG92ZXI6IHtcblx0XHRcdGJyaWdodG5lc3M6IDAuMSxcblx0XHRcdHNoYWRvdzogZmFsc2Vcblx0XHR9XG5cdH0sXG5cdHN0aWNreVRyYWNraW5nOiBmYWxzZSxcblx0dG9vbHRpcDoge1xuXHRcdGZvbGxvd1BvaW50ZXI6IHRydWVcblx0fVxufSk7XG5cbi8qKlxuICogRXh0ZW5kZWQgcG9pbnQgb2JqZWN0IGZvciBwaWVzXG4gKi9cbnZhciBQaWVQb2ludCA9IGV4dGVuZENsYXNzKFBvaW50LCB7XG5cdC8qKlxuXHQgKiBJbml0aWF0ZSB0aGUgcGllIHNsaWNlXG5cdCAqL1xuXHRpbml0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRQb2ludC5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdHRvZ2dsZVNsaWNlO1xuXG5cdFx0cG9pbnQubmFtZSA9IHBpY2socG9pbnQubmFtZSwgJ1NsaWNlJyk7XG5cblx0XHQvLyBhZGQgZXZlbnQgbGlzdGVuZXIgZm9yIHNlbGVjdFxuXHRcdHRvZ2dsZVNsaWNlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdHBvaW50LnNsaWNlKGUudHlwZSA9PT0gJ3NlbGVjdCcpO1xuXHRcdH07XG5cdFx0YWRkRXZlbnQocG9pbnQsICdzZWxlY3QnLCB0b2dnbGVTbGljZSk7XG5cdFx0YWRkRXZlbnQocG9pbnQsICd1bnNlbGVjdCcsIHRvZ2dsZVNsaWNlKTtcblxuXHRcdHJldHVybiBwb2ludDtcblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBwaWUgc2xpY2Vcblx0ICogQHBhcmFtIHtCb29sZWFufSB2aXMgV2hldGhlciB0byBzaG93IHRoZSBzbGljZSBvciBub3QuIElmIHVuZGVmaW5lZCwgdGhlXG5cdCAqICAgIHZpc2liaWxpdHkgaXMgdG9nZ2xlZFxuXHQgKi9cblx0c2V0VmlzaWJsZTogZnVuY3Rpb24gKHZpcywgcmVkcmF3KSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0aWdub3JlSGlkZGVuUG9pbnQgPSBzZXJpZXMub3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludDtcblx0XHRcblx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgaWdub3JlSGlkZGVuUG9pbnQpO1xuXG5cdFx0aWYgKHZpcyAhPT0gcG9pbnQudmlzaWJsZSkge1xuXG5cdFx0XHQvLyBJZiBjYWxsZWQgd2l0aG91dCBhbiBhcmd1bWVudCwgdG9nZ2xlIHZpc2liaWxpdHlcblx0XHRcdHBvaW50LnZpc2libGUgPSBwb2ludC5vcHRpb25zLnZpc2libGUgPSB2aXMgPSB2aXMgPT09IFVOREVGSU5FRCA/ICFwb2ludC52aXNpYmxlIDogdmlzO1xuXHRcdFx0c2VyaWVzLm9wdGlvbnMuZGF0YVtpbkFycmF5KHBvaW50LCBzZXJpZXMuZGF0YSldID0gcG9pbnQub3B0aW9uczsgLy8gdXBkYXRlIHVzZXJPcHRpb25zLmRhdGFcblxuXHRcdFx0Ly8gU2hvdyBhbmQgaGlkZSBhc3NvY2lhdGVkIGVsZW1lbnRzLiBUaGlzIGlzIHBlcmZvcm1lZCByZWdhcmRsZXNzIG9mIHJlZHJhdyBvciBub3QsXG5cdFx0XHQvLyBiZWNhdXNlIGNoYXJ0LnJlZHJhdyBvbmx5IGhhbmRsZXMgZnVsbCBzZXJpZXMuXG5cdFx0XHRlYWNoKFsnZ3JhcGhpYycsICdkYXRhTGFiZWwnLCAnY29ubmVjdG9yJywgJ3NoYWRvd0dyb3VwJ10sIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0aWYgKHBvaW50W2tleV0pIHtcblx0XHRcdFx0XHRwb2ludFtrZXldW3ZpcyA/ICdzaG93JyA6ICdoaWRlJ10odHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAocG9pbnQubGVnZW5kSXRlbSkge1xuXHRcdFx0XHRjaGFydC5sZWdlbmQuY29sb3JpemVJdGVtKHBvaW50LCB2aXMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAjNDE3MCwgaGlkZSBoYWxvIGFmdGVyIGhpZGluZyBwb2ludFxuXHRcdFx0aWYgKCF2aXMgJiYgcG9pbnQuc3RhdGUgPT09ICdob3ZlcicpIHtcblx0XHRcdFx0cG9pbnQuc2V0U3RhdGUoJycpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBIYW5kbGUgaWdub3JlIGhpZGRlbiBzbGljZXNcblx0XHRcdGlmIChpZ25vcmVIaWRkZW5Qb2ludCkge1xuXHRcdFx0XHRzZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0Y2hhcnQucmVkcmF3KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgb3IgdG9nZ2xlIHdoZXRoZXIgdGhlIHNsaWNlIGlzIGN1dCBvdXQgZnJvbSB0aGUgcGllXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2xpY2VkIFdoZW4gdW5kZWZpbmVkLCB0aGUgc2xpY2Ugc3RhdGUgaXMgdG9nZ2xlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhdyBXaGV0aGVyIHRvIHJlZHJhdyB0aGUgY2hhcnQuIFRydWUgYnkgZGVmYXVsdC5cblx0ICovXG5cdHNsaWNlOiBmdW5jdGlvbiAoc2xpY2VkLCByZWRyYXcsIGFuaW1hdGlvbikge1xuXHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdHRyYW5zbGF0aW9uO1xuXG5cdFx0c2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgY2hhcnQpO1xuXG5cdFx0Ly8gcmVkcmF3IGlzIHRydWUgYnkgZGVmYXVsdFxuXHRcdHJlZHJhdyA9IHBpY2socmVkcmF3LCB0cnVlKTtcblxuXHRcdC8vIGlmIGNhbGxlZCB3aXRob3V0IGFuIGFyZ3VtZW50LCB0b2dnbGVcblx0XHRwb2ludC5zbGljZWQgPSBwb2ludC5vcHRpb25zLnNsaWNlZCA9IHNsaWNlZCA9IGRlZmluZWQoc2xpY2VkKSA/IHNsaWNlZCA6ICFwb2ludC5zbGljZWQ7XG5cdFx0c2VyaWVzLm9wdGlvbnMuZGF0YVtpbkFycmF5KHBvaW50LCBzZXJpZXMuZGF0YSldID0gcG9pbnQub3B0aW9uczsgLy8gdXBkYXRlIHVzZXJPcHRpb25zLmRhdGFcblxuXHRcdHRyYW5zbGF0aW9uID0gc2xpY2VkID8gcG9pbnQuc2xpY2VkVHJhbnNsYXRpb24gOiB7XG5cdFx0XHR0cmFuc2xhdGVYOiAwLFxuXHRcdFx0dHJhbnNsYXRlWTogMFxuXHRcdH07XG5cblx0XHRwb2ludC5ncmFwaGljLmFuaW1hdGUodHJhbnNsYXRpb24pO1xuXHRcdFxuXHRcdGlmIChwb2ludC5zaGFkb3dHcm91cCkge1xuXHRcdFx0cG9pbnQuc2hhZG93R3JvdXAuYW5pbWF0ZSh0cmFuc2xhdGlvbik7XG5cdFx0fVxuXG5cdH0sXG5cblx0aGFsb1BhdGg6IGZ1bmN0aW9uIChzaXplKSB7XG5cdFx0dmFyIHNoYXBlQXJncyA9IHRoaXMuc2hhcGVBcmdzLFxuXHRcdFx0Y2hhcnQgPSB0aGlzLnNlcmllcy5jaGFydDtcblxuXHRcdHJldHVybiB0aGlzLnNsaWNlZCB8fCAhdGhpcy52aXNpYmxlID8gW10gOiB0aGlzLnNlcmllcy5jaGFydC5yZW5kZXJlci5zeW1ib2xzLmFyYyhjaGFydC5wbG90TGVmdCArIHNoYXBlQXJncy54LCBjaGFydC5wbG90VG9wICsgc2hhcGVBcmdzLnksIHNoYXBlQXJncy5yICsgc2l6ZSwgc2hhcGVBcmdzLnIgKyBzaXplLCB7XG5cdFx0XHRpbm5lclI6IHRoaXMuc2hhcGVBcmdzLnIsXG5cdFx0XHRzdGFydDogc2hhcGVBcmdzLnN0YXJ0LFxuXHRcdFx0ZW5kOiBzaGFwZUFyZ3MuZW5kXG5cdFx0fSk7XG5cdH1cbn0pO1xuXG4vKipcbiAqIFRoZSBQaWUgc2VyaWVzIGNsYXNzXG4gKi9cbnZhciBQaWVTZXJpZXMgPSB7XG5cdHR5cGU6ICdwaWUnLFxuXHRpc0NhcnRlc2lhbjogZmFsc2UsXG5cdHBvaW50Q2xhc3M6IFBpZVBvaW50LFxuXHRyZXF1aXJlU29ydGluZzogZmFsc2UsXG5cdGRpcmVjdFRvdWNoOiB0cnVlLFxuXHRub1NoYXJlZFRvb2x0aXA6IHRydWUsXG5cdHRyYWNrZXJHcm91cHM6IFsnZ3JvdXAnLCAnZGF0YUxhYmVsc0dyb3VwJ10sXG5cdGF4aXNUeXBlczogW10sXG5cdHBvaW50QXR0clRvT3B0aW9uczogeyAvLyBtYXBwaW5nIGJldHdlZW4gU1ZHIGF0dHJpYnV0ZXMgYW5kIHRoZSBjb3JyZXNwb25kaW5nIG9wdGlvbnNcblx0XHRzdHJva2U6ICdib3JkZXJDb2xvcicsXG5cdFx0J3N0cm9rZS13aWR0aCc6ICdib3JkZXJXaWR0aCcsXG5cdFx0ZmlsbDogJ2NvbG9yJ1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBbmltYXRlIHRoZSBwaWVzIGluXG5cdCAqL1xuXHRhbmltYXRlOiBmdW5jdGlvbiAoaW5pdCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0cG9pbnRzID0gc2VyaWVzLnBvaW50cyxcblx0XHRcdHN0YXJ0QW5nbGVSYWQgPSBzZXJpZXMuc3RhcnRBbmdsZVJhZDtcblxuXHRcdGlmICghaW5pdCkge1xuXHRcdFx0ZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHR2YXIgZ3JhcGhpYyA9IHBvaW50LmdyYXBoaWMsXG5cdFx0XHRcdFx0YXJncyA9IHBvaW50LnNoYXBlQXJncztcblxuXHRcdFx0XHRpZiAoZ3JhcGhpYykge1xuXHRcdFx0XHRcdC8vIHN0YXJ0IHZhbHVlc1xuXHRcdFx0XHRcdGdyYXBoaWMuYXR0cih7XG5cdFx0XHRcdFx0XHRyOiBwb2ludC5zdGFydFIgfHwgKHNlcmllcy5jZW50ZXJbM10gLyAyKSwgLy8gYW5pbWF0ZSBmcm9tIGlubmVyIHJhZGl1cyAoIzc3OSlcblx0XHRcdFx0XHRcdHN0YXJ0OiBzdGFydEFuZ2xlUmFkLFxuXHRcdFx0XHRcdFx0ZW5kOiBzdGFydEFuZ2xlUmFkXG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvLyBhbmltYXRlXG5cdFx0XHRcdFx0Z3JhcGhpYy5hbmltYXRlKHtcblx0XHRcdFx0XHRcdHI6IGFyZ3Mucixcblx0XHRcdFx0XHRcdHN0YXJ0OiBhcmdzLnN0YXJ0LFxuXHRcdFx0XHRcdFx0ZW5kOiBhcmdzLmVuZFxuXHRcdFx0XHRcdH0sIHNlcmllcy5vcHRpb25zLmFuaW1hdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBkZWxldGUgdGhpcyBmdW5jdGlvbiB0byBhbGxvdyBpdCBvbmx5IG9uY2Vcblx0XHRcdHNlcmllcy5hbmltYXRlID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlY29tcHV0ZSB0b3RhbCBjaGFydCBzdW0gYW5kIHVwZGF0ZSBwZXJjZW50YWdlcyBvZiBwb2ludHMuXG5cdCAqL1xuXHR1cGRhdGVUb3RhbHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaSxcblx0XHRcdHRvdGFsID0gMCxcblx0XHRcdHBvaW50cyA9IHRoaXMucG9pbnRzLFxuXHRcdFx0bGVuID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdHBvaW50LFxuXHRcdFx0aWdub3JlSGlkZGVuUG9pbnQgPSB0aGlzLm9wdGlvbnMuaWdub3JlSGlkZGVuUG9pbnQ7XG5cblx0XHQvLyBHZXQgdGhlIHRvdGFsIHN1bVxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHR0b3RhbCArPSAoaWdub3JlSGlkZGVuUG9pbnQgJiYgIXBvaW50LnZpc2libGUpID8gMCA6IHBvaW50Lnk7XG5cdFx0fVxuXHRcdHRoaXMudG90YWwgPSB0b3RhbDtcblxuXHRcdC8vIFNldCBlYWNoIHBvaW50J3MgcHJvcGVydGllc1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRwb2ludC5wZXJjZW50YWdlID0gKHRvdGFsID4gMCAmJiAocG9pbnQudmlzaWJsZSB8fCAhaWdub3JlSGlkZGVuUG9pbnQpKSA/IHBvaW50LnkgLyB0b3RhbCAqIDEwMCA6IDA7XG5cdFx0XHRwb2ludC50b3RhbCA9IHRvdGFsO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogRXh0ZW5kIHRoZSBnZW5lcmF0ZVBvaW50cyBtZXRob2QgYnkgYWRkaW5nIHRvdGFsIGFuZCBwZXJjZW50YWdlIHByb3BlcnRpZXMgdG8gZWFjaCBwb2ludFxuXHQgKi9cblx0Z2VuZXJhdGVQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHRTZXJpZXMucHJvdG90eXBlLmdlbmVyYXRlUG9pbnRzLmNhbGwodGhpcyk7XG5cdFx0dGhpcy51cGRhdGVUb3RhbHMoKTtcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBEbyB0cmFuc2xhdGlvbiBmb3IgcGllIHNsaWNlc1xuXHQgKi9cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAocG9zaXRpb25zKSB7XG5cdFx0dGhpcy5nZW5lcmF0ZVBvaW50cygpO1xuXHRcdFxuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y3VtdWxhdGl2ZSA9IDAsXG5cdFx0XHRwcmVjaXNpb24gPSAxMDAwLCAvLyBpc3N1ZSAjMTcyXG5cdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRzbGljZWRPZmZzZXQgPSBvcHRpb25zLnNsaWNlZE9mZnNldCxcblx0XHRcdGNvbm5lY3Rvck9mZnNldCA9IHNsaWNlZE9mZnNldCArIG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRzdGFydCxcblx0XHRcdGVuZCxcblx0XHRcdGFuZ2xlLFxuXHRcdFx0c3RhcnRBbmdsZSA9IG9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwLFxuXHRcdFx0c3RhcnRBbmdsZVJhZCA9IHNlcmllcy5zdGFydEFuZ2xlUmFkID0gbWF0aFBJIC8gMTgwICogKHN0YXJ0QW5nbGUgLSA5MCksXG5cdFx0XHRlbmRBbmdsZVJhZCA9IHNlcmllcy5lbmRBbmdsZVJhZCA9IG1hdGhQSSAvIDE4MCAqICgocGljayhvcHRpb25zLmVuZEFuZ2xlLCBzdGFydEFuZ2xlICsgMzYwKSkgLSA5MCksXG5cdFx0XHRjaXJjID0gZW5kQW5nbGVSYWQgLSBzdGFydEFuZ2xlUmFkLCAvLzIgKiBtYXRoUEksXG5cdFx0XHRwb2ludHMgPSBzZXJpZXMucG9pbnRzLFxuXHRcdFx0cmFkaXVzWCwgLy8gdGhlIHggY29tcG9uZW50IG9mIHRoZSByYWRpdXMgdmVjdG9yIGZvciBhIGdpdmVuIHBvaW50XG5cdFx0XHRyYWRpdXNZLFxuXHRcdFx0bGFiZWxEaXN0YW5jZSA9IG9wdGlvbnMuZGF0YUxhYmVscy5kaXN0YW5jZSxcblx0XHRcdGlnbm9yZUhpZGRlblBvaW50ID0gb3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludCxcblx0XHRcdGksXG5cdFx0XHRsZW4gPSBwb2ludHMubGVuZ3RoLFxuXHRcdFx0cG9pbnQ7XG5cblx0XHQvLyBHZXQgcG9zaXRpb25zIC0gZWl0aGVyIGFuIGludGVnZXIgb3IgYSBwZXJjZW50YWdlIHN0cmluZyBtdXN0IGJlIGdpdmVuLlxuXHRcdC8vIElmIHBvc2l0aW9ucyBhcmUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLCB3ZSdyZSBpbiBhIHJlY3Vyc2l2ZSBsb29wIGZvciBhZGp1c3Rpbmdcblx0XHQvLyBzcGFjZSBmb3IgZGF0YSBsYWJlbHMuXG5cdFx0aWYgKCFwb3NpdGlvbnMpIHtcblx0XHRcdHNlcmllcy5jZW50ZXIgPSBwb3NpdGlvbnMgPSBzZXJpZXMuZ2V0Q2VudGVyKCk7XG5cdFx0fVxuXG5cdFx0Ly8gdXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgeCB2YWx1ZSBmcm9tIGEgZ2l2ZW4geSwgdXNlZCBmb3IgYW50aWNvbGxpc2lvbiBsb2dpYyBpbiBkYXRhIGxhYmVsc1xuXHRcdHNlcmllcy5nZXRYID0gZnVuY3Rpb24gKHksIGxlZnQpIHtcblxuXHRcdFx0YW5nbGUgPSBtYXRoLmFzaW4obWF0aE1pbigoeSAtIHBvc2l0aW9uc1sxXSkgLyAocG9zaXRpb25zWzJdIC8gMiArIGxhYmVsRGlzdGFuY2UpLCAxKSk7XG5cblx0XHRcdHJldHVybiBwb3NpdGlvbnNbMF0gK1xuXHRcdFx0XHQobGVmdCA/IC0xIDogMSkgKlxuXHRcdFx0XHQobWF0aENvcyhhbmdsZSkgKiAocG9zaXRpb25zWzJdIC8gMiArIGxhYmVsRGlzdGFuY2UpKTtcblx0XHR9O1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIHRoZSBnZW9tZXRyeSBmb3IgZWFjaCBwb2ludFxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XG5cdFx0XHRwb2ludCA9IHBvaW50c1tpXTtcblx0XHRcdFxuXHRcdFx0Ly8gc2V0IHN0YXJ0IGFuZCBlbmQgYW5nbGVcblx0XHRcdHN0YXJ0ID0gc3RhcnRBbmdsZVJhZCArIChjdW11bGF0aXZlICogY2lyYyk7XG5cdFx0XHRpZiAoIWlnbm9yZUhpZGRlblBvaW50IHx8IHBvaW50LnZpc2libGUpIHtcblx0XHRcdFx0Y3VtdWxhdGl2ZSArPSBwb2ludC5wZXJjZW50YWdlIC8gMTAwO1xuXHRcdFx0fVxuXHRcdFx0ZW5kID0gc3RhcnRBbmdsZVJhZCArIChjdW11bGF0aXZlICogY2lyYyk7XG5cblx0XHRcdC8vIHNldCB0aGUgc2hhcGVcblx0XHRcdHBvaW50LnNoYXBlVHlwZSA9ICdhcmMnO1xuXHRcdFx0cG9pbnQuc2hhcGVBcmdzID0ge1xuXHRcdFx0XHR4OiBwb3NpdGlvbnNbMF0sXG5cdFx0XHRcdHk6IHBvc2l0aW9uc1sxXSxcblx0XHRcdFx0cjogcG9zaXRpb25zWzJdIC8gMixcblx0XHRcdFx0aW5uZXJSOiBwb3NpdGlvbnNbM10gLyAyLFxuXHRcdFx0XHRzdGFydDogbWF0aFJvdW5kKHN0YXJ0ICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbixcblx0XHRcdFx0ZW5kOiBtYXRoUm91bmQoZW5kICogcHJlY2lzaW9uKSAvIHByZWNpc2lvblxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gVGhlIGFuZ2xlIG11c3Qgc3RheSB3aXRoaW4gLTkwIGFuZCAyNzAgKCMyNjQ1KVxuXHRcdFx0YW5nbGUgPSAoZW5kICsgc3RhcnQpIC8gMjtcblx0XHRcdGlmIChhbmdsZSA+IDEuNSAqIG1hdGhQSSkge1xuXHRcdFx0XHRhbmdsZSAtPSAyICogbWF0aFBJO1xuXHRcdFx0fSBlbHNlIGlmIChhbmdsZSA8IC1tYXRoUEkgLyAyKSB7XG5cdFx0XHRcdGFuZ2xlICs9IDIgKiBtYXRoUEk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENlbnRlciBmb3IgdGhlIHNsaWNlZCBvdXQgc2xpY2Vcblx0XHRcdHBvaW50LnNsaWNlZFRyYW5zbGF0aW9uID0ge1xuXHRcdFx0XHR0cmFuc2xhdGVYOiBtYXRoUm91bmQobWF0aENvcyhhbmdsZSkgKiBzbGljZWRPZmZzZXQpLFxuXHRcdFx0XHR0cmFuc2xhdGVZOiBtYXRoUm91bmQobWF0aFNpbihhbmdsZSkgKiBzbGljZWRPZmZzZXQpXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBzZXQgdGhlIGFuY2hvciBwb2ludCBmb3IgdG9vbHRpcHNcblx0XHRcdHJhZGl1c1ggPSBtYXRoQ29zKGFuZ2xlKSAqIHBvc2l0aW9uc1syXSAvIDI7XG5cdFx0XHRyYWRpdXNZID0gbWF0aFNpbihhbmdsZSkgKiBwb3NpdGlvbnNbMl0gLyAyO1xuXHRcdFx0cG9pbnQudG9vbHRpcFBvcyA9IFtcblx0XHRcdFx0cG9zaXRpb25zWzBdICsgcmFkaXVzWCAqIDAuNyxcblx0XHRcdFx0cG9zaXRpb25zWzFdICsgcmFkaXVzWSAqIDAuN1xuXHRcdFx0XTtcblx0XHRcdFxuXHRcdFx0cG9pbnQuaGFsZiA9IGFuZ2xlIDwgLW1hdGhQSSAvIDIgfHwgYW5nbGUgPiBtYXRoUEkgLyAyID8gMSA6IDA7XG5cdFx0XHRwb2ludC5hbmdsZSA9IGFuZ2xlO1xuXG5cdFx0XHQvLyBzZXQgdGhlIGFuY2hvciBwb2ludCBmb3IgZGF0YSBsYWJlbHNcblx0XHRcdGNvbm5lY3Rvck9mZnNldCA9IG1hdGhNaW4oY29ubmVjdG9yT2Zmc2V0LCBsYWJlbERpc3RhbmNlIC8gMik7IC8vICMxNjc4XG5cdFx0XHRwb2ludC5sYWJlbFBvcyA9IFtcblx0XHRcdFx0cG9zaXRpb25zWzBdICsgcmFkaXVzWCArIG1hdGhDb3MoYW5nbGUpICogbGFiZWxEaXN0YW5jZSwgLy8gZmlyc3QgYnJlYWsgb2YgY29ubmVjdG9yXG5cdFx0XHRcdHBvc2l0aW9uc1sxXSArIHJhZGl1c1kgKyBtYXRoU2luKGFuZ2xlKSAqIGxhYmVsRGlzdGFuY2UsIC8vIGEvYVxuXHRcdFx0XHRwb3NpdGlvbnNbMF0gKyByYWRpdXNYICsgbWF0aENvcyhhbmdsZSkgKiBjb25uZWN0b3JPZmZzZXQsIC8vIHNlY29uZCBicmVhaywgcmlnaHQgb3V0c2lkZSBwaWVcblx0XHRcdFx0cG9zaXRpb25zWzFdICsgcmFkaXVzWSArIG1hdGhTaW4oYW5nbGUpICogY29ubmVjdG9yT2Zmc2V0LCAvLyBhL2Fcblx0XHRcdFx0cG9zaXRpb25zWzBdICsgcmFkaXVzWCwgLy8gbGFuZGluZyBwb2ludCBmb3IgY29ubmVjdG9yXG5cdFx0XHRcdHBvc2l0aW9uc1sxXSArIHJhZGl1c1ksIC8vIGEvYVxuXHRcdFx0XHRsYWJlbERpc3RhbmNlIDwgMCA/IC8vIGFsaWdubWVudFxuXHRcdFx0XHRcdCdjZW50ZXInIDpcblx0XHRcdFx0XHRwb2ludC5oYWxmID8gJ3JpZ2h0JyA6ICdsZWZ0JywgLy8gYWxpZ25tZW50XG5cdFx0XHRcdGFuZ2xlIC8vIGNlbnRlciBhbmdsZVxuXHRcdFx0XTtcblxuXHRcdH1cblx0fSxcblx0XG5cdGRyYXdHcmFwaDogbnVsbCxcblxuXHQvKipcblx0ICogRHJhdyB0aGUgZGF0YSBwb2ludHNcblx0ICovXG5cdGRyYXdQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdGdyb3VwVHJhbnNsYXRpb24sXG5cdFx0XHQvL2NlbnRlcixcblx0XHRcdGdyYXBoaWMsXG5cdFx0XHQvL2dyb3VwLFxuXHRcdFx0c2hhZG93ID0gc2VyaWVzLm9wdGlvbnMuc2hhZG93LFxuXHRcdFx0c2hhZG93R3JvdXAsXG5cdFx0XHRzaGFwZUFyZ3MsXG5cdFx0XHRhdHRyO1xuXG5cdFx0aWYgKHNoYWRvdyAmJiAhc2VyaWVzLnNoYWRvd0dyb3VwKSB7XG5cdFx0XHRzZXJpZXMuc2hhZG93R3JvdXAgPSByZW5kZXJlci5nKCdzaGFkb3cnKVxuXHRcdFx0XHQuYWRkKHNlcmllcy5ncm91cCk7XG5cdFx0fVxuXG5cdFx0Ly8gZHJhdyB0aGUgc2xpY2VzXG5cdFx0ZWFjaChzZXJpZXMucG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdGlmIChwb2ludC55ICE9PSBudWxsKSB7XG5cdFx0XHRcdGdyYXBoaWMgPSBwb2ludC5ncmFwaGljO1xuXHRcdFx0XHRzaGFwZUFyZ3MgPSBwb2ludC5zaGFwZUFyZ3M7XG5cdFx0XHRcdHNoYWRvd0dyb3VwID0gcG9pbnQuc2hhZG93R3JvdXA7XG5cblx0XHRcdFx0Ly8gcHV0IHRoZSBzaGFkb3cgYmVoaW5kIGFsbCBwb2ludHNcblx0XHRcdFx0aWYgKHNoYWRvdyAmJiAhc2hhZG93R3JvdXApIHtcblx0XHRcdFx0XHRzaGFkb3dHcm91cCA9IHBvaW50LnNoYWRvd0dyb3VwID0gcmVuZGVyZXIuZygnc2hhZG93Jylcblx0XHRcdFx0XHRcdC5hZGQoc2VyaWVzLnNoYWRvd0dyb3VwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIHRoZSBwb2ludCBpcyBzbGljZWQsIHVzZSBzcGVjaWFsIHRyYW5zbGF0aW9uLCBlbHNlIHVzZSBwbG90IGFyZWEgdHJhc2xhdGlvblxuXHRcdFx0XHRncm91cFRyYW5zbGF0aW9uID0gcG9pbnQuc2xpY2VkID8gcG9pbnQuc2xpY2VkVHJhbnNsYXRpb24gOiB7XG5cdFx0XHRcdFx0dHJhbnNsYXRlWDogMCxcblx0XHRcdFx0XHR0cmFuc2xhdGVZOiAwXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly9ncm91cC50cmFuc2xhdGUoZ3JvdXBUcmFuc2xhdGlvblswXSwgZ3JvdXBUcmFuc2xhdGlvblsxXSk7XG5cdFx0XHRcdGlmIChzaGFkb3dHcm91cCkge1xuXHRcdFx0XHRcdHNoYWRvd0dyb3VwLmF0dHIoZ3JvdXBUcmFuc2xhdGlvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBkcmF3IHRoZSBzbGljZVxuXHRcdFx0XHRpZiAoZ3JhcGhpYykge1xuXHRcdFx0XHRcdGdyYXBoaWNcblx0XHRcdFx0XHRcdC5zZXRSYWRpYWxSZWZlcmVuY2Uoc2VyaWVzLmNlbnRlcilcblx0XHRcdFx0XHRcdC5hbmltYXRlKGV4dGVuZChzaGFwZUFyZ3MsIGdyb3VwVHJhbnNsYXRpb24pKTtcdFx0XHRcdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGF0dHIgPSB7ICdzdHJva2UtbGluZWpvaW4nOiAncm91bmQnIH07XG5cdFx0XHRcdFx0aWYgKCFwb2ludC52aXNpYmxlKSB7XG5cdFx0XHRcdFx0XHRhdHRyLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwb2ludC5ncmFwaGljID0gZ3JhcGhpYyA9IHJlbmRlcmVyW3BvaW50LnNoYXBlVHlwZV0oc2hhcGVBcmdzKVxuXHRcdFx0XHRcdFx0LnNldFJhZGlhbFJlZmVyZW5jZShzZXJpZXMuY2VudGVyKVxuXHRcdFx0XHRcdFx0LmF0dHIoXG5cdFx0XHRcdFx0XHRcdHBvaW50LnBvaW50QXR0cltwb2ludC5zZWxlY3RlZCA/IFNFTEVDVF9TVEFURSA6IE5PUk1BTF9TVEFURV1cblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdC5hdHRyKGF0dHIpXG5cdFx0XHRcdFx0XHQuYXR0cihncm91cFRyYW5zbGF0aW9uKVxuXHRcdFx0XHRcdFx0LmFkZChzZXJpZXMuZ3JvdXApXG5cdFx0XHRcdFx0XHQuc2hhZG93KHNoYWRvdywgc2hhZG93R3JvdXApO1x0XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHR9LFxuXG5cblx0c2VhcmNoUG9pbnQ6IG5vb3AsXG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgZm9yIHNvcnRpbmcgZGF0YSBsYWJlbHNcblx0ICovXG5cdHNvcnRCeUFuZ2xlOiBmdW5jdGlvbiAocG9pbnRzLCBzaWduKSB7XG5cdFx0cG9pbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBhLmFuZ2xlICE9PSB1bmRlZmluZWQgJiYgKGIuYW5nbGUgLSBhLmFuZ2xlKSAqIHNpZ247XG5cdFx0fSk7XG5cdH0sXHRcdFxuXG5cdC8qKlxuXHQgKiBVc2UgYSBzaW1wbGUgc3ltYm9sIGZyb20gTGVnZW5kU3ltYm9sTWl4aW5cblx0ICovXG5cdGRyYXdMZWdlbmRTeW1ib2w6IExlZ2VuZFN5bWJvbE1peGluLmRyYXdSZWN0YW5nbGUsXG5cblx0LyoqXG5cdCAqIFVzZSB0aGUgZ2V0Q2VudGVyIG1ldGhvZCBmcm9tIGRyYXdMZWdlbmRTeW1ib2xcblx0ICovXG5cdGdldENlbnRlcjogQ2VudGVyZWRTZXJpZXNNaXhpbi5nZXRDZW50ZXIsXG5cblx0LyoqXG5cdCAqIFBpZXMgZG9uJ3QgaGF2ZSBwb2ludCBtYXJrZXIgc3ltYm9sc1xuXHQgKi9cblx0Z2V0U3ltYm9sOiBub29wXG5cbn07XG5QaWVTZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMsIFBpZVNlcmllcyk7XG5zZXJpZXNUeXBlcy5waWUgPSBQaWVTZXJpZXM7XG5cbi8qKlxuICogRHJhdyB0aGUgZGF0YSBsYWJlbHNcbiAqL1xuU2VyaWVzLnByb3RvdHlwZS5kcmF3RGF0YUxhYmVscyA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRzZXJpZXNPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0Y3Vyc29yID0gc2VyaWVzT3B0aW9ucy5jdXJzb3IsXG5cdFx0b3B0aW9ucyA9IHNlcmllc09wdGlvbnMuZGF0YUxhYmVscyxcblx0XHRwb2ludHMgPSBzZXJpZXMucG9pbnRzLFxuXHRcdHBvaW50T3B0aW9ucyxcblx0XHRnZW5lcmFsT3B0aW9ucyxcblx0XHRoYXNSZW5kZXJlZCA9IHNlcmllcy5oYXNSZW5kZXJlZCB8fCAwLFxuXHRcdHN0cixcblx0XHRkYXRhTGFiZWxzR3JvdXAsXG5cdFx0cmVuZGVyZXIgPSBzZXJpZXMuY2hhcnQucmVuZGVyZXI7XG5cblx0aWYgKG9wdGlvbnMuZW5hYmxlZCB8fCBzZXJpZXMuX2hhc1BvaW50TGFiZWxzKSB7XG5cblx0XHQvLyBQcm9jZXNzIGRlZmF1bHQgYWxpZ25tZW50IG9mIGRhdGEgbGFiZWxzIGZvciBjb2x1bW5zXG5cdFx0aWYgKHNlcmllcy5kbFByb2Nlc3NPcHRpb25zKSB7XG5cdFx0XHRzZXJpZXMuZGxQcm9jZXNzT3B0aW9ucyhvcHRpb25zKTtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSBzZXBhcmF0ZSBncm91cCBmb3IgdGhlIGRhdGEgbGFiZWxzIHRvIGF2b2lkIHJvdGF0aW9uXG5cdFx0ZGF0YUxhYmVsc0dyb3VwID0gc2VyaWVzLnBsb3RHcm91cChcblx0XHRcdCdkYXRhTGFiZWxzR3JvdXAnLFxuXHRcdFx0J2RhdGEtbGFiZWxzJyxcblx0XHRcdG9wdGlvbnMuZGVmZXIgPyBISURERU4gOiBWSVNJQkxFLFxuXHRcdFx0b3B0aW9ucy56SW5kZXggfHwgNlxuXHRcdCk7XG5cblx0XHRpZiAocGljayhvcHRpb25zLmRlZmVyLCB0cnVlKSkge1xuXHRcdFx0ZGF0YUxhYmVsc0dyb3VwLmF0dHIoeyBvcGFjaXR5OiAraGFzUmVuZGVyZWQgfSk7IC8vICMzMzAwXG5cdFx0XHRpZiAoIWhhc1JlbmRlcmVkKSB7XG5cdFx0XHRcdGFkZEV2ZW50KHNlcmllcywgJ2FmdGVyQW5pbWF0ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoc2VyaWVzLnZpc2libGUpIHsgLy8gIzMwMjMsICMzMDI0XG5cdFx0XHRcdFx0XHRkYXRhTGFiZWxzR3JvdXAuc2hvdygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhTGFiZWxzR3JvdXBbc2VyaWVzT3B0aW9ucy5hbmltYXRpb24gPyAnYW5pbWF0ZScgOiAnYXR0ciddKHsgb3BhY2l0eTogMSB9LCB7IGR1cmF0aW9uOiAyMDAgfSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE1ha2UgdGhlIGxhYmVscyBmb3IgZWFjaCBwb2ludFxuXHRcdGdlbmVyYWxPcHRpb25zID0gb3B0aW9ucztcblx0XHRlYWNoKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cblx0XHRcdHZhciBlbmFibGVkLFxuXHRcdFx0XHRkYXRhTGFiZWwgPSBwb2ludC5kYXRhTGFiZWwsXG5cdFx0XHRcdGxhYmVsQ29uZmlnLFxuXHRcdFx0XHRhdHRyLFxuXHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRyb3RhdGlvbixcblx0XHRcdFx0Y29ubmVjdG9yID0gcG9pbnQuY29ubmVjdG9yLFxuXHRcdFx0XHRpc05ldyA9IHRydWUsXG5cdFx0XHRcdHN0eWxlLFxuXHRcdFx0XHRtb3JlU3R5bGUgPSB7fTtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIGVhY2ggZGF0YSBsYWJlbCBpcyBlbmFibGVkXG5cdFx0XHRwb2ludE9wdGlvbnMgPSBwb2ludC5kbE9wdGlvbnMgfHwgKHBvaW50Lm9wdGlvbnMgJiYgcG9pbnQub3B0aW9ucy5kYXRhTGFiZWxzKTsgLy8gZGxPcHRpb25zIGlzIHVzZWQgaW4gdHJlZW1hcHNcblx0XHRcdGVuYWJsZWQgPSBwaWNrKHBvaW50T3B0aW9ucyAmJiBwb2ludE9wdGlvbnMuZW5hYmxlZCwgZ2VuZXJhbE9wdGlvbnMuZW5hYmxlZCk7IC8vICMyMjgyXG5cblxuXHRcdFx0Ly8gSWYgdGhlIHBvaW50IGlzIG91dHNpZGUgdGhlIHBsb3QgYXJlYSwgZGVzdHJveSBpdC4gIzY3OCwgIzgyMFxuXHRcdFx0aWYgKGRhdGFMYWJlbCAmJiAhZW5hYmxlZCkge1xuXHRcdFx0XHRwb2ludC5kYXRhTGFiZWwgPSBkYXRhTGFiZWwuZGVzdHJveSgpO1xuXG5cdFx0XHQvLyBJbmRpdmlkdWFsIGxhYmVscyBhcmUgZGlzYWJsZWQgaWYgdGhlIGFyZSBleHBsaWNpdGx5IGRpc2FibGVkXG5cdFx0XHQvLyBpbiB0aGUgcG9pbnQgb3B0aW9ucywgb3IgaWYgdGhleSBmYWxsIG91dHNpZGUgdGhlIHBsb3QgYXJlYS5cblx0XHRcdH0gZWxzZSBpZiAoZW5hYmxlZCkge1xuXG5cdFx0XHRcdC8vIENyZWF0ZSBpbmRpdmlkdWFsIG9wdGlvbnMgc3RydWN0dXJlIHRoYXQgY2FuIGJlIGV4dGVuZGVkIHdpdGhvdXRcblx0XHRcdFx0Ly8gYWZmZWN0aW5nIG90aGVyc1xuXHRcdFx0XHRvcHRpb25zID0gbWVyZ2UoZ2VuZXJhbE9wdGlvbnMsIHBvaW50T3B0aW9ucyk7XG5cdFx0XHRcdHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuXHRcdFx0XHRyb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG5cblx0XHRcdFx0Ly8gR2V0IHRoZSBzdHJpbmdcblx0XHRcdFx0bGFiZWxDb25maWcgPSBwb2ludC5nZXRMYWJlbENvbmZpZygpO1xuXHRcdFx0XHRzdHIgPSBvcHRpb25zLmZvcm1hdCA/XG5cdFx0XHRcdFx0Zm9ybWF0KG9wdGlvbnMuZm9ybWF0LCBsYWJlbENvbmZpZykgOlxuXHRcdFx0XHRcdG9wdGlvbnMuZm9ybWF0dGVyLmNhbGwobGFiZWxDb25maWcsIG9wdGlvbnMpO1xuXG5cdFx0XHRcdC8vIERldGVybWluZSB0aGUgY29sb3Jcblx0XHRcdFx0c3R5bGUuY29sb3IgPSBwaWNrKG9wdGlvbnMuY29sb3IsIHN0eWxlLmNvbG9yLCBzZXJpZXMuY29sb3IsICdibGFjaycpO1xuXG5cblx0XHRcdFx0Ly8gdXBkYXRlIGV4aXN0aW5nIGxhYmVsXG5cdFx0XHRcdGlmIChkYXRhTGFiZWwpIHtcblxuXHRcdFx0XHRcdGlmIChkZWZpbmVkKHN0cikpIHtcblx0XHRcdFx0XHRcdGRhdGFMYWJlbFxuXHRcdFx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRcdFx0dGV4dDogc3RyXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0aXNOZXcgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7IC8vICMxNDM3IC0gdGhlIGxhYmVsIGlzIHNob3duIGNvbmRpdGlvbmFsbHlcblx0XHRcdFx0XHRcdHBvaW50LmRhdGFMYWJlbCA9IGRhdGFMYWJlbCA9IGRhdGFMYWJlbC5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRpZiAoY29ubmVjdG9yKSB7XG5cdFx0XHRcdFx0XHRcdHBvaW50LmNvbm5lY3RvciA9IGNvbm5lY3Rvci5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNyZWF0ZSBuZXcgbGFiZWxcblx0XHRcdFx0fSBlbHNlIGlmIChkZWZpbmVkKHN0cikpIHtcblx0XHRcdFx0XHRhdHRyID0ge1xuXHRcdFx0XHRcdFx0Ly9hbGlnbjogYWxpZ24sXG5cdFx0XHRcdFx0XHRmaWxsOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdFx0XHRcdHN0cm9rZTogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0XHRcdFx0cjogb3B0aW9ucy5ib3JkZXJSYWRpdXMgfHwgMCxcblx0XHRcdFx0XHRcdHJvdGF0aW9uOiByb3RhdGlvbixcblx0XHRcdFx0XHRcdHBhZGRpbmc6IG9wdGlvbnMucGFkZGluZyxcblx0XHRcdFx0XHRcdHpJbmRleDogMVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gR2V0IGF1dG9tYXRlZCBjb250cmFzdCBjb2xvclxuXHRcdFx0XHRcdGlmIChzdHlsZS5jb2xvciA9PT0gJ2NvbnRyYXN0Jykge1xuXHRcdFx0XHRcdFx0bW9yZVN0eWxlLmNvbG9yID0gb3B0aW9ucy5pbnNpZGUgfHwgb3B0aW9ucy5kaXN0YW5jZSA8IDAgfHwgISFzZXJpZXNPcHRpb25zLnN0YWNraW5nID8gXG5cdFx0XHRcdFx0XHRcdHJlbmRlcmVyLmdldENvbnRyYXN0KHBvaW50LmNvbG9yIHx8IHNlcmllcy5jb2xvcikgOiBcblx0XHRcdFx0XHRcdFx0JyMwMDAwMDAnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY3Vyc29yKSB7XG5cdFx0XHRcdFx0XHRtb3JlU3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblxuXHRcdFx0XHRcdC8vIFJlbW92ZSB1bnVzZWQgYXR0cmlidXRlcyAoIzk0Nylcblx0XHRcdFx0XHRmb3IgKG5hbWUgaW4gYXR0cikge1xuXHRcdFx0XHRcdFx0aWYgKGF0dHJbbmFtZV0gPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgYXR0cltuYW1lXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkYXRhTGFiZWwgPSBwb2ludC5kYXRhTGFiZWwgPSByZW5kZXJlcltyb3RhdGlvbiA/ICd0ZXh0JyA6ICdsYWJlbCddKCAvLyBsYWJlbHMgZG9uJ3Qgc3VwcG9ydCByb3RhdGlvblxuXHRcdFx0XHRcdFx0c3RyLFxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdC05OTksXG5cdFx0XHRcdFx0XHRvcHRpb25zLnNoYXBlLFxuXHRcdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0XHRvcHRpb25zLnVzZUhUTUxcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LmF0dHIoYXR0cilcblx0XHRcdFx0XHQuY3NzKGV4dGVuZChzdHlsZSwgbW9yZVN0eWxlKSlcblx0XHRcdFx0XHQuYWRkKGRhdGFMYWJlbHNHcm91cClcblx0XHRcdFx0XHQuc2hhZG93KG9wdGlvbnMuc2hhZG93KTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRhdGFMYWJlbCkge1xuXHRcdFx0XHRcdC8vIE5vdyB0aGUgZGF0YSBsYWJlbCBpcyBjcmVhdGVkIGFuZCBwbGFjZWQgYXQgMCwwLCBzbyB3ZSBuZWVkIHRvIGFsaWduIGl0XG5cdFx0XHRcdFx0c2VyaWVzLmFsaWduRGF0YUxhYmVsKHBvaW50LCBkYXRhTGFiZWwsIG9wdGlvbnMsIG51bGwsIGlzTmV3KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59O1xuXG4vKipcbiAqIEFsaWduIGVhY2ggaW5kaXZpZHVhbCBkYXRhIGxhYmVsXG4gKi9cblNlcmllcy5wcm90b3R5cGUuYWxpZ25EYXRhTGFiZWwgPSBmdW5jdGlvbiAocG9pbnQsIGRhdGFMYWJlbCwgb3B0aW9ucywgYWxpZ25UbywgaXNOZXcpIHtcblx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdHBsb3RYID0gcGljayhwb2ludC5wbG90WCwgLTk5OSksXG5cdFx0cGxvdFkgPSBwaWNrKHBvaW50LnBsb3RZLCAtOTk5KSxcblx0XHRiQm94ID0gZGF0YUxhYmVsLmdldEJCb3goKSxcblx0XHRiYXNlbGluZSA9IGNoYXJ0LnJlbmRlcmVyLmZvbnRNZXRyaWNzKG9wdGlvbnMuc3R5bGUuZm9udFNpemUpLmIsXG5cdFx0cm90Q29yciwgLy8gcm90YXRpb24gY29ycmVjdGlvblxuXHRcdC8vIE1hdGgucm91bmQgZm9yIHJvdW5kaW5nIGVycm9ycyAoIzI2ODMpLCBhbGlnblRvIHRvIGFsbG93IGNvbHVtbiBsYWJlbHMgKCMyNzAwKVxuXHRcdHZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgKHBvaW50LnNlcmllcy5mb3JjZURMIHx8IGNoYXJ0LmlzSW5zaWRlUGxvdChwbG90WCwgbWF0aFJvdW5kKHBsb3RZKSwgaW52ZXJ0ZWQpIHx8XG5cdFx0XHQoYWxpZ25UbyAmJiBjaGFydC5pc0luc2lkZVBsb3QocGxvdFgsIGludmVydGVkID8gYWxpZ25Uby54ICsgMSA6IGFsaWduVG8ueSArIGFsaWduVG8uaGVpZ2h0IC0gMSwgaW52ZXJ0ZWQpKSksXG5cdFx0YWxpZ25BdHRyOyAvLyB0aGUgZmluYWwgcG9zaXRpb247XG5cblx0aWYgKHZpc2libGUpIHtcblxuXHRcdC8vIFRoZSBhbGlnbm1lbnQgYm94IGlzIGEgc2luZ3VsYXIgcG9pbnRcblx0XHRhbGlnblRvID0gZXh0ZW5kKHtcblx0XHRcdHg6IGludmVydGVkID8gY2hhcnQucGxvdFdpZHRoIC0gcGxvdFkgOiBwbG90WCxcblx0XHRcdHk6IG1hdGhSb3VuZChpbnZlcnRlZCA/IGNoYXJ0LnBsb3RIZWlnaHQgLSBwbG90WCA6IHBsb3RZKSxcblx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0aGVpZ2h0OiAwXG5cdFx0fSwgYWxpZ25Ubyk7XG5cblx0XHQvLyBBZGQgdGhlIHRleHQgc2l6ZSBmb3IgYWxpZ25tZW50IGNhbGN1bGF0aW9uXG5cdFx0ZXh0ZW5kKG9wdGlvbnMsIHtcblx0XHRcdHdpZHRoOiBiQm94LndpZHRoLFxuXHRcdFx0aGVpZ2h0OiBiQm94LmhlaWdodFxuXHRcdH0pO1xuXG5cdFx0Ly8gQWxsb3cgYSBob29rIGZvciBjaGFuZ2luZyBhbGlnbm1lbnQgaW4gdGhlIGxhc3QgbW9tZW50LCB0aGVuIGRvIHRoZSBhbGlnbm1lbnRcblx0XHRpZiAob3B0aW9ucy5yb3RhdGlvbikgeyAvLyBGYW5jeSBib3ggYWxpZ25tZW50IGlzbid0IHN1cHBvcnRlZCBmb3Igcm90YXRlZCB0ZXh0XG5cdFx0XHRyb3RDb3JyID0gY2hhcnQucmVuZGVyZXIucm90Q29ycihiYXNlbGluZSwgb3B0aW9ucy5yb3RhdGlvbik7IC8vICMzNzIzXG5cdFx0XHRkYXRhTGFiZWxbaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKHtcblx0XHRcdFx0XHR4OiBhbGlnblRvLnggKyBvcHRpb25zLnggKyBhbGlnblRvLndpZHRoIC8gMiArIHJvdENvcnIueCxcblx0XHRcdFx0XHR5OiBhbGlnblRvLnkgKyBvcHRpb25zLnkgKyBhbGlnblRvLmhlaWdodCAvIDJcblx0XHRcdFx0fSlcblx0XHRcdFx0LmF0dHIoeyAvLyAjMzAwM1xuXHRcdFx0XHRcdGFsaWduOiBvcHRpb25zLmFsaWduXG5cdFx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhTGFiZWwuYWxpZ24ob3B0aW9ucywgbnVsbCwgYWxpZ25Ubyk7XG5cdFx0XHRhbGlnbkF0dHIgPSBkYXRhTGFiZWwuYWxpZ25BdHRyO1xuXG5cdFx0XHQvLyBIYW5kbGUganVzdGlmeSBvciBjcm9wXG5cdFx0XHRpZiAocGljayhvcHRpb25zLm92ZXJmbG93LCAnanVzdGlmeScpID09PSAnanVzdGlmeScpIHtcblx0XHRcdFx0dGhpcy5qdXN0aWZ5RGF0YUxhYmVsKGRhdGFMYWJlbCwgb3B0aW9ucywgYWxpZ25BdHRyLCBiQm94LCBhbGlnblRvLCBpc05ldyk7XG5cblx0XHRcdH0gZWxzZSBpZiAocGljayhvcHRpb25zLmNyb3AsIHRydWUpKSB7XG5cdFx0XHRcdC8vIE5vdyBjaGVjayB0aGF0IHRoZSBkYXRhIGxhYmVsIGlzIHdpdGhpbiB0aGUgcGxvdCBhcmVhXG5cdFx0XHRcdHZpc2libGUgPSBjaGFydC5pc0luc2lkZVBsb3QoYWxpZ25BdHRyLngsIGFsaWduQXR0ci55KSAmJiBjaGFydC5pc0luc2lkZVBsb3QoYWxpZ25BdHRyLnggKyBiQm94LndpZHRoLCBhbGlnbkF0dHIueSArIGJCb3guaGVpZ2h0KTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBXaGVuIHdlJ3JlIHVzaW5nIGEgc2hhcGUsIG1ha2UgaXQgcG9zc2libGUgd2l0aCBhIGNvbm5lY3RvciBvciBhbiBhcnJvdyBwb2ludGluZyB0byB0aGllIHBvaW50XG5cdFx0XHRpZiAob3B0aW9ucy5zaGFwZSkge1xuXHRcdFx0XHRkYXRhTGFiZWwuYXR0cih7XG5cdFx0XHRcdFx0YW5jaG9yWDogcG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0YW5jaG9yWTogcG9pbnQucGxvdFlcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHR9XG5cdH1cblxuXHQvLyBTaG93IG9yIGhpZGUgYmFzZWQgb24gdGhlIGZpbmFsIGFsaWduZWQgcG9zaXRpb25cblx0aWYgKCF2aXNpYmxlKSB7XG5cdFx0c3RvcChkYXRhTGFiZWwpO1xuXHRcdGRhdGFMYWJlbC5hdHRyKHsgeTogLTk5OSB9KTtcblx0XHRkYXRhTGFiZWwucGxhY2VkID0gZmFsc2U7IC8vIGRvbid0IGFuaW1hdGUgYmFjayBpblxuXHR9XG5cbn07XG5cbi8qKlxuICogSWYgZGF0YSBsYWJlbHMgZmFsbCBwYXJ0bHkgb3V0c2lkZSB0aGUgcGxvdCBhcmVhLCBhbGlnbiB0aGVtIGJhY2sgaW4sIGluIGEgd2F5IHRoYXRcbiAqIGRvZXNuJ3QgaGlkZSB0aGUgcG9pbnQuXG4gKi9cblNlcmllcy5wcm90b3R5cGUuanVzdGlmeURhdGFMYWJlbCA9IGZ1bmN0aW9uIChkYXRhTGFiZWwsIG9wdGlvbnMsIGFsaWduQXR0ciwgYkJveCwgYWxpZ25UbywgaXNOZXcpIHtcblx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRhbGlnbiA9IG9wdGlvbnMuYWxpZ24sXG5cdFx0dmVydGljYWxBbGlnbiA9IG9wdGlvbnMudmVydGljYWxBbGlnbixcblx0XHRvZmYsXG5cdFx0anVzdGlmaWVkLFxuXHRcdHBhZGRpbmcgPSBkYXRhTGFiZWwuYm94ID8gMCA6IChkYXRhTGFiZWwucGFkZGluZyB8fCAwKTtcblxuXHQvLyBPZmYgbGVmdFxuXHRvZmYgPSBhbGlnbkF0dHIueCArIHBhZGRpbmc7XG5cdGlmIChvZmYgPCAwKSB7XG5cdFx0aWYgKGFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0XHRvcHRpb25zLmFsaWduID0gJ2xlZnQnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvcHRpb25zLnggPSAtb2ZmO1xuXHRcdH1cblx0XHRqdXN0aWZpZWQgPSB0cnVlO1xuXHR9XG5cblx0Ly8gT2ZmIHJpZ2h0XG5cdG9mZiA9IGFsaWduQXR0ci54ICsgYkJveC53aWR0aCAtIHBhZGRpbmc7XG5cdGlmIChvZmYgPiBjaGFydC5wbG90V2lkdGgpIHtcblx0XHRpZiAoYWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0b3B0aW9ucy5hbGlnbiA9ICdyaWdodCc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9wdGlvbnMueCA9IGNoYXJ0LnBsb3RXaWR0aCAtIG9mZjtcblx0XHR9XG5cdFx0anVzdGlmaWVkID0gdHJ1ZTtcblx0fVxuXG5cdC8vIE9mZiB0b3Bcblx0b2ZmID0gYWxpZ25BdHRyLnkgKyBwYWRkaW5nO1xuXHRpZiAob2ZmIDwgMCkge1xuXHRcdGlmICh2ZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJykge1xuXHRcdFx0b3B0aW9ucy52ZXJ0aWNhbEFsaWduID0gJ3RvcCc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9wdGlvbnMueSA9IC1vZmY7XG5cdFx0fVxuXHRcdGp1c3RpZmllZCA9IHRydWU7XG5cdH1cblxuXHQvLyBPZmYgYm90dG9tXG5cdG9mZiA9IGFsaWduQXR0ci55ICsgYkJveC5oZWlnaHQgLSBwYWRkaW5nO1xuXHRpZiAob2ZmID4gY2hhcnQucGxvdEhlaWdodCkge1xuXHRcdGlmICh2ZXJ0aWNhbEFsaWduID09PSAndG9wJykge1xuXHRcdFx0b3B0aW9ucy52ZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9wdGlvbnMueSA9IGNoYXJ0LnBsb3RIZWlnaHQgLSBvZmY7XG5cdFx0fVxuXHRcdGp1c3RpZmllZCA9IHRydWU7XG5cdH1cblxuXHRpZiAoanVzdGlmaWVkKSB7XG5cdFx0ZGF0YUxhYmVsLnBsYWNlZCA9ICFpc05ldztcblx0XHRkYXRhTGFiZWwuYWxpZ24ob3B0aW9ucywgbnVsbCwgYWxpZ25Ubyk7XG5cdH1cbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGJhc2UgZHJhd0RhdGFMYWJlbHMgbWV0aG9kIGJ5IHBpZSBzcGVjaWZpYyBmdW5jdGlvbmFsaXR5XG4gKi9cbmlmIChzZXJpZXNUeXBlcy5waWUpIHtcblx0c2VyaWVzVHlwZXMucGllLnByb3RvdHlwZS5kcmF3RGF0YUxhYmVscyA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSxcblx0XHRcdHBvaW50LFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMuZGF0YUxhYmVscyxcblx0XHRcdGNvbm5lY3RvclBhZGRpbmcgPSBwaWNrKG9wdGlvbnMuY29ubmVjdG9yUGFkZGluZywgMTApLFxuXHRcdFx0Y29ubmVjdG9yV2lkdGggPSBwaWNrKG9wdGlvbnMuY29ubmVjdG9yV2lkdGgsIDEpLFxuXHRcdFx0cGxvdFdpZHRoID0gY2hhcnQucGxvdFdpZHRoLFxuXHRcdFx0cGxvdEhlaWdodCA9IGNoYXJ0LnBsb3RIZWlnaHQsXG5cdFx0XHRjb25uZWN0b3IsXG5cdFx0XHRjb25uZWN0b3JQYXRoLFxuXHRcdFx0c29mdENvbm5lY3RvciA9IHBpY2sob3B0aW9ucy5zb2Z0Q29ubmVjdG9yLCB0cnVlKSxcblx0XHRcdGRpc3RhbmNlT3B0aW9uID0gb3B0aW9ucy5kaXN0YW5jZSxcblx0XHRcdHNlcmllc0NlbnRlciA9IHNlcmllcy5jZW50ZXIsXG5cdFx0XHRyYWRpdXMgPSBzZXJpZXNDZW50ZXJbMl0gLyAyLFxuXHRcdFx0Y2VudGVyWSA9IHNlcmllc0NlbnRlclsxXSxcblx0XHRcdG91dHNpZGUgPSBkaXN0YW5jZU9wdGlvbiA+IDAsXG5cdFx0XHRkYXRhTGFiZWwsXG5cdFx0XHRkYXRhTGFiZWxXaWR0aCxcblx0XHRcdGxhYmVsUG9zLFxuXHRcdFx0bGFiZWxIZWlnaHQsXG5cdFx0XHRoYWx2ZXMgPSBbLy8gZGl2aWRlIHRoZSBwb2ludHMgaW50byByaWdodCBhbmQgbGVmdCBoYWx2ZXMgZm9yIGFudGkgY29sbGlzaW9uXG5cdFx0XHRcdFtdLCAvLyByaWdodFxuXHRcdFx0XHRbXSAgLy8gbGVmdFxuXHRcdFx0XSxcblx0XHRcdHgsXG5cdFx0XHR5LFxuXHRcdFx0dmlzaWJpbGl0eSxcblx0XHRcdHJhbmtBcnIsXG5cdFx0XHRpLFxuXHRcdFx0aixcblx0XHRcdG92ZXJmbG93ID0gWzAsIDAsIDAsIDBdLCAvLyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcblx0XHRcdHNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYi55IC0gYS55O1xuXHRcdFx0fTtcblxuXHRcdC8vIGdldCBvdXQgaWYgbm90IGVuYWJsZWRcblx0XHRpZiAoIXNlcmllcy52aXNpYmxlIHx8ICghb3B0aW9ucy5lbmFibGVkICYmICFzZXJpZXMuX2hhc1BvaW50TGFiZWxzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHJ1biBwYXJlbnQgbWV0aG9kXG5cdFx0U2VyaWVzLnByb3RvdHlwZS5kcmF3RGF0YUxhYmVscy5hcHBseShzZXJpZXMpO1xuXG5cdFx0Ly8gYXJyYW5nZSBwb2ludHMgZm9yIGRldGVjdGlvbiBjb2xsaXNpb25cblx0XHRlYWNoKGRhdGEsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0aWYgKHBvaW50LmRhdGFMYWJlbCAmJiBwb2ludC52aXNpYmxlKSB7IC8vICM0MDcsICMyNTEwXG5cdFx0XHRcdGhhbHZlc1twb2ludC5oYWxmXS5wdXNoKHBvaW50KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8qIExvb3Agb3ZlciB0aGUgcG9pbnRzIGluIGVhY2ggaGFsZiwgc3RhcnRpbmcgZnJvbSB0aGUgdG9wIGFuZCBib3R0b21cblx0XHQgKiBvZiB0aGUgcGllIHRvIGRldGVjdCBvdmVybGFwcGluZyBsYWJlbHMuXG5cdFx0ICovXG5cdFx0aSA9IDI7XG5cdFx0d2hpbGUgKGktLSkge1xuXG5cdFx0XHR2YXIgc2xvdHMgPSBbXSxcblx0XHRcdFx0c2xvdHNMZW5ndGgsXG5cdFx0XHRcdHVzZWRTbG90cyA9IFtdLFxuXHRcdFx0XHRwb2ludHMgPSBoYWx2ZXNbaV0sXG5cdFx0XHRcdHBvcyxcblx0XHRcdFx0Ym90dG9tLFxuXHRcdFx0XHRsZW5ndGggPSBwb2ludHMubGVuZ3RoLFxuXHRcdFx0XHRzbG90SW5kZXg7XG5cblx0XHRcdGlmICghbGVuZ3RoKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTb3J0IGJ5IGFuZ2xlXG5cdFx0XHRzZXJpZXMuc29ydEJ5QW5nbGUocG9pbnRzLCBpIC0gMC41KTtcblxuXHRcdFx0Ly8gQXNzdW1lIGVxdWFsIGxhYmVsIGhlaWdodHMgb24gZWl0aGVyIGhlbWlzcGhlcmUgKCMyNjMwKVxuXHRcdFx0aiA9IGxhYmVsSGVpZ2h0ID0gMDtcblx0XHRcdHdoaWxlICghbGFiZWxIZWlnaHQgJiYgcG9pbnRzW2pdKSB7IC8vICMxNTY5XG5cdFx0XHRcdGxhYmVsSGVpZ2h0ID0gcG9pbnRzW2pdICYmIHBvaW50c1tqXS5kYXRhTGFiZWwgJiYgKHBvaW50c1tqXS5kYXRhTGFiZWwuZ2V0QkJveCgpLmhlaWdodCB8fCAyMSk7IC8vIDIxIGlzIGZvciAjOTY4XG5cdFx0XHRcdGorKztcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBkbyBhbnRpLWNvbGxpc2lvbiB3aGVuIHdlIGFyZSBvdXRzaWRlIHRoZSBwaWUgYW5kIGhhdmUgY29ubmVjdG9ycyAoIzg1Nilcblx0XHRcdGlmIChkaXN0YW5jZU9wdGlvbiA+IDApIHtcblxuXHRcdFx0XHQvLyBCdWlsZCB0aGUgc2xvdHNcblx0XHRcdFx0Ym90dG9tID0gbWF0aE1pbihjZW50ZXJZICsgcmFkaXVzICsgZGlzdGFuY2VPcHRpb24sIGNoYXJ0LnBsb3RIZWlnaHQpO1xuXHRcdFx0XHRmb3IgKHBvcyA9IG1hdGhNYXgoMCwgY2VudGVyWSAtIHJhZGl1cyAtIGRpc3RhbmNlT3B0aW9uKTsgcG9zIDw9IGJvdHRvbTsgcG9zICs9IGxhYmVsSGVpZ2h0KSB7XG5cdFx0XHRcdFx0c2xvdHMucHVzaChwb3MpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNsb3RzTGVuZ3RoID0gc2xvdHMubGVuZ3RoO1xuXG5cblx0XHRcdFx0LyogVmlzdWFsaXplIHRoZSBzbG90c1xuXHRcdFx0XHRpZiAoIXNlcmllcy5zbG90RWxlbWVudHMpIHtcblx0XHRcdFx0XHRzZXJpZXMuc2xvdEVsZW1lbnRzID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGkgPT09IDEpIHtcblx0XHRcdFx0XHRzZXJpZXMuc2xvdEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcblx0XHRcdFx0XHRcdGVsZW0uZGVzdHJveSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHNlcmllcy5zbG90RWxlbWVudHMubGVuZ3RoID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRzbG90cy5mb3JFYWNoKGZ1bmN0aW9uIChwb3MsIG5vKSB7XG5cdFx0XHRcdFx0dmFyIHNsb3RYID0gc2VyaWVzLmdldFgocG9zLCBpKSArIGNoYXJ0LnBsb3RMZWZ0IC0gKGkgPyAxMDAgOiAwKSxcblx0XHRcdFx0XHRcdHNsb3RZID0gcG9zICsgY2hhcnQucGxvdFRvcDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIWlzTmFOKHNsb3RYKSkge1xuXHRcdFx0XHRcdFx0c2VyaWVzLnNsb3RFbGVtZW50cy5wdXNoKGNoYXJ0LnJlbmRlcmVyLnJlY3Qoc2xvdFgsIHNsb3RZIC0gNywgMTAwLCBsYWJlbEhlaWdodCwgMSlcblx0XHRcdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiAxLFxuXHRcdFx0XHRcdFx0XHRcdHN0cm9rZTogJ3NpbHZlcicsXG5cdFx0XHRcdFx0XHRcdFx0ZmlsbDogJ3JnYmEoMCwwLDI1NSwwLjEpJ1xuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHQuYWRkKCkpO1xuXHRcdFx0XHRcdFx0c2VyaWVzLnNsb3RFbGVtZW50cy5wdXNoKGNoYXJ0LnJlbmRlcmVyLnRleHQoJ1Nsb3QgJysgbm8sIHNsb3RYLCBzbG90WSArIDQpXG5cdFx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0XHRmaWxsOiAnc2lsdmVyJ1xuXHRcdFx0XHRcdFx0XHR9KS5hZGQoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gKi9cblxuXHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbW9yZSB2YWx1ZXMgdGhhbiBhdmFpbGFibGUgc2xvdHMsIHJlbW92ZSBsb3dlc3QgdmFsdWVzXG5cdFx0XHRcdGlmIChsZW5ndGggPiBzbG90c0xlbmd0aCkge1xuXHRcdFx0XHRcdC8vIGNyZWF0ZSBhbiBhcnJheSBmb3Igc29ydGluZyBhbmQgcmFua2luZyB0aGUgcG9pbnRzIHdpdGhpbiBlYWNoIHF1YXJ0ZXJcblx0XHRcdFx0XHRyYW5rQXJyID0gW10uY29uY2F0KHBvaW50cyk7XG5cdFx0XHRcdFx0cmFua0Fyci5zb3J0KHNvcnQpO1xuXHRcdFx0XHRcdGogPSBsZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKGotLSkge1xuXHRcdFx0XHRcdFx0cmFua0FycltqXS5yYW5rID0gajtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aiA9IGxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoai0tKSB7XG5cdFx0XHRcdFx0XHRpZiAocG9pbnRzW2pdLnJhbmsgPj0gc2xvdHNMZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0cG9pbnRzLnNwbGljZShqLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRoZSBsYWJlbCBnb2VzIHRvIHRoZSBuZWFyZXN0IG9wZW4gc2xvdCwgYnV0IG5vdCBjbG9zZXIgdG8gdGhlIGVkZ2UgdGhhblxuXHRcdFx0XHQvLyB0aGUgbGFiZWwncyBpbmRleC5cblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG5cblx0XHRcdFx0XHRwb2ludCA9IHBvaW50c1tqXTtcblx0XHRcdFx0XHRsYWJlbFBvcyA9IHBvaW50LmxhYmVsUG9zO1xuXG5cdFx0XHRcdFx0dmFyIGNsb3Nlc3QgPSA5OTk5LFxuXHRcdFx0XHRcdFx0ZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRzbG90STtcblxuXHRcdFx0XHRcdC8vIGZpbmQgdGhlIGNsb3Nlc3Qgc2xvdCBpbmRleFxuXHRcdFx0XHRcdGZvciAoc2xvdEkgPSAwOyBzbG90SSA8IHNsb3RzTGVuZ3RoOyBzbG90SSsrKSB7XG5cdFx0XHRcdFx0XHRkaXN0YW5jZSA9IG1hdGhBYnMoc2xvdHNbc2xvdEldIC0gbGFiZWxQb3NbMV0pO1xuXHRcdFx0XHRcdFx0aWYgKGRpc3RhbmNlIDwgY2xvc2VzdCkge1xuXHRcdFx0XHRcdFx0XHRjbG9zZXN0ID0gZGlzdGFuY2U7XG5cdFx0XHRcdFx0XHRcdHNsb3RJbmRleCA9IHNsb3RJO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGlmIHRoYXQgc2xvdCBpbmRleCBpcyBjbG9zZXIgdG8gdGhlIGVkZ2VzIG9mIHRoZSBzbG90cywgbW92ZSBpdFxuXHRcdFx0XHRcdC8vIHRvIHRoZSBjbG9zZXN0IGFwcHJvcHJpYXRlIHNsb3Rcblx0XHRcdFx0XHRpZiAoc2xvdEluZGV4IDwgaiAmJiBzbG90c1tqXSAhPT0gbnVsbCkgeyAvLyBjbHVzdGVyIGF0IHRoZSB0b3Bcblx0XHRcdFx0XHRcdHNsb3RJbmRleCA9IGo7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzbG90c0xlbmd0aCAgPCBsZW5ndGggLSBqICsgc2xvdEluZGV4ICYmIHNsb3RzW2pdICE9PSBudWxsKSB7IC8vIGNsdXN0ZXIgYXQgdGhlIGJvdHRvbVxuXHRcdFx0XHRcdFx0c2xvdEluZGV4ID0gc2xvdHNMZW5ndGggLSBsZW5ndGggKyBqO1xuXHRcdFx0XHRcdFx0d2hpbGUgKHNsb3RzW3Nsb3RJbmRleF0gPT09IG51bGwpIHsgLy8gbWFrZSBzdXJlIGl0IGlzIG5vdCB0YWtlblxuXHRcdFx0XHRcdFx0XHRzbG90SW5kZXgrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gU2xvdCBpcyB0YWtlbiwgZmluZCBuZXh0IGZyZWUgc2xvdCBiZWxvdy4gSW4gdGhlIG5leHQgcnVuLCB0aGUgbmV4dCBzbGljZSB3aWxsIGZpbmQgdGhlXG5cdFx0XHRcdFx0XHQvLyBzbG90IGFib3ZlIHRoZXNlLCBiZWNhdXNlIGl0IGlzIHRoZSBjbG9zZXN0IG9uZVxuXHRcdFx0XHRcdFx0d2hpbGUgKHNsb3RzW3Nsb3RJbmRleF0gPT09IG51bGwpIHsgLy8gbWFrZSBzdXJlIGl0IGlzIG5vdCB0YWtlblxuXHRcdFx0XHRcdFx0XHRzbG90SW5kZXgrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR1c2VkU2xvdHMucHVzaCh7IGk6IHNsb3RJbmRleCwgeTogc2xvdHNbc2xvdEluZGV4XSB9KTtcblx0XHRcdFx0XHRzbG90c1tzbG90SW5kZXhdID0gbnVsbDsgLy8gbWFyayBhcyB0YWtlblxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNvcnQgdGhlbSBpbiBvcmRlciB0byBmaWxsIGluIGZyb20gdGhlIHRvcFxuXHRcdFx0XHR1c2VkU2xvdHMuc29ydChzb3J0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbm93IHRoZSB1c2VkIHNsb3RzIGFyZSBzb3J0ZWQsIGZpbGwgdGhlbSB1cCBzZXF1ZW50aWFsbHlcblx0XHRcdGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuXG5cdFx0XHRcdHZhciBzbG90LCBuYXR1cmFsWTtcblxuXHRcdFx0XHRwb2ludCA9IHBvaW50c1tqXTtcblx0XHRcdFx0bGFiZWxQb3MgPSBwb2ludC5sYWJlbFBvcztcblx0XHRcdFx0ZGF0YUxhYmVsID0gcG9pbnQuZGF0YUxhYmVsO1xuXHRcdFx0XHR2aXNpYmlsaXR5ID0gcG9pbnQudmlzaWJsZSA9PT0gZmFsc2UgPyBISURERU4gOiAnaW5oZXJpdCc7XG5cdFx0XHRcdG5hdHVyYWxZID0gbGFiZWxQb3NbMV07XG5cblx0XHRcdFx0aWYgKGRpc3RhbmNlT3B0aW9uID4gMCkge1xuXHRcdFx0XHRcdHNsb3QgPSB1c2VkU2xvdHMucG9wKCk7XG5cdFx0XHRcdFx0c2xvdEluZGV4ID0gc2xvdC5pO1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIHNsb3QgbmV4dCB0byBjdXJycmVudCBzbG90IGlzIGZyZWUsIHRoZSB5IHZhbHVlIGlzIGFsbG93ZWRcblx0XHRcdFx0XHQvLyB0byBmYWxsIGJhY2sgdG8gdGhlIG5hdHVyYWwgcG9zaXRpb25cblx0XHRcdFx0XHR5ID0gc2xvdC55O1xuXHRcdFx0XHRcdGlmICgobmF0dXJhbFkgPiB5ICYmIHNsb3RzW3Nsb3RJbmRleCArIDFdICE9PSBudWxsKSB8fFxuXHRcdFx0XHRcdFx0XHQobmF0dXJhbFkgPCB5ICYmICBzbG90c1tzbG90SW5kZXggLSAxXSAhPT0gbnVsbCkpIHtcblx0XHRcdFx0XHRcdHkgPSBtYXRoTWluKG1hdGhNYXgoMCwgbmF0dXJhbFkpLCBjaGFydC5wbG90SGVpZ2h0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5ID0gbmF0dXJhbFk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBnZXQgdGhlIHggLSB1c2UgdGhlIG5hdHVyYWwgeCBwb3NpdGlvbiBmb3IgZmlyc3QgYW5kIGxhc3Qgc2xvdCwgdG8gcHJldmVudCB0aGUgdG9wXG5cdFx0XHRcdC8vIGFuZCBib3R0b24gc2xpY2UgY29ubmVjdG9ycyBmcm9tIHRvdWNoaW5nIGVhY2ggb3RoZXIgb24gZWl0aGVyIHNpZGVcblx0XHRcdFx0eCA9IG9wdGlvbnMuanVzdGlmeSA/XG5cdFx0XHRcdFx0c2VyaWVzQ2VudGVyWzBdICsgKGkgPyAtMSA6IDEpICogKHJhZGl1cyArIGRpc3RhbmNlT3B0aW9uKSA6XG5cdFx0XHRcdFx0c2VyaWVzLmdldFgoeSA9PT0gY2VudGVyWSAtIHJhZGl1cyAtIGRpc3RhbmNlT3B0aW9uIHx8IHkgPT09IGNlbnRlclkgKyByYWRpdXMgKyBkaXN0YW5jZU9wdGlvbiA/IG5hdHVyYWxZIDogeSwgaSk7XG5cblxuXHRcdFx0XHQvLyBSZWNvcmQgdGhlIHBsYWNlbWVudCBhbmQgdmlzaWJpbGl0eVxuXHRcdFx0XHRkYXRhTGFiZWwuX2F0dHIgPSB7XG5cdFx0XHRcdFx0dmlzaWJpbGl0eTogdmlzaWJpbGl0eSxcblx0XHRcdFx0XHRhbGlnbjogbGFiZWxQb3NbNl1cblx0XHRcdFx0fTtcblx0XHRcdFx0ZGF0YUxhYmVsLl9wb3MgPSB7XG5cdFx0XHRcdFx0eDogeCArIG9wdGlvbnMueCArXG5cdFx0XHRcdFx0XHQoeyBsZWZ0OiBjb25uZWN0b3JQYWRkaW5nLCByaWdodDogLWNvbm5lY3RvclBhZGRpbmcgfVtsYWJlbFBvc1s2XV0gfHwgMCksXG5cdFx0XHRcdFx0eTogeSArIG9wdGlvbnMueSAtIDEwIC8vIDEwIGlzIGZvciB0aGUgYmFzZWxpbmUgKGxhYmVsIHZzIHRleHQpXG5cdFx0XHRcdH07XG5cdFx0XHRcdGRhdGFMYWJlbC5jb25uWCA9IHg7XG5cdFx0XHRcdGRhdGFMYWJlbC5jb25uWSA9IHk7XG5cblxuXHRcdFx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3dpbmcgZGF0YSBsYWJlbHNcblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zaXplID09PSBudWxsKSB7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsV2lkdGggPSBkYXRhTGFiZWwud2lkdGg7XG5cdFx0XHRcdFx0Ly8gT3ZlcmZsb3cgbGVmdFxuXHRcdFx0XHRcdGlmICh4IC0gZGF0YUxhYmVsV2lkdGggPCBjb25uZWN0b3JQYWRkaW5nKSB7XG5cdFx0XHRcdFx0XHRvdmVyZmxvd1szXSA9IG1hdGhNYXgobWF0aFJvdW5kKGRhdGFMYWJlbFdpZHRoIC0geCArIGNvbm5lY3RvclBhZGRpbmcpLCBvdmVyZmxvd1szXSk7XG5cblx0XHRcdFx0XHQvLyBPdmVyZmxvdyByaWdodFxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoeCArIGRhdGFMYWJlbFdpZHRoID4gcGxvdFdpZHRoIC0gY29ubmVjdG9yUGFkZGluZykge1xuXHRcdFx0XHRcdFx0b3ZlcmZsb3dbMV0gPSBtYXRoTWF4KG1hdGhSb3VuZCh4ICsgZGF0YUxhYmVsV2lkdGggLSBwbG90V2lkdGggKyBjb25uZWN0b3JQYWRkaW5nKSwgb3ZlcmZsb3dbMV0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE92ZXJmbG93IHRvcFxuXHRcdFx0XHRcdGlmICh5IC0gbGFiZWxIZWlnaHQgLyAyIDwgMCkge1xuXHRcdFx0XHRcdFx0b3ZlcmZsb3dbMF0gPSBtYXRoTWF4KG1hdGhSb3VuZCgteSArIGxhYmVsSGVpZ2h0IC8gMiksIG92ZXJmbG93WzBdKTtcblxuXHRcdFx0XHRcdC8vIE92ZXJmbG93IGxlZnRcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHkgKyBsYWJlbEhlaWdodCAvIDIgPiBwbG90SGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHRvdmVyZmxvd1syXSA9IG1hdGhNYXgobWF0aFJvdW5kKHkgKyBsYWJlbEhlaWdodCAvIDIgLSBwbG90SGVpZ2h0KSwgb3ZlcmZsb3dbMl0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBmb3IgZWFjaCBwb2ludFxuXHRcdH0gLy8gZm9yIGVhY2ggaGFsZlxuXG5cdFx0Ly8gRG8gbm90IGFwcGx5IHRoZSBmaW5hbCBwbGFjZW1lbnQgYW5kIGRyYXcgdGhlIGNvbm5lY3RvcnMgdW50aWwgd2UgaGF2ZSB2ZXJpZmllZFxuXHRcdC8vIHRoYXQgbGFiZWxzIGFyZSBub3Qgc3BpbGxpbmcgb3Zlci5cblx0XHRpZiAoYXJyYXlNYXgob3ZlcmZsb3cpID09PSAwIHx8IHRoaXMudmVyaWZ5RGF0YUxhYmVsT3ZlcmZsb3cob3ZlcmZsb3cpKSB7XG5cblx0XHRcdC8vIFBsYWNlIHRoZSBsYWJlbHMgaW4gdGhlIGZpbmFsIHBvc2l0aW9uXG5cdFx0XHR0aGlzLnBsYWNlRGF0YUxhYmVscygpO1xuXG5cdFx0XHQvLyBEcmF3IHRoZSBjb25uZWN0b3JzXG5cdFx0XHRpZiAob3V0c2lkZSAmJiBjb25uZWN0b3JXaWR0aCkge1xuXHRcdFx0XHRlYWNoKHRoaXMucG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XHRjb25uZWN0b3IgPSBwb2ludC5jb25uZWN0b3I7XG5cdFx0XHRcdFx0bGFiZWxQb3MgPSBwb2ludC5sYWJlbFBvcztcblx0XHRcdFx0XHRkYXRhTGFiZWwgPSBwb2ludC5kYXRhTGFiZWw7XG5cblx0XHRcdFx0XHRpZiAoZGF0YUxhYmVsICYmIGRhdGFMYWJlbC5fcG9zICYmIHBvaW50LnZpc2libGUpIHtcblx0XHRcdFx0XHRcdHZpc2liaWxpdHkgPSBkYXRhTGFiZWwuX2F0dHIudmlzaWJpbGl0eTtcblx0XHRcdFx0XHRcdHggPSBkYXRhTGFiZWwuY29ublg7XG5cdFx0XHRcdFx0XHR5ID0gZGF0YUxhYmVsLmNvbm5ZO1xuXHRcdFx0XHRcdFx0Y29ubmVjdG9yUGF0aCA9IHNvZnRDb25uZWN0b3IgPyBbXG5cdFx0XHRcdFx0XHRcdE0sXG5cdFx0XHRcdFx0XHRcdHggKyAobGFiZWxQb3NbNl0gPT09ICdsZWZ0JyA/IDUgOiAtNSksIHksIC8vIGVuZCBvZiB0aGUgc3RyaW5nIGF0IHRoZSBsYWJlbFxuXHRcdFx0XHRcdFx0XHQnQycsXG5cdFx0XHRcdFx0XHRcdHgsIHksIC8vIGZpcnN0IGJyZWFrLCBuZXh0IHRvIHRoZSBsYWJlbFxuXHRcdFx0XHRcdFx0XHQyICogbGFiZWxQb3NbMl0gLSBsYWJlbFBvc1s0XSwgMiAqIGxhYmVsUG9zWzNdIC0gbGFiZWxQb3NbNV0sXG5cdFx0XHRcdFx0XHRcdGxhYmVsUG9zWzJdLCBsYWJlbFBvc1szXSwgLy8gc2Vjb25kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdEwsXG5cdFx0XHRcdFx0XHRcdGxhYmVsUG9zWzRdLCBsYWJlbFBvc1s1XSAvLyBiYXNlXG5cdFx0XHRcdFx0XHRdIDogW1xuXHRcdFx0XHRcdFx0XHRNLFxuXHRcdFx0XHRcdFx0XHR4ICsgKGxhYmVsUG9zWzZdID09PSAnbGVmdCcgPyA1IDogLTUpLCB5LCAvLyBlbmQgb2YgdGhlIHN0cmluZyBhdCB0aGUgbGFiZWxcblx0XHRcdFx0XHRcdFx0TCxcblx0XHRcdFx0XHRcdFx0bGFiZWxQb3NbMl0sIGxhYmVsUG9zWzNdLCAvLyBzZWNvbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0TCxcblx0XHRcdFx0XHRcdFx0bGFiZWxQb3NbNF0sIGxhYmVsUG9zWzVdIC8vIGJhc2Vcblx0XHRcdFx0XHRcdF07XG5cblx0XHRcdFx0XHRcdGlmIChjb25uZWN0b3IpIHtcblx0XHRcdFx0XHRcdFx0Y29ubmVjdG9yLmFuaW1hdGUoeyBkOiBjb25uZWN0b3JQYXRoIH0pO1xuXHRcdFx0XHRcdFx0XHRjb25uZWN0b3IuYXR0cigndmlzaWJpbGl0eScsIHZpc2liaWxpdHkpO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwb2ludC5jb25uZWN0b3IgPSBjb25uZWN0b3IgPSBzZXJpZXMuY2hhcnQucmVuZGVyZXIucGF0aChjb25uZWN0b3JQYXRoKS5hdHRyKHtcblx0XHRcdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogY29ubmVjdG9yV2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0c3Ryb2tlOiBvcHRpb25zLmNvbm5lY3RvckNvbG9yIHx8IHBvaW50LmNvbG9yIHx8ICcjNjA2MDYwJyxcblx0XHRcdFx0XHRcdFx0XHR2aXNpYmlsaXR5OiB2aXNpYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0Ly96SW5kZXg6IDAgLy8gIzI3MjIgKHJldmVyc2VkKVxuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHQuYWRkKHNlcmllcy5kYXRhTGFiZWxzR3JvdXApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY29ubmVjdG9yKSB7XG5cdFx0XHRcdFx0XHRwb2ludC5jb25uZWN0b3IgPSBjb25uZWN0b3IuZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHQvKipcblx0ICogUGVyZm9ybSB0aGUgZmluYWwgcGxhY2VtZW50IG9mIHRoZSBkYXRhIGxhYmVscyBhZnRlciB3ZSBoYXZlIHZlcmlmaWVkIHRoYXQgdGhleVxuXHQgKiBmYWxsIHdpdGhpbiB0aGUgcGxvdCBhcmVhLlxuXHQgKi9cblx0c2VyaWVzVHlwZXMucGllLnByb3RvdHlwZS5wbGFjZURhdGFMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ZWFjaCh0aGlzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHR2YXIgZGF0YUxhYmVsID0gcG9pbnQuZGF0YUxhYmVsLFxuXHRcdFx0XHRfcG9zO1xuXG5cdFx0XHRpZiAoZGF0YUxhYmVsICYmIHBvaW50LnZpc2libGUpIHtcblx0XHRcdFx0X3BvcyA9IGRhdGFMYWJlbC5fcG9zO1xuXHRcdFx0XHRpZiAoX3Bvcykge1xuXHRcdFx0XHRcdGRhdGFMYWJlbC5hdHRyKGRhdGFMYWJlbC5fYXR0cik7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsW2RhdGFMYWJlbC5tb3ZlZCA/ICdhbmltYXRlJyA6ICdhdHRyJ10oX3Bvcyk7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsLm1vdmVkID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChkYXRhTGFiZWwpIHtcblx0XHRcdFx0XHRkYXRhTGFiZWwuYXR0cih7IHk6IC05OTkgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHRzZXJpZXNUeXBlcy5waWUucHJvdG90eXBlLmFsaWduRGF0YUxhYmVsID0gIG5vb3A7XG5cblx0LyoqXG5cdCAqIFZlcmlmeSB3aGV0aGVyIHRoZSBkYXRhIGxhYmVscyBhcmUgYWxsb3dlZCB0byBkcmF3LCBvciB3ZSBzaG91bGQgcnVuIG1vcmUgdHJhbnNsYXRpb24gYW5kIGRhdGFcblx0ICogbGFiZWwgcG9zaXRpb25pbmcgdG8ga2VlcCB0aGVtIGluc2lkZSB0aGUgcGxvdCBhcmVhLiBSZXR1cm5zIHRydWUgd2hlbiBkYXRhIGxhYmVscyBhcmUgcmVhZHlcblx0ICogdG8gZHJhdy5cblx0ICovXG5cdHNlcmllc1R5cGVzLnBpZS5wcm90b3R5cGUudmVyaWZ5RGF0YUxhYmVsT3ZlcmZsb3cgPSBmdW5jdGlvbiAob3ZlcmZsb3cpIHtcblxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcixcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRjZW50ZXJPcHRpb24gPSBvcHRpb25zLmNlbnRlcixcblx0XHRcdG1pblNpemUgPSBvcHRpb25zLm1pblNpemUgfHwgODAsXG5cdFx0XHRuZXdTaXplID0gbWluU2l6ZSxcblx0XHRcdHJldDtcblxuXHRcdC8vIEhhbmRsZSBob3Jpem9udGFsIHNpemUgYW5kIGNlbnRlclxuXHRcdGlmIChjZW50ZXJPcHRpb25bMF0gIT09IG51bGwpIHsgLy8gRml4ZWQgY2VudGVyXG5cdFx0XHRuZXdTaXplID0gbWF0aE1heChjZW50ZXJbMl0gLSBtYXRoTWF4KG92ZXJmbG93WzFdLCBvdmVyZmxvd1szXSksIG1pblNpemUpO1xuXG5cdFx0fSBlbHNlIHsgLy8gQXV0byBjZW50ZXJcblx0XHRcdG5ld1NpemUgPSBtYXRoTWF4KFxuXHRcdFx0XHRjZW50ZXJbMl0gLSBvdmVyZmxvd1sxXSAtIG92ZXJmbG93WzNdLCAvLyBob3Jpem9udGFsIG92ZXJmbG93XG5cdFx0XHRcdG1pblNpemVcblx0XHRcdCk7XG5cdFx0XHRjZW50ZXJbMF0gKz0gKG92ZXJmbG93WzNdIC0gb3ZlcmZsb3dbMV0pIC8gMjsgLy8gaG9yaXpvbnRhbCBjZW50ZXJcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgdmVydGljYWwgc2l6ZSBhbmQgY2VudGVyXG5cdFx0aWYgKGNlbnRlck9wdGlvblsxXSAhPT0gbnVsbCkgeyAvLyBGaXhlZCBjZW50ZXJcblx0XHRcdG5ld1NpemUgPSBtYXRoTWF4KG1hdGhNaW4obmV3U2l6ZSwgY2VudGVyWzJdIC0gbWF0aE1heChvdmVyZmxvd1swXSwgb3ZlcmZsb3dbMl0pKSwgbWluU2l6ZSk7XG5cblx0XHR9IGVsc2UgeyAvLyBBdXRvIGNlbnRlclxuXHRcdFx0bmV3U2l6ZSA9IG1hdGhNYXgoXG5cdFx0XHRcdG1hdGhNaW4oXG5cdFx0XHRcdFx0bmV3U2l6ZSxcblx0XHRcdFx0XHRjZW50ZXJbMl0gLSBvdmVyZmxvd1swXSAtIG92ZXJmbG93WzJdIC8vIHZlcnRpY2FsIG92ZXJmbG93XG5cdFx0XHRcdCksXG5cdFx0XHRcdG1pblNpemVcblx0XHRcdCk7XG5cdFx0XHRjZW50ZXJbMV0gKz0gKG92ZXJmbG93WzBdIC0gb3ZlcmZsb3dbMl0pIC8gMjsgLy8gdmVydGljYWwgY2VudGVyXG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIHNpemUgbXVzdCBiZSBkZWNyZWFzZWQsIHdlIG5lZWQgdG8gcnVuIHRyYW5zbGF0ZSBhbmQgZHJhd0RhdGFMYWJlbHMgYWdhaW5cblx0XHRpZiAobmV3U2l6ZSA8IGNlbnRlclsyXSkge1xuXHRcdFx0Y2VudGVyWzJdID0gbmV3U2l6ZTtcblx0XHRcdGNlbnRlclszXSA9IE1hdGgubWluKHJlbGF0aXZlTGVuZ3RoKG9wdGlvbnMuaW5uZXJTaXplIHx8IDAsIG5ld1NpemUpLCBuZXdTaXplKTsgLy8gIzM2MzJcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0XHRlYWNoKHRoaXMucG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0aWYgKHBvaW50LmRhdGFMYWJlbCkge1xuXHRcdFx0XHRcdHBvaW50LmRhdGFMYWJlbC5fcG9zID0gbnVsbDsgLy8gcmVzZXRcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmICh0aGlzLmRyYXdEYXRhTGFiZWxzKSB7XG5cdFx0XHRcdHRoaXMuZHJhd0RhdGFMYWJlbHMoKTtcblx0XHRcdH1cblx0XHQvLyBFbHNlLCByZXR1cm4gdHJ1ZSB0byBpbmRpY2F0ZSB0aGF0IHRoZSBwaWUgYW5kIGl0cyBsYWJlbHMgaXMgd2l0aGluIHRoZSBwbG90IGFyZWFcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0ID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn1cblxuaWYgKHNlcmllc1R5cGVzLmNvbHVtbikge1xuXG5cdC8qKlxuXHQgKiBPdmVycmlkZSB0aGUgYmFzaWMgZGF0YSBsYWJlbCBhbGlnbm1lbnQgYnkgYWRqdXN0aW5nIGZvciB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbHVtblxuXHQgKi9cblx0c2VyaWVzVHlwZXMuY29sdW1uLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbCA9IGZ1bmN0aW9uIChwb2ludCwgZGF0YUxhYmVsLCBvcHRpb25zLCAgYWxpZ25UbywgaXNOZXcpIHtcblx0XHR2YXIgaW52ZXJ0ZWQgPSB0aGlzLmNoYXJ0LmludmVydGVkLFxuXHRcdFx0c2VyaWVzID0gcG9pbnQuc2VyaWVzLFxuXHRcdFx0ZGxCb3ggPSBwb2ludC5kbEJveCB8fCBwb2ludC5zaGFwZUFyZ3MsIC8vIGRhdGEgbGFiZWwgYm94IGZvciBhbGlnbm1lbnRcblx0XHRcdGJlbG93ID0gcGljayhwb2ludC5iZWxvdywgcG9pbnQucGxvdFkgPiBwaWNrKHRoaXMudHJhbnNsYXRlZFRocmVzaG9sZCwgc2VyaWVzLnlBeGlzLmxlbikpLCAvLyBwb2ludC5iZWxvdyBpcyB1c2VkIGluIHJhbmdlIHNlcmllc1xuXHRcdFx0aW5zaWRlID0gcGljayhvcHRpb25zLmluc2lkZSwgISF0aGlzLm9wdGlvbnMuc3RhY2tpbmcpOyAvLyBkcmF3IGl0IGluc2lkZSB0aGUgYm94P1xuXG5cdFx0Ly8gQWxpZ24gdG8gdGhlIGNvbHVtbiBpdHNlbGYsIG9yIHRoZSB0b3Agb2YgaXRcblx0XHRpZiAoZGxCb3gpIHsgLy8gQXJlYSByYW5nZSB1c2VzIHRoaXMgbWV0aG9kIGJ1dCBub3QgYWxpZ25Ub1xuXHRcdFx0YWxpZ25UbyA9IG1lcmdlKGRsQm94KTtcblxuXHRcdFx0aWYgKGludmVydGVkKSB7XG5cdFx0XHRcdGFsaWduVG8gPSB7XG5cdFx0XHRcdFx0eDogc2VyaWVzLnlBeGlzLmxlbiAtIGFsaWduVG8ueSAtIGFsaWduVG8uaGVpZ2h0LFxuXHRcdFx0XHRcdHk6IHNlcmllcy54QXhpcy5sZW4gLSBhbGlnblRvLnggLSBhbGlnblRvLndpZHRoLFxuXHRcdFx0XHRcdHdpZHRoOiBhbGlnblRvLmhlaWdodCxcblx0XHRcdFx0XHRoZWlnaHQ6IGFsaWduVG8ud2lkdGhcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcHV0ZSB0aGUgYWxpZ25tZW50IGJveFxuXHRcdFx0aWYgKCFpbnNpZGUpIHtcblx0XHRcdFx0aWYgKGludmVydGVkKSB7XG5cdFx0XHRcdFx0YWxpZ25Uby54ICs9IGJlbG93ID8gMCA6IGFsaWduVG8ud2lkdGg7XG5cdFx0XHRcdFx0YWxpZ25Uby53aWR0aCA9IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWxpZ25Uby55ICs9IGJlbG93ID8gYWxpZ25Uby5oZWlnaHQgOiAwO1xuXHRcdFx0XHRcdGFsaWduVG8uaGVpZ2h0ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0Ly8gV2hlbiBhbGlnbm1lbnQgaXMgdW5kZWZpbmVkICh0eXBpY2FsbHkgY29sdW1ucyBhbmQgYmFycyksIGRpc3BsYXkgdGhlIGluZGl2aWR1YWxcblx0XHQvLyBwb2ludCBiZWxvdyBvciBhYm92ZSB0aGUgcG9pbnQgZGVwZW5kaW5nIG9uIHRoZSB0aHJlc2hvbGRcblx0XHRvcHRpb25zLmFsaWduID0gcGljayhcblx0XHRcdG9wdGlvbnMuYWxpZ24sXG5cdFx0XHQhaW52ZXJ0ZWQgfHwgaW5zaWRlID8gJ2NlbnRlcicgOiBiZWxvdyA/ICdyaWdodCcgOiAnbGVmdCdcblx0XHQpO1xuXHRcdG9wdGlvbnMudmVydGljYWxBbGlnbiA9IHBpY2soXG5cdFx0XHRvcHRpb25zLnZlcnRpY2FsQWxpZ24sXG5cdFx0XHRpbnZlcnRlZCB8fCBpbnNpZGUgPyAnbWlkZGxlJyA6IGJlbG93ID8gJ3RvcCcgOiAnYm90dG9tJ1xuXHRcdCk7XG5cblx0XHQvLyBDYWxsIHRoZSBwYXJlbnQgbWV0aG9kXG5cdFx0U2VyaWVzLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbC5jYWxsKHRoaXMsIHBvaW50LCBkYXRhTGFiZWwsIG9wdGlvbnMsIGFsaWduVG8sIGlzTmV3KTtcblx0fTtcbn1cblxuXG5cbi8qKlxuICogSGlnaGNoYXJ0cyBKUyB2NC4xLjkgKDIwMTUtMTAtMDcpXG4gKiBIaWdoY2hhcnRzIG1vZHVsZSB0byBoaWRlIG92ZXJsYXBwaW5nIGRhdGEgbGFiZWxzLiBUaGlzIG1vZHVsZSBpcyBpbmNsdWRlZCBieSBkZWZhdWx0IGluIEhpZ2htYXBzLlxuICpcbiAqIChjKSAyMDEwLTIwMTQgVG9yc3RlaW4gSG9uc2lcbiAqXG4gKiBMaWNlbnNlOiB3d3cuaGlnaGNoYXJ0cy5jb20vbGljZW5zZVxuICovXG5cbi8qZ2xvYmFsIEhpZ2hjaGFydHMsIEhpZ2hjaGFydHNBZGFwdGVyICovXG4oZnVuY3Rpb24gKEgpIHtcblx0dmFyIENoYXJ0ID0gSC5DaGFydCxcblx0XHRlYWNoID0gSC5lYWNoLFxuXHRcdHBpY2sgPSBILnBpY2ssXG5cdFx0YWRkRXZlbnQgPSBIaWdoY2hhcnRzQWRhcHRlci5hZGRFdmVudDtcblxuXHQvLyBDb2xsZWN0IHBvdGVuc2lhbCBvdmVybGFwcGluZyBkYXRhIGxhYmVscy4gU3RhY2sgbGFiZWxzIHByb2JhYmx5IGRvbid0IG5lZWQgdG8gYmUgXG5cdC8vIGNvbnNpZGVyZWQgYmVjYXVzZSB0aGV5IGFyZSB1c3VhbGx5IGFjY29tcGFuaWVkIGJ5IGRhdGEgbGFiZWxzIHRoYXQgbGllIGluc2lkZSB0aGUgY29sdW1ucy5cblx0Q2hhcnQucHJvdG90eXBlLmNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChjaGFydCkge1xuXHRcdGZ1bmN0aW9uIGNvbGxlY3RBbmRIaWRlKCkge1xuXHRcdFx0dmFyIGxhYmVscyA9IFtdO1xuXG5cdFx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHR2YXIgZGxPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMuZGF0YUxhYmVscyxcblx0XHRcdFx0XHRjb2xsZWN0aW9ucyA9IHNlcmllcy5kYXRhTGFiZWxDb2xsZWN0aW9ucyB8fCBbJ2RhdGFMYWJlbCddOyAvLyBSYW5nZSBzZXJpZXMgaGF2ZSB0d28gY29sbGVjdGlvbnNcblx0XHRcdFx0aWYgKChkbE9wdGlvbnMuZW5hYmxlZCB8fCBzZXJpZXMuX2hhc1BvaW50TGFiZWxzKSAmJiAhZGxPcHRpb25zLmFsbG93T3ZlcmxhcCAmJiBzZXJpZXMudmlzaWJsZSkgeyAvLyAjMzg2NlxuXHRcdFx0XHRcdGVhY2goY29sbGVjdGlvbnMsIGZ1bmN0aW9uIChjb2xsKSB7XG5cdFx0XHRcdFx0XHRlYWNoKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRcdFx0XHRpZiAocG9pbnRbY29sbF0pIHtcblx0XHRcdFx0XHRcdFx0XHRwb2ludFtjb2xsXS5sYWJlbHJhbmsgPSBwaWNrKHBvaW50LmxhYmVscmFuaywgcG9pbnQuc2hhcGVBcmdzICYmIHBvaW50LnNoYXBlQXJncy5oZWlnaHQpOyAvLyAjNDExOFxuXHRcdFx0XHRcdFx0XHRcdGxhYmVscy5wdXNoKHBvaW50W2NvbGxdKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0Y2hhcnQuaGlkZU92ZXJsYXBwaW5nTGFiZWxzKGxhYmVscyk7XG5cdFx0fVxuXG5cdFx0Ly8gRG8gaXQgbm93IC4uLlxuXHRcdGNvbGxlY3RBbmRIaWRlKCk7XG5cblx0XHQvLyAuLi4gYW5kIGFmdGVyIGVhY2ggY2hhcnQgcmVkcmF3XG5cdFx0YWRkRXZlbnQoY2hhcnQsICdyZWRyYXcnLCBjb2xsZWN0QW5kSGlkZSk7XG5cblx0fSk7XG5cblx0LyoqXG5cdCAqIEhpZGUgb3ZlcmxhcHBpbmcgbGFiZWxzLiBMYWJlbHMgYXJlIG1vdmVkIGFuZCBmYWRlZCBpbiBhbmQgb3V0IG9uIHpvb20gdG8gcHJvdmlkZSBhIHNtb290aCBcblx0ICogdmlzdWFsIGltcmVzc2lvbi5cblx0ICovXHRcdFxuXHRDaGFydC5wcm90b3R5cGUuaGlkZU92ZXJsYXBwaW5nTGFiZWxzID0gZnVuY3Rpb24gKGxhYmVscykge1xuXG5cdFx0dmFyIGxlbiA9IGxhYmVscy5sZW5ndGgsXG5cdFx0XHRsYWJlbCxcblx0XHRcdGksXG5cdFx0XHRqLFxuXHRcdFx0bGFiZWwxLFxuXHRcdFx0bGFiZWwyLFxuXHRcdFx0aXNJbnRlcnNlY3RpbmcsXG5cdFx0XHRwb3MxLFxuXHRcdFx0cG9zMixcblx0XHRcdHBhZGRpbmcsXG5cdFx0XHRpbnRlcnNlY3RSZWN0ID0gZnVuY3Rpb24gKHgxLCB5MSwgdzEsIGgxLCB4MiwgeTIsIHcyLCBoMikge1xuXHRcdFx0XHRyZXR1cm4gIShcblx0XHRcdFx0XHR4MiA+IHgxICsgdzEgfHxcblx0XHRcdFx0XHR4MiArIHcyIDwgeDEgfHxcblx0XHRcdFx0XHR5MiA+IHkxICsgaDEgfHxcblx0XHRcdFx0XHR5MiArIGgyIDwgeTFcblx0XHRcdFx0KTtcblx0XHRcdH07XG5cdFxuXHRcdC8vIE1hcmsgd2l0aCBpbml0aWFsIG9wYWNpdHlcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGxhYmVsID0gbGFiZWxzW2ldO1xuXHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdGxhYmVsLm9sZE9wYWNpdHkgPSBsYWJlbC5vcGFjaXR5O1xuXHRcdFx0XHRsYWJlbC5uZXdPcGFjaXR5ID0gMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmV2ZW50IGEgc2l0dWF0aW9uIGluIGEgZ3JhZHVhbGx5IHJpc2luZyBzbG9wZSwgdGhhdCBlYWNoIGxhYmVsXG5cdFx0Ly8gd2lsbCBoaWRlIHRoZSBwcmV2aW91cyBvbmUgYmVjYXVzZSB0aGUgcHJldmlvdXMgb25lIGFsd2F5cyBoYXNcblx0XHQvLyBsb3dlciByYW5rLlxuXHRcdGxhYmVscy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gKGIubGFiZWxyYW5rIHx8IDApIC0gKGEubGFiZWxyYW5rIHx8IDApO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRGV0ZWN0IG92ZXJsYXBwaW5nIGxhYmVsc1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0bGFiZWwxID0gbGFiZWxzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSBpICsgMTsgaiA8IGxlbjsgKytqKSB7XG5cdFx0XHRcdGxhYmVsMiA9IGxhYmVsc1tqXTtcblx0XHRcdFx0aWYgKGxhYmVsMSAmJiBsYWJlbDIgJiYgbGFiZWwxLnBsYWNlZCAmJiBsYWJlbDIucGxhY2VkICYmIGxhYmVsMS5uZXdPcGFjaXR5ICE9PSAwICYmIGxhYmVsMi5uZXdPcGFjaXR5ICE9PSAwKSB7XG5cdFx0XHRcdFx0cG9zMSA9IGxhYmVsMS5hbGlnbkF0dHI7XG5cdFx0XHRcdFx0cG9zMiA9IGxhYmVsMi5hbGlnbkF0dHI7XG5cdFx0XHRcdFx0cGFkZGluZyA9IDIgKiAobGFiZWwxLmJveCA/IDAgOiBsYWJlbDEucGFkZGluZyk7IC8vIFN1YnN0cmFjdCB0aGUgcGFkZGluZyBpZiBubyBiYWNrZ3JvdW5kIG9yIGJvcmRlciAoIzQzMzMpXG5cdFx0XHRcdFx0aXNJbnRlcnNlY3RpbmcgPSBpbnRlcnNlY3RSZWN0KFxuXHRcdFx0XHRcdFx0cG9zMS54LFxuXHRcdFx0XHRcdFx0cG9zMS55LFxuXHRcdFx0XHRcdFx0bGFiZWwxLndpZHRoIC0gcGFkZGluZyxcblx0XHRcdFx0XHRcdGxhYmVsMS5oZWlnaHQgLSBwYWRkaW5nLFxuXHRcdFx0XHRcdFx0cG9zMi54LFxuXHRcdFx0XHRcdFx0cG9zMi55LFxuXHRcdFx0XHRcdFx0bGFiZWwyLndpZHRoIC0gcGFkZGluZyxcblx0XHRcdFx0XHRcdGxhYmVsMi5oZWlnaHQgLSBwYWRkaW5nXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGlmIChpc0ludGVyc2VjdGluZykge1xuXHRcdFx0XHRcdFx0KGxhYmVsMS5sYWJlbHJhbmsgPCBsYWJlbDIubGFiZWxyYW5rID8gbGFiZWwxIDogbGFiZWwyKS5uZXdPcGFjaXR5ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBIaWRlIG9yIHNob3dcblx0XHRlYWNoKGxhYmVscywgZnVuY3Rpb24gKGxhYmVsKSB7XG5cdFx0XHR2YXIgY29tcGxldGUsXG5cdFx0XHRcdG5ld09wYWNpdHk7XG5cblx0XHRcdGlmIChsYWJlbCkge1xuXHRcdFx0XHRuZXdPcGFjaXR5ID0gbGFiZWwubmV3T3BhY2l0eTtcblxuXHRcdFx0XHRpZiAobGFiZWwub2xkT3BhY2l0eSAhPT0gbmV3T3BhY2l0eSAmJiBsYWJlbC5wbGFjZWQpIHtcblxuXHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGUgbGFiZWwgaXMgY29tcGxldGVseSBoaWRkZW4gdG8gYXZvaWQgY2F0Y2hpbmcgY2xpY2tzICgjNDM2Milcblx0XHRcdFx0XHRpZiAobmV3T3BhY2l0eSkge1xuXHRcdFx0XHRcdFx0bGFiZWwuc2hvdyh0cnVlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdGxhYmVsLmhpZGUoKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQW5pbWF0ZSBvciBzZXQgdGhlIG9wYWNpdHlcdFx0XHRcdFx0XG5cdFx0XHRcdFx0bGFiZWwuYWxpZ25BdHRyLm9wYWNpdHkgPSBuZXdPcGFjaXR5O1xuXHRcdFx0XHRcdGxhYmVsW2xhYmVsLmlzT2xkID8gJ2FuaW1hdGUnIDogJ2F0dHInXShsYWJlbC5hbGlnbkF0dHIsIG51bGwsIGNvbXBsZXRlKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0fVxuXHRcdFx0XHRsYWJlbC5pc09sZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cbn0oSGlnaGNoYXJ0cykpOy8qKlxuICogVHJhY2tlck1peGluIGZvciBwb2ludHMgYW5kIGdyYXBoc1xuICovXG5cbnZhciBUcmFja2VyTWl4aW4gPSBIaWdoY2hhcnRzLlRyYWNrZXJNaXhpbiA9IHtcblxuXHRkcmF3VHJhY2tlclBvaW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdHBvaW50ZXIgPSBjaGFydC5wb2ludGVyLFxuXHRcdFx0Y3Vyc29yID0gc2VyaWVzLm9wdGlvbnMuY3Vyc29yLFxuXHRcdFx0Y3NzID0gY3Vyc29yICYmIHsgY3Vyc29yOiBjdXJzb3IgfSxcblx0XHRcdG9uTW91c2VPdmVyID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGUudGFyZ2V0LFxuXHRcdFx0XHRwb2ludDtcblxuXHRcdFx0XHR3aGlsZSAodGFyZ2V0ICYmICFwb2ludCkge1xuXHRcdFx0XHRcdHBvaW50ID0gdGFyZ2V0LnBvaW50O1xuXHRcdFx0XHRcdHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHBvaW50ICE9PSBVTkRFRklORUQgJiYgcG9pbnQgIT09IGNoYXJ0LmhvdmVyUG9pbnQpIHsgLy8gdW5kZWZpbmVkIG9uIGdyYXBoIGluIHNjYXR0ZXJjaGFydFxuXHRcdFx0XHRcdHBvaW50Lm9uTW91c2VPdmVyKGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQWRkIHJlZmVyZW5jZSB0byB0aGUgcG9pbnRcblx0XHRlYWNoKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0aWYgKHBvaW50LmdyYXBoaWMpIHtcblx0XHRcdFx0cG9pbnQuZ3JhcGhpYy5lbGVtZW50LnBvaW50ID0gcG9pbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAocG9pbnQuZGF0YUxhYmVsKSB7XG5cdFx0XHRcdHBvaW50LmRhdGFMYWJlbC5lbGVtZW50LnBvaW50ID0gcG9pbnQ7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVycywgd2UgbmVlZCB0byBkbyB0aGlzIG9ubHkgb25jZVxuXHRcdGlmICghc2VyaWVzLl9oYXNUcmFja2luZykge1xuXHRcdFx0ZWFjaChzZXJpZXMudHJhY2tlckdyb3VwcywgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRpZiAoc2VyaWVzW2tleV0pIHsgLy8gd2UgZG9uJ3QgYWx3YXlzIGhhdmUgZGF0YUxhYmVsc0dyb3VwXG5cdFx0XHRcdFx0c2VyaWVzW2tleV1cblx0XHRcdFx0XHRcdC5hZGRDbGFzcyhQUkVGSVggKyAndHJhY2tlcicpXG5cdFx0XHRcdFx0XHQub24oJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKVxuXHRcdFx0XHRcdFx0Lm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChlKSB7IHBvaW50ZXIub25UcmFja2VyTW91c2VPdXQoZSk7IH0pXG5cdFx0XHRcdFx0XHQuY3NzKGNzcyk7XG5cdFx0XHRcdFx0aWYgKGhhc1RvdWNoKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXNba2V5XS5vbigndG91Y2hzdGFydCcsIG9uTW91c2VPdmVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0c2VyaWVzLl9oYXNUcmFja2luZyA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3IHRoZSB0cmFja2VyIG9iamVjdCB0aGF0IHNpdHMgYWJvdmUgYWxsIGRhdGEgbGFiZWxzIGFuZCBtYXJrZXJzIHRvXG5cdCAqIHRyYWNrIG1vdXNlIGV2ZW50cyBvbiB0aGUgZ3JhcGggb3IgcG9pbnRzLiBGb3IgdGhlIGxpbmUgdHlwZSBjaGFydHNcblx0ICogdGhlIHRyYWNrZXIgdXNlcyB0aGUgc2FtZSBncmFwaFBhdGgsIGJ1dCB3aXRoIGEgZ3JlYXRlciBzdHJva2Ugd2lkdGhcblx0ICogZm9yIGJldHRlciBjb250cm9sLlxuXHQgKi9cblx0ZHJhd1RyYWNrZXJHcmFwaDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0dHJhY2tCeUFyZWEgPSBvcHRpb25zLnRyYWNrQnlBcmVhLFxuXHRcdFx0dHJhY2tlclBhdGggPSBbXS5jb25jYXQodHJhY2tCeUFyZWEgPyBzZXJpZXMuYXJlYVBhdGggOiBzZXJpZXMuZ3JhcGhQYXRoKSxcblx0XHRcdHRyYWNrZXJQYXRoTGVuZ3RoID0gdHJhY2tlclBhdGgubGVuZ3RoLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRwb2ludGVyID0gY2hhcnQucG9pbnRlcixcblx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRzbmFwID0gY2hhcnQub3B0aW9ucy50b29sdGlwLnNuYXAsXG5cdFx0XHR0cmFja2VyID0gc2VyaWVzLnRyYWNrZXIsXG5cdFx0XHRjdXJzb3IgPSBvcHRpb25zLmN1cnNvcixcblx0XHRcdGNzcyA9IGN1cnNvciAmJiB7IGN1cnNvcjogY3Vyc29yIH0sXG5cdFx0XHRzaW5nbGVQb2ludHMgPSBzZXJpZXMuc2luZ2xlUG9pbnRzLFxuXHRcdFx0c2luZ2xlUG9pbnQsXG5cdFx0XHRpLFxuXHRcdFx0b25Nb3VzZU92ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChjaGFydC5ob3ZlclNlcmllcyAhPT0gc2VyaWVzKSB7XG5cdFx0XHRcdFx0c2VyaWVzLm9uTW91c2VPdmVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvKlxuXHRcdFx0ICogRW1waXJpY2FsIGxvd2VzdCBwb3NzaWJsZSBvcGFjaXRpZXMgZm9yIFRSQUNLRVJfRklMTCBmb3IgYW4gZWxlbWVudCB0byBzdGF5IGludmlzaWJsZSBidXQgY2xpY2thYmxlXG5cdFx0XHQgKiBJRTY6IDAuMDAyXG5cdFx0XHQgKiBJRTc6IDAuMDAyXG5cdFx0XHQgKiBJRTg6IDAuMDAyXG5cdFx0XHQgKiBJRTk6IDAuMDAwMDAwMDAwMDEgKHVubGltaXRlZClcblx0XHRcdCAqIElFMTA6IDAuMDAwMSAoZXhwb3J0aW5nIG9ubHkpXG5cdFx0XHQgKiBGRjogMC4wMDAwMDAwMDAwMSAodW5saW1pdGVkKVxuXHRcdFx0ICogQ2hyb21lOiAwLjAwMDAwMVxuXHRcdFx0ICogU2FmYXJpOiAwLjAwMDAwMVxuXHRcdFx0ICogT3BlcmE6IDAuMDAwMDAwMDAwMDEgKHVubGltaXRlZClcblx0XHRcdCAqL1xuXHRcdFx0VFJBQ0tFUl9GSUxMID0gJ3JnYmEoMTkyLDE5MiwxOTIsJyArIChoYXNTVkcgPyAwLjAwMDEgOiAwLjAwMikgKyAnKSc7XG5cblx0XHQvLyBFeHRlbmQgZW5kIHBvaW50cy4gQSBiZXR0ZXIgd2F5IHdvdWxkIGJlIHRvIHVzZSByb3VuZCBsaW5lY2Fwcyxcblx0XHQvLyBidXQgdGhvc2UgYXJlIG5vdCBjbGlja2FibGUgaW4gVk1MLlxuXHRcdGlmICh0cmFja2VyUGF0aExlbmd0aCAmJiAhdHJhY2tCeUFyZWEpIHtcblx0XHRcdGkgPSB0cmFja2VyUGF0aExlbmd0aCArIDE7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdGlmICh0cmFja2VyUGF0aFtpXSA9PT0gTSkgeyAvLyBleHRlbmQgbGVmdCBzaWRlXG5cdFx0XHRcdFx0dHJhY2tlclBhdGguc3BsaWNlKGkgKyAxLCAwLCB0cmFja2VyUGF0aFtpICsgMV0gLSBzbmFwLCB0cmFja2VyUGF0aFtpICsgMl0sIEwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgoaSAmJiB0cmFja2VyUGF0aFtpXSA9PT0gTSkgfHwgaSA9PT0gdHJhY2tlclBhdGhMZW5ndGgpIHsgLy8gZXh0ZW5kIHJpZ2h0IHNpZGVcblx0XHRcdFx0XHR0cmFja2VyUGF0aC5zcGxpY2UoaSwgMCwgTCwgdHJhY2tlclBhdGhbaSAtIDJdICsgc25hcCwgdHJhY2tlclBhdGhbaSAtIDFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGhhbmRsZSBzaW5nbGUgcG9pbnRzXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNpbmdsZVBvaW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2luZ2xlUG9pbnQgPSBzaW5nbGVQb2ludHNbaV07XG5cdFx0XHR0cmFja2VyUGF0aC5wdXNoKE0sIHNpbmdsZVBvaW50LnBsb3RYIC0gc25hcCwgc2luZ2xlUG9pbnQucGxvdFksXG5cdFx0XHRMLCBzaW5nbGVQb2ludC5wbG90WCArIHNuYXAsIHNpbmdsZVBvaW50LnBsb3RZKTtcblx0XHR9XG5cblx0XHQvLyBkcmF3IHRoZSB0cmFja2VyXG5cdFx0aWYgKHRyYWNrZXIpIHtcblx0XHRcdHRyYWNrZXIuYXR0cih7IGQ6IHRyYWNrZXJQYXRoIH0pO1xuXHRcdH0gZWxzZSB7IC8vIGNyZWF0ZVxuXG5cdFx0XHRzZXJpZXMudHJhY2tlciA9IHJlbmRlcmVyLnBhdGgodHJhY2tlclBhdGgpXG5cdFx0XHQuYXR0cih7XG5cdFx0XHRcdCdzdHJva2UtbGluZWpvaW4nOiAncm91bmQnLCAvLyAjMTIyNVxuXHRcdFx0XHR2aXNpYmlsaXR5OiBzZXJpZXMudmlzaWJsZSA/IFZJU0lCTEUgOiBISURERU4sXG5cdFx0XHRcdHN0cm9rZTogVFJBQ0tFUl9GSUxMLFxuXHRcdFx0XHRmaWxsOiB0cmFja0J5QXJlYSA/IFRSQUNLRVJfRklMTCA6IE5PTkUsXG5cdFx0XHRcdCdzdHJva2Utd2lkdGgnIDogb3B0aW9ucy5saW5lV2lkdGggKyAodHJhY2tCeUFyZWEgPyAwIDogMiAqIHNuYXApLFxuXHRcdFx0XHR6SW5kZXg6IDJcblx0XHRcdH0pXG5cdFx0XHQuYWRkKHNlcmllcy5ncm91cCk7XG5cblx0XHRcdC8vIFRoZSB0cmFja2VyIGlzIGFkZGVkIHRvIHRoZSBzZXJpZXMgZ3JvdXAsIHdoaWNoIGlzIGNsaXBwZWQsIGJ1dCBpcyBjb3ZlcmVkXG5cdFx0XHQvLyBieSB0aGUgbWFya2VyIGdyb3VwLiBTbyB0aGUgbWFya2VyIGdyb3VwIGFsc28gbmVlZHMgdG8gY2FwdHVyZSBldmVudHMuXG5cdFx0XHRlYWNoKFtzZXJpZXMudHJhY2tlciwgc2VyaWVzLm1hcmtlckdyb3VwXSwgZnVuY3Rpb24gKHRyYWNrZXIpIHtcblx0XHRcdFx0dHJhY2tlci5hZGRDbGFzcyhQUkVGSVggKyAndHJhY2tlcicpXG5cdFx0XHRcdFx0Lm9uKCdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcilcblx0XHRcdFx0XHQub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGUpIHsgcG9pbnRlci5vblRyYWNrZXJNb3VzZU91dChlKTsgfSlcblx0XHRcdFx0XHQuY3NzKGNzcyk7XG5cblx0XHRcdFx0aWYgKGhhc1RvdWNoKSB7XG5cdFx0XHRcdFx0dHJhY2tlci5vbigndG91Y2hzdGFydCcsIG9uTW91c2VPdmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59O1xuLyogRW5kIFRyYWNrZXJNaXhpbiAqL1xuXG5cbi8qKlxuICogQWRkIHRyYWNraW5nIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBzZXJpZXMgZ3JvdXAsIHNvIHRoZSBwb2ludCBncmFwaGljc1xuICogdGhlbXNlbHZlcyBhY3QgYXMgdHJhY2tlcnNcbiAqLyBcblxuaWYgKHNlcmllc1R5cGVzLmNvbHVtbikge1xuXHRDb2x1bW5TZXJpZXMucHJvdG90eXBlLmRyYXdUcmFja2VyID0gVHJhY2tlck1peGluLmRyYXdUcmFja2VyUG9pbnQ7XHRcbn1cblxuaWYgKHNlcmllc1R5cGVzLnBpZSkge1xuXHRzZXJpZXNUeXBlcy5waWUucHJvdG90eXBlLmRyYXdUcmFja2VyID0gVHJhY2tlck1peGluLmRyYXdUcmFja2VyUG9pbnQ7XG59XG5cbmlmIChzZXJpZXNUeXBlcy5zY2F0dGVyKSB7XG5cdFNjYXR0ZXJTZXJpZXMucHJvdG90eXBlLmRyYXdUcmFja2VyID0gVHJhY2tlck1peGluLmRyYXdUcmFja2VyUG9pbnQ7XG59XG5cbi8qIFxuICogRXh0ZW5kIExlZ2VuZCBmb3IgaXRlbSBldmVudHMgXG4gKi8gXG5leHRlbmQoTGVnZW5kLnByb3RvdHlwZSwge1xuXG5cdHNldEl0ZW1FdmVudHM6IGZ1bmN0aW9uIChpdGVtLCBsZWdlbmRJdGVtLCB1c2VIVE1MLCBpdGVtU3R5bGUsIGl0ZW1IaWRkZW5TdHlsZSkge1xuXHR2YXIgbGVnZW5kID0gdGhpcztcblx0Ly8gU2V0IHRoZSBldmVudHMgb24gdGhlIGl0ZW0gZ3JvdXAsIG9yIGluIGNhc2Ugb2YgdXNlSFRNTCwgdGhlIGl0ZW0gaXRzZWxmICgjMTI0OSlcblx0KHVzZUhUTUwgPyBsZWdlbmRJdGVtIDogaXRlbS5sZWdlbmRHcm91cCkub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGl0ZW0uc2V0U3RhdGUoSE9WRVJfU1RBVEUpO1xuXHRcdFx0bGVnZW5kSXRlbS5jc3MobGVnZW5kLm9wdGlvbnMuaXRlbUhvdmVyU3R5bGUpO1xuXHRcdH0pXG5cdFx0Lm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGxlZ2VuZEl0ZW0uY3NzKGl0ZW0udmlzaWJsZSA/IGl0ZW1TdHlsZSA6IGl0ZW1IaWRkZW5TdHlsZSk7XG5cdFx0XHRpdGVtLnNldFN0YXRlKCk7XG5cdFx0fSlcblx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHR2YXIgc3RyTGVnZW5kSXRlbUNsaWNrID0gJ2xlZ2VuZEl0ZW1DbGljaycsXG5cdFx0XHRcdGZuTGVnZW5kSXRlbUNsaWNrID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChpdGVtLnNldFZpc2libGUpIHtcblx0XHRcdFx0XHRcdGl0ZW0uc2V0VmlzaWJsZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHQvLyBQYXNzIG92ZXIgdGhlIGNsaWNrL3RvdWNoIGV2ZW50LiAjNC5cblx0XHRcdGV2ZW50ID0ge1xuXHRcdFx0XHRicm93c2VyRXZlbnQ6IGV2ZW50XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBjbGljayB0aGUgbmFtZSBvciBzeW1ib2xcblx0XHRcdGlmIChpdGVtLmZpcmVQb2ludEV2ZW50KSB7IC8vIHBvaW50XG5cdFx0XHRcdGl0ZW0uZmlyZVBvaW50RXZlbnQoc3RyTGVnZW5kSXRlbUNsaWNrLCBldmVudCwgZm5MZWdlbmRJdGVtQ2xpY2spO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZmlyZUV2ZW50KGl0ZW0sIHN0ckxlZ2VuZEl0ZW1DbGljaywgZXZlbnQsIGZuTGVnZW5kSXRlbUNsaWNrKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRjcmVhdGVDaGVja2JveEZvckl0ZW06IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIGxlZ2VuZCA9IHRoaXM7XG5cblx0XHRpdGVtLmNoZWNrYm94ID0gY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7XG5cdFx0XHR0eXBlOiAnY2hlY2tib3gnLFxuXHRcdFx0Y2hlY2tlZDogaXRlbS5zZWxlY3RlZCxcblx0XHRcdGRlZmF1bHRDaGVja2VkOiBpdGVtLnNlbGVjdGVkIC8vIHJlcXVpcmVkIGJ5IElFN1xuXHRcdH0sIGxlZ2VuZC5vcHRpb25zLml0ZW1DaGVja2JveFN0eWxlLCBsZWdlbmQuY2hhcnQuY29udGFpbmVyKTtcblxuXHRcdGFkZEV2ZW50KGl0ZW0uY2hlY2tib3gsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdGZpcmVFdmVudChpdGVtLnNlcmllcyB8fCBpdGVtLCAnY2hlY2tib3hDbGljaycsIHsgLy8gIzM3MTJcblx0XHRcdFx0XHRjaGVja2VkOiB0YXJnZXQuY2hlY2tlZCxcblx0XHRcdFx0XHRpdGVtOiBpdGVtXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpdGVtLnNlbGVjdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0pO1xuXHR9XHRcbn0pO1xuXG4vKiBcbiAqIEFkZCBwb2ludGVyIGN1cnNvciB0byBsZWdlbmQgaXRlbXN0eWxlIGluIGRlZmF1bHRPcHRpb25zXG4gKi9cbmRlZmF1bHRPcHRpb25zLmxlZ2VuZC5pdGVtU3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuXG5cbi8qIFxuICogRXh0ZW5kIHRoZSBDaGFydCBvYmplY3Qgd2l0aCBpbnRlcmFjdGlvblxuICovXG5cbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIHtcblx0LyoqXG5cdCAqIERpc3BsYXkgdGhlIHpvb20gYnV0dG9uXG5cdCAqL1xuXHRzaG93UmVzZXRab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdGxhbmcgPSBkZWZhdWx0T3B0aW9ucy5sYW5nLFxuXHRcdFx0YnRuT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQucmVzZXRab29tQnV0dG9uLFxuXHRcdFx0dGhlbWUgPSBidG5PcHRpb25zLnRoZW1lLFxuXHRcdFx0c3RhdGVzID0gdGhlbWUuc3RhdGVzLFxuXHRcdFx0YWxpZ25UbyA9IGJ0bk9wdGlvbnMucmVsYXRpdmVUbyA9PT0gJ2NoYXJ0JyA/IG51bGwgOiAncGxvdEJveCc7XG5cdFx0XHRcblx0XHR0aGlzLnJlc2V0Wm9vbUJ1dHRvbiA9IGNoYXJ0LnJlbmRlcmVyLmJ1dHRvbihsYW5nLnJlc2V0Wm9vbSwgbnVsbCwgbnVsbCwgZnVuY3Rpb24gKCkgeyBjaGFydC56b29tT3V0KCk7IH0sIHRoZW1lLCBzdGF0ZXMgJiYgc3RhdGVzLmhvdmVyKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRhbGlnbjogYnRuT3B0aW9ucy5wb3NpdGlvbi5hbGlnbixcblx0XHRcdFx0dGl0bGU6IGxhbmcucmVzZXRab29tVGl0bGVcblx0XHRcdH0pXG5cdFx0XHQuYWRkKClcblx0XHRcdC5hbGlnbihidG5PcHRpb25zLnBvc2l0aW9uLCBmYWxzZSwgYWxpZ25Ubyk7XG5cdFx0XHRcblx0fSxcblxuXHQvKipcblx0ICogWm9vbSBvdXQgdG8gMToxXG5cdCAqL1xuXHR6b29tT3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcztcblx0XHRmaXJlRXZlbnQoY2hhcnQsICdzZWxlY3Rpb24nLCB7IHJlc2V0U2VsZWN0aW9uOiB0cnVlIH0sIGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRjaGFydC56b29tKCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFpvb20gaW50byBhIGdpdmVuIHBvcnRpb24gb2YgdGhlIGNoYXJ0IGdpdmVuIGJ5IGF4aXMgY29vcmRpbmF0ZXNcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdCAqL1xuXHR6b29tOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0aGFzWm9vbWVkLFxuXHRcdFx0cG9pbnRlciA9IGNoYXJ0LnBvaW50ZXIsXG5cdFx0XHRkaXNwbGF5QnV0dG9uID0gZmFsc2UsXG5cdFx0XHRyZXNldFpvb21CdXR0b247XG5cblx0XHQvLyBJZiB6b29tIGlzIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgcmVzZXQgdGhlIGF4ZXNcblx0XHRpZiAoIWV2ZW50IHx8IGV2ZW50LnJlc2V0U2VsZWN0aW9uKSB7XG5cdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdGhhc1pvb21lZCA9IGF4aXMuem9vbSgpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHsgLy8gZWxzZSwgem9vbSBpbiBvbiBhbGwgYXhlc1xuXHRcdFx0ZWFjaChldmVudC54QXhpcy5jb25jYXQoZXZlbnQueUF4aXMpLCBmdW5jdGlvbiAoYXhpc0RhdGEpIHtcblx0XHRcdFx0dmFyIGF4aXMgPSBheGlzRGF0YS5heGlzLFxuXHRcdFx0XHRcdGlzWEF4aXMgPSBheGlzLmlzWEF4aXM7XG5cblx0XHRcdFx0Ly8gZG9uJ3Qgem9vbSBtb3JlIHRoYW4gbWluUmFuZ2Vcblx0XHRcdFx0aWYgKHBvaW50ZXJbaXNYQXhpcyA/ICd6b29tWCcgOiAnem9vbVknXSB8fCBwb2ludGVyW2lzWEF4aXMgPyAncGluY2hYJyA6ICdwaW5jaFknXSkge1xuXHRcdFx0XHRcdGhhc1pvb21lZCA9IGF4aXMuem9vbShheGlzRGF0YS5taW4sIGF4aXNEYXRhLm1heCk7XG5cdFx0XHRcdFx0aWYgKGF4aXMuZGlzcGxheUJ0bikge1xuXHRcdFx0XHRcdFx0ZGlzcGxheUJ1dHRvbiA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gU2hvdyBvciBoaWRlIHRoZSBSZXNldCB6b29tIGJ1dHRvblxuXHRcdHJlc2V0Wm9vbUJ1dHRvbiA9IGNoYXJ0LnJlc2V0Wm9vbUJ1dHRvbjtcblx0XHRpZiAoZGlzcGxheUJ1dHRvbiAmJiAhcmVzZXRab29tQnV0dG9uKSB7XG5cdFx0XHRjaGFydC5zaG93UmVzZXRab29tKCk7XG5cdFx0fSBlbHNlIGlmICghZGlzcGxheUJ1dHRvbiAmJiBpc09iamVjdChyZXNldFpvb21CdXR0b24pKSB7XG5cdFx0XHRjaGFydC5yZXNldFpvb21CdXR0b24gPSByZXNldFpvb21CdXR0b24uZGVzdHJveSgpO1xuXHRcdH1cblx0XHRcblxuXHRcdC8vIFJlZHJhd1xuXHRcdGlmIChoYXNab29tZWQpIHtcblx0XHRcdGNoYXJ0LnJlZHJhdyhcblx0XHRcdFx0cGljayhjaGFydC5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbiwgZXZlbnQgJiYgZXZlbnQuYW5pbWF0aW9uLCBjaGFydC5wb2ludENvdW50IDwgMTAwKSAvLyBhbmltYXRpb25cblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBQYW4gdGhlIGNoYXJ0IGJ5IGRyYWdnaW5nIHRoZSBtb3VzZSBhY3Jvc3MgdGhlIHBhbmUuIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkXG5cdCAqIG9uIG1vdXNlIG1vdmUsIGFuZCB0aGUgZGlzdGFuY2UgdG8gcGFuIGlzIGNvbXB1dGVkIGZyb20gY2hhcnRYIGNvbXBhcmVkIHRvXG5cdCAqIHRoZSBmaXJzdCBjaGFydFggcG9zaXRpb24gaW4gdGhlIGRyYWdnaW5nIG9wZXJhdGlvbi5cblx0ICovXG5cdHBhbjogZnVuY3Rpb24gKGUsIHBhbm5pbmcpIHtcblxuXHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRob3ZlclBvaW50cyA9IGNoYXJ0LmhvdmVyUG9pbnRzLFxuXHRcdFx0ZG9SZWRyYXc7XG5cblx0XHQvLyByZW1vdmUgYWN0aXZlIHBvaW50cyBmb3Igc2hhcmVkIHRvb2x0aXBcblx0XHRpZiAoaG92ZXJQb2ludHMpIHtcblx0XHRcdGVhY2goaG92ZXJQb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRwb2ludC5zZXRTdGF0ZSgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0ZWFjaChwYW5uaW5nID09PSAneHknID8gWzEsIDBdIDogWzFdLCBmdW5jdGlvbiAoaXNYKSB7IC8vIHh5IGlzIHVzZWQgaW4gbWFwc1xuXHRcdFx0dmFyIG1vdXNlUG9zID0gZVtpc1ggPyAnY2hhcnRYJyA6ICdjaGFydFknXSxcblx0XHRcdFx0YXhpcyA9IGNoYXJ0W2lzWCA/ICd4QXhpcycgOiAneUF4aXMnXVswXSxcblx0XHRcdFx0c3RhcnRQb3MgPSBjaGFydFtpc1ggPyAnbW91c2VEb3duWCcgOiAnbW91c2VEb3duWSddLFxuXHRcdFx0XHRoYWxmUG9pbnRSYW5nZSA9IChheGlzLnBvaW50UmFuZ2UgfHwgMCkgLyAyLFxuXHRcdFx0XHRleHRyZW1lcyA9IGF4aXMuZ2V0RXh0cmVtZXMoKSxcblx0XHRcdFx0bmV3TWluID0gYXhpcy50b1ZhbHVlKHN0YXJ0UG9zIC0gbW91c2VQb3MsIHRydWUpICsgaGFsZlBvaW50UmFuZ2UsXG5cdFx0XHRcdG5ld01heCA9IGF4aXMudG9WYWx1ZShzdGFydFBvcyArIGNoYXJ0W2lzWCA/ICdwbG90V2lkdGgnIDogJ3Bsb3RIZWlnaHQnXSAtIG1vdXNlUG9zLCB0cnVlKSAtIGhhbGZQb2ludFJhbmdlLFxuXHRcdFx0XHRnb2luZ0xlZnQgPSBzdGFydFBvcyA+IG1vdXNlUG9zOyAvLyAjMzYxM1xuXG5cdFx0XHRpZiAoYXhpcy5zZXJpZXMubGVuZ3RoICYmIFxuXHRcdFx0XHRcdChnb2luZ0xlZnQgfHwgbmV3TWluID4gbWF0aE1pbihleHRyZW1lcy5kYXRhTWluLCBleHRyZW1lcy5taW4pKSAmJiBcblx0XHRcdFx0XHQoIWdvaW5nTGVmdCB8fCBuZXdNYXggPCBtYXRoTWF4KGV4dHJlbWVzLmRhdGFNYXgsIGV4dHJlbWVzLm1heCkpKSB7XG5cdFx0XHRcdGF4aXMuc2V0RXh0cmVtZXMobmV3TWluLCBuZXdNYXgsIGZhbHNlLCBmYWxzZSwgeyB0cmlnZ2VyOiAncGFuJyB9KTtcblx0XHRcdFx0ZG9SZWRyYXcgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGFydFtpc1ggPyAnbW91c2VEb3duWCcgOiAnbW91c2VEb3duWSddID0gbW91c2VQb3M7IC8vIHNldCBuZXcgcmVmZXJlbmNlIGZvciBuZXh0IHJ1blxuXHRcdH0pO1xuXG5cdFx0aWYgKGRvUmVkcmF3KSB7XG5cdFx0XHRjaGFydC5yZWRyYXcoZmFsc2UpO1xuXHRcdH1cblx0XHRjc3MoY2hhcnQuY29udGFpbmVyLCB7IGN1cnNvcjogJ21vdmUnIH0pO1xuXHR9XG59KTtcblxuLypcbiAqIEV4dGVuZCB0aGUgUG9pbnQgb2JqZWN0IHdpdGggaW50ZXJhY3Rpb25cbiAqL1xuZXh0ZW5kKFBvaW50LnByb3RvdHlwZSwge1xuXHQvKipcblx0ICogVG9nZ2xlIHRoZSBzZWxlY3Rpb24gc3RhdHVzIG9mIGEgcG9pbnRcblx0ICogQHBhcmFtIHtCb29sZWFufSBzZWxlY3RlZCBXaGV0aGVyIHRvIHNlbGVjdCBvciB1bnNlbGVjdCB0aGUgcG9pbnQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWNjdW11bGF0ZSBXaGV0aGVyIHRvIGFkZCB0byB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLiBCeSBkZWZhdWx0LFxuXHQgKlx0XHQgdGhpcyBoYXBwZW5zIGlmIHRoZSBjb250cm9sIGtleSAoQ21kIG9uIE1hYykgd2FzIHByZXNzZWQgZHVyaW5nIGNsaWNraW5nLlxuXHQgKi9cblx0c2VsZWN0OiBmdW5jdGlvbiAoc2VsZWN0ZWQsIGFjY3VtdWxhdGUpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0c2VyaWVzID0gcG9pbnQuc2VyaWVzLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQ7XG5cblx0XHRzZWxlY3RlZCA9IHBpY2soc2VsZWN0ZWQsICFwb2ludC5zZWxlY3RlZCk7XG5cblx0XHQvLyBmaXJlIHRoZSBldmVudCB3aXRoIHRoZSBkZWZhbHV0IGhhbmRsZXJcblx0XHRwb2ludC5maXJlUG9pbnRFdmVudChzZWxlY3RlZCA/ICdzZWxlY3QnIDogJ3Vuc2VsZWN0JywgeyBhY2N1bXVsYXRlOiBhY2N1bXVsYXRlIH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHBvaW50LnNlbGVjdGVkID0gcG9pbnQub3B0aW9ucy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuXHRcdFx0c2VyaWVzLm9wdGlvbnMuZGF0YVtpbkFycmF5KHBvaW50LCBzZXJpZXMuZGF0YSldID0gcG9pbnQub3B0aW9ucztcblxuXHRcdFx0cG9pbnQuc2V0U3RhdGUoc2VsZWN0ZWQgJiYgU0VMRUNUX1NUQVRFKTtcblxuXHRcdFx0Ly8gdW5zZWxlY3QgYWxsIG90aGVyIHBvaW50cyB1bmxlc3MgQ3RybCBvciBDbWQgKyBjbGlja1xuXHRcdFx0aWYgKCFhY2N1bXVsYXRlKSB7XG5cdFx0XHRcdGVhY2goY2hhcnQuZ2V0U2VsZWN0ZWRQb2ludHMoKSwgZnVuY3Rpb24gKGxvb3BQb2ludCkge1xuXHRcdFx0XHRcdGlmIChsb29wUG9pbnQuc2VsZWN0ZWQgJiYgbG9vcFBvaW50ICE9PSBwb2ludCkge1xuXHRcdFx0XHRcdFx0bG9vcFBvaW50LnNlbGVjdGVkID0gbG9vcFBvaW50Lm9wdGlvbnMuc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHNlcmllcy5vcHRpb25zLmRhdGFbaW5BcnJheShsb29wUG9pbnQsIHNlcmllcy5kYXRhKV0gPSBsb29wUG9pbnQub3B0aW9ucztcblx0XHRcdFx0XHRcdGxvb3BQb2ludC5zZXRTdGF0ZShOT1JNQUxfU1RBVEUpO1xuXHRcdFx0XHRcdFx0XHRsb29wUG9pbnQuZmlyZVBvaW50RXZlbnQoJ3Vuc2VsZWN0Jyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogUnVucyBvbiBtb3VzZSBvdmVyIHRoZSBwb2ludFxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZXZlbnQgYXJndW1lbnRzXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYnlQcm94aW1pdHkgRmFsc3kgZm9yIGtkIHBvaW50cyB0aGF0IGFyZSBjbG9zZXN0IHRvIHRoZSBtb3VzZSwgb3IgdG8gXG5cdCAqICAgICAgICBhY3R1YWxseSBob3ZlcmVkIHBvaW50cy4gVHJ1ZSBmb3Igb3RoZXIgcG9pbnRzIGluIHNoYXJlZCB0b29sdGlwLlxuXHQgKi9cblx0b25Nb3VzZU92ZXI6IGZ1bmN0aW9uIChlLCBieVByb3hpbWl0eSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdHRvb2x0aXAgPSBjaGFydC50b29sdGlwLFxuXHRcdFx0aG92ZXJQb2ludCA9IGNoYXJ0LmhvdmVyUG9pbnQ7XG5cblx0XHRpZiAoY2hhcnQuaG92ZXJTZXJpZXMgIT09IHNlcmllcykge1xuXHRcdFx0c2VyaWVzLm9uTW91c2VPdmVyKCk7XG5cdFx0fVx0XHRcblxuXHRcdC8vIHNldCBub3JtYWwgc3RhdGUgdG8gcHJldmlvdXMgc2VyaWVzXG5cdFx0aWYgKGhvdmVyUG9pbnQgJiYgaG92ZXJQb2ludCAhPT0gcG9pbnQpIHtcblx0XHRcdGhvdmVyUG9pbnQub25Nb3VzZU91dCgpO1xuXHRcdH1cblxuXHRcdGlmIChwb2ludC5zZXJpZXMpIHsgLy8gSXQgbWF5IGhhdmUgYmVlbiBkZXN0cm95ZWQsICM0MTMwXG5cblx0XHRcdC8vIHRyaWdnZXIgdGhlIGV2ZW50XG5cdFx0XHRwb2ludC5maXJlUG9pbnRFdmVudCgnbW91c2VPdmVyJyk7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgdG9vbHRpcFxuXHRcdFx0aWYgKHRvb2x0aXAgJiYgKCF0b29sdGlwLnNoYXJlZCB8fCBzZXJpZXMubm9TaGFyZWRUb29sdGlwKSkge1xuXHRcdFx0XHR0b29sdGlwLnJlZnJlc2gocG9pbnQsIGUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBob3ZlciB0aGlzXG5cdFx0XHRwb2ludC5zZXRTdGF0ZShIT1ZFUl9TVEFURSk7XG5cdFx0XHRpZiAoIWJ5UHJveGltaXR5KSB7XG5cdFx0XHRcdGNoYXJ0LmhvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJ1bnMgb24gbW91c2Ugb3V0IGZyb20gdGhlIHBvaW50XG5cdCAqL1xuXHRvbk1vdXNlT3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5zZXJpZXMuY2hhcnQsXG5cdFx0XHRob3ZlclBvaW50cyA9IGNoYXJ0LmhvdmVyUG9pbnRzO1xuXG5cdFx0dGhpcy5maXJlUG9pbnRFdmVudCgnbW91c2VPdXQnKTtcblxuXHRcdGlmICghaG92ZXJQb2ludHMgfHwgaW5BcnJheSh0aGlzLCBob3ZlclBvaW50cykgPT09IC0xKSB7IC8vICM4ODcsICMyMjQwXG5cdFx0XHR0aGlzLnNldFN0YXRlKCk7XG5cdFx0XHRjaGFydC5ob3ZlclBvaW50ID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEltcG9ydCBldmVudHMgZnJvbSB0aGUgc2VyaWVzJyBhbmQgcG9pbnQncyBvcHRpb25zLiBPbmx5IGRvIGl0IG9uXG5cdCAqIGRlbWFuZCwgdG8gc2F2ZSBwcm9jZXNzaW5nIHRpbWUgb24gaG92ZXJpbmcuXG5cdCAqL1xuXHRpbXBvcnRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuaGFzSW1wb3J0ZWRFdmVudHMpIHtcblx0XHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSBtZXJnZShwb2ludC5zZXJpZXMub3B0aW9ucy5wb2ludCwgcG9pbnQub3B0aW9ucyksXG5cdFx0XHRcdGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzLFxuXHRcdFx0XHRldmVudFR5cGU7XG5cblx0XHRcdHBvaW50LmV2ZW50cyA9IGV2ZW50cztcblxuXHRcdFx0Zm9yIChldmVudFR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHRcdGFkZEV2ZW50KHBvaW50LCBldmVudFR5cGUsIGV2ZW50c1tldmVudFR5cGVdKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGFzSW1wb3J0ZWRFdmVudHMgPSB0cnVlO1xuXG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIHBvaW50J3Mgc3RhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0YXRlXG5cdCAqL1xuXHRzZXRTdGF0ZTogZnVuY3Rpb24gKHN0YXRlLCBtb3ZlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdHBsb3RYID0gbWF0aEZsb29yKHBvaW50LnBsb3RYKSwgLy8gIzQ1ODZcblx0XHRcdHBsb3RZID0gcG9pbnQucGxvdFksXG5cdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRzdGF0ZU9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucy5zdGF0ZXMsXG5cdFx0XHRtYXJrZXJPcHRpb25zID0gZGVmYXVsdFBsb3RPcHRpb25zW3Nlcmllcy50eXBlXS5tYXJrZXIgJiYgc2VyaWVzLm9wdGlvbnMubWFya2VyLFxuXHRcdFx0bm9ybWFsRGlzYWJsZWQgPSBtYXJrZXJPcHRpb25zICYmICFtYXJrZXJPcHRpb25zLmVuYWJsZWQsXG5cdFx0XHRtYXJrZXJTdGF0ZU9wdGlvbnMgPSBtYXJrZXJPcHRpb25zICYmIG1hcmtlck9wdGlvbnMuc3RhdGVzW3N0YXRlXSxcblx0XHRcdHN0YXRlRGlzYWJsZWQgPSBtYXJrZXJTdGF0ZU9wdGlvbnMgJiYgbWFya2VyU3RhdGVPcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlLFxuXHRcdFx0c3RhdGVNYXJrZXJHcmFwaGljID0gc2VyaWVzLnN0YXRlTWFya2VyR3JhcGhpYyxcblx0XHRcdHBvaW50TWFya2VyID0gcG9pbnQubWFya2VyIHx8IHt9LFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRyYWRpdXMsXG5cdFx0XHRoYWxvID0gc2VyaWVzLmhhbG8sXG5cdFx0XHRoYWxvT3B0aW9ucyxcblx0XHRcdG5ld1N5bWJvbCxcblx0XHRcdHBvaW50QXR0cjtcblxuXHRcdHN0YXRlID0gc3RhdGUgfHwgTk9STUFMX1NUQVRFOyAvLyBlbXB0eSBzdHJpbmdcblx0XHRwb2ludEF0dHIgPSBwb2ludC5wb2ludEF0dHJbc3RhdGVdIHx8IHNlcmllcy5wb2ludEF0dHJbc3RhdGVdO1xuXG5cdFx0aWYgKFxuXHRcdFx0XHQvLyBhbHJlYWR5IGhhcyB0aGlzIHN0YXRlXG5cdFx0XHRcdChzdGF0ZSA9PT0gcG9pbnQuc3RhdGUgJiYgIW1vdmUpIHx8XG5cdFx0XHRcdC8vIHNlbGVjdGVkIHBvaW50cyBkb24ndCByZXNwb25kIHRvIGhvdmVyXG5cdFx0XHRcdChwb2ludC5zZWxlY3RlZCAmJiBzdGF0ZSAhPT0gU0VMRUNUX1NUQVRFKSB8fFxuXHRcdFx0XHQvLyBzZXJpZXMnIHN0YXRlIG9wdGlvbnMgaXMgZGlzYWJsZWRcblx0XHRcdFx0KHN0YXRlT3B0aW9uc1tzdGF0ZV0gJiYgc3RhdGVPcHRpb25zW3N0YXRlXS5lbmFibGVkID09PSBmYWxzZSkgfHxcblx0XHRcdFx0Ly8gZ2VuZXJhbCBwb2ludCBtYXJrZXIncyBzdGF0ZSBvcHRpb25zIGlzIGRpc2FibGVkXG5cdFx0XHRcdChzdGF0ZSAmJiAoc3RhdGVEaXNhYmxlZCB8fCAobm9ybWFsRGlzYWJsZWQgJiYgbWFya2VyU3RhdGVPcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlKSkpIHx8XG5cdFx0XHRcdC8vIGluZGl2aWR1YWwgcG9pbnQgbWFya2VyJ3Mgc3RhdGUgb3B0aW9ucyBpcyBkaXNhYmxlZFxuXHRcdFx0XHQoc3RhdGUgJiYgcG9pbnRNYXJrZXIuc3RhdGVzICYmIHBvaW50TWFya2VyLnN0YXRlc1tzdGF0ZV0gJiYgcG9pbnRNYXJrZXIuc3RhdGVzW3N0YXRlXS5lbmFibGVkID09PSBmYWxzZSkgLy8gIzE2MTBcblxuXHRcdFx0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gYXBwbHkgaG92ZXIgc3R5bGVzIHRvIHRoZSBleGlzdGluZyBwb2ludFxuXHRcdGlmIChwb2ludC5ncmFwaGljKSB7XG5cdFx0XHRyYWRpdXMgPSBtYXJrZXJPcHRpb25zICYmIHBvaW50LmdyYXBoaWMuc3ltYm9sTmFtZSAmJiBwb2ludEF0dHIucjtcblx0XHRcdHBvaW50LmdyYXBoaWMuYXR0cihtZXJnZShcblx0XHRcdFx0cG9pbnRBdHRyLFxuXHRcdFx0XHRyYWRpdXMgPyB7IC8vIG5ldyBzeW1ib2wgYXR0cmlidXRlcyAoIzUwNywgIzYxMilcblx0XHRcdFx0XHR4OiBwbG90WCAtIHJhZGl1cyxcblx0XHRcdFx0XHR5OiBwbG90WSAtIHJhZGl1cyxcblx0XHRcdFx0XHR3aWR0aDogMiAqIHJhZGl1cyxcblx0XHRcdFx0XHRoZWlnaHQ6IDIgKiByYWRpdXNcblx0XHRcdFx0fSA6IHt9XG5cdFx0XHQpKTtcblxuXHRcdFx0Ly8gWm9vbWluZyBpbiBmcm9tIGEgcmFuZ2Ugd2l0aCBubyBtYXJrZXJzIHRvIGEgcmFuZ2Ugd2l0aCBtYXJrZXJzXG5cdFx0XHRpZiAoc3RhdGVNYXJrZXJHcmFwaGljKSB7XG5cdFx0XHRcdHN0YXRlTWFya2VyR3JhcGhpYy5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGlmIGEgZ3JhcGhpYyBpcyBub3QgYXBwbGllZCB0byBlYWNoIHBvaW50IGluIHRoZSBub3JtYWwgc3RhdGUsIGNyZWF0ZSBhIHNoYXJlZFxuXHRcdFx0Ly8gZ3JhcGhpYyBmb3IgdGhlIGhvdmVyIHN0YXRlXG5cdFx0XHRpZiAoc3RhdGUgJiYgbWFya2VyU3RhdGVPcHRpb25zKSB7XG5cdFx0XHRcdHJhZGl1cyA9IG1hcmtlclN0YXRlT3B0aW9ucy5yYWRpdXM7XG5cdFx0XHRcdG5ld1N5bWJvbCA9IHBvaW50TWFya2VyLnN5bWJvbCB8fCBzZXJpZXMuc3ltYm9sO1xuXG5cdFx0XHRcdC8vIElmIHRoZSBwb2ludCBoYXMgYW5vdGhlciBzeW1ib2wgdGhhbiB0aGUgcHJldmlvdXMgb25lLCB0aHJvdyBhd2F5IHRoZVxuXHRcdFx0XHQvLyBzdGF0ZSBtYXJrZXIgZ3JhcGhpYyBhbmQgZm9yY2UgYSBuZXcgb25lICgjMTQ1OSlcblx0XHRcdFx0aWYgKHN0YXRlTWFya2VyR3JhcGhpYyAmJiBzdGF0ZU1hcmtlckdyYXBoaWMuY3VycmVudFN5bWJvbCAhPT0gbmV3U3ltYm9sKSB7XG5cdFx0XHRcdFx0c3RhdGVNYXJrZXJHcmFwaGljID0gc3RhdGVNYXJrZXJHcmFwaGljLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBhIG5ldyBzdGF0ZSBtYXJrZXIgZ3JhcGhpY1xuXHRcdFx0XHRpZiAoIXN0YXRlTWFya2VyR3JhcGhpYykge1xuXHRcdFx0XHRcdGlmIChuZXdTeW1ib2wpIHtcblx0XHRcdFx0XHRcdHNlcmllcy5zdGF0ZU1hcmtlckdyYXBoaWMgPSBzdGF0ZU1hcmtlckdyYXBoaWMgPSBjaGFydC5yZW5kZXJlci5zeW1ib2woXG5cdFx0XHRcdFx0XHRcdG5ld1N5bWJvbCxcblx0XHRcdFx0XHRcdFx0cGxvdFggLSByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdHBsb3RZIC0gcmFkaXVzLFxuXHRcdFx0XHRcdFx0XHQyICogcmFkaXVzLFxuXHRcdFx0XHRcdFx0XHQyICogcmFkaXVzXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYXR0cihwb2ludEF0dHIpXG5cdFx0XHRcdFx0XHQuYWRkKHNlcmllcy5tYXJrZXJHcm91cCk7XG5cdFx0XHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWMuY3VycmVudFN5bWJvbCA9IG5ld1N5bWJvbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSB0aGUgZXhpc3RpbmcgZ3JhcGhpY1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXRlTWFya2VyR3JhcGhpY1ttb3ZlID8gJ2FuaW1hdGUnIDogJ2F0dHInXSh7IC8vICMxMDU0XG5cdFx0XHRcdFx0XHR4OiBwbG90WCAtIHJhZGl1cyxcblx0XHRcdFx0XHRcdHk6IHBsb3RZIC0gcmFkaXVzXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHN0YXRlTWFya2VyR3JhcGhpYykge1xuXHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWNbc3RhdGUgJiYgY2hhcnQuaXNJbnNpZGVQbG90KHBsb3RYLCBwbG90WSwgY2hhcnQuaW52ZXJ0ZWQpID8gJ3Nob3cnIDogJ2hpZGUnXSgpOyAvLyAjMjQ1MFxuXHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWMuZWxlbWVudC5wb2ludCA9IHBvaW50OyAvLyAjNDMxMFxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNob3cgbWUgeW91ciBoYWxvXG5cdFx0aGFsb09wdGlvbnMgPSBzdGF0ZU9wdGlvbnNbc3RhdGVdICYmIHN0YXRlT3B0aW9uc1tzdGF0ZV0uaGFsbztcblx0XHRpZiAoaGFsb09wdGlvbnMgJiYgaGFsb09wdGlvbnMuc2l6ZSkge1xuXHRcdFx0aWYgKCFoYWxvKSB7XG5cdFx0XHRcdHNlcmllcy5oYWxvID0gaGFsbyA9IGNoYXJ0LnJlbmRlcmVyLnBhdGgoKVxuXHRcdFx0XHRcdC5hZGQoY2hhcnQuc2VyaWVzR3JvdXApO1xuXHRcdFx0fVxuXHRcdFx0aGFsby5hdHRyKGV4dGVuZCh7XG5cdFx0XHRcdGZpbGw6IENvbG9yKHBvaW50LmNvbG9yIHx8IHNlcmllcy5jb2xvcikuc2V0T3BhY2l0eShoYWxvT3B0aW9ucy5vcGFjaXR5KS5nZXQoKVxuXHRcdFx0fSwgaGFsb09wdGlvbnMuYXR0cmlidXRlcykpW21vdmUgPyAnYW5pbWF0ZScgOiAnYXR0ciddKHtcblx0XHRcdFx0ZDogcG9pbnQuaGFsb1BhdGgoaGFsb09wdGlvbnMuc2l6ZSlcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoaGFsbykge1xuXHRcdFx0aGFsby5hdHRyKHsgZDogW10gfSk7XG5cdFx0fVxuXG5cdFx0cG9pbnQuc3RhdGUgPSBzdGF0ZTtcblx0fSxcblxuXHRoYWxvUGF0aDogZnVuY3Rpb24gKHNpemUpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcy5zZXJpZXMsXG5cdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdHBsb3RCb3ggPSBzZXJpZXMuZ2V0UGxvdEJveCgpLFxuXHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZDtcblxuXHRcdHJldHVybiBjaGFydC5yZW5kZXJlci5zeW1ib2xzLmNpcmNsZShcblx0XHRcdHBsb3RCb3gudHJhbnNsYXRlWCArIChpbnZlcnRlZCA/IHNlcmllcy55QXhpcy5sZW4gLSB0aGlzLnBsb3RZIDogdGhpcy5wbG90WCkgLSBzaXplLCBcblx0XHRcdHBsb3RCb3gudHJhbnNsYXRlWSArIChpbnZlcnRlZCA/IHNlcmllcy54QXhpcy5sZW4gLSB0aGlzLnBsb3RYIDogdGhpcy5wbG90WSkgLSBzaXplLCBcblx0XHRcdHNpemUgKiAyLCBcblx0XHRcdHNpemUgKiAyXG5cdFx0KTtcblx0fVxufSk7XG5cbi8qXG4gKiBFeHRlbmQgdGhlIFNlcmllcyBvYmplY3Qgd2l0aCBpbnRlcmFjdGlvblxuICovXG5cbmV4dGVuZChTZXJpZXMucHJvdG90eXBlLCB7XG5cdC8qKlxuXHQgKiBTZXJpZXMgbW91c2Ugb3ZlciBoYW5kbGVyXG5cdCAqL1xuXHRvbk1vdXNlT3ZlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRob3ZlclNlcmllcyA9IGNoYXJ0LmhvdmVyU2VyaWVzO1xuXG5cdFx0Ly8gc2V0IG5vcm1hbCBzdGF0ZSB0byBwcmV2aW91cyBzZXJpZXNcblx0XHRpZiAoaG92ZXJTZXJpZXMgJiYgaG92ZXJTZXJpZXMgIT09IHNlcmllcykge1xuXHRcdFx0aG92ZXJTZXJpZXMub25Nb3VzZU91dCgpO1xuXHRcdH1cblxuXHRcdC8vIHRyaWdnZXIgdGhlIGV2ZW50LCBidXQgdG8gc2F2ZSBwcm9jZXNzaW5nIHRpbWUsXG5cdFx0Ly8gb25seSBpZiBkZWZpbmVkXG5cdFx0aWYgKHNlcmllcy5vcHRpb25zLmV2ZW50cy5tb3VzZU92ZXIpIHtcblx0XHRcdGZpcmVFdmVudChzZXJpZXMsICdtb3VzZU92ZXInKTtcblx0XHR9XG5cblx0XHQvLyBob3ZlciB0aGlzXG5cdFx0c2VyaWVzLnNldFN0YXRlKEhPVkVSX1NUQVRFKTtcblx0XHRjaGFydC5ob3ZlclNlcmllcyA9IHNlcmllcztcblx0fSxcblxuXHQvKipcblx0ICogU2VyaWVzIG1vdXNlIG91dCBoYW5kbGVyXG5cdCAqL1xuXHRvbk1vdXNlT3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdHJpZ2dlciB0aGUgZXZlbnQgb25seSBpZiBsaXN0ZW5lcnMgZXhpc3Rcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0dG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXAsXG5cdFx0XHRob3ZlclBvaW50ID0gY2hhcnQuaG92ZXJQb2ludDtcblxuXHRcdGNoYXJ0LmhvdmVyU2VyaWVzID0gbnVsbDsgLy8gIzE4Miwgc2V0IHRvIG51bGwgYmVmb3JlIHRoZSBtb3VzZU91dCBldmVudCBmaXJlc1xuXG5cdFx0Ly8gdHJpZ2dlciBtb3VzZSBvdXQgb24gdGhlIHBvaW50LCB3aGljaCBtdXN0IGJlIGluIHRoaXMgc2VyaWVzXG5cdFx0aWYgKGhvdmVyUG9pbnQpIHtcblx0XHRcdGhvdmVyUG9pbnQub25Nb3VzZU91dCgpO1xuXHRcdH1cblxuXHRcdC8vIGZpcmUgdGhlIG1vdXNlIG91dCBldmVudFxuXHRcdGlmIChzZXJpZXMgJiYgb3B0aW9ucy5ldmVudHMubW91c2VPdXQpIHtcblx0XHRcdGZpcmVFdmVudChzZXJpZXMsICdtb3VzZU91dCcpO1xuXHRcdH1cblxuXG5cdFx0Ly8gaGlkZSB0aGUgdG9vbHRpcFxuXHRcdGlmICh0b29sdGlwICYmICFvcHRpb25zLnN0aWNreVRyYWNraW5nICYmICghdG9vbHRpcC5zaGFyZWQgfHwgc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCkpIHtcblx0XHRcdHRvb2x0aXAuaGlkZSgpO1xuXHRcdH1cblxuXHRcdC8vIHNldCBub3JtYWwgc3RhdGVcblx0XHRzZXJpZXMuc2V0U3RhdGUoKTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSBzdGF0ZSBvZiB0aGUgZ3JhcGhcblx0ICovXG5cdHNldFN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdGdyYXBoID0gc2VyaWVzLmdyYXBoLFxuXHRcdFx0c3RhdGVPcHRpb25zID0gb3B0aW9ucy5zdGF0ZXMsXG5cdFx0XHRsaW5lV2lkdGggPSBvcHRpb25zLmxpbmVXaWR0aCxcblx0XHRcdGF0dHJpYnMsXG5cdFx0XHRpID0gMDtcblxuXHRcdHN0YXRlID0gc3RhdGUgfHwgTk9STUFMX1NUQVRFO1xuXG5cdFx0aWYgKHNlcmllcy5zdGF0ZSAhPT0gc3RhdGUpIHtcblx0XHRcdHNlcmllcy5zdGF0ZSA9IHN0YXRlO1xuXG5cdFx0XHRpZiAoc3RhdGVPcHRpb25zW3N0YXRlXSAmJiBzdGF0ZU9wdGlvbnNbc3RhdGVdLmVuYWJsZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHN0YXRlKSB7XG5cdFx0XHRcdGxpbmVXaWR0aCA9IHN0YXRlT3B0aW9uc1tzdGF0ZV0ubGluZVdpZHRoIHx8IGxpbmVXaWR0aCArIChzdGF0ZU9wdGlvbnNbc3RhdGVdLmxpbmVXaWR0aFBsdXMgfHwgMCk7IC8vICM0MDM1XG5cdFx0XHR9XG5cblx0XHRcdGlmIChncmFwaCAmJiAhZ3JhcGguZGFzaHN0eWxlKSB7IC8vIGhvdmVyIGlzIHR1cm5lZCBvZmYgZm9yIGRhc2hlZCBsaW5lcyBpbiBWTUxcblx0XHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogbGluZVdpZHRoXG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIHVzZSBhdHRyIGJlY2F1c2UgYW5pbWF0ZSB3aWxsIGNhdXNlIGFueSBvdGhlciBhbmltYXRpb24gb24gdGhlIGdyYXBoIHRvIHN0b3Bcblx0XHRcdFx0Z3JhcGguYXR0cihhdHRyaWJzKTtcblx0XHRcdFx0d2hpbGUgKHNlcmllc1snem9uZUdyYXBoJyArIGldKSB7XG5cdFx0XHRcdFx0c2VyaWVzWyd6b25lR3JhcGgnICsgaV0uYXR0cihhdHRyaWJzKTtcblx0XHRcdFx0XHRpID0gaSArIDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZ3JhcGhcblx0ICpcblx0ICogQHBhcmFtIHZpcyB7Qm9vbGVhbn0gVHJ1ZSB0byBzaG93IHRoZSBzZXJpZXMsIGZhbHNlIHRvIGhpZGUuIElmIFVOREVGSU5FRCxcblx0ICpcdFx0XHRcdHRoZSB2aXNpYmlsaXR5IGlzIHRvZ2dsZWQuXG5cdCAqL1xuXHRzZXRWaXNpYmxlOiBmdW5jdGlvbiAodmlzLCByZWRyYXcpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0bGVnZW5kSXRlbSA9IHNlcmllcy5sZWdlbmRJdGVtLFxuXHRcdFx0c2hvd09ySGlkZSxcblx0XHRcdGlnbm9yZUhpZGRlblNlcmllcyA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzLFxuXHRcdFx0b2xkVmlzaWJpbGl0eSA9IHNlcmllcy52aXNpYmxlO1xuXG5cdFx0Ly8gaWYgY2FsbGVkIHdpdGhvdXQgYW4gYXJndW1lbnQsIHRvZ2dsZSB2aXNpYmlsaXR5XG5cdFx0c2VyaWVzLnZpc2libGUgPSB2aXMgPSBzZXJpZXMudXNlck9wdGlvbnMudmlzaWJsZSA9IHZpcyA9PT0gVU5ERUZJTkVEID8gIW9sZFZpc2liaWxpdHkgOiB2aXM7XG5cdFx0c2hvd09ySGlkZSA9IHZpcyA/ICdzaG93JyA6ICdoaWRlJztcblxuXHRcdC8vIHNob3cgb3IgaGlkZSBlbGVtZW50c1xuXHRcdGVhY2goWydncm91cCcsICdkYXRhTGFiZWxzR3JvdXAnLCAnbWFya2VyR3JvdXAnLCAndHJhY2tlciddLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAoc2VyaWVzW2tleV0pIHtcblx0XHRcdFx0c2VyaWVzW2tleV1bc2hvd09ySGlkZV0oKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXG5cdFx0Ly8gaGlkZSB0b29sdGlwICgjMTM2MSlcblx0XHRpZiAoY2hhcnQuaG92ZXJTZXJpZXMgPT09IHNlcmllcyB8fCAoY2hhcnQuaG92ZXJQb2ludCAmJiBjaGFydC5ob3ZlclBvaW50LnNlcmllcykgPT09IHNlcmllcykge1xuXHRcdFx0c2VyaWVzLm9uTW91c2VPdXQoKTtcblx0XHR9XG5cblxuXHRcdGlmIChsZWdlbmRJdGVtKSB7XG5cdFx0XHRjaGFydC5sZWdlbmQuY29sb3JpemVJdGVtKHNlcmllcywgdmlzKTtcblx0XHR9XG5cblxuXHRcdC8vIHJlc2NhbGUgb3IgYWRhcHQgdG8gcmVzaXplZCBjaGFydFxuXHRcdHNlcmllcy5pc0RpcnR5ID0gdHJ1ZTtcblx0XHQvLyBpbiBhIHN0YWNrLCBhbGwgb3RoZXIgc2VyaWVzIGFyZSBhZmZlY3RlZFxuXHRcdGlmIChzZXJpZXMub3B0aW9ucy5zdGFja2luZykge1xuXHRcdFx0ZWFjaChjaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChvdGhlclNlcmllcykge1xuXHRcdFx0XHRpZiAob3RoZXJTZXJpZXMub3B0aW9ucy5zdGFja2luZyAmJiBvdGhlclNlcmllcy52aXNpYmxlKSB7XG5cdFx0XHRcdFx0b3RoZXJTZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIHNob3cgb3IgaGlkZSBsaW5rZWQgc2VyaWVzXG5cdFx0ZWFjaChzZXJpZXMubGlua2VkU2VyaWVzLCBmdW5jdGlvbiAob3RoZXJTZXJpZXMpIHtcblx0XHRcdG90aGVyU2VyaWVzLnNldFZpc2libGUodmlzLCBmYWxzZSk7XG5cdFx0fSk7XG5cblx0XHRpZiAoaWdub3JlSGlkZGVuU2VyaWVzKSB7XG5cdFx0XHRjaGFydC5pc0RpcnR5Qm94ID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKHJlZHJhdyAhPT0gZmFsc2UpIHtcblx0XHRcdGNoYXJ0LnJlZHJhdygpO1xuXHRcdH1cblxuXHRcdGZpcmVFdmVudChzZXJpZXMsIHNob3dPckhpZGUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTaG93IHRoZSBncmFwaFxuXHQgKi9cblx0c2hvdzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2V0VmlzaWJsZSh0cnVlKTtcblx0fSxcblxuXHQvKipcblx0ICogSGlkZSB0aGUgZ3JhcGhcblx0ICovXG5cdGhpZGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNldFZpc2libGUoZmFsc2UpO1xuXHR9LFxuXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgdGhlIGdyYXBoXG5cdCAqXG5cdCAqIEBwYXJhbSBzZWxlY3RlZCB7Qm9vbGVhbn0gVHJ1ZSB0byBzZWxlY3QgdGhlIHNlcmllcywgZmFsc2UgdG8gdW5zZWxlY3QuIElmXG5cdCAqXHRcdFx0XHRVTkRFRklORUQsIHRoZSBzZWxlY3Rpb24gc3RhdGUgaXMgdG9nZ2xlZC5cblx0ICovXG5cdHNlbGVjdDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXM7XG5cdFx0Ly8gaWYgY2FsbGVkIHdpdGhvdXQgYW4gYXJndW1lbnQsIHRvZ2dsZVxuXHRcdHNlcmllcy5zZWxlY3RlZCA9IHNlbGVjdGVkID0gKHNlbGVjdGVkID09PSBVTkRFRklORUQpID8gIXNlcmllcy5zZWxlY3RlZCA6IHNlbGVjdGVkO1xuXG5cdFx0aWYgKHNlcmllcy5jaGVja2JveCkge1xuXHRcdFx0c2VyaWVzLmNoZWNrYm94LmNoZWNrZWQgPSBzZWxlY3RlZDtcblx0XHR9XG5cblx0XHRmaXJlRXZlbnQoc2VyaWVzLCBzZWxlY3RlZCA/ICdzZWxlY3QnIDogJ3Vuc2VsZWN0Jyk7XG5cdH0sXG5cblx0ZHJhd1RyYWNrZXI6IFRyYWNrZXJNaXhpbi5kcmF3VHJhY2tlckdyYXBoXG59KTtcbi8vIGdsb2JhbCB2YXJpYWJsZXNcbmV4dGVuZChIaWdoY2hhcnRzLCB7XG5cdFxuXHQvLyBDb25zdHJ1Y3RvcnNcblx0Q29sb3I6IENvbG9yLFxuXHRQb2ludDogUG9pbnQsXG5cdFRpY2s6IFRpY2ssXHRcblx0UmVuZGVyZXI6IFJlbmRlcmVyLFxuXHRTVkdFbGVtZW50OiBTVkdFbGVtZW50LFxuXHRTVkdSZW5kZXJlcjogU1ZHUmVuZGVyZXIsXG5cdFxuXHQvLyBWYXJpb3VzXG5cdGFycmF5TWluOiBhcnJheU1pbixcblx0YXJyYXlNYXg6IGFycmF5TWF4LFxuXHRjaGFydHM6IGNoYXJ0cyxcblx0ZGF0ZUZvcm1hdDogZGF0ZUZvcm1hdCxcblx0ZXJyb3I6IGVycm9yLFxuXHRmb3JtYXQ6IGZvcm1hdCxcblx0cGF0aEFuaW06IHBhdGhBbmltLFxuXHRnZXRPcHRpb25zOiBnZXRPcHRpb25zLFxuXHRoYXNCaWRpQnVnOiBoYXNCaWRpQnVnLFxuXHRpc1RvdWNoRGV2aWNlOiBpc1RvdWNoRGV2aWNlLFxuXHRzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuXHRhZGRFdmVudDogYWRkRXZlbnQsXG5cdHJlbW92ZUV2ZW50OiByZW1vdmVFdmVudCxcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcblx0ZGlzY2FyZEVsZW1lbnQ6IGRpc2NhcmRFbGVtZW50LFxuXHRjc3M6IGNzcyxcblx0ZWFjaDogZWFjaCxcblx0bWFwOiBtYXAsXG5cdG1lcmdlOiBtZXJnZSxcblx0c3BsYXQ6IHNwbGF0LFxuXHRleHRlbmRDbGFzczogZXh0ZW5kQ2xhc3MsXG5cdHBJbnQ6IHBJbnQsXG5cdHN2ZzogaGFzU1ZHLFxuXHRjYW52YXM6IHVzZUNhblZHLFxuXHR2bWw6ICFoYXNTVkcgJiYgIXVzZUNhblZHLFxuXHRwcm9kdWN0OiBQUk9EVUNULFxuXHR2ZXJzaW9uOiBWRVJTSU9OXG59KTtcblxufSgpKTtcbjtcblxubW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuSGlnaGNoYXJ0czsiLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjIuMS40XG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMDUsIDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNS0wNC0yOFQxNjowMVpcbiAqL1xuXG4oZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDE4K1xuLy8gQ2FuJ3QgYmUgaW4gc3RyaWN0IG1vZGUsIHNldmVyYWwgbGlicyBpbmNsdWRpbmcgQVNQLk5FVCB0cmFjZVxuLy8gdGhlIHN0YWNrIHZpYSBhcmd1bWVudHMuY2FsbGVyLmNhbGxlZSBhbmQgRmlyZWZveCBkaWVzIGlmXG4vLyB5b3UgdHJ5IHRvIHRyYWNlIHRocm91Z2ggXCJ1c2Ugc3RyaWN0XCIgY2FsbCBjaGFpbnMuICgjMTMzMzUpXG4vL1xuXG52YXIgYXJyID0gW107XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxudmFyXG5cdC8vIFVzZSB0aGUgY29ycmVjdCBkb2N1bWVudCBhY2NvcmRpbmdseSB3aXRoIHdpbmRvdyBhcmd1bWVudCAoc2FuZGJveClcblx0ZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXG5cblx0dmVyc2lvbiA9IFwiMi4xLjRcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFtcXGRhLXpdKS9naSxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiXCIsXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gIT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdFx0c2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHQvLyAoWW91IGNhbiBzZWVkIHRoZSBhcmd1bWVudHMgd2l0aCBhbiBhcnJheSBvZiBhcmdzLCBidXQgdGhpcyBpc1xuXHQvLyBvbmx5IHVzZWQgaW50ZXJuYWxseS4pXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjaywgYXJncyApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrLCBhcmdzICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9KSk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1tqXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcihudWxsKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkge1xuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoY29weSkpICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0Ly8gYWRkaW5nIDEgY29ycmVjdHMgbG9zcyBvZiBwcmVjaXNpb24gZnJvbSBwYXJzZUZsb2F0ICgjMTUxMDApXG5cdFx0cmV0dXJuICFqUXVlcnkuaXNBcnJheSggb2JqICkgJiYgKG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICsgMSkgPj0gMDtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8vIE5vdCBwbGFpbiBvYmplY3RzOlxuXHRcdC8vIC0gQW55IG9iamVjdCBvciB2YWx1ZSB3aG9zZSBpbnRlcm5hbCBbW0NsYXNzXV0gcHJvcGVydHkgaXMgbm90IFwiW29iamVjdCBPYmplY3RdXCJcblx0XHQvLyAtIERPTSBub2Rlc1xuXHRcdC8vIC0gd2luZG93XG5cdFx0aWYgKCBqUXVlcnkudHlwZSggb2JqICkgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCBvYmouY29uc3RydWN0b3IgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgcmV0dXJuZWQgYWxyZWFkeSwgd2UncmUgY29uZmlkZW50IHRoYXRcblx0XHQvLyB8b2JqfCBpcyBhIHBsYWluIG9iamVjdCwgY3JlYXRlZCBieSB7fSBvciBjb25zdHJ1Y3RlZCB3aXRoIG5ldyBPYmplY3Rcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjAsIGlPUzw2IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwob2JqKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHR2YXIgc2NyaXB0LFxuXHRcdFx0aW5kaXJlY3QgPSBldmFsO1xuXG5cdFx0Y29kZSA9IGpRdWVyeS50cmltKCBjb2RlICk7XG5cblx0XHRpZiAoIGNvZGUgKSB7XG5cdFx0XHQvLyBJZiB0aGUgY29kZSBpbmNsdWRlcyBhIHZhbGlkLCBwcm9sb2d1ZSBwb3NpdGlvblxuXHRcdFx0Ly8gc3RyaWN0IG1vZGUgcHJhZ21hLCBleGVjdXRlIGNvZGUgYnkgaW5qZWN0aW5nIGFcblx0XHRcdC8vIHNjcmlwdCB0YWcgaW50byB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpZiAoIGNvZGUuaW5kZXhPZihcInVzZSBzdHJpY3RcIikgPT09IDEgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cdFx0XHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBhdm9pZCB0aGUgRE9NIG5vZGUgY3JlYXRpb24sIGluc2VydGlvblxuXHRcdFx0Ly8gYW5kIHJlbW92YWwgYnkgdXNpbmcgYW4gaW5kaXJlY3QgZ2xvYmFsIGV2YWxcblx0XHRcdFx0aW5kaXJlY3QoIGNvZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHQvLyBhcmdzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aCxcblx0XHRcdGlzQXJyYXkgPSBpc0FycmF5bGlrZSggb2JqICk7XG5cblx0XHRpZiAoIGFyZ3MgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suYXBwbHkoIG9ialsgaSBdLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseSggb2JqWyBpIF0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBIHNwZWNpYWwsIGZhc3QsIGNhc2UgZm9yIHRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgZWFjaFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5bGlrZSggT2JqZWN0KGFycikgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0aXNBcnJheSA9IGlzQXJyYXlsaWtlKCBlbGVtcyApLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0pO1xuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oaSwgbmFtZSkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0pO1xuXG5mdW5jdGlvbiBpc0FycmF5bGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IGlPUyA4LjIgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIG9iai5ub2RlVHlwZSA9PT0gMSAmJiBsZW5ndGggKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMi4wLXByZVxuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE0LTEyLTE2XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBHZW5lcmFsLXB1cnBvc2UgY29uc3RhbnRzXG5cdE1BWF9ORUdBVElWRSA9IDEgPDwgMzEsXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHA6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIFdoaXRlc3BhY2UgY2hhcmFjdGVycyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jY2hhcmFjdGVyc1xuXHRjaGFyYWN0ZXJFbmNvZGluZyA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gTG9vc2VseSBtb2RlbGVkIG9uIENTUyBpZGVudGlmaWVyIGNoYXJhY3RlcnNcblx0Ly8gQW4gdW5xdW90ZWQgdmFsdWUgc2hvdWxkIGJlIGEgQ1NTIGlkZW50aWZpZXIgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0Ly8gUHJvcGVyIHN5bnRheDogaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3I1wiICksXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcucmVwbGFjZSggXCJ3XCIsIFwidypcIiApICsgXCIpXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cdHJlc2NhcGUgPSAvJ3xcXFxcL2csXG5cblx0Ly8gQ1NTIGVzY2FwZXMgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9O1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtYXRjaCwgZWxlbSwgbSwgbm9kZVR5cGUsXG5cdFx0Ly8gUVNBIHZhcnNcblx0XHRpLCBncm91cHMsIG9sZCwgbmlkLCBuZXdDb250ZXh0LCBuZXdTZWxlY3RvcjtcblxuXHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblxuXHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cdG5vZGVUeXBlID0gY29udGV4dC5ub2RlVHlwZTtcblxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdGlmICggIXNlZWQgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIHdoZW4gcG9zc2libGUgKGUuZy4sIG5vdCB1bmRlciBEb2N1bWVudEZyYWdtZW50KVxuXHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiI0lEXCIpXG5cdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICk7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50IChqUXVlcnkgIzY5NjMpXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSwgT3BlcmEsIGFuZCBXZWJraXQgcmV0dXJuIGl0ZW1zXG5cdFx0XHRcdFx0XHQvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQ29udGV4dCBpcyBub3QgYSBkb2N1bWVudFxuXHRcdFx0XHRcdGlmICggY29udGV4dC5vd25lckRvY3VtZW50ICYmIChlbGVtID0gY29udGV4dC5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiVEFHXCIpXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcIi5DTEFTU1wiKVxuXHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBRU0EgcGF0aFxuXHRcdGlmICggc3VwcG9ydC5xc2EgJiYgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblx0XHRcdG5pZCA9IG9sZCA9IGV4cGFuZG87XG5cdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdG5ld1NlbGVjdG9yID0gbm9kZVR5cGUgIT09IDEgJiYgc2VsZWN0b3I7XG5cblx0XHRcdC8vIHFTQSB3b3JrcyBzdHJhbmdlbHkgb24gRWxlbWVudC1yb290ZWQgcXVlcmllc1xuXHRcdFx0Ly8gV2UgY2FuIHdvcmsgYXJvdW5kIHRoaXMgYnkgc3BlY2lmeWluZyBhbiBleHRyYSBJRCBvbiB0aGUgcm9vdFxuXHRcdFx0Ly8gYW5kIHdvcmtpbmcgdXAgZnJvbSB0aGVyZSAoVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoZSB0ZWNobmlxdWUpXG5cdFx0XHQvLyBJRSA4IGRvZXNuJ3Qgd29yayBvbiBvYmplY3QgZWxlbWVudHNcblx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiYgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblxuXHRcdFx0XHRpZiAoIChvbGQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpKSApIHtcblx0XHRcdFx0XHRuaWQgPSBvbGQucmVwbGFjZSggcmVzY2FwZSwgXCJcXFxcJCZcIiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIG5pZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5pZCA9IFwiW2lkPSdcIiArIG5pZCArIFwiJ10gXCI7XG5cblx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGdyb3Vwc1tpXSA9IG5pZCArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0O1xuXHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKFwiLFwiKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaChxc2FFcnJvcikge1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggIW9sZCApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbihzdHJpbmcsIE9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZGl2IGFuZCBleHBlY3RzIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZGl2ICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBkaXYucGFyZW50Tm9kZSApIHtcblx0XHRcdGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBkaXYgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRkaXYgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGF0dHJzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHQoIH5iLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApIC1cblx0XHRcdCggfmEuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICk7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHBhcmVudCxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gSWYgbm8gZG9jdW1lbnQgYW5kIGRvY3VtZW50RWxlbWVudCBpcyBhdmFpbGFibGUsIHJldHVyblxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFNldCBvdXIgZG9jdW1lbnRcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRwYXJlbnQgPSBkb2MuZGVmYXVsdFZpZXc7XG5cblx0Ly8gU3VwcG9ydDogSUU+OFxuXHQvLyBJZiBpZnJhbWUgZG9jdW1lbnQgaXMgYXNzaWduZWQgdG8gXCJkb2N1bWVudFwiIHZhcmlhYmxlIGFuZCBpZiBpZnJhbWUgaGFzIGJlZW4gcmVsb2FkZWQsXG5cdC8vIElFIHdpbGwgdGhyb3cgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gYWNjZXNzaW5nIFwiZG9jdW1lbnRcIiB2YXJpYWJsZSwgc2VlIGpRdWVyeSAjMTM5MzZcblx0Ly8gSUU2LTggZG8gbm90IHN1cHBvcnQgdGhlIGRlZmF1bHRWaWV3IHByb3BlcnR5IHNvIHBhcmVudCB3aWxsIGJlIHVuZGVmaW5lZFxuXHRpZiAoIHBhcmVudCAmJiBwYXJlbnQgIT09IHBhcmVudC50b3AgKSB7XG5cdFx0Ly8gSUUxMSBkb2VzIG5vdCBoYXZlIGF0dGFjaEV2ZW50LCBzbyBhbGwgbXVzdCBzdWZmZXJcblx0XHRpZiAoIHBhcmVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0cGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cdFx0fSBlbHNlIGlmICggcGFyZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0cGFyZW50LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBTdXBwb3J0IHRlc3RzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvYyApO1xuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFkaXYuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2MuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvYy5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmluZCBhbmQgZmlsdGVyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG5cdFx0XHRcdHJldHVybiBtICYmIG0ucGFyZW50Tm9kZSA/IFsgbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvYy5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcZl0nIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjIrLCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuNytcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2MuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZGl2LCBcImRpdlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZGl2LCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IGRvZXMgbm90IGltcGxlbWVudCBpbmNsdXNpdmUgZGVzY2VuZGVudFxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2MgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2MgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvYyA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jO1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBkaWZmLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IHBhcmVudFsgZXhwYW5kbyBdIHx8IChwYXJlbnRbIGV4cGFuZG8gXSA9IHt9KTtcblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMl07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdXNlQ2FjaGUgJiYgKGNhY2hlID0gKGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pKVsgdHlwZSBdKSAmJiBjYWNoZVswXSA9PT0gZGlycnVucyApIHtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IGNhY2hlWzFdO1xuXG5cdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSApICYmICsrZGlmZiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdChub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KSlbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRcImRpc2FibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGRpciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblx0XHRcdFx0XHRcdGlmICggKG9sZENhY2hlID0gb3V0ZXJDYWNoZVsgZGlyIF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIGRpciBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCAhPT0gZG9jdW1lbnQgJiYgY29udGV4dDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIEtlZXAgYGlgIGEgc3RyaW5nIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyBzbyBgbWF0Y2hlZENvdW50YCB3aWxsIGJlIFwiMDBcIiBiZWxvd1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgbm8gc2VlZCBhbmQgb25seSBvbmUgZ3JvdXBcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBUYWtlIGEgc2hvcnRjdXQgYW5kIHNldCB0aGUgY29udGV4dCBpZiB0aGUgcm9vdCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdHN1cHBvcnQuZ2V0QnlJZCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0XHRcdEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZGl2MSApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBkaXYxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZGl2LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0cmV0dXJuIGRpdi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xualF1ZXJ5LmV4cHJbXCI6XCJdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoL148KFxcdyspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9KTtcblxuXHR9XG5cblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0pO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+PSAwICkgIT09IG5vdDtcblx0fSk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXSA6XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0pKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG5cdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59KTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSopKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbMF0gPT09IFwiPFwiICYmIHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmIHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKG1hdGNoWzFdIHx8ICFjb250ZXh0KSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsxXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbMF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsxXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsxXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsyXSApO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQmxhY2tiZXJyeSA0LjZcblx0XHRcdFx0XHQvLyBnRUJJRCByZXR1cm5zIG5vZGVzIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKCM2OTYzKVxuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdFx0dGhpc1swXSA9IGVsZW07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290alF1ZXJ5ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gdGhpc1swXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHJvb3RqUXVlcnkucmVhZHkgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRyb290alF1ZXJ5LnJlYWR5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0ZGlyOiBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fSxcblxuXHRzaWJsaW5nOiBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdFx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1tpXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHRwb3MgPSBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApIHx8IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRmb3IgKCBjdXIgPSB0aGlzW2ldOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKHBvcyA/XG5cdFx0XHRcdFx0cG9zLmluZGV4KGN1cikgPiAtMSA6XG5cblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykpICkge1xuXG5cdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZSggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlKFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoc2VsZWN0b3IpXG5cdFx0KTtcblx0fVxufSk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoIChjdXIgPSBjdXJbZGlyXSkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goe1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuc2libGluZyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgalF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWUoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59KTtcbnZhciBybm90d2hpdGUgPSAoL1xcUysvZyk7XG5cblxuXG4vLyBTdHJpbmcgdG8gT2JqZWN0IG9wdGlvbnMgZm9ybWF0IGNhY2hlXG52YXIgb3B0aW9uc0NhY2hlID0ge307XG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzIGFuZCBzdG9yZSBpbiBjYWNoZVxuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IG9wdGlvbnNDYWNoZVsgb3B0aW9ucyBdID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9KTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHQoIG9wdGlvbnNDYWNoZVsgb3B0aW9ucyBdIHx8IGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBMYXN0IGZpcmUgdmFsdWUgKGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHMpXG5cdFx0bWVtb3J5LFxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblx0XHQvLyBGaXJzdCBjYWxsYmFjayB0byBmaXJlICh1c2VkIGludGVybmFsbHkgYnkgYWRkIGFuZCBmaXJlV2l0aClcblx0XHRmaXJpbmdTdGFydCxcblx0XHQvLyBFbmQgb2YgdGhlIGxvb3Agd2hlbiBmaXJpbmdcblx0XHRmaXJpbmdMZW5ndGgsXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgcmVtb3ZlIGlmIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCxcblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblx0XHQvLyBTdGFjayBvZiBmaXJlIGNhbGxzIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0c3RhY2sgPSAhb3B0aW9ucy5vbmNlICYmIFtdLFxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0bWVtb3J5ID0gb3B0aW9ucy5tZW1vcnkgJiYgZGF0YTtcblx0XHRcdGZpcmVkID0gdHJ1ZTtcblx0XHRcdGZpcmluZ0luZGV4ID0gZmlyaW5nU3RhcnQgfHwgMDtcblx0XHRcdGZpcmluZ1N0YXJ0ID0gMDtcblx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0ZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgbGlzdCAmJiBmaXJpbmdJbmRleCA8IGZpcmluZ0xlbmd0aDsgZmlyaW5nSW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBkYXRhWyAwIF0sIGRhdGFbIDEgXSApID09PSBmYWxzZSAmJiBvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlOyAvLyBUbyBwcmV2ZW50IGZ1cnRoZXIgY2FsbHMgdXNpbmcgYWRkXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRpZiAoIHN0YWNrICkge1xuXHRcdFx0XHRcdGlmICggc3RhY2subGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0ZmlyZSggc3RhY2suc2hpZnQoKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmRpc2FibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdC8vIEZpcnN0LCB3ZSBzYXZlIHRoZSBjdXJyZW50IGxlbmd0aFxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdChmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggYXJnICk7XG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSkoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdC8vIERvIHdlIG5lZWQgdG8gYWRkIHRoZSBjYWxsYmFja3MgdG8gdGhlXG5cdFx0XHRcdFx0Ly8gY3VycmVudCBmaXJpbmcgYmF0Y2g/XG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHQvLyBXaXRoIG1lbW9yeSwgaWYgd2UncmUgbm90IGZpcmluZyB0aGVuXG5cdFx0XHRcdFx0Ly8gd2Ugc2hvdWxkIGNhbGwgcmlnaHQgYXdheVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRcdGZpcmluZ1N0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRmaXJlKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0xlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aC0tO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID8galF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6ICEhKCBsaXN0ICYmIGxpc3QubGVuZ3RoICk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdGZpcmluZ0xlbmd0aCA9IDA7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIEhhdmUgdGhlIGxpc3QgZG8gbm90aGluZyBhbnltb3JlXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bGlzdCA9IHN0YWNrID0gbWVtb3J5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBJcyBpdCBkaXNhYmxlZD9cblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblx0XHRcdC8vIExvY2sgdGhlIGxpc3QgaW4gaXRzIGN1cnJlbnQgc3RhdGVcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzdGFjayA9IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICkge1xuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIElzIGl0IGxvY2tlZD9cblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhc3RhY2s7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoIGxpc3QgJiYgKCAhZmlyZWQgfHwgc3RhY2sgKSApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdGlmICggZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0c3RhY2sucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmaXJlKCBhcmdzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGxpc3RlbmVyIGxpc3QsIGZpbmFsIHN0YXRlXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVqZWN0ZWRcIiBdLFxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm1lbW9yeVwiKSBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyBpIF0gKSAmJiBmbnNbIGkgXTtcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsxXSBdKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBwcm9taXNlID8gbmV3RGVmZXIucHJvbWlzZSgpIDogdGhpcywgZm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0pLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRwcm9taXNlLnBpcGUgPSBwcm9taXNlLnRoZW47XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cblx0XHRcdC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsxXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gc3RhdGUgPSBbIHJlc29sdmVkIHwgcmVqZWN0ZWQgXVxuXHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cblx0XHRcdFx0Ly8gWyByZWplY3RfbGlzdCB8IHJlc29sdmVfbGlzdCBdLmRpc2FibGU7IHByb2dyZXNzX2xpc3QubG9ja1xuXHRcdFx0XHR9LCB0dXBsZXNbIGkgXiAxIF1bIDIgXS5kaXNhYmxlLCB0dXBsZXNbIDIgXVsgMiBdLmxvY2sgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVmZXJyZWRbIHJlc29sdmUgfCByZWplY3QgfCBub3RpZnkgXVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdGRlZmVycmVkWyB0dXBsZVswXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0pO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcblxuXHRcdFx0Ly8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8ICggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZC4gSWYgcmVzb2x2ZVZhbHVlcyBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgRGVmZXJyZWQsIGp1c3QgdXNlIHRoYXQuXG5cdFx0XHRkZWZlcnJlZCA9IHJlbWFpbmluZyA9PT0gMSA/IHN1Ym9yZGluYXRlIDogalF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIFVwZGF0ZSBmdW5jdGlvbiBmb3IgYm90aCByZXNvbHZlIGFuZCBwcm9ncmVzcyB2YWx1ZXNcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSwgY29udGV4dHMsIHZhbHVlcyApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRjb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHR2YWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoIHZhbHVlcyA9PT0gcHJvZ3Jlc3NWYWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMsIHByb2dyZXNzQ29udGV4dHMsIHJlc29sdmVDb250ZXh0cztcblxuXHRcdC8vIEFkZCBsaXN0ZW5lcnMgdG8gRGVmZXJyZWQgc3Vib3JkaW5hdGVzOyB0cmVhdCBvdGhlcnMgYXMgcmVzb2x2ZWRcblx0XHRpZiAoIGxlbmd0aCA+IDEgKSB7XG5cdFx0XHRwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRwcm9ncmVzc0NvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0LmRvbmUoIHVwZGF0ZUZ1bmMoIGksIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApIClcblx0XHRcdFx0XHRcdC5mYWlsKCBkZWZlcnJlZC5yZWplY3QgKVxuXHRcdFx0XHRcdFx0LnByb2dyZXNzKCB1cGRhdGVGdW5jKCBpLCBwcm9ncmVzc0NvbnRleHRzLCBwcm9ncmVzc1ZhbHVlcyApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LS1yZW1haW5pbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZyBvbiBhbnl0aGluZywgcmVzb2x2ZSB0aGUgbWFzdGVyXG5cdFx0aWYgKCAhcmVtYWluaW5nICkge1xuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdH1cbn0pO1xuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdDtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXHQvLyBBZGQgdGhlIGNhbGxiYWNrXG5cdGpRdWVyeS5yZWFkeS5wcm9taXNlKCkuZG9uZSggZm4gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cblx0XHQvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcblx0XHRpZiAoIGpRdWVyeS5mbi50cmlnZ2VySGFuZGxlciApIHtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS50cmlnZ2VySGFuZGxlciggXCJyZWFkeVwiICk7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkub2ZmKCBcInJlYWR5XCIgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vKipcbiAqIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG5qUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdGlmICggIXJlYWR5TGlzdCApIHtcblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG5cdFx0Ly8gV2Ugb25jZSB0cmllZCB0byB1c2UgcmVhZHlTdGF0ZSBcImludGVyYWN0aXZlXCIgaGVyZSwgYnV0IGl0IGNhdXNlZCBpc3N1ZXMgbGlrZSB0aGUgb25lXG5cdFx0Ly8gZGlzY292ZXJlZCBieSBDaHJpc1MgaGVyZTogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIyODIjY29tbWVudDoxNVxuXHRcdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiICkge1xuXHRcdFx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdFx0XHRzZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlYWR5TGlzdC5wcm9taXNlKCBvYmogKTtcbn07XG5cbi8vIEtpY2sgb2ZmIHRoZSBET00gcmVhZHkgY2hlY2sgZXZlbiBpZiB0aGUgdXNlciBkb2VzIG5vdFxualF1ZXJ5LnJlYWR5LnByb21pc2UoKTtcblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBqUXVlcnkuYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRqUXVlcnkuYWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVtpXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oIGVsZW1zW2ldLCBrZXksIHJhdyA/IHZhbHVlIDogdmFsdWUuY2FsbCggZWxlbXNbaV0sIGksIGZuKCBlbGVtc1tpXSwga2V5ICkgKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjaGFpbmFibGUgP1xuXHRcdGVsZW1zIDpcblxuXHRcdC8vIEdldHNcblx0XHRidWxrID9cblx0XHRcdGZuLmNhbGwoIGVsZW1zICkgOlxuXHRcdFx0bGVuID8gZm4oIGVsZW1zWzBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgY2FuIGhhdmUgZGF0YVxuICovXG5qUXVlcnkuYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdC8qIGpzaGludCAtVzAxOCAqL1xuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NCxcblx0Ly8gT2xkIFdlYktpdCBkb2VzIG5vdCBoYXZlIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucy9mcmVlemUgbWV0aG9kLFxuXHQvLyByZXR1cm4gbmV3IGVtcHR5IG9iamVjdCBpbnN0ZWFkIHdpdGggbm8gW1tzZXRdXSBhY2Nlc3NvclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMuY2FjaGUgPSB7fSwgMCwge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXHR9KTtcblxuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcbkRhdGEuYWNjZXB0cyA9IGpRdWVyeS5hY2NlcHREYXRhO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblx0a2V5OiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHQvLyBBbHdheXMgcmV0dXJuIHRoZSBrZXkgZm9yIGEgZnJvemVuIG9iamVjdC5cblx0XHRpZiAoICFEYXRhLmFjY2VwdHMoIG93bmVyICkgKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgZGVzY3JpcHRvciA9IHt9LFxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlIGtleVxuXHRcdFx0dW5sb2NrID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdW5sb2NrICkge1xuXHRcdFx0dW5sb2NrID0gRGF0YS51aWQrKztcblxuXHRcdFx0Ly8gU2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUsIG5vbi13cml0YWJsZSBwcm9wZXJ0eVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGVzY3JpcHRvclsgdGhpcy5leHBhbmRvIF0gPSB7IHZhbHVlOiB1bmxvY2sgfTtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG93bmVyLCBkZXNjcmlwdG9yICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NFxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gYSBsZXNzIHNlY3VyZSBkZWZpbml0aW9uXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0ZGVzY3JpcHRvclsgdGhpcy5leHBhbmRvIF0gPSB1bmxvY2s7XG5cdFx0XHRcdGpRdWVyeS5leHRlbmQoIG93bmVyLCBkZXNjcmlwdG9yICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRpZiAoICF0aGlzLmNhY2hlWyB1bmxvY2sgXSApIHtcblx0XHRcdHRoaXMuY2FjaGVbIHVubG9jayBdID0ge307XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVubG9jaztcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Ly8gVGhlcmUgbWF5IGJlIGFuIHVubG9jayBhc3NpZ25lZCB0byB0aGlzIG5vZGUsXG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBubyBlbnRyeSBmb3IgdGhpcyBcIm93bmVyXCIsIGNyZWF0ZSBvbmUgaW5saW5lXG5cdFx0XHQvLyBhbmQgc2V0IHRoZSB1bmxvY2sgYXMgdGhvdWdoIGFuIG93bmVyIGVudHJ5IGhhZCBhbHdheXMgZXhpc3RlZFxuXHRcdFx0dW5sb2NrID0gdGhpcy5rZXkoIG93bmVyICksXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGVbIHVubG9jayBdO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgZGF0YSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBGcmVzaCBhc3NpZ25tZW50cyBieSBvYmplY3QgYXJlIHNoYWxsb3cgY29waWVkXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLmNhY2hlWyB1bmxvY2sgXSwgZGF0YSApO1xuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGNhY2hlWyBwcm9wIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdC8vIEVpdGhlciBhIHZhbGlkIGNhY2hlIGlzIGZvdW5kLCBvciB3aWxsIGJlIGNyZWF0ZWQuXG5cdFx0Ly8gTmV3IGNhY2hlcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSB1bmxvY2sgcmV0dXJuZWQsXG5cdFx0Ly8gYWxsb3dpbmcgZGlyZWN0IGFjY2VzcyB0byB0aGUgbmV3bHkgY3JlYXRlZFxuXHRcdC8vIGVtcHR5IGRhdGEgb2JqZWN0LiBBIHZhbGlkIG93bmVyIG9iamVjdCBtdXN0IGJlIHByb3ZpZGVkLlxuXHRcdHZhciBjYWNoZSA9IHRoaXMuY2FjaGVbIHRoaXMua2V5KCBvd25lciApIF07XG5cblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0Y2FjaGUgOiBjYWNoZVsga2V5IF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBzdG9yZWQ7XG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KChrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgKSB7XG5cblx0XHRcdHN0b3JlZCA9IHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cblx0XHRcdHJldHVybiBzdG9yZWQgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHN0b3JlZCA6IHRoaXMuZ2V0KCBvd25lciwgalF1ZXJ5LmNhbWVsQ2FzZShrZXkpICk7XG5cdFx0fVxuXG5cdFx0Ly8gWypdV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLCBuYW1lLCBjYW1lbCxcblx0XHRcdHVubG9jayA9IHRoaXMua2V5KCBvd25lciApLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlWyB1bmxvY2sgXTtcblxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLmNhY2hlWyB1bmxvY2sgXSA9IHt9O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblx0XHRcdFx0Ly8gSWYgXCJuYW1lXCIgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXaGVuIGRhdGEgaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIHZpYSAoXCJrZXlcIiwgXCJ2YWxcIikgc2lnbmF0dXJlLFxuXHRcdFx0XHQvLyBrZXlzIHdpbGwgYmUgY29udmVydGVkIHRvIGNhbWVsQ2FzZS5cblx0XHRcdFx0Ly8gU2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIHRlbGwgX2hvd18gYSBrZXkgd2FzIGFkZGVkLCByZW1vdmVcblx0XHRcdFx0Ly8gYm90aCBwbGFpbiBrZXkgYW5kIGNhbWVsQ2FzZSBrZXkuICMxMjc4NlxuXHRcdFx0XHQvLyBUaGlzIHdpbGwgb25seSBwZW5hbGl6ZSB0aGUgYXJyYXkgYXJndW1lbnQgcGF0aC5cblx0XHRcdFx0bmFtZSA9IGtleS5jb25jYXQoIGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FtZWwgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblx0XHRcdFx0Ly8gVHJ5IHRoZSBzdHJpbmcgYXMgYSBrZXkgYmVmb3JlIGFueSBtYW5pcHVsYXRpb25cblx0XHRcdFx0aWYgKCBrZXkgaW4gY2FjaGUgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IFsga2V5LCBjYW1lbCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRcdG5hbWUgPSBjYW1lbDtcblx0XHRcdFx0XHRuYW1lID0gbmFtZSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0XHRbIG5hbWUgXSA6ICggbmFtZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBuYW1lWyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHRyZXR1cm4gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KFxuXHRcdFx0dGhpcy5jYWNoZVsgb3duZXJbIHRoaXMuZXhwYW5kbyBdIF0gfHwge31cblx0XHQpO1xuXHR9LFxuXHRkaXNjYXJkOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0aWYgKCBvd25lclsgdGhpcy5leHBhbmRvIF0gKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5jYWNoZVsgb3duZXJbIHRoaXMuZXhwYW5kbyBdIF07XG5cdFx0fVxuXHR9XG59O1xudmFyIGRhdGFfcHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhX3VzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gLyhbQS1aXSkvZztcblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQxXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcIm51bGxcIiA/IG51bGwgOlxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhX3VzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YV91c2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhX3ByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhX3VzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YV91c2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFfcHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhX3ByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMStcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoNSkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YV9wcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YV91c2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YSxcblx0XHRcdFx0Y2FtZWxLZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBhcy1pc1xuXHRcdFx0XHRkYXRhID0gZGF0YV91c2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgY2FtZWxpemVkXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtLCBjYW1lbEtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBjYW1lbEtleSwgdW5kZWZpbmVkICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBGaXJzdCwgYXR0ZW1wdCB0byBzdG9yZSBhIGNvcHkgb3IgcmVmZXJlbmNlIG9mIGFueVxuXHRcdFx0XHQvLyBkYXRhIHRoYXQgbWlnaHQndmUgYmVlbiBzdG9yZSB3aXRoIGEgY2FtZWxDYXNlZCBrZXkuXG5cdFx0XHRcdHZhciBkYXRhID0gZGF0YV91c2VyLmdldCggdGhpcywgY2FtZWxLZXkgKTtcblxuXHRcdFx0XHQvLyBGb3IgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZSBpbnRlcm9wLCB3ZSBoYXZlIHRvXG5cdFx0XHRcdC8vIHN0b3JlIHByb3BlcnR5IG5hbWVzIHdpdGggZGFzaGVzIGluIGEgY2FtZWxDYXNlIGZvcm0uXG5cdFx0XHRcdC8vIFRoaXMgbWlnaHQgbm90IGFwcGx5IHRvIGFsbCBwcm9wZXJ0aWVzLi4uKlxuXHRcdFx0XHRkYXRhX3VzZXIuc2V0KCB0aGlzLCBjYW1lbEtleSwgdmFsdWUgKTtcblxuXHRcdFx0XHQvLyAqLi4uIEluIHRoZSBjYXNlIG9mIHByb3BlcnRpZXMgdGhhdCBtaWdodCBfYWN0dWFsbHlfXG5cdFx0XHRcdC8vIGhhdmUgZGFzaGVzLCB3ZSBuZWVkIHRvIGFsc28gc3RvcmUgYSBjb3B5IG9mIHRoYXRcblx0XHRcdFx0Ly8gdW5jaGFuZ2VkIHByb3BlcnR5LlxuXHRcdFx0XHRpZiAoIGtleS5pbmRleE9mKFwiLVwiKSAhPT0gLTEgJiYgZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGRhdGFfdXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YV91c2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5leHRlbmQoe1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YV9wcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KGRhdGEpICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFfcHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKS5hZGQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0pXG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbMF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVswXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0pO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YV9wcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSk7XG52YXIgcG51bSA9ICgvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLykuc291cmNlO1xuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblx0XHQvLyBpc0hpZGRlbiBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIiB8fCAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0fTtcblxudmFyIHJjaGVja2FibGVUeXBlID0gKC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pKTtcblxuXG5cbihmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaTw9NS4xXG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmk8PTUuMSwgQW5kcm9pZDw0LjJcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59KSgpO1xudmFyIHN0cnVuZGVmaW5lZCA9IHR5cGVvZiB1bmRlZmluZWQ7XG5cblxuXG5zdXBwb3J0LmZvY3VzaW5CdWJibGVzID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnUpfGNsaWNrLyxcblx0cmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpJC87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFfcHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IHN0cnVuZGVmaW5lZCAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsyXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0pICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8IHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFfcHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YV9wcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsyXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbMl0gJiYgbmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fCBzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkZWxldGUgZWxlbURhdGEuaGFuZGxlO1xuXHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgXCJldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKFwiLlwiKSA+PSAwICkge1xuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXCIuXCIpO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoXCI6XCIpIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZV9yZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoIChjdXIgPSBldmVudFBhdGhbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFfcHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJiBkYXRhX3ByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgalF1ZXJ5LmFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICghc3BlY2lhbC5fZGVmYXVsdCB8fCBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UpICYmXG5cdFx0XHRcdGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFfcHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1swXSA9IGV2ZW50O1xuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0pICYmICFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50Lm5hbWVzcGFjZV9yZSB8fCBldmVudC5uYW1lc3BhY2VfcmUudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSkuaGFuZGxlIHx8IGhhbmRsZU9iai5oYW5kbGVyIClcblx0XHRcdFx0XHRcdFx0LmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChldmVudC5yZXN1bHQgPSByZXQpID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIG1hdGNoZXMsIHNlbCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxuXHRcdC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGJ1YmJsaW5nIGluIEZpcmVmb3ggKCMzODYxKVxuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJiBjdXIubm9kZVR5cGUgJiYgKCFldmVudC5idXR0b24gfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gW107XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+PSAwIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlcyB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdC8vIEluY2x1ZGVzIHNvbWUgZXZlbnQgcHJvcHMgc2hhcmVkIGJ5IEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50XG5cdHByb3BzOiBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGV2ZW50UGhhc2UgbWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFwiLnNwbGl0KFwiIFwiKSxcblxuXHRmaXhIb29rczoge30sXG5cblx0a2V5SG9va3M6IHtcblx0XHRwcm9wczogXCJjaGFyIGNoYXJDb2RlIGtleSBrZXlDb2RlXCIuc3BsaXQoXCIgXCIpLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gb3JpZ2luYWwuY2hhckNvZGUgIT0gbnVsbCA/IG9yaWdpbmFsLmNoYXJDb2RlIDogb3JpZ2luYWwua2V5Q29kZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRtb3VzZUhvb2tzOiB7XG5cdFx0cHJvcHM6IFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblx0XHRcdHZhciBldmVudERvYywgZG9jLCBib2R5LFxuXHRcdFx0XHRidXR0b24gPSBvcmlnaW5hbC5idXR0b247XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcblx0XHRcdGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0Ym9keSA9IGV2ZW50RG9jLmJvZHk7XG5cblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICsgKCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCApO1xuXHRcdFx0XHRldmVudC5wYWdlWSA9IG9yaWdpbmFsLmNsaWVudFkgKyAoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50VG9wICB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wICB8fCAwICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRcdC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XG5cdFx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSAoIGJ1dHRvbiAmIDEgPyAxIDogKCBidXR0b24gJiAyID8gMyA6ICggYnV0dG9uICYgNCA/IDIgOiAwICkgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIGEgd3JpdGFibGUgY29weSBvZiB0aGUgZXZlbnQgb2JqZWN0IGFuZCBub3JtYWxpemUgc29tZSBwcm9wZXJ0aWVzXG5cdFx0dmFyIGksIHByb3AsIGNvcHksXG5cdFx0XHR0eXBlID0gZXZlbnQudHlwZSxcblx0XHRcdG9yaWdpbmFsRXZlbnQgPSBldmVudCxcblx0XHRcdGZpeEhvb2sgPSB0aGlzLmZpeEhvb2tzWyB0eXBlIF07XG5cblx0XHRpZiAoICFmaXhIb29rICkge1xuXHRcdFx0dGhpcy5maXhIb29rc1sgdHlwZSBdID0gZml4SG9vayA9XG5cdFx0XHRcdHJtb3VzZUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMubW91c2VIb29rcyA6XG5cdFx0XHRcdHJrZXlFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLmtleUhvb2tzIDpcblx0XHRcdFx0e307XG5cdFx0fVxuXHRcdGNvcHkgPSBmaXhIb29rLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoIGZpeEhvb2sucHJvcHMgKSA6IHRoaXMucHJvcHM7XG5cblx0XHRldmVudCA9IG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblxuXHRcdGkgPSBjb3B5Lmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHByb3AgPSBjb3B5WyBpIF07XG5cdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ2luYWxFdmVudFsgcHJvcCBdO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IENvcmRvdmEgMi41IChXZWJLaXQpICgjMTMyNTUpXG5cdFx0Ly8gQWxsIGV2ZW50cyBzaG91bGQgaGF2ZSBhIHRhcmdldDsgQ29yZG92YSBkZXZpY2VyZWFkeSBkb2Vzbid0XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDYuMCssIENocm9tZTwyOFxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0aWYgKCBldmVudC50YXJnZXQubm9kZVR5cGUgPT09IDMgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZml4SG9vay5maWx0ZXIgPyBmaXhIb29rLmZpbHRlciggZXZlbnQsIG9yaWdpbmFsRXZlbnQgKSA6IGV2ZW50O1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50LCBidWJibGUgKSB7XG5cdFx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lLlxuXHRcdC8vIEZha2Ugb3JpZ2luYWxFdmVudCB0byBhdm9pZCBkb25vcidzIHN0b3BQcm9wYWdhdGlvbiwgYnV0IGlmIHRoZVxuXHRcdC8vIHNpbXVsYXRlZCBldmVudCBwcmV2ZW50cyBkZWZhdWx0IHRoZW4gd2UgZG8gdGhlIHNhbWUgb24gdGhlIGRvbm9yLlxuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZSxcblx0XHRcdFx0b3JpZ2luYWxFdmVudDoge31cblx0XHRcdH1cblx0XHQpO1xuXHRcdGlmICggYnViYmxlICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmNhbGwoIGVsZW0sIGUgKTtcblx0XHR9XG5cdFx0aWYgKCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlLCBmYWxzZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISh0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50KSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiBlLnN0b3BQcm9wYWdhdGlvbiApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gU3VwcG9ydDogQ2hyb21lIDE1K1xualF1ZXJ5LmVhY2goe1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkpICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBGaXJlZm94LCBDaHJvbWUsIFNhZmFyaVxuLy8gQ3JlYXRlIFwiYnViYmxpbmdcIiBmb2N1cyBhbmQgYmx1ciBldmVudHNcbmlmICggIXN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgKSB7XG5cdGpRdWVyeS5lYWNoKHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICksIHRydWUgKTtcblx0XHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIC8qSU5URVJOQUwqLyBvbmUgKSB7XG5cdFx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHRcdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub24oIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRcdG9yaWdGbiA9IGZuO1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fTtcblx0XHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdFx0fSk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6IGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0pO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSk7XG5cblxudmFyXG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6XSspW14+XSopXFwvPi9naSxcblx0cnRhZ05hbWUgPSAvPChbXFx3Ol0rKS8sXG5cdHJodG1sID0gLzx8JiM/XFx3KzsvLFxuXHRybm9Jbm5lcmh0bWwgPSAvPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLFxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZSA9IC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZyxcblxuXHQvLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxuXHR3cmFwTWFwID0ge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0XHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdFx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0XHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdFx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdFx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG5cdH07XG5cbi8vIFN1cHBvcnQ6IElFOVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbi8vIFN1cHBvcnQ6IDEueCBjb21wYXRpYmlsaXR5XG4vLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgP1xuXG5cdFx0ZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpWzBdIHx8XG5cdFx0XHRlbGVtLmFwcGVuZENoaWxkKCBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpICkgOlxuXHRcdGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9IChlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikgIT09IG51bGwpICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFfcHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLCBcImdsb2JhbEV2YWxcIiwgIXJlZkVsZW1lbnRzIHx8IGRhdGFfcHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFfcHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFfcHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YV9wcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YV91c2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YV91c2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFfdXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cdHZhciByZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lID8gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0Y29udGV4dC5xdWVyeVNlbGVjdG9yQWxsID8gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRbXTtcblxuXHRyZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgP1xuXHRcdGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApIDpcblx0XHRyZXQ7XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHA6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0YnVpbGRGcmFnbWVudDogZnVuY3Rpb24oIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24gKSB7XG5cdFx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0XHRub2RlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0XHRpZiAoIGpRdWVyeS50eXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXQsIFBoYW50b21KU1xuXHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKTtcblxuXHRcdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgZWxlbS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0LCBQaGFudG9tSlNcblx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRcdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKGVsZW0gPSBub2Rlc1sgaSsrIF0pICkge1xuXG5cdFx0XHQvLyAjNDA4NyAtIElmIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gZWxlbWVudHMgYXJlIHRoZSBzYW1lLCBhbmQgdGhpcyBpc1xuXHRcdFx0Ly8gdGhhdCBlbGVtZW50LCBkbyBub3QgZG8gYW55dGhpbmdcblx0XHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSAhPT0gLTEgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gdG1wWyBqKysgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZyYWdtZW50O1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLCBrZXksXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSBlbGVtc1sgaSBdKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGtleSA9IGVsZW1bIGRhdGFfcHJpdi5leHBhbmRvIF07XG5cblx0XHRcdFx0aWYgKCBrZXkgJiYgKGRhdGEgPSBkYXRhX3ByaXYuY2FjaGVbIGtleSBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBkYXRhX3ByaXYuY2FjaGVbIGtleSBdICkge1xuXHRcdFx0XHRcdFx0Ly8gRGlzY2FyZCBhbnkgcmVtYWluaW5nIGBwcml2YXRlYCBkYXRhXG5cdFx0XHRcdFx0XHRkZWxldGUgZGF0YV9wcml2LmNhY2hlWyBrZXkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIERpc2NhcmQgYW55IHJlbWFpbmluZyBgdXNlcmAgZGF0YVxuXHRcdFx0ZGVsZXRlIGRhdGFfdXNlci5jYWNoZVsgZWxlbVsgZGF0YV91c2VyLmV4cGFuZG8gXSBdO1xuXHRcdH1cblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3Rvciwga2VlcERhdGEgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRlbGVtcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHRoaXMgKSA6IHRoaXMsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCAha2VlcERhdGEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtICkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9KTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJnID0gYXJndW1lbnRzWyAwIF07XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHR0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0YXJnID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXG5cdFx0XHRpZiAoIGFyZyApIHtcblx0XHRcdFx0YXJnLnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRm9yY2UgcmVtb3ZhbCBpZiB0aGVyZSB3YXMgbm8gbmV3IGNvbnRlbnQgKGUuZy4sIGZyb20gZW1wdHkgYXJndW1lbnRzKVxuXHRcdHJldHVybiBhcmcgJiYgKGFyZy5sZW5ndGggfHwgYXJnLm5vZGVUeXBlKSA/IHRoaXMgOiB0aGlzLnJlbW92ZSgpO1xuXHR9LFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZSggc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRkb21NYW5pcDogZnVuY3Rpb24oIGFyZ3MsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0XHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNldCA9IHRoaXMsXG5cdFx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0XHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHNldC5lcSggaW5kZXggKTtcblx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuZG9tTWFuaXAoIGFyZ3MsIGNhbGxiYWNrICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIGwgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBhcmdzLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIHRoaXMgKTtcblx0XHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmaXJzdCApIHtcblx0XHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbSBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXRcblx0XHRcdFx0XHRcdFx0Ly8galF1ZXJ5Lm1lcmdlIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCggdGhpc1sgaSBdLCBub2RlLCBpICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHRcdCFkYXRhX3ByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmIGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaCh7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0pO1xuXG5cbnZhciBpZnJhbWUsXG5cdGVsZW1kaXNwbGF5ID0ge307XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGFjdHVhbCBkaXNwbGF5IG9mIGEgZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbm9kZU5hbWUgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgRG9jdW1lbnQgb2JqZWN0XG4gKi9cbi8vIENhbGxlZCBvbmx5IGZyb20gd2l0aGluIGRlZmF1bHREaXNwbGF5XG5mdW5jdGlvbiBhY3R1YWxEaXNwbGF5KCBuYW1lLCBkb2MgKSB7XG5cdHZhciBzdHlsZSxcblx0XHRlbGVtID0galF1ZXJ5KCBkb2MuY3JlYXRlRWxlbWVudCggbmFtZSApICkuYXBwZW5kVG8oIGRvYy5ib2R5ICksXG5cblx0XHQvLyBnZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSBtaWdodCBiZSByZWxpYWJseSB1c2VkIG9ubHkgb24gYXR0YWNoZWQgZWxlbWVudFxuXHRcdGRpc3BsYXkgPSB3aW5kb3cuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUgJiYgKCBzdHlsZSA9IHdpbmRvdy5nZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSggZWxlbVsgMCBdICkgKSA/XG5cblx0XHRcdC8vIFVzZSBvZiB0aGlzIG1ldGhvZCBpcyBhIHRlbXBvcmFyeSBmaXggKG1vcmUgbGlrZSBvcHRpbWl6YXRpb24pIHVudGlsIHNvbWV0aGluZyBiZXR0ZXIgY29tZXMgYWxvbmcsXG5cdFx0XHQvLyBzaW5jZSBpdCB3YXMgcmVtb3ZlZCBmcm9tIHNwZWNpZmljYXRpb24gYW5kIHN1cHBvcnRlZCBvbmx5IGluIEZGXG5cdFx0XHRzdHlsZS5kaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbVsgMCBdLCBcImRpc3BsYXlcIiApO1xuXG5cdC8vIFdlIGRvbid0IGhhdmUgYW55IGRhdGEgc3RvcmVkIG9uIHRoZSBlbGVtZW50LFxuXHQvLyBzbyB1c2UgXCJkZXRhY2hcIiBtZXRob2QgYXMgZmFzdCB3YXkgdG8gZ2V0IHJpZCBvZiB0aGUgZWxlbWVudFxuXHRlbGVtLmRldGFjaCgpO1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG4vKipcbiAqIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkoIG5vZGVOYW1lICkge1xuXHR2YXIgZG9jID0gZG9jdW1lbnQsXG5cdFx0ZGlzcGxheSA9IGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdO1xuXG5cdGlmICggIWRpc3BsYXkgKSB7XG5cdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblxuXHRcdC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLCByZWFkIGZyb20gaW5zaWRlIGFuIGlmcmFtZVxuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIWRpc3BsYXkgKSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgYWxyZWFkeS1jcmVhdGVkIGlmcmFtZSBpZiBwb3NzaWJsZVxuXHRcdFx0aWZyYW1lID0gKGlmcmFtZSB8fCBqUXVlcnkoIFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlwiICkpLmFwcGVuZFRvKCBkb2MuZG9jdW1lbnRFbGVtZW50ICk7XG5cblx0XHRcdC8vIEFsd2F5cyB3cml0ZSBhIG5ldyBIVE1MIHNrZWxldG9uIHNvIFdlYmtpdCBhbmQgRmlyZWZveCBkb24ndCBjaG9rZSBvbiByZXVzZVxuXHRcdFx0ZG9jID0gaWZyYW1lWyAwIF0uY29udGVudERvY3VtZW50O1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdFx0ZG9jLndyaXRlKCk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblxuXHRcdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblx0XHRcdGlmcmFtZS5kZXRhY2goKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXlcblx0XHRlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cdH1cblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cbnZhciBybWFyZ2luID0gKC9ebWFyZ2luLyk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdC8vIFN1cHBvcnQ6IElFPD0xMSssIEZpcmVmb3g8PTMwKyAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0aWYgKCBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcub3BlbmVyICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XG5cdH07XG5cblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXHR9XG5cblx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogaU9TIDwgNlxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBpT1MgPCA2IChhdCBsZWFzdCkgcmV0dXJucyBwZXJjZW50YWdlIGZvciBhIGxhcmdlciBzZXQgb2YgdmFsdWVzLCBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzXG5cdFx0Ly8gdGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOiBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAodGhpcy5nZXQgPSBob29rRm4pLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsXG5cdFx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDttYXJnaW4tdG9wOjFweDtcIiArXG5cdFx0XCJwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCkge1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpibG9jazttYXJnaW4tdG9wOjElO3RvcDoxJTtcIiArXG5cdFx0XHRcImJvcmRlcjoxcHg7cGFkZGluZzoxcHg7d2lkdGg6NHB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2LCBudWxsICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHRkb2NFbGVtLnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IG5vZGUuanMganNkb21cblx0Ly8gRG9uJ3QgYXNzdW1lIHRoYXQgZ2V0Q29tcHV0ZWRTdHlsZSBpcyBhIHByb3BlcnR5IG9mIHRoZSBnbG9iYWwgb2JqZWN0XG5cdGlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gVGhpcyB0ZXN0IGlzIGV4ZWN1dGVkIG9ubHkgb25jZSBidXQgd2Ugc3RpbGwgZG8gbWVtb2l6aW5nXG5cdFx0XHRcdC8vIHNpbmNlIHdlIGNhbiB1c2UgdGhlIGJveFNpemluZ1JlbGlhYmxlIHByZS1jb21wdXRpbmcuXG5cdFx0XHRcdC8vIE5vIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHRlc3Qgd2FzIGFscmVhZHkgcGVyZm9ybWVkLCB0aG91Z2guXG5cdFx0XHRcdGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKTtcblx0XHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0XHR9LFxuXHRcdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdFx0Y29tcHV0ZVBpeGVsUG9zaXRpb25BbmRCb3hTaXppbmdSZWxpYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHRcdH0sXG5cdFx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBDaGVjayBpZiBkaXYgd2l0aCBleHBsaWNpdCB3aWR0aCBhbmQgbm8gbWFyZ2luLXJpZ2h0IGluY29ycmVjdGx5XG5cdFx0XHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gKCMzMzMzKVxuXHRcdFx0XHQvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcblx0XHRcdFx0Ly8gVGhpcyBzdXBwb3J0IGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgb25jZSBzbyBubyBtZW1vaXppbmcgaXMgbmVlZGVkLlxuXHRcdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRcdG1hcmdpbkRpdiA9IGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gUmVzZXQgQ1NTOiBib3gtc2l6aW5nOyBkaXNwbGF5OyBtYXJnaW47IGJvcmRlcjsgcGFkZGluZ1xuXHRcdFx0XHRtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xuXHRcdFx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy1tb3otYm94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFx0XCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowXCI7XG5cdFx0XHRcdG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0XHRkaXYuc3R5bGUud2lkdGggPSBcIjFweFwiO1xuXHRcdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdFx0XHRyZXQgPSAhcGFyc2VGbG9hdCggd2luZG93LmdldENvbXB1dGVkU3R5bGUoIG1hcmdpbkRpdiwgbnVsbCApLm1hcmdpblJpZ2h0ICk7XG5cblx0XHRcdFx0ZG9jRWxlbS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdFx0XHRcdGRpdi5yZW1vdmVDaGlsZCggbWFyZ2luRGl2ICk7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSkoKTtcblxuXG4vLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zLlxualF1ZXJ5LnN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXJcblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZSBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cm51bXNwbGl0ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSguKikkXCIsIFwiaVwiICksXG5cdHJyZWxOdW0gPSBuZXcgUmVnRXhwKCBcIl4oWystXSk9KFwiICsgcG51bSArIFwiKVwiLCBcImlcIiApLFxuXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiIF07XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBzdHlsZSwgbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gc3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcblx0XHRvcmlnTmFtZSA9IG5hbWUsXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIHN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG9yaWdOYW1lO1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXHR2YXIgbWF0Y2hlcyA9IHJudW1zcGxpdC5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMSBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMiBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSA9IGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgP1xuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRcdDQgOlxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHR2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcblx0Ly8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cdGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KHZhbCkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiICk7XG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cdFx0XHQvLyBSZXNldCB0aGUgaW5saW5lIGRpc3BsYXkgb2YgdGhpcyBlbGVtZW50IHRvIGxlYXJuIGlmIGl0IGlzXG5cdFx0XHQvLyBiZWluZyBoaWRkZW4gYnkgY2FzY2FkZWQgcnVsZXMgb3Igbm90XG5cdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gJiYgZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBlbGVtZW50cyB3aGljaCBoYXZlIGJlZW4gb3ZlcnJpZGRlbiB3aXRoIGRpc3BsYXk6IG5vbmVcblx0XHRcdC8vIGluIGEgc3R5bGVzaGVldCB0byB3aGF0ZXZlciB0aGUgZGVmYXVsdCBicm93c2VyIHN0eWxlIGlzXG5cdFx0XHQvLyBmb3Igc3VjaCBhbiBlbGVtZW50XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbiggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBcIm9sZGRpc3BsYXlcIiwgZGVmYXVsdERpc3BsYXkoZWxlbS5ub2RlTmFtZSkgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlkZGVuID0gaXNIaWRkZW4oIGVsZW0gKTtcblxuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiB8fCAhaGlkZGVuICkge1xuXHRcdFx0XHRkYXRhX3ByaXYuc2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiwgaGlkZGVuID8gZGlzcGxheSA6IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuXHQvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKCAhc2hvdyB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZXNbIGluZGV4IF0gfHwgXCJcIiA6IFwibm9uZVwiO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8ICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIHN0eWxlLCBvcmlnTmFtZSApICk7XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmIChyZXQgPSBycmVsTnVtLmV4ZWMoIHZhbHVlICkpICkge1xuXHRcdFx0XHR2YWx1ZSA9ICggcmV0WzFdICsgMSApICogcmV0WzJdICsgcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApICk7XG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIsIGFkZCAncHgnIHRvIHRoZSAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdICkge1xuXHRcdFx0XHR2YWx1ZSArPSBcInB4XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgKHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCAoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBlbGVtLnN0eWxlLCBvcmlnTmFtZSApICk7XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGpRdWVyeS5pc051bWVyaWMoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaChbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiYgZWxlbS5vZmZzZXRXaWR0aCA9PT0gMCA/XG5cdFx0XHRcdFx0alF1ZXJ5LnN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIGV4dHJhID9cblx0XHRcdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCkgOiAwXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xualF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5zd2FwKCBlbGVtLCB7IFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiIH0sXG5cdFx0XHRcdGN1ckNTUywgWyBlbGVtLCBcIm1hcmdpblJpZ2h0XCIgXSApO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goe1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoXCIgXCIpIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IFwic3dpbmdcIjtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdGlmICggdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiZcblx0XHRcdFx0KCF0d2Vlbi5lbGVtLnN0eWxlIHx8IHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsKSApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5zdHlsZSAmJiAoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fCBqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fVxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgQ29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIHRpbWVySWQsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRyZnhudW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLyxcblx0YW5pbWF0aW9uUHJlZmlsdGVycyA9IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXHR0d2VlbmVycyA9IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApLFxuXHRcdFx0XHR0YXJnZXQgPSB0d2Vlbi5jdXIoKSxcblx0XHRcdFx0cGFydHMgPSByZnhudW0uZXhlYyggdmFsdWUgKSxcblx0XHRcdFx0dW5pdCA9IHBhcnRzICYmIHBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHRcdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRcdFx0c3RhcnQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK3RhcmdldCApICYmXG5cdFx0XHRcdFx0cmZ4bnVtLmV4ZWMoIGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHByb3AgKSApLFxuXHRcdFx0XHRzY2FsZSA9IDEsXG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAyMDtcblxuXHRcdFx0aWYgKCBzdGFydCAmJiBzdGFydFsgMyBdICE9PSB1bml0ICkge1xuXHRcdFx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0XHRcdHVuaXQgPSB1bml0IHx8IHN0YXJ0WyAzIF07XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdFx0XHRwYXJ0cyA9IHBhcnRzIHx8IFtdO1xuXG5cdFx0XHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0XHRcdHN0YXJ0ID0gK3RhcmdldCB8fCAxO1xuXG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0XHRcdHNjYWxlID0gc2NhbGUgfHwgXCIuNVwiO1xuXG5cdFx0XHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0XHRcdHN0YXJ0ID0gc3RhcnQgLyBzY2FsZTtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHByb3AsIHN0YXJ0ICsgdW5pdCApO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpLFxuXHRcdFx0XHQvLyBicmVhayB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoXG5cdFx0XHRcdH0gd2hpbGUgKCBzY2FsZSAhPT0gKHNjYWxlID0gdHdlZW4uY3VyKCkgLyB0YXJnZXQpICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9ucyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdHdlZW4gcHJvcGVydGllc1xuXHRcdFx0aWYgKCBwYXJ0cyApIHtcblx0XHRcdFx0c3RhcnQgPSB0d2Vlbi5zdGFydCA9ICtzdGFydCB8fCArdGFyZ2V0IHx8IDA7XG5cdFx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0XHQvLyBJZiBhICs9Ly09IHRva2VuIHdhcyBwcm92aWRlZCwgd2UncmUgZG9pbmcgYSByZWxhdGl2ZSBhbmltYXRpb25cblx0XHRcdFx0dHdlZW4uZW5kID0gcGFydHNbIDEgXSA/XG5cdFx0XHRcdFx0c3RhcnQgKyAoIHBhcnRzWyAxIF0gKyAxICkgKiBwYXJ0c1sgMiBdIDpcblx0XHRcdFx0XHQrcGFydHNbIDIgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9O1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggdHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggdHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAodHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHQvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCB0d2VlbiwgaG9va3MsIG9sZGZpcmUsIGRpc3BsYXksIGNoZWNrRGlzcGxheSxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW4oIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBIYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIEhlaWdodC93aWR0aCBvdmVyZmxvdyBwYXNzXG5cdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiaGVpZ2h0XCIgaW4gcHJvcHMgfHwgXCJ3aWR0aFwiIGluIHByb3BzICkgKSB7XG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRTktMTAgZG8gbm90XG5cdFx0Ly8gY2hhbmdlIHRoZSBvdmVyZmxvdyBhdHRyaWJ1dGUgd2hlbiBvdmVyZmxvd1ggYW5kXG5cdFx0Ly8gb3ZlcmZsb3dZIGFyZSBzZXQgdG8gdGhlIHNhbWUgdmFsdWVcblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIFNldCBkaXNwbGF5IHByb3BlcnR5IHRvIGlubGluZS1ibG9jayBmb3IgaGVpZ2h0L3dpZHRoXG5cdFx0Ly8gYW5pbWF0aW9ucyBvbiBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgaGF2aW5nIHdpZHRoL2hlaWdodCBhbmltYXRlZFxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXG5cdFx0Ly8gVGVzdCBkZWZhdWx0IGRpc3BsYXkgaWYgZGlzcGxheSBpcyBjdXJyZW50bHkgXCJub25lXCJcblx0XHRjaGVja0Rpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/XG5cdFx0XHRkYXRhX3ByaXYuZ2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApIHx8IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5O1xuXG5cdFx0aWYgKCBjaGVja0Rpc3BsYXkgPT09IFwiaW5saW5lXCIgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gc2hvdy9oaWRlIHBhc3Ncblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy5leGVjKCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBkYXRhU2hvdyBsZWZ0IG92ZXIgZnJvbSBhIHN0b3BwZWQgaGlkZSBvciBzaG93IGFuZCB3ZSBhcmUgZ29pbmcgdG8gcHJvY2VlZCB3aXRoIHNob3csIHdlIHNob3VsZCBwcmV0ZW5kIHRvIGJlIGhpZGRlblxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblxuXHRcdC8vIEFueSBub24tZnggdmFsdWUgc3RvcHMgdXMgZnJvbSByZXN0b3JpbmcgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlzcGxheSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblxuXHRpZiAoICFqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YVNob3cgPSBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7fSApO1xuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHN0YXRlIGlmIGl0cyB0b2dnbGUgLSBlbmFibGVzIC5zdG9wKCkudG9nZ2xlKCkgdG8gXCJyZXZlcnNlXCJcblx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0fVxuXHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0alF1ZXJ5KCBlbGVtICkuc2hvdygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcDtcblxuXHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdHR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cblx0XHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRcdHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRcdHR3ZWVuLnN0YXJ0ID0gcHJvcCA9PT0gXCJ3aWR0aFwiIHx8IHByb3AgPT09IFwiaGVpZ2h0XCIgPyAxIDogMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHQvLyBJZiB0aGlzIGlzIGEgbm9vcCBsaWtlIC5oaWRlKCkuaGlkZSgpLCByZXN0b3JlIGFuIG92ZXJ3cml0dGVuIGRpc3BsYXkgdmFsdWVcblx0fSBlbHNlIGlmICggKGRpc3BsYXkgPT09IFwibm9uZVwiID8gZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXkpID09PSBcImlubGluZVwiICkge1xuXHRcdHN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBhbmltYXRpb25QcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0pO1xuXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2Uoe1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwgeyBzcGVjaWFsRWFzaW5nOiB7fSB9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBhbmltYXRpb25QcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSlcblx0KTtcblxuXHQvLyBhdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRyZXR1cm4gYW5pbWF0aW9uLnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMuc3BsaXQoXCIgXCIpO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHR0d2VlbmVyc1sgcHJvcCBdID0gdHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdHR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0YW5pbWF0aW9uUHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmltYXRpb25QcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59KTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZngub2ZmID8gMCA6IHR5cGVvZiBvcHQuZHVyYXRpb24gPT09IFwibnVtYmVyXCIgPyBvcHQuZHVyYXRpb24gOlxuXHRcdG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID8galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW4gKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhX3ByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3ByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiAodHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSkgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFfcHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaChbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCh7XG5cdHNsaWRlRG93bjogZ2VuRngoXCJzaG93XCIpLFxuXHRzbGlkZVVwOiBnZW5GeChcImhpZGVcIiksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeChcInRvZ2dsZVwiKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59KTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xuXG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0Y2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0pO1xufTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogaU9TPD01LjEsIEFuZHJvaWQ8PTQuMitcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPD0yLjNcblx0Ly8gT3B0aW9ucyBpbnNpZGUgZGlzYWJsZWQgc2VsZWN0cyBhcmUgaW5jb3JyZWN0bHkgbWFya2VkIGFzIGRpc2FibGVkXG5cdHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XG5cdHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSkoKTtcblxuXG52YXIgbm9kZUhvb2ssIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gZG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBhdHRyaWJ1dGVzIGFyZSBsb3dlcmNhc2Vcblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogbm9kZUhvb2sgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/XG5cdFx0XHRcdHVuZGVmaW5lZCA6XG5cdFx0XHRcdHJldDtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLCBwcm9wTmFtZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKG5hbWUgPSBhdHRyTmFtZXNbaSsrXSkgKSB7XG5cdFx0XHRcdHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcblx0XHRcdFx0aWYgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0XHQvLyBTZXQgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB0byBmYWxzZVxuXHRcdFx0XHRcdGVsZW1bIHByb3BOYW1lIF0gPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH0sXG5cblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLCBub3R4bWwsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRub3R4bWwgPSBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICk7XG5cblx0XHRpZiAoIG5vdHhtbCApIHtcblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cmV0IDpcblx0XHRcdFx0KCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgP1xuXHRcdFx0XHRyZXQgOlxuXHRcdFx0XHRlbGVtWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5oYXNBdHRyaWJ1dGUoIFwidGFiaW5kZXhcIiApIHx8IHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8IGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0ZWxlbS50YWJJbmRleCA6XG5cdFx0XHRcdFx0LTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaChbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRwcm9jZWVkID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgdGhpcy5jbGFzc05hbWUgKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCBwcm9jZWVkICkge1xuXHRcdFx0Ly8gVGhlIGRpc2p1bmN0aW9uIGhlcmUgaXMgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSByZW1vdmVDbGFzcylcblx0XHRcdGNsYXNzZXMgPSAoIHZhbHVlIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggZWxlbS5jbGFzc05hbWUgP1xuXHRcdFx0XHRcdCggXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRcIiBcIlxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gb25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdHByb2NlZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lICkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAoIHByb2NlZWQgKSB7XG5cdFx0XHRjbGFzc2VzID0gKCB2YWx1ZSB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIGVsZW0uY2xhc3NOYW1lID9cblx0XHRcdFx0XHQoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XG5cdFx0XHRcdFx0XCJcIlxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID49IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gdmFsdWUgPyBqUXVlcnkudHJpbSggY3VyICkgOiBcIlwiO1xuXHRcdFx0XHRcdGlmICggZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyggdmFsdWUuY2FsbCh0aGlzLCBpLCB0aGlzLmNsYXNzTmFtZSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSxcblx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoIChjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSkgKSB7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IHN0cnVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHQvLyBzdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YV9wcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIHRoaXMuY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID8gXCJcIiA6IGRhdGFfcHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIjtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRpZiAoIHRoaXNbaV0ubm9kZVR5cGUgPT09IDEgJiYgKFwiIFwiICsgdGhpc1tpXS5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZShyY2xhc3MsIFwiIFwiKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+PSAwICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbMF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZShycmV0dXJuLCBcIlwiKSA6XG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdFx0cmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKFwic2V0XCIgaW4gaG9va3MpIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTEwLTExK1xuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHRqUXVlcnkudHJpbSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIgfHwgaW5kZXggPCAwLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cblx0XHRcdFx0XHRcdG1heCA6XG5cdFx0XHRcdFx0XHRvbmUgPyBpbmRleCA6IDA7XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBJRTYtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQoIHN1cHBvcnQub3B0RGlzYWJsZWQgPyAhb3B0aW9uLmRpc2FibGVkIDogb3B0aW9uLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT09IG51bGwgKSAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fCAhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggKG9wdGlvbi5zZWxlY3RlZCA9IGpRdWVyeS5pbkFycmF5KCBvcHRpb24udmFsdWUsIHZhbHVlcyApID49IDApICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KGVsZW0pLnZhbCgpLCB2YWx1ZSApID49IDAgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbmpRdWVyeS5lYWNoKCAoXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIikuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9LFxuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gdGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6IHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59KTtcblxuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoL1xcPy8pO1xuXG5cblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbi8vIFdvcmthcm91bmQgZmFpbHVyZSB0byBzdHJpbmctY2FzdCBudWxsIGlucHV0XG5qUXVlcnkucGFyc2VKU09OID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICsgXCJcIiApO1xufTtcblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbCwgdG1wO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdHRyeSB7XG5cdFx0dG1wID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdHhtbCA9IHRtcC5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblx0cnVybCA9IC9eKFtcXHcuKy1dKzopKD86XFwvXFwvKD86W15cXC8/I10qQHwpKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gRG9jdW1lbnQgbG9jYXRpb25cblx0YWpheExvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLmhyZWYsXG5cblx0Ly8gU2VnbWVudCBsb2NhdGlvbiBpbnRvIHBhcnRzXG5cdGFqYXhMb2NQYXJ0cyA9IHJ1cmwuZXhlYyggYWpheExvY2F0aW9uLnRvTG93ZXJDYXNlKCkgKSB8fCBbXTtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKGRhdGFUeXBlID0gZGF0YVR5cGVzW2krK10pICkge1xuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWzBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmICFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKGRlZXAgPSB7fSkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1swXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHNbIFwidGhyb3dzXCIgXSApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7IHN0YXRlOiBcInBhcnNlcmVycm9yXCIsIGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudCB9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogYWpheExvY2F0aW9uLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggYWpheExvY1BhcnRzWyAxIF0gKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC94bWwvLFxuXHRcdFx0aHRtbDogL2h0bWwvLFxuXHRcdFx0anNvbjogL2pzb24vXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IGpRdWVyeS5wYXJzZUpTT04sXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblx0XHRcdC8vIENyb3NzLWRvbWFpbiBkZXRlY3Rpb24gdmFyc1xuXHRcdFx0cGFydHMsXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmICggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblx0XHRcdC8vIFRoZSBqcVhIUiBzdGF0ZVxuXHRcdFx0c3RhdGUgPSAwLFxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2sgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKS5jb21wbGV0ZSA9IGNvbXBsZXRlRGVmZXJyZWQuYWRkO1xuXHRcdGpxWEhSLnN1Y2Nlc3MgPSBqcVhIUi5kb25lO1xuXHRcdGpxWEhSLmVycm9yID0ganFYSFIuZmFpbDtcblxuXHRcdC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGFqYXhMb2NhdGlvbiApICsgXCJcIiApLnJlcGxhY2UoIHJoYXNoLCBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGFqYXhMb2NQYXJ0c1sgMSBdICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0galF1ZXJ5LnRyaW0oIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB3ZSBoYXZlIGEgcHJvdG9jb2w6aG9zdDpwb3J0IG1pc21hdGNoXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHRwYXJ0cyA9IHJ1cmwuZXhlYyggcy51cmwudG9Mb3dlckNhc2UoKSApO1xuXHRcdFx0cy5jcm9zc0RvbWFpbiA9ICEhKCBwYXJ0cyAmJlxuXHRcdFx0XHQoIHBhcnRzWyAxIF0gIT09IGFqYXhMb2NQYXJ0c1sgMSBdIHx8IHBhcnRzWyAyIF0gIT09IGFqYXhMb2NQYXJ0c1sgMiBdIHx8XG5cdFx0XHRcdFx0KCBwYXJ0c1sgMyBdIHx8ICggcGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgIT09XG5cdFx0XHRcdFx0XHQoIGFqYXhMb2NQYXJ0c1sgMyBdIHx8ICggYWpheExvY1BhcnRzWyAxIF0gPT09IFwiaHR0cDpcIiA/IFwiODBcIiA6IFwiNDQzXCIgKSApIClcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RhcnRcIik7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybDtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSAoIHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGEgKTtcblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdICsgKCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiYgKCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydChcInRpbWVvdXRcIik7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBleGNlcHRpb24gYXMgZXJyb3IgaWYgbm90IGRvbmVcblx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdFx0Ly8gU2ltcGx5IHJldGhyb3cgb3RoZXJ3aXNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIENhbGxlZCBvbmNlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXRlIGlzIFwiZG9uZVwiIG5vd1xuXHRcdFx0c3RhdGUgPSAyO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoe1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0pO1xuXHR9O1xufSk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KHtcblx0XHR1cmw6IHVybCxcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWwuY2FsbCh0aGlzLCBpKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCh0aGlzLCBpKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKHRoaXMsIGkpIDogaHRtbCApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0pLmVuZCgpO1xuXHR9XG59KTtcblxuXG5qUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBTdXBwb3J0OiBPcGVyYSA8PSAxMi4xMlxuXHQvLyBPcGVyYSByZXBvcnRzIG9mZnNldFdpZHRocyBhbmQgb2Zmc2V0SGVpZ2h0cyBsZXNzIHRoYW4gemVybyBvbiBzb21lIGVsZW1lbnRzXG5cdHJldHVybiBlbGVtLm9mZnNldFdpZHRoIDw9IDAgJiYgZWxlbS5vZmZzZXRIZWlnaHQgPD0gMDtcbn07XG5qUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiggZWxlbSApO1xufTtcblxuXG5cblxudmFyIHIyMCA9IC8lMjAvZyxcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiID8gaSA6IFwiXCIgKSArIFwiXVwiLCB2LCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG5cdFx0XHR2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApID8gdmFsdWUoKSA6ICggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIFNldCB0cmFkaXRpb25hbCB0byB0cnVlIGZvciBqUXVlcnkgPD0gMS4zLjIgYmVoYXZpb3IuXG5cdGlmICggdHJhZGl0aW9uYWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHR0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MgJiYgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9KTtcblxuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0pXG5cdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSlcblx0XHQubWFwKGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSkuZ2V0KCk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoKCBlICkge31cbn07XG5cbnZhciB4aHJJZCA9IDAsXG5cdHhockNhbGxiYWNrcyA9IHt9LFxuXHR4aHJTdWNjZXNzU3RhdHVzID0ge1xuXHRcdC8vIGZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG4vLyBTdXBwb3J0OiBJRTlcbi8vIE9wZW4gcmVxdWVzdHMgbXVzdCBiZSBtYW51YWxseSBhYm9ydGVkIG9uIHVubG9hZCAoIzUyODApXG4vLyBTZWUgaHR0cHM6Ly9zdXBwb3J0Lm1pY3Jvc29mdC5jb20va2IvMjg1Njc0NiBmb3IgbW9yZSBpbmZvXG5pZiAoIHdpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0d2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xuXHRcdGZvciAoIHZhciBrZXkgaW4geGhyQ2FsbGJhY2tzICkge1xuXHRcdFx0eGhyQ2FsbGJhY2tzWyBrZXkgXSgpO1xuXHRcdH1cblx0fSk7XG59XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydChmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCksXG5cdFx0XHRcdFx0aWQgPSArK3hocklkO1xuXG5cdFx0XHRcdHhoci5vcGVuKCBvcHRpb25zLnR5cGUsIG9wdGlvbnMudXJsLCBvcHRpb25zLmFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkICk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSB4aHJDYWxsYmFja3NbIGlkIF07XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0geGhyLm9ubG9hZCA9IHhoci5vbmVycm9yID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBBY2Nlc3NpbmcgYmluYXJ5LWRhdGEgcmVzcG9uc2VUZXh0IHRocm93cyBhbiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHRcdC8vICgjMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gXCJzdHJpbmdcIiA/IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dDogeGhyLnJlc3BvbnNlVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0fSA6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdHhoci5vbmVycm9yID0gY2FsbGJhY2soXCJlcnJvclwiKTtcblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0geGhyQ2FsbGJhY2tzWyBpZCBdID0gY2FsbGJhY2soXCJhYm9ydFwiKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCh7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogLyg/OmphdmF8ZWNtYSlzY3JpcHQvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59KTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeShcIjxzY3JpcHQ+XCIpLnByb3Aoe1xuXHRcdFx0XHRcdGFzeW5jOiB0cnVlLFxuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0pLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59KTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiAhKCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmIHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBmb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gUmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBzYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBkYXRhOiBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LCBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcblx0XHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbMV0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcbnZhciBfbG9hZCA9IGpRdWVyeS5mbi5sb2FkO1xuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHRpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XG5cdFx0cmV0dXJuIF9sb2FkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoXCIgXCIpO1xuXG5cdGlmICggb2ZmID49IDAgKSB7XG5cdFx0c2VsZWN0b3IgPSBqUXVlcnkudHJpbSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBpZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkXG5cdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSkuZG9uZShmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeShcIjxkaXY+XCIpLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdH0pLmNvbXBsZXRlKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggY2FsbGJhY2ssIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbIFwiYWpheFN0YXJ0XCIsIFwiYWpheFN0b3BcIiwgXCJhamF4Q29tcGxldGVcIiwgXCJhamF4RXJyb3JcIiwgXCJhamF4U3VjY2Vzc1wiLCBcImFqYXhTZW5kXCIgXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSk7XG5cblxuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSkubGVuZ3RoO1xufTtcblxuXG5cblxudmFyIGRvY0VsZW0gPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKFwiYXV0b1wiKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGN1ck9mZnNldCApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRpZiAoICFkb2MgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBNYWtlIHN1cmUgaXQncyBub3QgYSBkaXNjb25uZWN0ZWQgRE9NIG5vZGVcblx0XHRpZiAoICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcblx0XHRcdHJldHVybiBib3g7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKVxuXHRcdC8vIElmIHdlIGRvbid0IGhhdmUgZ0JDUiwganVzdCB1c2UgMCwwIHJhdGhlciB0aGFuIGVycm9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09IHN0cnVuZGVmaW5lZCApIHtcblx0XHRcdGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0fVxuXHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogYm94LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuXHRcdFx0bGVmdDogYm94LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHR9O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LCBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2NFbGVtO1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudCwgXCJodG1sXCIgKSAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jRWxlbTtcblx0XHR9KTtcblx0fVxufSk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblx0XHRcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW5kb3cucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGgsIG51bGwgKTtcblx0fTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmk8NyssIENocm9tZTwzNytcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTI4MFxuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0pO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sIGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0XHQvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxuXHRcdFx0XHRcdC8vIGlzbid0IGEgd2hvbGUgbG90IHdlIGNhbiBkby4gU2VlIHB1bGwgcmVxdWVzdCBhdCB0aGlzIFVSTCBmb3IgZGlzY3Vzc2lvbjpcblx0XHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzc2NFxuXHRcdFx0XHRcdHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUsIG51bGwgKTtcblx0XHR9O1xuXHR9KTtcbn0pO1xuXG5cbi8vIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5qUXVlcnkuZm4uc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5qUXVlcnkuZm4uYW5kU2VsZiA9IGpRdWVyeS5mbi5hZGRCYWNrO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0pO1xufVxuXG5cblxuXG52YXJcblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IHN0cnVuZGVmaW5lZCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xuXG59KSk7XG4iLCJ2YXIgQXBwID0ge1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXBwOyIsInZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbnZhciBQcm9kdWN0TW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvcHJvZHVjdCcpXG5cbnZhciBCdWxiQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcblx0bW9kZWw6IFByb2R1Y3RNb2RlbCxcblx0dXJsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ2FwaS9idWxiJ1xuXHR9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1bGJDb2xsZWN0aW9uOyIsInZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbnZhciBQcm9kdWN0TW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvcHJvZHVjdCcpXG5cbnZhciBGYW5Db2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuXHRtb2RlbDogUHJvZHVjdE1vZGVsLFxuXHR1cmw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAnYXBpL2Zhbidcblx0fVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBGYW5Db2xsZWN0aW9uOyIsIi8vIERlcGVuZGVuY2llc1xudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgSGFuZGxlYmFycyA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcblxuLy8gQXBwXG52YXIgQXBwID0gcmVxdWlyZSgnLi9hcHAnKVxuXG5cbi8vIFZpZXdzXG52YXIgSG9tZVZpZXcgPSByZXF1aXJlKCcuL3ZpZXdzL2hvbWUuanMnKTtcbnZhciBob21lVmlldyA9IG5ldyBIb21lVmlldygpO1xuXG52YXIgQWJvdXRWaWV3ID0gcmVxdWlyZSgnLi92aWV3cy9hYm91dC5qcycpO1xudmFyIGFib3V0VmlldyA9IG5ldyBBYm91dFZpZXcoKTtcblxudmFyIENvbXBhcmVWaWV3ID0gcmVxdWlyZSgnLi92aWV3cy9jb21wYXJlLmpzJyk7XG52YXIgY29tcGFyZVZpZXcgPSBuZXcgQ29tcGFyZVZpZXcoKTtcblxudmFyIFByb2R1Y3RQcm9maWxlVmlldyA9IHJlcXVpcmUoJy4vdmlld3MvcHJvZHVjdC1wcm9maWxlLmpzJyk7XG52YXIgcHJvZHVjdFByb2ZpbGVWaWV3ID0gbmV3IFByb2R1Y3RQcm9maWxlVmlldygpO1xuXG5cbiQoZnVuY3Rpb24oKSB7XG5cblx0dmFyIEFwcFJvdXRlciA9IEJhY2tib25lLlJvdXRlci5leHRlbmQoe1xuXHQgICAgXG5cdCAgICByb3V0ZXM6IHtcblx0ICAgIFx0JygvKSc6ICdpbmRleCcsXG5cdCAgICBcdCdhYm91dCgvKSc6ICdhYm91dCcsXG5cdCAgICBcdCdjb21wYXJlKC8pJzogJ2NvbXBhcmUnLFxuXHQgICAgICAgIC8vICdhZGQtcHJvZHVjdCgvKSc6ICdhZGRQcm9kdWN0Jyxcblx0ICAgICAgICAncHJvZHVjdC86aWQoLyknOiAncHJvZHVjdFByb2ZpbGUnLFxuXHQgICAgICAgICcqYWN0aW9ucyc6ICdkZWZhdWx0Um91dGUnXG5cdCAgICB9LFxuXG5cdCAgICBpbmRleDogZnVuY3Rpb24oKSB7XG5cdCAgICBcdGhvbWVWaWV3LnJlbmRlcigpO1xuXHQgICAgfSxcblxuXHQgICAgYWJvdXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgXHRhYm91dFZpZXcucmVuZGVyKCk7XG5cdCAgICB9LFxuXG5cdCAgICBjb21wYXJlOiBmdW5jdGlvbigpIHtcblx0ICAgIFx0Y29uc29sZS5sb2coJ2NvbXBhcmUnKTtcblx0ICAgIFx0Y29tcGFyZVZpZXcucmVuZGVyKCk7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBhZGRQcm9kdWN0OiBmdW5jdGlvbigpIHtcblx0ICAgIC8vIFx0Y29uc29sZS5sb2coJ0FkZCBQcm9kdWN0Jyk7XG5cdCAgICAvLyB9LFxuXG5cdCAgICBwcm9kdWN0UHJvZmlsZTogZnVuY3Rpb24oaWQpIHtcblx0ICAgIFx0cHJvZHVjdFByb2ZpbGVWaWV3LnJlbmRlcihpZCk7XG5cdCAgICB9LFxuXG5cdCAgICBkZWZhdWx0Um91dGU6IGZ1bmN0aW9uKCkge1xuXHQgICAgXHRjb25zb2xlLmxvZygnNDA0Jyk7XG5cdCAgICB9XG5cblxuXHR9KTtcblxuXHQvLyBJbnN0YW50aWF0ZSB0aGUgcm91dGVyXG5cdEFwcC5hcHBSb3V0ZXIgPSBuZXcgQXBwUm91dGVyO1xuXG5cdC8vIFN0YXJ0IEJhY2tib25lIGhpc3RvcnkgYSBuZWNlc3Nhcnkgc3RlcCBmb3IgYm9va21hcmthYmxlIFVSTCdzXG5cdEJhY2tib25lLmhpc3Rvcnkuc3RhcnQoKTtcblxuXG5cblxufSkiLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG52YXIgUHJvZHVjdE1vZGVsID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcblxuXHR1cmw6IGZ1bmN0aW9uKCkge1xuXG5cdFx0Y29uc29sZS5sb2coJ3VybCBpbiBwcm9kdWN0IG1vZGVsJylcblx0XHRyZXR1cm4gJy9hcGkvcHJvZHVjdC8nICsgdGhpcy5wcm9kdWN0X2lkXG5cdH1cblx0XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2R1Y3RNb2RlbDsiLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwiPGRpdj5cXG5cdDxkaXY+XHRcXG5cdFx0PGgyPkludmVzdCBOb3cgdG8gU2F2ZSBMYXRlcjwvaDI+XFxuXHQ8L2Rpdj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJhYm91dC1jb250ZW50XFxcIj5cXG5cdDxoMT5BYm91dCBVczwvaDE+XFxuXHQ8cD5PdXIgR29hbCBpcyB0byBtYWtlIGluZm9ybWF0aW9uIG1vcmUgYWNjZXNzaWJsZSB0byBjb25zdW1lcnMuIFdlIHdhbnQgdG8gaGVscCBjb25zdW1lcnMgc2VlIHRoZSBsb25nLXRlcm0gc2F2aW5ncyB0aGV5IGNhbiBleHBlY3Qgd2hlbiBwdXJjaGFzaW5nIGhpZ2hlci1xdWFsaXR5IGVsZWN0cmljaXR5LWNvbnN1bWluZyBwcm9kdWN0cy48L3A+XFxuXHQ8aDE+VGhpbmdzIHRvIENvbnNpZGVyOjwvaDE+XFxuXHQ8ZGl2IGNsYXNzPVxcXCJhYm91dC1kZXRhaWxzXFxcIj5cXG5cdFx0PGgyPkRDIE1vdG9yPC9oMj5cXG5cdFx0PGRpdiBjbGFzcz1cXFwibWVkaWEtb2JqZWN0XFxcIj5cXG5cdFx0XHQ8ZGl2IGNsYXNzPVxcXCJtZWRpYS1ncmFwaGljXFxcIiBzdHlsZT1cXFwiYmFja2dyb3VuZC1pbWFnZTogdXJsKC9pbWFnZXMvZGNfbW90b3IuanBnKTtcXFwiPjwvZGl2Plxcblx0XHRcdDxkaXYgY2xhc3M9XFxcIm1lZGlhLWNvbnRlbnRcXFwiPlxcblx0XHRcdFx0PHA+VGhlIHNwZWNpZmljIHR5cGUgb2YgREMgbW90b3IgdXNlZCBpbiBjZWlsaW5nIGZhbnMgaXMgYSBicnVzaGxlc3MgREMgbW90b3IsIChha2Egc3luY2hyb25vdXMgREMgbW90b3IpLiBBIERDIG1vdG9yIHVzZXMgYW4gaW50ZXJuYWwgYXJyYXkgb2YgbWFnbmV0cyBvZiBvcHBvc2luZyBwb2xhcml0eS4gVGhpcyBjcmVhdGVzIGEgbWFnbmV0aWMgZmllbGQgdGhhdCBjcmVhdGVzIHRoZSB0b3JxdWUgcmVxdWlyZWQgdG8gcm90YXRlIHRoZSBtb3RvcidzIHJvdG9yLiBUaGlzIHByb2Nlc3MgcmVxdWlyZXMgbGVzcyBlbGVjdHJpY2FsIGVuZXJneSwgdHJhbnNsYXRpbmcgaW50byBhIDcwJSBvciBncmVhdGVyIHJlZHVjdGlvbiBpbiBwb3dlciBjb25zdW1wdGlvbiBvdmVyIHN0YW5kYXJkIEFDIG1vdG9ycy48L3A+XFxuXHRcdFx0PC9kaXY+XFxuXHRcdDwvZGl2Plxcblx0XHQ8aDI+Q0ZNICYjMzg7IEFpcmZsb3cgRWZmaWNpZW5jeTwvaDI+XFxuXHRcdDxkaXYgY2xhc3M9XFxcIm1lZGlhLW9iamVjdFxcXCI+XFxuXHRcdFx0PGRpdiBjbGFzcz1cXFwibWVkaWEtZ3JhcGhpY1xcXCJzdHlsZT1cXFwiYmFja2dyb3VuZC1pbWFnZTogdXJsKC9pbWFnZXMvYWlyZmxvdy5qcGcpO1xcXCI+PC9kaXY+XFxuXHRcdFx0PGRpdiBjbGFzcz1cXFwibWVkaWEtY29udGVudFxcXCI+XFxuXHRcdFx0XHQ8cD5DRk0gaXMga2V5IHdoZW4gZGV0ZXJtaW5pbmcgYSBmYW7igJlzIGFpcmZsb3cgZWZmaWNpZW5jeS4gQWlyZmxvdyBlZmZpY2llbmN5IGlzIHRoZSBDRk0gZGl2aWRlZCBieSB0aGUgd2F0dHMvYW1vdW50IG9mIGVuZXJneSB1c2VkIHRvIHJ1biB0aGUgZmFuIGF0IGl0cyBoaWdoZXN0IHNwZWVkLiBBIENGTSBvZiA3NSBpcyB0aGUgbWluaW11bSBudW1iZXIgdG8gbWFrZSBhIGZhbiBlZmZpY2llbnQuIFNvIHlvdSBjb3VsZCBoYXZlIGEgZmFuIHRoYXQgbW92ZXMgYSBsb3Qgb2YgYWlyICh3aXRoIGEgaGlnaCBDRk0pIGJ1dCBkb2VzIHNvIGF0IGEgaGlnaCB3YXR0YWdlLCBzbyB0aGUgZmFuIG1heSBub3QgYmUgY29uc2lkZXJlZCBlZmZpY2llbnQuPC9wPlxcblx0XHRcdDwvZGl2Plxcblx0XHQ8L2Rpdj5cXG5cdFx0PGgyPlRoZXJtb3N0YXQ8L2gyPlxcblx0XHQ8ZGl2IGNsYXNzPVxcXCJtZWRpYS1vYmplY3RcXFwiPlxcblx0XHRcdDxkaXYgY2xhc3M9XFxcIm1lZGlhLWdyYXBoaWNcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoL2ltYWdlcy90aGVybW9zdGF0LmpwZyk7XFxcIj48L2Rpdj5cXG5cdFx0XHQ8ZGl2IGNsYXNzPVxcXCJtZWRpYS1jb250ZW50XFxcIj5cXG5cdFx0XHRcdDxwPkNlaWxpbmcgZmFucyB0aGF0IGluY2x1ZGUgYSB0aGVybW9zdGF0IGNhbiBhdXRvbWF0aWNhbGx5IHR1cm4geW91ciBmYW4gb24gYW5kIG9mZiBhbmQgc2V0IHRoZSBmYW4gc3BlZWQgYmFzZWQgb24gcm9vbSB0ZW1wZXJhdHVyZSwgY29uc2VydmluZyBlbmVyZ3kuPC9wPlxcblx0XHRcdDwvZGl2Plxcblx0XHQ8L2Rpdj5cXG5cdDwvZGl2PlxcbjwvZGl2PlwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwicHJvZHVjdC1jb21wYXJpc29uLWNoYXJ0XFxcIj48L2Rpdj5cXG48dGFibGUgY2xhc3M9XFxcImNvbXBhcmUtc2VsZWN0aW9uc1xcXCIgYm9yZGVyPVxcXCIxXFxcIj5cXG5cdDx0cj5cXG5cdFx0PHRkPkJyYW5kPC90ZD5cXG5cdFx0PHRkPmJyYW5kMTwvdGQ+XFxuXHRcdDx0ZD5icmFuZDI8L3RkPlxcblx0PC90cj5cXG5cdDx0cj5cXG5cdFx0PHRkPk1vZGVsPC90ZD5cXG5cdFx0PHRkPm1vZGVsMTwvdGQ+XFxuXHRcdDx0ZD5tb2RlbDI8L3RkPlxcblx0PC90cj5cXG5cdDx0cj5cXG5cdFx0PHRkPnByaWNlPC90ZD5cXG5cdFx0PHRkPiQ3NTwvdGQ+XFxuXHRcdDx0ZD4kMjI1PC90ZD5cXG5cdDwvdHI+XFxuXHQ8dHI+XFxuXHRcdDx0ZD5FbGVjdHJpYyBjb3N0L01vPC90ZD5cXG5cdFx0PHRkPiQ1PC90ZD5cXG5cdFx0PHRkPiQzPC90ZD5cXG5cdDwvdHI+XFxuXHQ8dHI+XFxuXHRcdDx0ZD5XaWR0aCAoaW4uKTwvdGQ+XFxuXHRcdDx0ZD41MjwvdGQ+XFxuXHRcdDx0ZD41MjwvdGQ+XFxuXHQ8L3RyPlxcblx0PHRyPlxcblx0XHQ8dGQ+QWlyZmxvdyAoQ0ZNKTwvdGQ+XFxuXHRcdDx0ZD4xODAwPC90ZD5cXG5cdFx0PHRkPjM1MDA8L3RkPlxcblx0PC90cj5cXG5cdDx0cj5cXG5cdFx0PHRkPlRoZXJtb3N0YXQ8L3RkPlxcblx0XHQ8dGQ+Tm88L3RkPlxcblx0XHQ8dGQ+WWVzPC90ZD5cXG5cdDwvdHI+XFxuXHQ8dHI+XFxuXHRcdDx0ZD5SZW1vdGU8L3RkPlxcblx0XHQ8dGQ+Tm88L3RkPlxcblx0XHQ8dGQ+WWVzPC90ZD5cXG5cdDwvdHI+XFxuXHQ8dHI+XFxuXHRcdDx0ZD5MaWdodGJ1bGI8L3RkPlxcblx0XHQ8dGQ+MTcgV2F0dCBDRkw8L3RkPlxcblx0XHQ8dGQ+MTggV2F0dCBMRUQ8L3RkPlxcblx0PC90cj5cXG48L3RhYmxlPlwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwidGFnbGluZVxcXCI+XHRcXG5cdDxoMj5JbnZlc3QgTm93IHRvIFNhdmUgTGF0ZXI8L2gyPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInNob3djYXNlXFxcIj5cXG5cdDxkaXYgY2xhc3M9XFxcImJhbm5lclxcXCI+XFxuXHRcdDxkaXYgY2xhc3M9XFxcImJhbm5lci10ZXh0XFxcIj5CcmFuZHM8L2Rpdj5cXG5cdFx0PGRpdiBjbGFzcz1cXFwibG9nb3NcXFwiPjwvZGl2Plxcblx0PC9kaXY+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwidXNlci1zZWxlY3Rpb25zXFxcIj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJwcm9kdWN0c1xcXCI+XFxuXHQ8c2VjdGlvbj5cXG5cdFx0PGgyPkNlaWxpbmcgZmFuczwvaDI+XFxuXHRcdDxkaXYgY2xhc3M9XFxcInRpbGVzIGZhbnNcXFwiPlxcblx0XHQ8L2Rpdj5cXG5cdDwvc2VjdGlvbj5cXG5cdDxzZWN0aW9uPlxcblx0XHQ8aDI+TGlnaHQgQnVsYnM8L2gyPlxcblx0XHQ8ZGl2IGNsYXNzPVxcXCJ0aWxlcyBidWxic1xcXCI+XFxuXHRcdDwvZGl2Plxcblx0PC9zZWN0aW9uPlxcbjwvZGl2PlwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiMVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDoge30sIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCJcdDxkaXYgZGF0YS1pZD1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnByb2R1Y3RfaWQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnByb2R1Y3RfaWQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcInByb2R1Y3RfaWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxcIiBjbGFzcz1cXFwidGlsZVxcXCI+XFxuXHRcdDxkaXYgY2xhc3M9XFxcInRpbGUtaW1hZ2VcXFwiXFxuXHRcdFx0c3R5bGU9XFxcImJhY2tncm91bmQtaW1hZ2U6IHVybCgvaW1hZ2VzL1wiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5maWxlX3BhdGggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmZpbGVfcGF0aCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiZmlsZV9wYXRoXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIi5qcGcpO1xcXCI+IFxcblx0XHQ8L2Rpdj5cXG5cdFx0PGRpdiBjbGFzcz1cXFwidGlsZS1kZXRhaWxzXFxcIj5cXG5cdFx0XHQ8ZGl2IGNsYXNzPVxcXCJ0aWxlLWRldGFpbHMxXFxcIj5cIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuYnJhbmRfbmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuYnJhbmRfbmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiYnJhbmRfbmFtZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCI8L2Rpdj4gXFxuXHRcdFx0PGRpdiBjbGFzcz1cXFwidGlsZS1kZXRhaWxzMlxcXCI+XCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm1vZGVsIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tb2RlbCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwibW9kZWxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiPC9kaXY+XFxuXHRcdFx0PGRpdiBjbGFzcz1cXFwiY29udHJvbFxcXCI+XFxuXHRcdFx0XHQ8YnV0dG9uPkluZm88L2J1dHRvbj5cXG5cdFx0XHRcdDxidXR0b24+Q2hvb3NlPC9idXR0b24+XFxuXHRcdFx0PC9kaXY+XFxuXHRcdDwvZGl2Plxcblx0PC9kaXY+XFxuXCI7XG59LFwiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IHt9LGRlcHRoMCx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDEsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBwYWdlVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvYWJvdXQuaGJzJyk7XG5cbnZhciBBYm91dFZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cdGVsOiAnLmNvbnRlbnQnLFxuXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHBhZ2VUZW1wbGF0ZSgpXG5cblx0XHR0aGlzLiRlbC5odG1sKHJlc3VsdClcblx0fVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBBYm91dFZpZXc7IiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBIaWdoQ2hhcnRzID0gcmVxdWlyZSgnaGlnaGNoYXJ0cy1icm93c2VyaWZ5Jyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHBhZ2VUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9jb21wYXJlLmhicycpO1xuLy8gdmFyIGNoYXJ0VGVtcGxhdGUgPSByZXF1aXJlKCcuLi9wcm9kdWN0X2NvbXBhcmVfY2hhcnQnKTtcblxudmFyIENvbXBhcmVWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXHRlbDogJy5jb250ZW50JyxcblxuXHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXN1bHQgPSBwYWdlVGVtcGxhdGUoKVxuXG5cdFx0dGhpcy4kZWwuaHRtbChyZXN1bHQpXG5cblx0XHRjb25zb2xlLmxvZygnYmVmb3JlIGNoYXJ0Jyk7XG5cblxuXHRcdG5ldyBIaWdoY2hhcnRzLkNoYXJ0KHtcblx0XHRcdGNoYXJ0OiB7XG5cdFx0XHRcdHJlbmRlclRvOiAkKCcucHJvZHVjdC1jb21wYXJpc29uLWNoYXJ0JylbMF0sXG5cdCAgICAgICAgICAgIHR5cGU6ICdsaW5lJ1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdGl0bGU6IHtcblx0ICAgICAgICAgICAgdGV4dDogJ0VuZXJneSBDb3N0J1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgeEF4aXM6IHtcblx0ICAgICAgICAgICAgY2F0ZWdvcmllczogWydQdXJjaGFzZSBEYXRlJywgJ1llYXIgMyddXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB5QXhpczoge1xuXHQgICAgICAgICAgICB0aXRsZToge1xuXHQgICAgICAgICAgICAgICAgdGV4dDogJ0luaXRpYWwgQ29zdCdcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2VyaWVzOiBbe1xuXHQgICAgICAgICAgICBuYW1lOiAnUHJvZHVjdCAxJyxcblx0ICAgICAgICAgICAgZGF0YTogWzIwMCwgNTAwXVxuXHQgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgbmFtZTogJ1Byb2R1Y3QgMicsXG5cdCAgICAgICAgICAgIGRhdGE6IFszMDAsIDQ1MF1cblx0ICAgICAgICB9XVxuXHRcdH0pXG5cdFx0XG5cblx0XHQvLyB2YXIgY2hhcnRUZW1wbGF0ZSA9IG5ldyBDaGFydFRlbXBsYXRlKClcblx0XHQvLyBjaGFydFRlbXBsYXRlLmZldGNoKCkuZG9uZShmdW5jdGlvbihjaGFydCkge1xuXHRcblx0XHQvLyAvLyByYXcgbm9uLWJhY2tib25lIGFycmF5IG9mIG9iamVjdHNcblx0XHQvLyBjb25zb2xlLmxvZygnZ290IHRvIGNoYXJ0cycpO1xuXHRcdC8vIHZhciByZXN1bHQgPSBwYWdlVGVtcGxhdGUoY2hhcnQpXG5cdFx0Ly8gJCgnLnByb2R1Y3QtY29tcGFyaXNvbi1jaGFydCcpLmh0bWwocmVzdWx0KTtcblxuXHRcdC8vIH0pXG5cdH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcGFyZVZpZXc7XG5cblxuLy8gY2hhcnQgZGl2ICAgLnByb2R1Y3QtY29tcGFyaXNvbi1jaGFydCIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHBhZ2VUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9ob21lLmhicycpO1xudmFyIHByb2R1Y3RUaWxlVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcHJvZHVjdF90aWxlLmhicycpXG5cbi8vIENvbGxlY3Rpb25zXG4vLyB2YXIgUHJvZHVjdENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9wcm9kdWN0LmpzJyk7XG52YXIgRmFuQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL2Zhbi5qcycpXG52YXIgQnVsYkNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9idWxiLmpzJylcblxuXG52YXIgSG9tZVZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cdGVsOiAnLmNvbnRlbnQnLFxuXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gY29uc29sZS5sb2coJ3JlbmRlciBob21lIHZpZXcnKVxuXHRcdHZhciByZXN1bHQgPSBwYWdlVGVtcGxhdGUoKVxuXG5cdFx0dGhpcy4kZWwuaHRtbChyZXN1bHQpXG5cblx0XHQvLyB2YXIgcHJvZHVjdENvbGxlY3Rpb24gPSBuZXcgUHJvZHVjdENvbGxlY3Rpb24oKVxuXHRcdC8vIHByb2R1Y3RDb2xsZWN0aW9uLmZldGNoKCkuZG9uZShmdW5jdGlvbihwcm9kdWN0cykge1xuXHRcdFx0XG5cdFx0Ly8gXHQvLyByYXcgbm9uLWJhY2tib25lIGFycmF5IG9mIG9iamVjdHNcblx0XHQvLyBcdGNvbnNvbGUubG9nKHByb2R1Y3RzKTtcblx0XHQvLyBcdHZhciByZXN1bHQgPSBwcm9kdWN0VGlsZVRlbXBsYXRlKHByb2R1Y3RzKVxuXHRcdC8vIFx0JCgnLnRpbGVzJykuaHRtbChyZXN1bHQpO1xuXG5cdFx0dmFyIGZhbkNvbGxlY3Rpb24gPSBuZXcgRmFuQ29sbGVjdGlvbigpXG5cdFx0ZmFuQ29sbGVjdGlvbi5mZXRjaCgpLmRvbmUoZnVuY3Rpb24oZmFucykge1xuXHRcdFxuXHRcdFx0Ly8gcmF3IG5vbi1iYWNrYm9uZSBhcnJheSBvZiBvYmplY3RzXG5cdFx0XHR2YXIgcmVzdWx0ID0gcHJvZHVjdFRpbGVUZW1wbGF0ZShmYW5zKVxuXHRcdFx0JCgnLnRpbGVzLmZhbnMnKS5odG1sKHJlc3VsdCk7XG5cdFx0fSlcblxuXHRcdHZhciBidWxiQ29sbGVjdGlvbiA9IG5ldyBCdWxiQ29sbGVjdGlvbigpXG5cdFx0YnVsYkNvbGxlY3Rpb24uZmV0Y2goKS5kb25lKGZ1bmN0aW9uKGJ1bGJzKSB7XG5cdFx0XG5cdFx0XHQvLyByYXcgbm9uLWJhY2tib25lIGFycmF5IG9mIG9iamVjdHNcblx0XHRcdHZhciByZXN1bHQgPSBwcm9kdWN0VGlsZVRlbXBsYXRlKGJ1bGJzKVxuXHRcdFx0JCgnLnRpbGVzLmJ1bGJzJykuaHRtbChyZXN1bHQpO1xuXG5cdFx0fSlcblx0fVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBIb21lVmlldzsiLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBwYWdlVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZXMvcHJvZHVjdF90aWxlLmhicycpO1xuXG4vL01vZGVsc1xudmFyIFByb2R1Y3RNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9wcm9kdWN0JylcblxuXG52YXIgUHJvZHVjdFByb2ZpbGVWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXHRcblx0ZWw6ICcuY29udGVudCcsXG5cblx0cmVuZGVyOiBmdW5jdGlvbihwcm9kdWN0X2lkKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpc1xuXG5cdFx0dmFyIHByb2R1Y3RNb2RlbCA9IG5ldyBQcm9kdWN0TW9kZWwoe2lkOiBwcm9kdWN0X2lkfSlcblx0XHRwcm9kdWN0TW9kZWwuZmV0Y2goKS5kb25lKGZ1bmN0aW9uKHByb2R1Y3Qpe1xuXHRcdFx0dmFyIHJlc3VsdCA9IHBhZ2VUZW1wbGF0ZShwcm9kdWN0WzBdKVxuXHRcdCBcdF90aGlzLiRlbC5odG1sKHJlc3VsdClcblx0XHR9KVxuXHRcdFxuXG5cdH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvZHVjdFByb2ZpbGVWaWV3O1xuXG5cblxuXG4iXX0=
